/**
 * Mars3D三维可视化平台  mars3d
 *
 * 版本信息：v3.4.2
 * 编译日期：2023-02-04 16:15:59
 * 版权所有：Copyright by 火星科技  http://mars3d.cn
 * 使用单位：中急管(北京)网络科技有限公司 ，2021-08-18
 */
(function (global, factory) {  if(typeof exports === 'object' && typeof module !== 'undefined' && !window.Cesium){ require('mars3d-cesium/Build/Cesium/Widgets/widgets.css') };
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, (window.Cesium || require('mars3d-cesium')), (window.turf || require('@turf/turf'))) :
  typeof define === 'function' && define.amd ? define(['exports', 'mars3d-cesium', '@turf/turf'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.mars3d = {}, global.Cesium, global.turf));
})(this, (function (exports, Cesium, turf) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return n;
  }

  var Cesium__namespace = /*#__PURE__*/_interopNamespace(Cesium);

  if (!Cesium__namespace?.Viewer) {
    throw new Error("请引入 Cesium 库")
  }

  // 在外边需要时自己加下下面代码
  // Cesium.Resource.ReplaceUrl = function (url) {
  //   if (url.endsWith(".b3dm") || url.endsWith(".b3dm")) {
  //     return url.replace(/\+/gm, "%2B") // 将3dtiles中的“+”符号转义下
  //   } else {
  //     return url
  //   }
  // }

  const getUrlComponent_old = Cesium__namespace.Resource.prototype.getUrlComponent;
  Cesium__namespace.Resource.prototype.getUrlComponent = function (query, proxy) {
    const url = getUrlComponent_old.bind(this)(query, proxy);
    if (Cesium__namespace.Resource.ReplaceUrl) {
      return Cesium__namespace.Resource.ReplaceUrl(url)
    } else {
      return url
    }
  };

  const getValueInReferenceFrame_old = Cesium__namespace.ConstantPositionProperty.prototype.getValueInReferenceFrame;

  Cesium__namespace.ConstantPositionProperty.prototype.getValueInReferenceFrame = function (time, referenceFrame, result) {
    if (!Cesium__namespace.defined(time)) {
      time = Cesium__namespace.JulianDate.now(); // 容错性处理，可以.getValue()直接取值
    }
    return getValueInReferenceFrame_old.bind(this)(time, referenceFrame, result)
  };

  // 修改方法，记录并保留最后一次方向值
  Cesium__namespace.VelocityOrientationProperty.prototype.getValue = function (time, result) {
    if (!this._positionScratch) {
      this._positionScratch = new Cesium__namespace.Cartesian3();
      this._velocityScratch = new Cesium__namespace.Cartesian3();
      this._rotationScratch = new Cesium__namespace.Matrix3();
    }

    let velocity = this._velocityVectorProperty._getValue(time, this._velocityScratch, this._positionScratch);

    // 【火星科技marsgis.cn】 Muyao 2021-8-23 记录并保留最后一次方向值。
    if (Cesium__namespace.defined(velocity)) {
      this._last_velocity = velocity.clone();
    } else {
      velocity = this._last_velocity;
    }
    // 【火星科技marsgis.cn】 Muyao 2021-8-23 记录并保留最后一次方向值

    if (!Cesium__namespace.defined(velocity)) {
      return undefined
    }

    Cesium__namespace.Transforms.rotationMatrixFromPositionVelocity(this._positionScratch, velocity, this._ellipsoid, this._rotationScratch);
    return Cesium__namespace.Quaternion.fromRotationMatrix(this._rotationScratch, result)
  };

  // map.scene.globe._surface.tileProvider :GlobeSurfaceTileProvider

  //  地形挖掘与淹没
  Object.defineProperties(Cesium__namespace.GlobeSurfaceTileProvider.prototype, {
    marsOptions: {
      get: function () {
        return this._marsOptions
      }
    }
  });

  Cesium__namespace.GlobeSurfaceTileProvider.prototype._initByMars3D = function (options) {
    const that = this;
    this._marsOptions = {
      flood: {},
      clip: {},
      resetValue: function () {
        // 地形开挖
        this.clip.enabled = false; // 是否开启
        this.clip.clipOutSide = false; // 是否开启仅展示自己
        this.clip.polygonTexture = undefined;
        this.clip.tailorRect = Cesium__namespace.Cartesian4.ZERO;
        this.clip.inverMatrix = Cesium__namespace.Matrix4.ZERO;

        // 淹没分析
        this.flood.enabled = false; // 是否开启
        this.flood.globe = true; // 是否全球淹没
        this.flood.showElseArea = true; // 是否显示非淹没区域
        this.flood.polygonTexture = undefined;
        this.flood.inverMatrix = Cesium__namespace.Matrix4.ZERO;
        this.flood.floodRect = Cesium__namespace.Cartesian4.ZERO;
        this.flood.heightVal = new Cesium__namespace.Cartesian4(0, 0, 0, 500); // [基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]
        this.flood.color = new Cesium__namespace.Color(0.15, 0.7, 0.95, 0.5); // [淹没颜色的r(0-1之间)，淹没颜色的g，淹没颜色的b，淹没混合系数（建议取值范围0.3-0.7）]
      },
      // 处理传递给 mars3d-cesium 内部的参数，下面命名无必要勿修改，与mars3d-cesium关联较大。
      updateTileUniformMap: function (frameState, globeSurfaceTileProvider) {
        return {
          // 地形开挖
          u_mars_clip_enabled: function () {
            return that._marsOptions.clip.enabled
          },
          u_mars_clip_only: function () {
            return that._marsOptions.clip.clipOutSide
          },
          u_mars_clip_area: function () {
            return that._marsOptions.clip.polygonTexture || frameState.context.defaultTexture
          },
          u_mars_clip_inverMatrix: function () {
            return that._marsOptions.clip.inverMatrix || Cesium__namespace.Matrix4.ZERO
          },
          u_mars_clip_rect: function () {
            return that._marsOptions.clip.tailorRect || Cesium__namespace.Cartesian4.ZERO
          },

          // 淹没分析
          u_mars_flood_emabled: function () {
            return that._marsOptions.flood.enabled
          },
          u_mars_flood_globe: function () {
            return that._marsOptions.flood.globe
          },
          u_mars_flood_showElse: function () {
            return that._marsOptions.flood.showElseArea
          },
          u_mars_flood_area: function () {
            return that._marsOptions.flood.polygonTexture || frameState.context.defaultTexture
          },
          u_mars_flood_inverMatrix: function () {
            return that._marsOptions.flood.inverMatrix || Cesium__namespace.Matrix4.ZERO
          },
          u_mars_flood_rect: function () {
            return that._marsOptions.flood.floodRect || Cesium__namespace.Cartesian4.ZERO
          },
          // 与 src\shaders\GlobeFlodByMaterial.glsl 有关
          u_mars_flood_val: function () {
            return that._marsOptions.flood.heightVal
          },
          u_mars_flood_color: function () {
            return that._marsOptions.flood.color
          }
        }
      }
    };

    this._marsOptions.resetValue();
  };

  Cesium__namespace.ImageryLayer.prototype._initByMars3D = function (imageryProvider, options) {
    // 瓦片滤镜效果
    this.invertColor = options.invertColor ?? imageryProvider.invertColor;
    this.filterColor = options.filterColor ?? imageryProvider.filterColor;
    if (this.filterColor && typeof this.filterColor === "string" && this.filterColor.constructor === String) {
      this.filterColor = Cesium__namespace.Color.fromCssColorString(this.filterColor);
    }
  };

  Cesium__namespace.ImageryLayerCollection.prototype.addImageryProvider = function (imageryProvider, index) {
    const layer = new Cesium__namespace.ImageryLayer(imageryProvider, imageryProvider.options); // 增加imageryProvider.options
    this.add(layer, index);
    return layer
  };

  const createShadowReceiveFragmentShader_old = Cesium__namespace.ShadowMapShader.createShadowReceiveFragmentShader;

  Cesium__namespace.ShadowMapShader.createShadowReceiveFragmentShader = function (fs, shadowMap, castShadows, isTerrain, hasTerrainNormal) {
    const shaderSource = createShadowReceiveFragmentShader_old.bind(this)(fs, shadowMap, castShadows, isTerrain, hasTerrainNormal);
    if (!isSun(shadowMap._lightCamera.position)) {
      const fsSource = shaderSource.sources[shaderSource.sources.length - 1];
      shaderSource.sources[shaderSource.sources.length - 1] = fsSource.replace(
        `gl_FragColor.rgb *= visibility;`,
        `gl_FragColor.rgb = gl_FragColor.rgb;`
      );
    }
    return shaderSource
  };

  // 可视域分析 相机位置很远则是太阳，否则是自己的shadowmap
  function isSun(position) {
    if (Math.abs(position.x) > 7471000) {
      return true
    }
    if (Math.abs(position.y) > 7471000) {
      return true
    }
    if (Math.abs(position.z) > 7471000) {
      return true
    }
    return false
  }

  Object.defineProperties(Cesium__namespace.Entity.prototype, {
    circle: {
      set: function (value) {
        this.ellipse = value;
      },
      get: function () {
        return this.ellipse
      }
    }
  });

  // 去掉 "N/A" ，修改为显示最后一次
  Cesium__namespace.PerformanceDisplay.prototype.update = function (renderedThisFrame) {
    const time = Cesium__namespace.getTimestamp();
    const updateDisplay = renderedThisFrame ?? true;

    this._fpsFrameCount++;
    const fpsElapsedTime = time - this._lastFpsSampleTime;
    if (fpsElapsedTime > 1000) {
      if (updateDisplay) {
        const fps = ((this._fpsFrameCount * 1000) / fpsElapsedTime) | 0;
        this._fpsText.nodeValue = `${fps} FPS`;
      }

      this._lastFpsSampleTime = time;
      this._fpsFrameCount = 0;
    }

    this._msFrameCount++;
    const msElapsedTime = time - this._lastMsSampleTime;
    if (msElapsedTime > 200) {
      if (updateDisplay) {
        const ms = (msElapsedTime / this._msFrameCount).toFixed(2);
        this._msText.nodeValue = `${ms} MS`;
      }

      this._lastMsSampleTime = time;
      this._msFrameCount = 0;
    }
  };

  Object.defineProperties(Cesium__namespace.CheckerboardMaterialProperty.prototype, {
    globalAlpha: {
      set: function (value) {
        this._globalAlpha = value;
      },
      get: function () {
        return this._globalAlpha ?? 1.0
      }
    }
  });
  const getValue_old$6 = Cesium__namespace.CheckerboardMaterialProperty.prototype.getValue;

  Cesium__namespace.CheckerboardMaterialProperty.prototype.getValue = function (time, result) {
    result = getValue_old$6.bind(this)(time, result);
    if (this.globalAlpha !== 1.0) {
      if (result.lightColor) {
        result.lightColor.alpha *= this.globalAlpha;
      }
      if (result.darkColor) {
        result.darkColor.alpha *= this.globalAlpha;
      }

      // 历史版本
      if (result.evenColor) {
        result.evenColor.alpha *= this.globalAlpha;
      }
      if (result.oddColor) {
        result.oddColor.alpha *= this.globalAlpha;
      }
    }
    return result
  };

  /**
   * SDK内部统一调用console.* 打印日志的控制类，在外部可以按需开启和关闭。
   * @module Log
   */

  let _hasInfo = true;
  let _hasError = true;

  /**
   * 是否 console.log 打印普通日志信息，可以按需关闭或开启
   *
   * @export
   * @param {Boolean} val 是否打印
   * @return {void}  无
   */
  function hasInfo(val) {
    _hasInfo = val;
  }

  /**
   * 是否 console.warn 打印警告日志信息，可以按需关闭或开启，但不建议关闭
   *
   * @export
   * @param {Boolean} val 是否打印
   * @return {void}  无
   */
  function hasWarn(val) {
    _hasInfo = val;
  }

  /**
   * 是否 console.error 打印错误日志信息，可以按需关闭或开启，但不建议关闭
   *
   * @export
   * @param {Boolean} val 是否打印
   * @return {void}  无
   */
  function hasError(val) {
    _hasError = val;
  }

  /**
   * console.log 打印普通日志信息,方便开发调试
   *
   * @export
   * @param {String|Object} sources 打印的日志内容
   * @return {void}  无
   */
  function logInfo(...sources) {
    if (!_hasInfo) {
      return
    }
    // eslint-disable-next-line no-console
    console.log(...sources);
  }

  /**
   * console.warn 打印警告日志信息,方便开发调试
   *
   * @export
   * @param {String|Object} sources 打印的警告日志内容
   * @return {void}  无
   */
  function logWarn(...sources) {
    // eslint-disable-next-line no-console
    console.warn(...sources);
  }

  /**
   * console.warn 打印错误日志信息,方便开发调试定位问题
   *
   * @export
   * @param {String|Object} sources 打印的错误日志内容
   * @return {void}  无
   */
  function logError(...sources) {
    if (!_hasError) {
      return
    }
    // eslint-disable-next-line no-console
    console.error(...sources);
  }

  var Log = {
    __proto__: null,
    hasInfo: hasInfo,
    hasWarn: hasWarn,
    hasError: hasError,
    logInfo: logInfo,
    logWarn: logWarn,
    logError: logError
  };

  /**
   * 矢量数据类型
   * @enum {String}
   *
   * @property {String}  label 文本点,对应类为：{@link LabelEntity }
   * @property {String}  labelP 文本点（图元）,对应类为：{@link LabelPrimitive }
   * @property {String}  point 像素点,，对应类为：{@link PointEntity }
   * @property {String}  pointP 像素点（图元），对应类为：{@link PointPrimitive }
   * @property {String}  billboard 图标点，对应类为：{@link BillboardEntity }
   * @property {String}  divBillboard HTML转图片后的图标点，对应类为：{@link DivBillboardEntity }
   * @property {String}  fontBillboard Font CSS字体点转图片后的图标点，对应类为：{@link FontBillboardEntity }
   * @property {String}  billboardP 图标点（图元），对应类为：{@link BillboardPrimitive }
   * @property {String}  model gltf小模型，对应类为：{@link ModelEntity }
   * @property {String}  modelP gltf小模型（图元）对应类为：{@link ModelPrimitive }
   * @property {String}  modelC gltf小模型（数据集），对应类为：{@link ModelCombine }
   * @property {String}  plane 平面，对应类为：{@link PlaneEntity }
   * @property {String}  planeP 平面（图元），对应类为：{@link PlanePrimitive }
   * @property {String}  box 盒子，对应类为：{@link BoxEntity }
   * @property {String}  boxP 盒子（图元），对应类为：{@link BoxPrimitive }
   * @property {String}  circle 圆、圆柱，对应类为：{@link CircleEntity }
   * @property {String}  circleP 圆、圆柱（图元）对应类为：{@link CirclePrimitive }
   * @property {String}  ellipse 椭圆、椭圆柱，对应类为：{@link EllipseEntity }
   * @property {String}  cylinder 圆锥，对应类为：{@link CylinderEntity }
   * @property {String}  cylinderP 圆锥（图元），对应类为：{@link CylinderPrimitive }
   * @property {String}  coneTrack 圆锥追踪体，对应类为：{@link ConeTrack }
   * @property {String}  coneTrackP 圆锥追踪体（图元），对应类为：{@link ConeTrackPrimitive }
   * @property {String}  ellipsoid 球体，对应类为：{@link EllipsoidEntity }
   * @property {String}  ellipsoidP 球体（图元），对应类为：{@link EllipsoidPrimitive }
   * @property {String}  polyline 线，对应类为：{@link PolylineEntity }
   * @property {String}  curve 曲线，对应类为：{@link CurveEntity }
   * @property {String}  polylineP 线（图元），对应类为：{@link PolylinePrimitive }
   * @property {String}  polylineSP 简单线（图元），对应类为：{@link PolylineSimplePrimitive }
   * @property {String}  polylineC 大数据线（数据集）对应类为：{@link PolylineCombine }
   * @property {String}  polylineVolume 管道线，对应类为：{@link PolylineVolumeEntity }
   * @property {String}  polylineVolumeP 管道线（图元），对应类为：{@link PolylineVolumePrimitive }
   * @property {String}  path 路径，对应类为：{@link PathEntity }
   * @property {String}  roamLine 飞行漫游路线，对应类为：{@link RoamLine }
   * @property {String}  dynamicRoamLine 动态漫游路线，对应类为：{@link DynamicRoamLine }
   * @property {String}  corridor 走廊，对应类为：{@link CorridorEntity }
   * @property {String}  corridorP 走廊（图元），对应类为：{@link CorridorPrimitive }
   * @property {String}  wall 墙，对应类为：{@link WallEntity }
   * @property {String}  wallP 墙（图元），对应类为：{@link WallPrimitive }
   * @property {String}  polygon 面，对应类为：{@link PolygonEntity }
   * @property {String}  polygonP 面（图元）对应类为：{@link PolygonPrimitive }
   * @property {String}  polygonC 大数据面（数据集）对应类为：{@link PolygonCombine }
   * @property {String}  rectangle 矩形，对应类为：{@link RectangleEntity }
   * @property {String}  rectangleP 矩形（图元），对应类为：{@link RectanglePrimitive }
   * @property {String}  frustum 四棱锥体（图元），对应类为：{@link FrustumPrimitive }
   *
   * @property {String}  water 水域面，对应类为：{@link Water }
   * @property {String}  waterC 大数据水域面（数据集），对应类为：{@link WaterCombine }
   * @property {String}  div DIV点，对应类为：{@link DivGraphic }
   * @property {String}  divLightPoint 动画的扩散div点，对应类为：{@link DivLightPoint }
   * @property {String}  divUpLabel 竖立的文本DIV点，对应类为：{@link DivUpLabel }
   * @property {String}  divBoderLabel 动态边框文本DIV点，对应类为：{@link DivBoderLabel }
   *
   * @property {String}  particleSystem 粒子效果，对应类为：{@link ParticleSystem }
   * @property {String}  video2D 视频融合（投射2D平面），对应类为：{@link Video2D }
   * @property {String}  video3D 视频融合（投射3D，贴物体表面）对应类为：{@link Video3D }
   * @property {String}  flatBillboard 平放的图标（数据集），对应类为：{@link FlatBillboard }
   * @property {String}  lightCone 光锥体，对应类为：{@link LightCone }
   * @property {String}  scrollWall 走马灯围墙效果，对应类为：{@link ScrollWall }
   * @property {String}  diffuseWall 立体面(或圆)散射效果，对应类为：{@link DiffuseWall }
   * @property {String}  dynamicRiver 动态河流，对应类为：{@link DynamicRiver }
   * @property {String}  road 道路，对应类为：{@link Road }
   * @property {String}  rectangularSensor 相控阵雷达，对应类为：{@link RectangularSensor }
   * @property {String}  pit 井，对应类为：{@link Pit }
   * @property {String}  tetrahedron 四面体（顶部正方形+倒立的三角椎体），对应类为：{@link Tetrahedron }
   *
   *
   * @property {String}   distanceMeasure 距离量算对象，对应类为：{@link DistanceMeasure }
   * @property {String}  distanceSurfaceMeasure 贴地距离量算对象，对应类为：{@link DistanceSurfaceMeasure }
   * @property {String}  sectionMeasure 剖面量算对象，对应类为：{@link SectionMeasure }
   * @property {String}  areaMeasure 面积量算对象，对应类为：{@link AreaMeasure }
   * @property {String}  areaSurfaceMeasure 贴地面积量算对象，对应类为：{@link AreaSurfaceMeasure }
   * @property {String}  volumeMeasure 方量量算对象，对应类为：{@link VolumeMeasure }
   * @property {String}  heightMeasure 高度量算对象，对应类为：{@link HeightMeasure }
   * @property {String}  heightTriangleMeasure 三角高度量算对象，对应类为：{@link HeightTriangleMeasure }
   * @property {String}  angleMeasure 角度量算对象，对应类为：{@link AngleMeasure }
   *
   * @property {String}  attackArrow 攻击箭头，对应类为：{@link AttackArrow }
   * @property {String}  attackArrowPW 攻击箭头(平尾)，对应类为：{@link AttackArrowPW }
   * @property {String}  attackArrowYW 攻击箭头（燕尾），对应类为：{@link AttackArrowYW }
   * @property {String}  doubleArrow 双箭头（钳击），对应类为：{@link DoubleArrow }
   * @property {String}  fineArrow 直箭头(2个点)，对应类为：{@link FineArrow }
   * @property {String}  fineArrowYW 燕尾直箭头(2个点)，对应类为：{@link FineArrowYW }
   * @property {String}  straightArrow 直箭头(3个点)，对应类为：{@link StraightArrow }
   * @property {String}  lune 弓形面(3个点)，对应类为：{@link Lune }
   * @property {String}  sector 扇形(3个点)，对应类为：{@link Sector }
   * @property {String}  regular 正多边形，对应类为：{@link Regular }
   * @property {String}  isosTriangle 等腰三角形(3个点)，对应类为：{@link IsosTriangle }
   * @property {String}  closeVurve 闭合曲面(3个点)，对应类为：{@link CloseVurve }
   * @property {String}  gatheringPlace 集结地(3个点)，对应类为：{@link GatheringPlace }
   *
   * @property {String}  camberRadar 双曲面拱形雷达【mars3d-space插件】，对应类为：{@link CamberRadar }
   * @property {String}  conicSensor 圆锥体（单目标雷达）【mars3d-space插件】，对应类为：{@link ConicSensor }
   * @property {String}  rectSensor 四棱锥体【mars3d-space插件】，对应类为：{@link RectSensor }
   * @property {String}  satelliteSensor 卫星视锥综合体（圆锥或四凌锥）【mars3d-space插件】，对应类为：{@link SatelliteSensor }
   * @property {String}  satellite 卫星综合体【mars3d-space插件】，对应类为：{@link Satellite }
   */
  const GraphicType = {};

  /**
   * 矢量数据 相关静态方法
   * @module GraphicUtil
   */

  // 矢量数据集合（按类型）
  const GraphicClass = {};

  /**
   * 是否有指定类型矢量对象
   * @param {String} type 矢量数据类型
   * @returns {Boolean} 是否有指定类型
   */
  function hasType(type) {
    if (GraphicClass[type]) {
      return true
    } else {
      return false
    }
  }

  /**
   * 循环执行矢量数据类型
   * @param {Function} method 执行的方法
   * @returns {void}
   */
   function eachGraphicType(method) {
    Object.keys(GraphicClass).forEach((key, index) => {
      method && method.call(this, key, index);
    });
  }


  /**
   * 判断该类型是否点状对象
   * @param {String} type 矢量数据类型
   * @returns {Boolean} 是否点状对象类型
   */
  function isPointType(type) {
    if (!type) {
      return false
    }
    if (GraphicClass[type] && GraphicClass[type].isPoint) {
      return true
    } else {
      return false
    }
  }

  /**
   * 判断该类型是否大数据对象
   * @param {String} type 矢量数据类型
   * @returns {Boolean} 是否大数据对象（继承了BaseCombine的相关类型）
   */
  function isCombineType(type) {
    if (!type) {
      return false
    }
    if (GraphicClass[type] && GraphicClass[type].isCombine) {
      return true
    } else {
      return false
    }
  }

  /**
   * 注册矢量数据类
   *
   * @export
   * @param {String} type 矢量数据类型
   * @param {BaseGraphic|*} graphicClass 矢量数据类
   * @return {void}  无
   */
  function register$4(type, graphicClass) {
    if (GraphicClass[type]) {
      logError(`register Graphic: ${type}类型已存在`, graphicClass);
    }
    GraphicType[type] = type;
    GraphicClass[type] = graphicClass;

    // console.log(`${type}，{@link ${graphicClass.name} }`)

    graphicClass.type = type; // 静态属性
    graphicClass.prototype._type = type; // 对象属性
  }

  /**
   * 根据 矢量数据类型 获取 矢量数据类
   * @param {String} type 矢量数据类型
   * @returns {BaseGraphic|undefined} 矢量数据类
   */
  function getClass$4(type) {
    if (GraphicClass[type]) {
      return GraphicClass[type]
    } else {
      logWarn("getClass:未找到该类型对应的处理类", type);
      return null
    }
  }

  /**
   * 根据类型和参数 创建Graphic工厂方法
   *
   * @export
   * @param {Object} type 数据类型
   * @param {Object} options 构造参数， 按type支持{@link GraphicType}类的构造方法参数
   * @return {BaseGraphic|*} 创建完成的矢量数据对象
   */
  function create$4(type, options) {
    const ThisGraphic = getClass$4(type);
    if (!ThisGraphic) {
      return
    }

    const graphic = new ThisGraphic(options);
    return graphic
  }

  /**
   * 通过标绘  创建Graphic工厂方法
   *
   * @export
   * @param {GraphicLayer} layer 图层对象
   * @param {Object} options Graphic构造参数,包含：
   * @param {GraphicType|String} options.type 类型
   * @param {Object} [options.style] 矢量数据样式，具体参考支持 {@link GraphicType}查询对应type的类
   * @param {Object} [options.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {String} [options.name] 矢量数据名称
   * @return {BaseGraphic|*} 创建完成的矢量数据对象
   */
  function fromDraw(layer, options) {
    if (!options.type) {
      logError("fromDraw:需要传入指定绘制的type类型！");
      return
    }

    const ThisGraphic = getClass$4(options.type);
    if (!ThisGraphic || !ThisGraphic.prototype.startDraw) {
      logInfo("对象不支持标绘", ThisGraphic);
      return
    }

    const graphic = new ThisGraphic(options);
    graphic.startDraw(layer);

    return graphic
  }

  var GraphicUtil = {
    __proto__: null,
    hasType: hasType,
    eachGraphicType: eachGraphicType,
    isPointType: isPointType,
    isCombineType: isCombineType,
    register: register$4,
    getClass: getClass$4,
    create: create$4,
    fromDraw: fromDraw
  };

  /* @preserve
  * @terraformer/arcgis - v2.0.7 - MIT
  * Copyright (c) 2012-2021 Environmental Systems Research Institute, Inc.
  * Thu Jul 22 2021 13:58:30 GMT-0700 (Pacific Daylight Time)
  */
  /* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
   * Apache-2.0 */

  var edgeIntersectsEdge = function edgeIntersectsEdge(a1, a2, b1, b2) {
    var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);
    var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);
    var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);

    if (uB !== 0) {
      var ua = uaT / uB;
      var ub = ubT / uB;

      if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
        return true;
      }
    }

    return false;
  };
  var coordinatesContainPoint = function coordinatesContainPoint(coordinates, point) {
    var contains = false;

    for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {
      if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {
        contains = !contains;
      }
    }

    return contains;
  };
  var pointsEqual = function pointsEqual(a, b) {
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  };
  var arrayIntersectsArray = function arrayIntersectsArray(a, b) {
    for (var i = 0; i < a.length - 1; i++) {
      for (var j = 0; j < b.length - 1; j++) {
        if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {
          return true;
        }
      }
    }

    return false;
  };

  /* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
   * Apache-2.0 */

  var closeRing = function closeRing(coordinates) {
    if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {
      coordinates.push(coordinates[0]);
    }

    return coordinates;
  }; // determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring
  // or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-
  // points-are-in-clockwise-order

  var ringIsClockwise = function ringIsClockwise(ringToTest) {
    var total = 0;
    var i = 0;
    var rLength = ringToTest.length;
    var pt1 = ringToTest[i];
    var pt2;

    for (i; i < rLength - 1; i++) {
      pt2 = ringToTest[i + 1];
      total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);
      pt1 = pt2;
    }

    return total >= 0;
  }; // This function ensures that rings are oriented in the right directions
  // from http://jsperf.com/cloning-an-object/2

  var shallowClone = function shallowClone(obj) {
    var target = {};

    for (var i in obj) {
      // both arcgis attributes and geojson props are just hardcoded keys
      if (obj.hasOwnProperty(i)) {
        // eslint-disable-line no-prototype-builtins
        target[i] = obj[i];
      }
    }

    return target;
  };

  /* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
   * Apache-2.0 */

  var coordinatesContainCoordinates = function coordinatesContainCoordinates(outer, inner) {
    var intersects = arrayIntersectsArray(outer, inner);
    var contains = coordinatesContainPoint(outer, inner[0]);

    if (!intersects && contains) {
      return true;
    }

    return false;
  }; // do any polygons in this array contain any other polygons in this array?
  // used for checking for holes in arcgis rings


  var convertRingsToGeoJSON = function convertRingsToGeoJSON(rings) {
    var outerRings = [];
    var holes = [];
    var x; // iterator

    var outerRing; // current outer ring being evaluated

    var hole; // current hole being evaluated
    // for each ring

    for (var r = 0; r < rings.length; r++) {
      var ring = closeRing(rings[r].slice(0));

      if (ring.length < 4) {
        continue;
      } // is this ring an outer ring? is it clockwise?


      if (ringIsClockwise(ring)) {
        var polygon = [ring.slice().reverse()]; // wind outer rings counterclockwise for RFC 7946 compliance

        outerRings.push(polygon); // push to outer rings
      } else {
        holes.push(ring.slice().reverse()); // wind inner rings clockwise for RFC 7946 compliance
      }
    }

    var uncontainedHoles = []; // while there are holes left...

    while (holes.length) {
      // pop a hole off out stack
      hole = holes.pop(); // loop over all outer rings and see if they contain our hole.

      var contained = false;

      for (x = outerRings.length - 1; x >= 0; x--) {
        outerRing = outerRings[x][0];

        if (coordinatesContainCoordinates(outerRing, hole)) {
          // the hole is contained push it into our polygon
          outerRings[x].push(hole);
          contained = true;
          break;
        }
      } // ring is not contained in any outer ring
      // sometimes this happens https://github.com/Esri/esri-leaflet/issues/320


      if (!contained) {
        uncontainedHoles.push(hole);
      }
    } // if we couldn't match any holes using contains we can try intersects...


    while (uncontainedHoles.length) {
      // pop a hole off out stack
      hole = uncontainedHoles.pop(); // loop over all outer rings and see if any intersect our hole.

      var intersects = false;

      for (x = outerRings.length - 1; x >= 0; x--) {
        outerRing = outerRings[x][0];

        if (arrayIntersectsArray(outerRing, hole)) {
          // the hole is contained push it into our polygon
          outerRings[x].push(hole);
          intersects = true;
          break;
        }
      }

      if (!intersects) {
        outerRings.push([hole.reverse()]);
      }
    }

    if (outerRings.length === 1) {
      return {
        type: 'Polygon',
        coordinates: outerRings[0]
      };
    } else {
      return {
        type: 'MultiPolygon',
        coordinates: outerRings
      };
    }
  };

  var getId = function getId(attributes, idAttribute) {
    var keys = idAttribute ? [idAttribute, 'OBJECTID', 'FID'] : ['OBJECTID', 'FID'];

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key in attributes && (typeof attributes[key] === 'string' || typeof attributes[key] === 'number')) {
        return attributes[key];
      }
    }

    throw Error('No valid id attribute found');
  };

  var arcgisToGeoJSON$1 = function arcgisToGeoJSON(arcgis, idAttribute) {
    var geojson = {};

    if (arcgis.features) {
      geojson.type = 'FeatureCollection';
      geojson.features = [];

      for (var i = 0; i < arcgis.features.length; i++) {
        geojson.features.push(arcgisToGeoJSON(arcgis.features[i], idAttribute));
      }
    }

    if (typeof arcgis.x === 'number' && typeof arcgis.y === 'number') {
      geojson.type = 'Point';
      geojson.coordinates = [arcgis.x, arcgis.y];

      if (typeof arcgis.z === 'number') {
        geojson.coordinates.push(arcgis.z);
      }
    }

    if (arcgis.points) {
      geojson.type = 'MultiPoint';
      geojson.coordinates = arcgis.points.slice(0);
    }

    if (arcgis.paths) {
      if (arcgis.paths.length === 1) {
        geojson.type = 'LineString';
        geojson.coordinates = arcgis.paths[0].slice(0);
      } else {
        geojson.type = 'MultiLineString';
        geojson.coordinates = arcgis.paths.slice(0);
      }
    }

    if (arcgis.rings) {
      geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));
    }

    if (typeof arcgis.xmin === 'number' && typeof arcgis.ymin === 'number' && typeof arcgis.xmax === 'number' && typeof arcgis.ymax === 'number') {
      geojson.type = 'Polygon';
      geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];
    }

    if (arcgis.geometry || arcgis.attributes) {
      geojson.type = 'Feature';
      geojson.geometry = arcgis.geometry ? arcgisToGeoJSON(arcgis.geometry) : null;
      geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;

      if (arcgis.attributes) {
        try {
          geojson.id = getId(arcgis.attributes, idAttribute);
        } catch (err) {// don't set an id
        }
      }
    } // if no valid geometry was encountered


    if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {
      geojson.geometry = null;
    }

    if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {
      console.warn('Object converted in non-standard crs - ' + JSON.stringify(arcgis.spatialReference));
    }

    return geojson;
  };

  /* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
   * Apache-2.0 */
  // outer rings are clockwise, holes are counterclockwise
  // used for converting GeoJSON Polygons to ArcGIS Polygons

  var orientRings = function orientRings(poly) {
    var output = [];
    var polygon = poly.slice(0);
    var outerRing = closeRing(polygon.shift().slice(0));

    if (outerRing.length >= 4) {
      if (!ringIsClockwise(outerRing)) {
        outerRing.reverse();
      }

      output.push(outerRing);

      for (var i = 0; i < polygon.length; i++) {
        var hole = closeRing(polygon[i].slice(0));

        if (hole.length >= 4) {
          if (ringIsClockwise(hole)) {
            hole.reverse();
          }

          output.push(hole);
        }
      }
    }

    return output;
  }; // This function flattens holes in multipolygons to one array of polygons
  // used for converting GeoJSON Polygons to ArcGIS Polygons


  var flattenMultiPolygonRings = function flattenMultiPolygonRings(rings) {
    var output = [];

    for (var i = 0; i < rings.length; i++) {
      var polygon = orientRings(rings[i]);

      for (var x = polygon.length - 1; x >= 0; x--) {
        var ring = polygon[x].slice(0);
        output.push(ring);
      }
    }

    return output;
  };

  var geojsonToArcGIS$1 = function geojsonToArcGIS(geojson, idAttribute) {
    idAttribute = idAttribute || 'OBJECTID';
    var spatialReference = {
      wkid: 4326
    };
    var result = {};
    var i;

    switch (geojson.type) {
      case 'Point':
        result.x = geojson.coordinates[0];
        result.y = geojson.coordinates[1];

        if (geojson.coordinates[2]) {
          result.z = geojson.coordinates[2];
        }

        result.spatialReference = spatialReference;
        break;

      case 'MultiPoint':
        result.points = geojson.coordinates.slice(0);

        if (geojson.coordinates[0][2]) {
          result.hasZ = true;
        }

        result.spatialReference = spatialReference;
        break;

      case 'LineString':
        result.paths = [geojson.coordinates.slice(0)];

        if (geojson.coordinates[0][2]) {
          result.hasZ = true;
        }

        result.spatialReference = spatialReference;
        break;

      case 'MultiLineString':
        result.paths = geojson.coordinates.slice(0);

        if (geojson.coordinates[0][0][2]) {
          result.hasZ = true;
        }

        result.spatialReference = spatialReference;
        break;

      case 'Polygon':
        result.rings = orientRings(geojson.coordinates.slice(0));

        if (geojson.coordinates[0][0][2]) {
          result.hasZ = true;
        }

        result.spatialReference = spatialReference;
        break;

      case 'MultiPolygon':
        result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));

        if (geojson.coordinates[0][0][0][2]) {
          result.hasZ = true;
        }

        result.spatialReference = spatialReference;
        break;

      case 'Feature':
        if (geojson.geometry) {
          result.geometry = geojsonToArcGIS(geojson.geometry, idAttribute);
        }

        result.attributes = geojson.properties ? shallowClone(geojson.properties) : {};

        if (geojson.id) {
          result.attributes[idAttribute] = geojson.id;
        }

        break;

      case 'FeatureCollection':
        result = [];

        for (i = 0; i < geojson.features.length; i++) {
          result.push(geojsonToArcGIS(geojson.features[i], idAttribute));
        }

        break;

      case 'GeometryCollection':
        result = [];

        for (i = 0; i < geojson.geometries.length; i++) {
          result.push(geojsonToArcGIS(geojson.geometries[i], idAttribute));
        }

        break;
    }

    return result;
  };

  function globals(defs) {
    defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
    defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
    defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

    defs.WGS84 = defs['EPSG:4326'];
    defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
    defs.GOOGLE = defs['EPSG:3857'];
    defs['EPSG:900913'] = defs['EPSG:3857'];
    defs['EPSG:102113'] = defs['EPSG:3857'];
  }

  var PJD_3PARAM = 1;
  var PJD_7PARAM = 2;
  var PJD_GRIDSHIFT = 3;
  var PJD_WGS84 = 4; // WGS84 or equivalent
  var PJD_NODATUM = 5; // WGS84 or equivalent
  var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms
  var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms
  var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
  var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
  var HALF_PI = Math.PI/2;
  // ellipoid pj_set_ell.c
  var SIXTH = 0.1666666666666666667;
  /* 1/6 */
  var RA4 = 0.04722222222222222222;
  /* 17/360 */
  var RA6 = 0.02215608465608465608;
  var EPSLN = 1.0e-10;
  // you'd think you could use Number.EPSILON above but that makes
  // Mollweide get into an infinate loop.

  var D2R$1 = 0.01745329251994329577;
  var R2D = 57.29577951308232088;
  var FORTPI = Math.PI/4;
  var TWO_PI = Math.PI * 2;
  // SPI is slightly greater than Math.PI, so values that exceed the -180..180
  // degree range by a tiny amount don't get wrapped. This prevents points that
  // have drifted from their original location along the 180th meridian (due to
  // floating point error) from changing their sign.
  var SPI = 3.14159265359;

  var exports$3 = {};

  exports$3.greenwich = 0.0; //"0dE",
  exports$3.lisbon = -9.131906111111; //"9d07'54.862\"W",
  exports$3.paris = 2.337229166667; //"2d20'14.025\"E",
  exports$3.bogota = -74.080916666667; //"74d04'51.3\"W",
  exports$3.madrid = -3.687938888889; //"3d41'16.58\"W",
  exports$3.rome = 12.452333333333; //"12d27'8.4\"E",
  exports$3.bern = 7.439583333333; //"7d26'22.5\"E",
  exports$3.jakarta = 106.807719444444; //"106d48'27.79\"E",
  exports$3.ferro = -17.666666666667; //"17d40'W",
  exports$3.brussels = 4.367975; //"4d22'4.71\"E",
  exports$3.stockholm = 18.058277777778; //"18d3'29.8\"E",
  exports$3.athens = 23.7163375; //"23d42'58.815\"E",
  exports$3.oslo = 10.722916666667; //"10d43'22.5\"E"

  var units = {
    ft: {to_meter: 0.3048},
    'us-ft': {to_meter: 1200 / 3937}
  };

  var ignoredChar = /[\s_\-\/\(\)]/g;
  function match(obj, key) {
    if (obj[key]) {
      return obj[key];
    }
    var keys = Object.keys(obj);
    var lkey = key.toLowerCase().replace(ignoredChar, '');
    var i = -1;
    var testkey, processedKey;
    while (++i < keys.length) {
      testkey = keys[i];
      processedKey = testkey.toLowerCase().replace(ignoredChar, '');
      if (processedKey === lkey) {
        return obj[testkey];
      }
    }
  }

  function projStr(defData) {
    var self = {};
    var paramObj = defData.split('+').map(function(v) {
      return v.trim();
    }).filter(function(a) {
      return a;
    }).reduce(function(p, a) {
      var split = a.split('=');
      split.push(true);
      p[split[0].toLowerCase()] = split[1];
      return p;
    }, {});
    var paramName, paramVal, paramOutname;
    var params = {
      proj: 'projName',
      datum: 'datumCode',
      rf: function(v) {
        self.rf = parseFloat(v);
      },
      lat_0: function(v) {
        self.lat0 = v * D2R$1;
      },
      lat_1: function(v) {
        self.lat1 = v * D2R$1;
      },
      lat_2: function(v) {
        self.lat2 = v * D2R$1;
      },
      lat_ts: function(v) {
        self.lat_ts = v * D2R$1;
      },
      lon_0: function(v) {
        self.long0 = v * D2R$1;
      },
      lon_1: function(v) {
        self.long1 = v * D2R$1;
      },
      lon_2: function(v) {
        self.long2 = v * D2R$1;
      },
      alpha: function(v) {
        self.alpha = parseFloat(v) * D2R$1;
      },
      gamma: function(v) {
        self.rectified_grid_angle = parseFloat(v);
      },
      lonc: function(v) {
        self.longc = v * D2R$1;
      },
      x_0: function(v) {
        self.x0 = parseFloat(v);
      },
      y_0: function(v) {
        self.y0 = parseFloat(v);
      },
      k_0: function(v) {
        self.k0 = parseFloat(v);
      },
      k: function(v) {
        self.k0 = parseFloat(v);
      },
      a: function(v) {
        self.a = parseFloat(v);
      },
      b: function(v) {
        self.b = parseFloat(v);
      },
      r_a: function() {
        self.R_A = true;
      },
      zone: function(v) {
        self.zone = parseInt(v, 10);
      },
      south: function() {
        self.utmSouth = true;
      },
      towgs84: function(v) {
        self.datum_params = v.split(",").map(function(a) {
          return parseFloat(a);
        });
      },
      to_meter: function(v) {
        self.to_meter = parseFloat(v);
      },
      units: function(v) {
        self.units = v;
        var unit = match(units, v);
        if (unit) {
          self.to_meter = unit.to_meter;
        }
      },
      from_greenwich: function(v) {
        self.from_greenwich = v * D2R$1;
      },
      pm: function(v) {
        var pm = match(exports$3, v);
        self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R$1;
      },
      nadgrids: function(v) {
        if (v === '@null') {
          self.datumCode = 'none';
        }
        else {
          self.nadgrids = v;
        }
      },
      axis: function(v) {
        var legalAxis = "ewnsud";
        if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
          self.axis = v;
        }
      },
      approx: function() {
        self.approx = true;
      }
    };
    for (paramName in paramObj) {
      paramVal = paramObj[paramName];
      if (paramName in params) {
        paramOutname = params[paramName];
        if (typeof paramOutname === 'function') {
          paramOutname(paramVal);
        }
        else {
          self[paramOutname] = paramVal;
        }
      }
      else {
        self[paramName] = paramVal;
      }
    }
    if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
      self.datumCode = self.datumCode.toLowerCase();
    }
    return self;
  }

  var NEUTRAL = 1;
  var KEYWORD = 2;
  var NUMBER = 3;
  var QUOTED = 4;
  var AFTERQUOTE = 5;
  var ENDED = -1;
  var whitespace = /\s/;
  var latin = /[A-Za-z]/;
  var keyword = /[A-Za-z84_]/;
  var endThings = /[,\]]/;
  var digets = /[\d\.E\-\+]/;
  // const ignoredChar = /[\s_\-\/\(\)]/g;
  function Parser(text) {
    if (typeof text !== 'string') {
      throw new Error('not a string');
    }
    this.text = text.trim();
    this.level = 0;
    this.place = 0;
    this.root = null;
    this.stack = [];
    this.currentObject = null;
    this.state = NEUTRAL;
  }
  Parser.prototype.readCharicter = function() {
    var char = this.text[this.place++];
    if (this.state !== QUOTED) {
      while (whitespace.test(char)) {
        if (this.place >= this.text.length) {
          return;
        }
        char = this.text[this.place++];
      }
    }
    switch (this.state) {
      case NEUTRAL:
        return this.neutral(char);
      case KEYWORD:
        return this.keyword(char)
      case QUOTED:
        return this.quoted(char);
      case AFTERQUOTE:
        return this.afterquote(char);
      case NUMBER:
        return this.number(char);
      case ENDED:
        return;
    }
  };
  Parser.prototype.afterquote = function(char) {
    if (char === '"') {
      this.word += '"';
      this.state = QUOTED;
      return;
    }
    if (endThings.test(char)) {
      this.word = this.word.trim();
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
  };
  Parser.prototype.afterItem = function(char) {
    if (char === ',') {
      if (this.word !== null) {
        this.currentObject.push(this.word);
      }
      this.word = null;
      this.state = NEUTRAL;
      return;
    }
    if (char === ']') {
      this.level--;
      if (this.word !== null) {
        this.currentObject.push(this.word);
        this.word = null;
      }
      this.state = NEUTRAL;
      this.currentObject = this.stack.pop();
      if (!this.currentObject) {
        this.state = ENDED;
      }

      return;
    }
  };
  Parser.prototype.number = function(char) {
    if (digets.test(char)) {
      this.word += char;
      return;
    }
    if (endThings.test(char)) {
      this.word = parseFloat(this.word);
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
  };
  Parser.prototype.quoted = function(char) {
    if (char === '"') {
      this.state = AFTERQUOTE;
      return;
    }
    this.word += char;
    return;
  };
  Parser.prototype.keyword = function(char) {
    if (keyword.test(char)) {
      this.word += char;
      return;
    }
    if (char === '[') {
      var newObjects = [];
      newObjects.push(this.word);
      this.level++;
      if (this.root === null) {
        this.root = newObjects;
      } else {
        this.currentObject.push(newObjects);
      }
      this.stack.push(this.currentObject);
      this.currentObject = newObjects;
      this.state = NEUTRAL;
      return;
    }
    if (endThings.test(char)) {
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
  };
  Parser.prototype.neutral = function(char) {
    if (latin.test(char)) {
      this.word = char;
      this.state = KEYWORD;
      return;
    }
    if (char === '"') {
      this.word = '';
      this.state = QUOTED;
      return;
    }
    if (digets.test(char)) {
      this.word = char;
      this.state = NUMBER;
      return;
    }
    if (endThings.test(char)) {
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
  };
  Parser.prototype.output = function() {
    while (this.place < this.text.length) {
      this.readCharicter();
    }
    if (this.state === ENDED) {
      return this.root;
    }
    throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
  };

  function parseString(txt) {
    var parser = new Parser(txt);
    return parser.output();
  }

  function mapit(obj, key, value) {
    if (Array.isArray(key)) {
      value.unshift(key);
      key = null;
    }
    var thing = key ? {} : obj;

    var out = value.reduce(function(newObj, item) {
      sExpr(item, newObj);
      return newObj
    }, thing);
    if (key) {
      obj[key] = out;
    }
  }

  function sExpr(v, obj) {
    if (!Array.isArray(v)) {
      obj[v] = true;
      return;
    }
    var key = v.shift();
    if (key === 'PARAMETER') {
      key = v.shift();
    }
    if (v.length === 1) {
      if (Array.isArray(v[0])) {
        obj[key] = {};
        sExpr(v[0], obj[key]);
        return;
      }
      obj[key] = v[0];
      return;
    }
    if (!v.length) {
      obj[key] = true;
      return;
    }
    if (key === 'TOWGS84') {
      obj[key] = v;
      return;
    }
    if (key === 'AXIS') {
      if (!(key in obj)) {
        obj[key] = [];
      }
      obj[key].push(v);
      return;
    }
    if (!Array.isArray(key)) {
      obj[key] = {};
    }

    var i;
    switch (key) {
      case 'UNIT':
      case 'PRIMEM':
      case 'VERT_DATUM':
        obj[key] = {
          name: v[0].toLowerCase(),
          convert: v[1]
        };
        if (v.length === 3) {
          sExpr(v[2], obj[key]);
        }
        return;
      case 'SPHEROID':
      case 'ELLIPSOID':
        obj[key] = {
          name: v[0],
          a: v[1],
          rf: v[2]
        };
        if (v.length === 4) {
          sExpr(v[3], obj[key]);
        }
        return;
      case 'PROJECTEDCRS':
      case 'PROJCRS':
      case 'GEOGCS':
      case 'GEOCCS':
      case 'PROJCS':
      case 'LOCAL_CS':
      case 'GEODCRS':
      case 'GEODETICCRS':
      case 'GEODETICDATUM':
      case 'EDATUM':
      case 'ENGINEERINGDATUM':
      case 'VERT_CS':
      case 'VERTCRS':
      case 'VERTICALCRS':
      case 'COMPD_CS':
      case 'COMPOUNDCRS':
      case 'ENGINEERINGCRS':
      case 'ENGCRS':
      case 'FITTED_CS':
      case 'LOCAL_DATUM':
      case 'DATUM':
        v[0] = ['name', v[0]];
        mapit(obj, key, v);
        return;
      default:
        i = -1;
        while (++i < v.length) {
          if (!Array.isArray(v[i])) {
            return sExpr(v, obj[key]);
          }
        }
        return mapit(obj, key, v);
    }
  }

  var D2R = 0.01745329251994329577;



  function rename(obj, params) {
    var outName = params[0];
    var inName = params[1];
    if (!(outName in obj) && (inName in obj)) {
      obj[outName] = obj[inName];
      if (params.length === 3) {
        obj[outName] = params[2](obj[outName]);
      }
    }
  }

  function d2r(input) {
    return input * D2R;
  }

  function cleanWKT(wkt) {
    if (wkt.type === 'GEOGCS') {
      wkt.projName = 'longlat';
    } else if (wkt.type === 'LOCAL_CS') {
      wkt.projName = 'identity';
      wkt.local = true;
    } else {
      if (typeof wkt.PROJECTION === 'object') {
        wkt.projName = Object.keys(wkt.PROJECTION)[0];
      } else {
        wkt.projName = wkt.PROJECTION;
      }
    }
    if (wkt.AXIS) {
      var axisOrder = '';
      for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
        var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
        if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {
          axisOrder += 'n';
        } else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {
          axisOrder += 's';
        } else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {
          axisOrder += 'e';
        } else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {
          axisOrder += 'w';
        }
      }
      if (axisOrder.length === 2) {
        axisOrder += 'u';
      }
      if (axisOrder.length === 3) {
        wkt.axis = axisOrder;
      }
    }
    if (wkt.UNIT) {
      wkt.units = wkt.UNIT.name.toLowerCase();
      if (wkt.units === 'metre') {
        wkt.units = 'meter';
      }
      if (wkt.UNIT.convert) {
        if (wkt.type === 'GEOGCS') {
          if (wkt.DATUM && wkt.DATUM.SPHEROID) {
            wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
          }
        } else {
          wkt.to_meter = wkt.UNIT.convert;
        }
      }
    }
    var geogcs = wkt.GEOGCS;
    if (wkt.type === 'GEOGCS') {
      geogcs = wkt;
    }
    if (geogcs) {
      //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
      //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
      //}
      if (geogcs.DATUM) {
        wkt.datumCode = geogcs.DATUM.name.toLowerCase();
      } else {
        wkt.datumCode = geogcs.name.toLowerCase();
      }
      if (wkt.datumCode.slice(0, 2) === 'd_') {
        wkt.datumCode = wkt.datumCode.slice(2);
      }
      if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
        wkt.datumCode = 'nzgd49';
      }
      if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
        if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
          wkt.sphere = true;
        }
        wkt.datumCode = 'wgs84';
      }
      if (wkt.datumCode.slice(-6) === '_ferro') {
        wkt.datumCode = wkt.datumCode.slice(0, - 6);
      }
      if (wkt.datumCode.slice(-8) === '_jakarta') {
        wkt.datumCode = wkt.datumCode.slice(0, - 8);
      }
      if (~wkt.datumCode.indexOf('belge')) {
        wkt.datumCode = 'rnb72';
      }
      if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
        wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
        if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
          wkt.ellps = 'intl';
        }

        wkt.a = geogcs.DATUM.SPHEROID.a;
        wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
      }

      if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
        wkt.datum_params = geogcs.DATUM.TOWGS84;
      }
      if (~wkt.datumCode.indexOf('osgb_1936')) {
        wkt.datumCode = 'osgb36';
      }
      if (~wkt.datumCode.indexOf('osni_1952')) {
        wkt.datumCode = 'osni52';
      }
      if (~wkt.datumCode.indexOf('tm65')
        || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
        wkt.datumCode = 'ire65';
      }
      if (wkt.datumCode === 'ch1903+') {
        wkt.datumCode = 'ch1903';
      }
      if (~wkt.datumCode.indexOf('israel')) {
        wkt.datumCode = 'isr93';
      }
    }
    if (wkt.b && !isFinite(wkt.b)) {
      wkt.b = wkt.a;
    }

    function toMeter(input) {
      var ratio = wkt.to_meter || 1;
      return input * ratio;
    }
    var renamer = function(a) {
      return rename(wkt, a);
    };
    var list = [
      ['standard_parallel_1', 'Standard_Parallel_1'],
      ['standard_parallel_1', 'Latitude of 1st standard parallel'],
      ['standard_parallel_2', 'Standard_Parallel_2'],
      ['standard_parallel_2', 'Latitude of 2nd standard parallel'],
      ['false_easting', 'False_Easting'],
      ['false_easting', 'False easting'],
      ['false-easting', 'Easting at false origin'],
      ['false_northing', 'False_Northing'],
      ['false_northing', 'False northing'],
      ['false_northing', 'Northing at false origin'],
      ['central_meridian', 'Central_Meridian'],
      ['central_meridian', 'Longitude of natural origin'],
      ['central_meridian', 'Longitude of false origin'],
      ['latitude_of_origin', 'Latitude_Of_Origin'],
      ['latitude_of_origin', 'Central_Parallel'],
      ['latitude_of_origin', 'Latitude of natural origin'],
      ['latitude_of_origin', 'Latitude of false origin'],
      ['scale_factor', 'Scale_Factor'],
      ['k0', 'scale_factor'],
      ['latitude_of_center', 'Latitude_Of_Center'],
      ['latitude_of_center', 'Latitude_of_center'],
      ['lat0', 'latitude_of_center', d2r],
      ['longitude_of_center', 'Longitude_Of_Center'],
      ['longitude_of_center', 'Longitude_of_center'],
      ['longc', 'longitude_of_center', d2r],
      ['x0', 'false_easting', toMeter],
      ['y0', 'false_northing', toMeter],
      ['long0', 'central_meridian', d2r],
      ['lat0', 'latitude_of_origin', d2r],
      ['lat0', 'standard_parallel_1', d2r],
      ['lat1', 'standard_parallel_1', d2r],
      ['lat2', 'standard_parallel_2', d2r],
      ['azimuth', 'Azimuth'],
      ['alpha', 'azimuth', d2r],
      ['srsCode', 'name']
    ];
    list.forEach(renamer);
    if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
      wkt.long0 = wkt.longc;
    }
    if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
      wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
      wkt.lat_ts = wkt.lat1;
    }
  }
  function wkt(wkt) {
    var lisp = parseString(wkt);
    var type = lisp.shift();
    var name = lisp.shift();
    lisp.unshift(['name', name]);
    lisp.unshift(['type', type]);
    var obj = {};
    sExpr(lisp, obj);
    cleanWKT(obj);
    return obj;
  }

  function defs(name) {
    /*global console*/
    var that = this;
    if (arguments.length === 2) {
      var def = arguments[1];
      if (typeof def === 'string') {
        if (def.charAt(0) === '+') {
          defs[name] = projStr(arguments[1]);
        }
        else {
          defs[name] = wkt(arguments[1]);
        }
      } else {
        defs[name] = def;
      }
    }
    else if (arguments.length === 1) {
      if (Array.isArray(name)) {
        return name.map(function(v) {
          if (Array.isArray(v)) {
            defs.apply(that, v);
          }
          else {
            defs(v);
          }
        });
      }
      else if (typeof name === 'string') {
        if (name in defs) {
          return defs[name];
        }
      }
      else if ('EPSG' in name) {
        defs['EPSG:' + name.EPSG] = name;
      }
      else if ('ESRI' in name) {
        defs['ESRI:' + name.ESRI] = name;
      }
      else if ('IAU2000' in name) {
        defs['IAU2000:' + name.IAU2000] = name;
      }
      else {
        console.log(name);
      }
      return;
    }


  }
  globals(defs);

  function testObj(code){
    return typeof code === 'string';
  }
  function testDef(code){
    return code in defs;
  }
  var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
  function testWKT(code){
    return codeWords.some(function (word) {
      return code.indexOf(word) > -1;
    });
  }
  var codes = ['3857', '900913', '3785', '102113'];
  function checkMercator(item) {
    var auth = match(item, 'authority');
    if (!auth) {
      return;
    }
    var code = match(auth, 'epsg');
    return code && codes.indexOf(code) > -1;
  }
  function checkProjStr(item) {
    var ext = match(item, 'extension');
    if (!ext) {
      return;
    }
    return match(ext, 'proj4');
  }
  function testProj(code){
    return code[0] === '+';
  }
  function parse(code){
    if (testObj(code)) {
      //check to see if this is a WKT string
      if (testDef(code)) {
        return defs[code];
      }
      if (testWKT(code)) {
        var out = wkt(code);
        // test of spetial case, due to this being a very common and often malformed
        if (checkMercator(out)) {
          return defs['EPSG:3857'];
        }
        var maybeProjStr = checkProjStr(out);
        if (maybeProjStr) {
          return projStr(maybeProjStr);
        }
        return out;
      }
      if (testProj(code)) {
        return projStr(code);
      }
    }else {
      return code;
    }
  }

  function extend(destination, source) {
    destination = destination || {};
    var value, property;
    if (!source) {
      return destination;
    }
    for (property in source) {
      value = source[property];
      if (value !== undefined) {
        destination[property] = value;
      }
    }
    return destination;
  }

  function msfnz(eccent, sinphi, cosphi) {
    var con = eccent * sinphi;
    return cosphi / (Math.sqrt(1 - con * con));
  }

  function sign(x) {
    return x<0 ? -1 : 1;
  }

  function adjust_lon(x) {
    return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
  }

  function tsfnz(eccent, phi, sinphi) {
    var con = eccent * sinphi;
    var com = 0.5 * eccent;
    con = Math.pow(((1 - con) / (1 + con)), com);
    return (Math.tan(0.5 * (HALF_PI - phi)) / con);
  }

  function phi2z(eccent, ts) {
    var eccnth = 0.5 * eccent;
    var con, dphi;
    var phi = HALF_PI - 2 * Math.atan(ts);
    for (var i = 0; i <= 15; i++) {
      con = eccent * Math.sin(phi);
      dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }
    //console.log("phi2z has NoConvergence");
    return -9999;
  }

  function init$v() {
    var con = this.b / this.a;
    this.es = 1 - con * con;
    if(!('x0' in this)){
      this.x0 = 0;
    }
    if(!('y0' in this)){
      this.y0 = 0;
    }
    this.e = Math.sqrt(this.es);
    if (this.lat_ts) {
      if (this.sphere) {
        this.k0 = Math.cos(this.lat_ts);
      }
      else {
        this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
      }
    }
    else {
      if (!this.k0) {
        if (this.k) {
          this.k0 = this.k;
        }
        else {
          this.k0 = 1;
        }
      }
    }
  }

  /* Mercator forward equations--mapping lat,long to x,y
    --------------------------------------------------*/

  function forward$u(p) {
    var lon = p.x;
    var lat = p.y;
    // convert to radians
    if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
      return null;
    }

    var x, y;
    if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
      return null;
    }
    else {
      if (this.sphere) {
        x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
        y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
      }
      else {
        var sinphi = Math.sin(lat);
        var ts = tsfnz(this.e, lat, sinphi);
        x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
        y = this.y0 - this.a * this.k0 * Math.log(ts);
      }
      p.x = x;
      p.y = y;
      return p;
    }
  }

  /* Mercator inverse equations--mapping x,y to lat/long
    --------------------------------------------------*/
  function inverse$u(p) {

    var x = p.x - this.x0;
    var y = p.y - this.y0;
    var lon, lat;

    if (this.sphere) {
      lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
    }
    else {
      var ts = Math.exp(-y / (this.a * this.k0));
      lat = phi2z(this.e, ts);
      if (lat === -9999) {
        return null;
      }
    }
    lon = adjust_lon(this.long0 + x / (this.a * this.k0));

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$w = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
  var merc = {
    init: init$v,
    forward: forward$u,
    inverse: inverse$u,
    names: names$w
  };

  function init$u() {
    //no-op for longlat
  }

  function identity(pt) {
    return pt;
  }
  var names$v = ["longlat", "identity"];
  var longlat = {
    init: init$u,
    forward: identity,
    inverse: identity,
    names: names$v
  };

  var projs = [merc, longlat];
  var names$u = {};
  var projStore = [];

  function add(proj, i) {
    var len = projStore.length;
    if (!proj.names) {
      console.log(i);
      return true;
    }
    projStore[len] = proj;
    proj.names.forEach(function(n) {
      names$u[n.toLowerCase()] = len;
    });
    return this;
  }

  function get$1(name) {
    if (!name) {
      return false;
    }
    var n = name.toLowerCase();
    if (typeof names$u[n] !== 'undefined' && projStore[names$u[n]]) {
      return projStore[names$u[n]];
    }
  }

  function start() {
    projs.forEach(add);
  }
  var projections = {
    start: start,
    add: add,
    get: get$1
  };

  var exports$2 = {};
  exports$2.MERIT = {
    a: 6378137.0,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  };

  exports$2.SGS85 = {
    a: 6378136.0,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  };

  exports$2.GRS80 = {
    a: 6378137.0,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  };

  exports$2.IAU76 = {
    a: 6378140.0,
    rf: 298.257,
    ellipseName: "IAU 1976"
  };

  exports$2.airy = {
    a: 6377563.396,
    b: 6356256.910,
    ellipseName: "Airy 1830"
  };

  exports$2.APL4 = {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  };

  exports$2.NWL9D = {
    a: 6378145.0,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  };

  exports$2.mod_airy = {
    a: 6377340.189,
    b: 6356034.446,
    ellipseName: "Modified Airy"
  };

  exports$2.andrae = {
    a: 6377104.43,
    rf: 300.0,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  };

  exports$2.aust_SA = {
    a: 6378160.0,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  };

  exports$2.GRS67 = {
    a: 6378160.0,
    rf: 298.2471674270,
    ellipseName: "GRS 67(IUGG 1967)"
  };

  exports$2.bessel = {
    a: 6377397.155,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  };

  exports$2.bess_nam = {
    a: 6377483.865,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  };

  exports$2.clrk66 = {
    a: 6378206.4,
    b: 6356583.8,
    ellipseName: "Clarke 1866"
  };

  exports$2.clrk80 = {
    a: 6378249.145,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  };

  exports$2.clrk58 = {
    a: 6378293.645208759,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  };

  exports$2.CPM = {
    a: 6375738.7,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  };

  exports$2.delmbr = {
    a: 6376428.0,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  };

  exports$2.engelis = {
    a: 6378136.05,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  };

  exports$2.evrst30 = {
    a: 6377276.345,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  };

  exports$2.evrst48 = {
    a: 6377304.063,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  };

  exports$2.evrst56 = {
    a: 6377301.243,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  };

  exports$2.evrst69 = {
    a: 6377295.664,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  };

  exports$2.evrstSS = {
    a: 6377298.556,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  };

  exports$2.fschr60 = {
    a: 6378166.0,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  };

  exports$2.fschr60m = {
    a: 6378155.0,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  };

  exports$2.fschr68 = {
    a: 6378150.0,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  };

  exports$2.helmert = {
    a: 6378200.0,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  };

  exports$2.hough = {
    a: 6378270.0,
    rf: 297.0,
    ellipseName: "Hough"
  };

  exports$2.intl = {
    a: 6378388.0,
    rf: 297.0,
    ellipseName: "International 1909 (Hayford)"
  };

  exports$2.kaula = {
    a: 6378163.0,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  };

  exports$2.lerch = {
    a: 6378139.0,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  };

  exports$2.mprts = {
    a: 6397300.0,
    rf: 191.0,
    ellipseName: "Maupertius 1738"
  };

  exports$2.new_intl = {
    a: 6378157.5,
    b: 6356772.2,
    ellipseName: "New International 1967"
  };

  exports$2.plessis = {
    a: 6376523.0,
    rf: 6355863.0,
    ellipseName: "Plessis 1817 (France)"
  };

  exports$2.krass = {
    a: 6378245.0,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  };

  exports$2.SEasia = {
    a: 6378155.0,
    b: 6356773.3205,
    ellipseName: "Southeast Asia"
  };

  exports$2.walbeck = {
    a: 6376896.0,
    b: 6355834.8467,
    ellipseName: "Walbeck"
  };

  exports$2.WGS60 = {
    a: 6378165.0,
    rf: 298.3,
    ellipseName: "WGS 60"
  };

  exports$2.WGS66 = {
    a: 6378145.0,
    rf: 298.25,
    ellipseName: "WGS 66"
  };

  exports$2.WGS7 = {
    a: 6378135.0,
    rf: 298.26,
    ellipseName: "WGS 72"
  };

  var WGS84 = exports$2.WGS84 = {
    a: 6378137.0,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  };

  exports$2.sphere = {
    a: 6370997.0,
    b: 6370997.0,
    ellipseName: "Normal Sphere (r=6370997)"
  };

  function eccentricity(a, b, rf, R_A) {
    var a2 = a * a; // used in geocentric
    var b2 = b * b; // used in geocentric
    var es = (a2 - b2) / a2; // e ^ 2
    var e = 0;
    if (R_A) {
      a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
      a2 = a * a;
      es = 0;
    } else {
      e = Math.sqrt(es); // eccentricity
    }
    var ep2 = (a2 - b2) / b2; // used in geocentric
    return {
      es: es,
      e: e,
      ep2: ep2
    };
  }
  function sphere(a, b, rf, ellps, sphere) {
    if (!a) { // do we have an ellipsoid?
      var ellipse = match(exports$2, ellps);
      if (!ellipse) {
        ellipse = WGS84;
      }
      a = ellipse.a;
      b = ellipse.b;
      rf = ellipse.rf;
    }

    if (rf && !b) {
      b = (1.0 - 1.0 / rf) * a;
    }
    if (rf === 0 || Math.abs(a - b) < EPSLN) {
      sphere = true;
      b = a;
    }
    return {
      a: a,
      b: b,
      rf: rf,
      sphere: sphere
    };
  }

  var exports$1 = {};
  exports$1.wgs84 = {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  };

  exports$1.ch1903 = {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  };

  exports$1.ggrs87 = {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  };

  exports$1.nad83 = {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  };

  exports$1.nad27 = {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  };

  exports$1.potsdam = {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  };

  exports$1.carthage = {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  };

  exports$1.hermannskogel = {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  };

  exports$1.osni52 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  };

  exports$1.ire65 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  };

  exports$1.rassadiran = {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  };

  exports$1.nzgd49 = {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  };

  exports$1.osgb36 = {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Airy 1830"
  };

  exports$1.s_jtsk = {
    towgs84: "589,76,480",
    ellipse: 'bessel',
    datumName: 'S-JTSK (Ferro)'
  };

  exports$1.beduaram = {
    towgs84: '-106,-87,188',
    ellipse: 'clrk80',
    datumName: 'Beduaram'
  };

  exports$1.gunung_segara = {
    towgs84: '-403,684,41',
    ellipse: 'bessel',
    datumName: 'Gunung Segara Jakarta'
  };

  exports$1.rnb72 = {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  };

  function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
    var out = {};

    if (datumCode === undefined || datumCode === 'none') {
      out.datum_type = PJD_NODATUM;
    } else {
      out.datum_type = PJD_WGS84;
    }

    if (datum_params) {
      out.datum_params = datum_params.map(parseFloat);
      if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
        out.datum_type = PJD_3PARAM;
      }
      if (out.datum_params.length > 3) {
        if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
          out.datum_type = PJD_7PARAM;
          out.datum_params[3] *= SEC_TO_RAD;
          out.datum_params[4] *= SEC_TO_RAD;
          out.datum_params[5] *= SEC_TO_RAD;
          out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
        }
      }
    }

    if (nadgrids) {
      out.datum_type = PJD_GRIDSHIFT;
      out.grids = nadgrids;
    }
    out.a = a; //datum object also uses these values
    out.b = b;
    out.es = es;
    out.ep2 = ep2;
    return out;
  }

  /**
   * Resources for details of NTv2 file formats:
   * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
   * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
   */

  var loadedNadgrids = {};

  /**
   * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
   * as an ArrayBuffer.
   */
  function nadgrid(key, data) {
    var view = new DataView(data);
    var isLittleEndian = detectLittleEndian(view);
    var header = readHeader(view, isLittleEndian);
    if (header.nSubgrids > 1) {
      console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
    }
    var subgrids = readSubgrids(view, header, isLittleEndian);
    var nadgrid = {header: header, subgrids: subgrids};
    loadedNadgrids[key] = nadgrid;
    return nadgrid;
  }

  /**
   * Given a proj4 value for nadgrids, return an array of loaded grids
   */
  function getNadgrids(nadgrids) {
    // Format details: http://proj.maptools.org/gen_parms.html
    if (nadgrids === undefined) { return null; }
    var grids = nadgrids.split(',');
    return grids.map(parseNadgridString);
  }

  function parseNadgridString(value) {
    if (value.length === 0) {
      return null;
    }
    var optional = value[0] === '@';
    if (optional) {
      value = value.slice(1);
    }
    if (value === 'null') {
      return {name: 'null', mandatory: !optional, grid: null, isNull: true};
    }
    return {
      name: value,
      mandatory: !optional,
      grid: loadedNadgrids[value] || null,
      isNull: false
    };
  }

  function secondsToRadians(seconds) {
    return (seconds / 3600) * Math.PI / 180;
  }

  function detectLittleEndian(view) {
    var nFields = view.getInt32(8, false);
    if (nFields === 11) {
      return false;
    }
    nFields = view.getInt32(8, true);
    if (nFields !== 11) {
      console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
    }
    return true;
  }

  function readHeader(view, isLittleEndian) {
    return {
      nFields: view.getInt32(8, isLittleEndian),
      nSubgridFields: view.getInt32(24, isLittleEndian),
      nSubgrids: view.getInt32(40, isLittleEndian),
      shiftType: decodeString(view, 56, 56 + 8).trim(),
      fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
      fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
      toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
      toSemiMinorAxis: view.getFloat64(168, isLittleEndian),
    };
  }

  function decodeString(view, start, end) {
    return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
  }

  function readSubgrids(view, header, isLittleEndian) {
    var gridOffset = 176;
    var grids = [];
    for (var i = 0; i < header.nSubgrids; i++) {
      var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
      var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
      var lngColumnCount = Math.round(
        1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
      var latColumnCount = Math.round(
        1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
      // Proj4 operates on radians whereas the coordinates are in seconds in the grid
      grids.push({
        ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
        del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
        lim: [lngColumnCount, latColumnCount],
        count: subHeader.gridNodeCount,
        cvs: mapNodes(nodes)
      });
    }
    return grids;
  }

  function mapNodes(nodes) {
    return nodes.map(function (r) {return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];});
  }

  function readGridHeader(view, offset, isLittleEndian) {
    return {
      name: decodeString(view, offset + 8, offset + 16).trim(),
      parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
      lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
      upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
      lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
      upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
      latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
      longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
      gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
    };
  }

  function readGridNodes(view, offset, gridHeader, isLittleEndian) {
    var nodesOffset = offset + 176;
    var gridRecordLength = 16;
    var gridShiftRecords = [];
    for (var i = 0; i < gridHeader.gridNodeCount; i++) {
      var record = {
        latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
        longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
        latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
        longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),
      };
      gridShiftRecords.push(record);
    }
    return gridShiftRecords;
  }

  function Projection(srsCode,callback) {
    if (!(this instanceof Projection)) {
      return new Projection(srsCode);
    }
    callback = callback || function(error){
      if(error){
        throw error;
      }
    };
    var json = parse(srsCode);
    if(typeof json !== 'object'){
      callback(srsCode);
      return;
    }
    var ourProj = Projection.projections.get(json.projName);
    if(!ourProj){
      callback(srsCode);
      return;
    }
    if (json.datumCode && json.datumCode !== 'none') {
      var datumDef = match(exports$1, json.datumCode);
      if (datumDef) {
        json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
        json.ellps = datumDef.ellipse;
        json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
      }
    }
    json.k0 = json.k0 || 1.0;
    json.axis = json.axis || 'enu';
    json.ellps = json.ellps || 'wgs84';
    json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

    var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
    var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
    var nadgrids = getNadgrids(json.nadgrids);
    var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,
      nadgrids);

    extend(this, json); // transfer everything over from the projection because we don't know what we'll need
    extend(this, ourProj); // transfer all the methods from the projection

    // copy the 4 things over we calculated in deriveConstants.sphere
    this.a = sphere_.a;
    this.b = sphere_.b;
    this.rf = sphere_.rf;
    this.sphere = sphere_.sphere;

    // copy the 3 things we calculated in deriveConstants.eccentricity
    this.es = ecc.es;
    this.e = ecc.e;
    this.ep2 = ecc.ep2;

    // add in the datum object
    this.datum = datumObj;

    // init the projection
    this.init();

    // legecy callback from back in the day when it went to spatialreference.org
    callback(null, this);

  }
  Projection.projections = projections;
  Projection.projections.start();

  function compareDatums(source, dest) {
    if (source.datum_type !== dest.datum_type) {
      return false; // false, datums are not equal
    } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
      // the tolerance for es is to ensure that GRS80 and WGS84
      // are considered identical
      return false;
    } else if (source.datum_type === PJD_3PARAM) {
      return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
    } else if (source.datum_type === PJD_7PARAM) {
      return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
    } else {
      return true; // datums are equal
    }
  } // cs_compare_datums()

  /*
   * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
   * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
   * according to the current ellipsoid parameters.
   *
   *    Latitude  : Geodetic latitude in radians                     (input)
   *    Longitude : Geodetic longitude in radians                    (input)
   *    Height    : Geodetic height, in meters                       (input)
   *    X         : Calculated Geocentric X coordinate, in meters    (output)
   *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
   *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
   *
   */
  function geodeticToGeocentric(p, es, a) {
    var Longitude = p.x;
    var Latitude = p.y;
    var Height = p.z ? p.z : 0; //Z value not always supplied

    var Rn; /*  Earth radius at location  */
    var Sin_Lat; /*  Math.sin(Latitude)  */
    var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
    var Cos_Lat; /*  Math.cos(Latitude)  */

    /*
     ** Don't blow up if Latitude is just a little out of the value
     ** range as it may just be a rounding issue.  Also removed longitude
     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
     */
    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
      Latitude = -HALF_PI;
    } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
      Latitude = HALF_PI;
    } else if (Latitude < -HALF_PI) {
      /* Latitude out of range */
      //..reportError('geocent:lat out of range:' + Latitude);
      return { x: -Infinity, y: -Infinity, z: p.z };
    } else if (Latitude > HALF_PI) {
      /* Latitude out of range */
      return { x: Infinity, y: Infinity, z: p.z };
    }

    if (Longitude > Math.PI) {
      Longitude -= (2 * Math.PI);
    }
    Sin_Lat = Math.sin(Latitude);
    Cos_Lat = Math.cos(Latitude);
    Sin2_Lat = Sin_Lat * Sin_Lat;
    Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
    return {
      x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
      y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
      z: ((Rn * (1 - es)) + Height) * Sin_Lat
    };
  } // cs_geodetic_to_geocentric()

  function geocentricToGeodetic(p, es, a, b) {
    /* local defintions and variables */
    /* end-criterium of loop, accuracy of sin(Latitude) */
    var genau = 1e-12;
    var genau2 = (genau * genau);
    var maxiter = 30;

    var P; /* distance between semi-minor axis and location */
    var RR; /* distance between center and location */
    var CT; /* sin of geocentric latitude */
    var ST; /* cos of geocentric latitude */
    var RX;
    var RK;
    var RN; /* Earth radius at location */
    var CPHI0; /* cos of start or old geodetic latitude in iterations */
    var SPHI0; /* sin of start or old geodetic latitude in iterations */
    var CPHI; /* cos of searched geodetic latitude */
    var SPHI; /* sin of searched geodetic latitude */
    var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
    var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

    var X = p.x;
    var Y = p.y;
    var Z = p.z ? p.z : 0.0; //Z value not always supplied
    var Longitude;
    var Latitude;
    var Height;

    P = Math.sqrt(X * X + Y * Y);
    RR = Math.sqrt(X * X + Y * Y + Z * Z);

    /*      special cases for latitude and longitude */
    if (P / a < genau) {

      /*  special case, if P=0. (X=0., Y=0.) */
      Longitude = 0.0;

      /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
       *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
      if (RR / a < genau) {
        Latitude = HALF_PI;
        Height = -b;
        return {
          x: p.x,
          y: p.y,
          z: p.z
        };
      }
    } else {
      /*  ellipsoidal (geodetic) longitude
       *  interval: -PI < Longitude <= +PI */
      Longitude = Math.atan2(Y, X);
    }

    /* --------------------------------------------------------------
     * Following iterative algorithm was developped by
     * "Institut for Erdmessung", University of Hannover, July 1988.
     * Internet: www.ife.uni-hannover.de
     * Iterative computation of CPHI,SPHI and Height.
     * Iteration of CPHI and SPHI to 10**-12 radian resp.
     * 2*10**-7 arcsec.
     * --------------------------------------------------------------
     */
    CT = Z / RR;
    ST = P / RR;
    RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
    CPHI0 = ST * (1.0 - es) * RX;
    SPHI0 = CT * RX;
    iter = 0;

    /* loop to find sin(Latitude) resp. Latitude
     * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
    do {
      iter++;
      RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

      /*  ellipsoidal (geodetic) height */
      Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

      RK = es * RN / (RN + Height);
      RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
      CPHI = ST * (1.0 - RK) * RX;
      SPHI = CT * RX;
      SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
      CPHI0 = CPHI;
      SPHI0 = SPHI;
    }
    while (SDPHI * SDPHI > genau2 && iter < maxiter);

    /*      ellipsoidal (geodetic) latitude */
    Latitude = Math.atan(SPHI / Math.abs(CPHI));
    return {
      x: Longitude,
      y: Latitude,
      z: Height
    };
  } // cs_geocentric_to_geodetic()

  /****************************************************************/
  // pj_geocentic_to_wgs84( p )
  //  p = point to transform in geocentric coordinates (x,y,z)


  /** point object, nothing fancy, just allows values to be
      passed back and forth by reference rather than by value.
      Other point classes may be used as long as they have
      x and y properties, which will get modified in the transform method.
  */
  function geocentricToWgs84(p, datum_type, datum_params) {

    if (datum_type === PJD_3PARAM) {
      // if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: p.x + datum_params[0],
        y: p.y + datum_params[1],
        z: p.z + datum_params[2],
      };
    } else if (datum_type === PJD_7PARAM) {
      var Dx_BF = datum_params[0];
      var Dy_BF = datum_params[1];
      var Dz_BF = datum_params[2];
      var Rx_BF = datum_params[3];
      var Ry_BF = datum_params[4];
      var Rz_BF = datum_params[5];
      var M_BF = datum_params[6];
      // if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
        y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
        z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
      };
    }
  } // cs_geocentric_to_wgs84

  /****************************************************************/
  // pj_geocentic_from_wgs84()
  //  coordinate system definition,
  //  point to transform in geocentric coordinates (x,y,z)
  function geocentricFromWgs84(p, datum_type, datum_params) {

    if (datum_type === PJD_3PARAM) {
      //if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: p.x - datum_params[0],
        y: p.y - datum_params[1],
        z: p.z - datum_params[2],
      };

    } else if (datum_type === PJD_7PARAM) {
      var Dx_BF = datum_params[0];
      var Dy_BF = datum_params[1];
      var Dz_BF = datum_params[2];
      var Rx_BF = datum_params[3];
      var Ry_BF = datum_params[4];
      var Rz_BF = datum_params[5];
      var M_BF = datum_params[6];
      var x_tmp = (p.x - Dx_BF) / M_BF;
      var y_tmp = (p.y - Dy_BF) / M_BF;
      var z_tmp = (p.z - Dz_BF) / M_BF;
      //if( x[io] === HUGE_VAL )
      //    continue;

      return {
        x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
        y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
        z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
      };
    } //cs_geocentric_from_wgs84()
  }

  function checkParams(type) {
    return (type === PJD_3PARAM || type === PJD_7PARAM);
  }

  function datum_transform(source, dest, point) {
    // Short cut if the datums are identical.
    if (compareDatums(source, dest)) {
      return point; // in this case, zero is sucess,
      // whereas cs_compare_datums returns 1 to indicate TRUE
      // confusing, should fix this
    }

    // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
    if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
      return point;
    }

    // If this datum requires grid shifts, then apply it to geodetic coordinates.
    var source_a = source.a;
    var source_es = source.es;
    if (source.datum_type === PJD_GRIDSHIFT) {
      var gridShiftCode = applyGridShift(source, false, point);
      if (gridShiftCode !== 0) {
        return undefined;
      }
      source_a = SRS_WGS84_SEMIMAJOR;
      source_es = SRS_WGS84_ESQUARED;
    }

    var dest_a = dest.a;
    var dest_b = dest.b;
    var dest_es = dest.es;
    if (dest.datum_type === PJD_GRIDSHIFT) {
      dest_a = SRS_WGS84_SEMIMAJOR;
      dest_b = SRS_WGS84_SEMIMINOR;
      dest_es = SRS_WGS84_ESQUARED;
    }

    // Do we need to go through geocentric coordinates?
    if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
      return point;
    }

    // Convert to geocentric coordinates.
    point = geodeticToGeocentric(point, source_es, source_a);
    // Convert between datums
    if (checkParams(source.datum_type)) {
      point = geocentricToWgs84(point, source.datum_type, source.datum_params);
    }
    if (checkParams(dest.datum_type)) {
      point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
    }
    point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

    if (dest.datum_type === PJD_GRIDSHIFT) {
      var destGridShiftResult = applyGridShift(dest, true, point);
      if (destGridShiftResult !== 0) {
        return undefined;
      }
    }

    return point;
  }

  function applyGridShift(source, inverse, point) {
    if (source.grids === null || source.grids.length === 0) {
      console.log('Grid shift grids not found');
      return -1;
    }
    var input = {x: -point.x, y: point.y};
    var output = {x: Number.NaN, y: Number.NaN};
    var attemptedGrids = [];
    for (var i = 0; i < source.grids.length; i++) {
      var grid = source.grids[i];
      attemptedGrids.push(grid.name);
      if (grid.isNull) {
        output = input;
        break;
      }
      if (grid.grid === null) {
        if (grid.mandatory) {
          console.log("Unable to find mandatory grid '" + grid.name + "'");
          return -1;
        }
        continue;
      }
      var subgrid = grid.grid.subgrids[0];
      // skip tables that don't match our point at all
      var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
      var minX = subgrid.ll[0] - epsilon;
      var minY = subgrid.ll[1] - epsilon;
      var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
      var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
      if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {
        continue;
      }
      output = applySubgridShift(input, inverse, subgrid);
      if (!isNaN(output.x)) {
        break;
      }
    }
    if (isNaN(output.x)) {
      console.log("Failed to find a grid shift table for location '"+
        -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
      return -1;
    }
    point.x = -output.x;
    point.y = output.y;
    return 0;
  }

  function applySubgridShift(pin, inverse, ct) {
    var val = {x: Number.NaN, y: Number.NaN};
    if (isNaN(pin.x)) { return val; }
    var tb = {x: pin.x, y: pin.y};
    tb.x -= ct.ll[0];
    tb.y -= ct.ll[1];
    tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
    var t = nadInterpolate(tb, ct);
    if (inverse) {
      if (isNaN(t.x)) {
        return val;
      }
      t.x = tb.x - t.x;
      t.y = tb.y - t.y;
      var i = 9, tol = 1e-12;
      var dif, del;
      do {
        del = nadInterpolate(t, ct);
        if (isNaN(del.x)) {
          console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
          break;
        }
        dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};
        t.x += dif.x;
        t.y += dif.y;
      } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
      if (i < 0) {
        console.log("Inverse grid shift iterator failed to converge.");
        return val;
      }
      val.x = adjust_lon(t.x + ct.ll[0]);
      val.y = t.y + ct.ll[1];
    } else {
      if (!isNaN(t.x)) {
        val.x = pin.x + t.x;
        val.y = pin.y + t.y;
      }
    }
    return val;
  }

  function nadInterpolate(pin, ct) {
    var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};
    var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};
    var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};
    var val= {x: Number.NaN, y: Number.NaN};
    var inx;
    if (indx.x < 0 || indx.x >= ct.lim[0]) {
      return val;
    }
    if (indx.y < 0 || indx.y >= ct.lim[1]) {
      return val;
    }
    inx = (indx.y * ct.lim[0]) + indx.x;
    var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
    inx++;
    var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
    inx += ct.lim[0];
    var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
    inx--;
    var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
    var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),
      m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;
    val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);
    val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);
    return val;
  }

  function adjust_axis(crs, denorm, point) {
    var xin = point.x,
      yin = point.y,
      zin = point.z || 0.0;
    var v, t, i;
    var out = {};
    for (i = 0; i < 3; i++) {
      if (denorm && i === 2 && point.z === undefined) {
        continue;
      }
      if (i === 0) {
        v = xin;
        if ("ew".indexOf(crs.axis[i]) !== -1) {
          t = 'x';
        } else {
          t = 'y';
        }

      }
      else if (i === 1) {
        v = yin;
        if ("ns".indexOf(crs.axis[i]) !== -1) {
          t = 'y';
        } else {
          t = 'x';
        }
      }
      else {
        v = zin;
        t = 'z';
      }
      switch (crs.axis[i]) {
      case 'e':
        out[t] = v;
        break;
      case 'w':
        out[t] = -v;
        break;
      case 'n':
        out[t] = v;
        break;
      case 's':
        out[t] = -v;
        break;
      case 'u':
        if (point[t] !== undefined) {
          out.z = v;
        }
        break;
      case 'd':
        if (point[t] !== undefined) {
          out.z = -v;
        }
        break;
      default:
        //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
        return null;
      }
    }
    return out;
  }

  function common (array){
    var out = {
      x: array[0],
      y: array[1]
    };
    if (array.length>2) {
      out.z = array[2];
    }
    if (array.length>3) {
      out.m = array[3];
    }
    return out;
  }

  function checkSanity (point) {
    checkCoord(point.x);
    checkCoord(point.y);
  }
  function checkCoord(num) {
    if (typeof Number.isFinite === 'function') {
      if (Number.isFinite(num)) {
        return;
      }
      throw new TypeError('coordinates must be finite numbers');
    }
    if (typeof num !== 'number' || num !== num || !isFinite(num)) {
      throw new TypeError('coordinates must be finite numbers');
    }
  }

  function checkNotWGS(source, dest) {
    return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
  }

  function transform(source, dest, point, enforceAxis) {
    var wgs84;
    if (Array.isArray(point)) {
      point = common(point);
    }
    checkSanity(point);
    // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
    if (source.datum && dest.datum && checkNotWGS(source, dest)) {
      wgs84 = new Projection('WGS84');
      point = transform(source, wgs84, point, enforceAxis);
      source = wgs84;
    }
    // DGR, 2010/11/12
    if (enforceAxis && source.axis !== 'enu') {
      point = adjust_axis(source, false, point);
    }
    // Transform source points to long/lat, if they aren't already.
    if (source.projName === 'longlat') {
      point = {
        x: point.x * D2R$1,
        y: point.y * D2R$1,
        z: point.z || 0
      };
    } else {
      if (source.to_meter) {
        point = {
          x: point.x * source.to_meter,
          y: point.y * source.to_meter,
          z: point.z || 0
        };
      }
      point = source.inverse(point); // Convert Cartesian to longlat
      if (!point) {
        return;
      }
    }
    // Adjust for the prime meridian if necessary
    if (source.from_greenwich) {
      point.x += source.from_greenwich;
    }

    // Convert datums if needed, and if possible.
    point = datum_transform(source.datum, dest.datum, point);
    if (!point) {
      return;
    }

    // Adjust for the prime meridian if necessary
    if (dest.from_greenwich) {
      point = {
        x: point.x - dest.from_greenwich,
        y: point.y,
        z: point.z || 0
      };
    }

    if (dest.projName === 'longlat') {
      // convert radians to decimal degrees
      point = {
        x: point.x * R2D,
        y: point.y * R2D,
        z: point.z || 0
      };
    } else { // else project
      point = dest.forward(point);
      if (dest.to_meter) {
        point = {
          x: point.x / dest.to_meter,
          y: point.y / dest.to_meter,
          z: point.z || 0
        };
      }
    }

    // DGR, 2010/11/12
    if (enforceAxis && dest.axis !== 'enu') {
      return adjust_axis(dest, true, point);
    }

    return point;
  }

  var wgs84 = Projection('WGS84');

  function transformer(from, to, coords, enforceAxis) {
    var transformedArray, out, keys;
    if (Array.isArray(coords)) {
      transformedArray = transform(from, to, coords, enforceAxis) || {x: NaN, y: NaN};
      if (coords.length > 2) {
        if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
          if (typeof transformedArray.z === 'number') {
            return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
          } else {
            return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
          }
        } else {
          return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
        }
      } else {
        return [transformedArray.x, transformedArray.y];
      }
    } else {
      out = transform(from, to, coords, enforceAxis);
      keys = Object.keys(coords);
      if (keys.length === 2) {
        return out;
      }
      keys.forEach(function (key) {
        if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
          if (key === 'x' || key === 'y' || key === 'z') {
            return;
          }
        } else {
          if (key === 'x' || key === 'y') {
            return;
          }
        }
        out[key] = coords[key];
      });
      return out;
    }
  }

  function checkProj(item) {
    if (item instanceof Projection) {
      return item;
    }
    if (item.oProj) {
      return item.oProj;
    }
    return Projection(item);
  }

  function proj4(fromProj, toProj, coord) {
    fromProj = checkProj(fromProj);
    var single = false;
    var obj;
    if (typeof toProj === 'undefined') {
      toProj = fromProj;
      fromProj = wgs84;
      single = true;
    } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
      coord = toProj;
      toProj = fromProj;
      fromProj = wgs84;
      single = true;
    }
    toProj = checkProj(toProj);
    if (coord) {
      return transformer(fromProj, toProj, coord);
    } else {
      obj = {
        forward: function (coords, enforceAxis) {
          return transformer(fromProj, toProj, coords, enforceAxis);
        },
        inverse: function (coords, enforceAxis) {
          return transformer(toProj, fromProj, coords, enforceAxis);
        }
      };
      if (single) {
        obj.oProj = toProj;
      }
      return obj;
    }
  }

  /**
   * UTM zones are grouped, and assigned to one of a group of 6
   * sets.
   *
   * {int} @private
   */
  var NUM_100K_SETS = 6;

  /**
   * The column letters (for easting) of the lower left value, per
   * set.
   *
   * {string} @private
   */
  var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

  /**
   * The row letters (for northing) of the lower left value, per
   * set.
   *
   * {string} @private
   */
  var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

  var A = 65; // A
  var I = 73; // I
  var O = 79; // O
  var V = 86; // V
  var Z = 90; // Z
  var mgrs = {
    forward: forward$t,
    inverse: inverse$t,
    toPoint: toPoint
  };
  /**
   * Conversion of lat/lon to MGRS.
   *
   * @param {object} ll Object literal with lat and lon properties on a
   *     WGS84 ellipsoid.
   * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
   *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
   * @return {string} the MGRS string for the given location and accuracy.
   */
  function forward$t(ll, accuracy) {
    accuracy = accuracy || 5; // default accuracy 1m
    return encode$1(LLtoUTM({
      lat: ll[1],
      lon: ll[0]
    }), accuracy);
  }
  /**
   * Conversion of MGRS to lat/lon.
   *
   * @param {string} mgrs MGRS string.
   * @return {array} An array with left (longitude), bottom (latitude), right
   *     (longitude) and top (latitude) values in WGS84, representing the
   *     bounding box for the provided MGRS reference.
   */
  function inverse$t(mgrs) {
    var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
      return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
    }
    return [bbox.left, bbox.bottom, bbox.right, bbox.top];
  }
  function toPoint(mgrs) {
    var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
      return [bbox.lon, bbox.lat];
    }
    return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
  }/**
   * Conversion from degrees to radians.
   *
   * @private
   * @param {number} deg the angle in degrees.
   * @return {number} the angle in radians.
   */
  function degToRad(deg) {
    return (deg * (Math.PI / 180.0));
  }

  /**
   * Conversion from radians to degrees.
   *
   * @private
   * @param {number} rad the angle in radians.
   * @return {number} the angle in degrees.
   */
  function radToDeg(rad) {
    return (180.0 * (rad / Math.PI));
  }

  /**
   * Converts a set of Longitude and Latitude co-ordinates to UTM
   * using the WGS84 ellipsoid.
   *
   * @private
   * @param {object} ll Object literal with lat and lon properties
   *     representing the WGS84 coordinate to be converted.
   * @return {object} Object literal containing the UTM value with easting,
   *     northing, zoneNumber and zoneLetter properties, and an optional
   *     accuracy property in digits. Returns null if the conversion failed.
   */
  function LLtoUTM(ll) {
    var Lat = ll.lat;
    var Long = ll.lon;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var k0 = 0.9996;
    var LongOrigin;
    var eccPrimeSquared;
    var N, T, C, A, M;
    var LatRad = degToRad(Lat);
    var LongRad = degToRad(Long);
    var LongOriginRad;
    var ZoneNumber;
    // (int)
    ZoneNumber = Math.floor((Long + 180) / 6) + 1;

    //Make sure the longitude 180.00 is in Zone 60
    if (Long === 180) {
      ZoneNumber = 60;
    }

    // Special zone for Norway
    if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
      ZoneNumber = 32;
    }

    // Special zones for Svalbard
    if (Lat >= 72.0 && Lat < 84.0) {
      if (Long >= 0.0 && Long < 9.0) {
        ZoneNumber = 31;
      }
      else if (Long >= 9.0 && Long < 21.0) {
        ZoneNumber = 33;
      }
      else if (Long >= 21.0 && Long < 33.0) {
        ZoneNumber = 35;
      }
      else if (Long >= 33.0 && Long < 42.0) {
        ZoneNumber = 37;
      }
    }

    LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
    // in middle of
    // zone
    LongOriginRad = degToRad(LongOrigin);

    eccPrimeSquared = (eccSquared) / (1 - eccSquared);

    N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
    T = Math.tan(LatRad) * Math.tan(LatRad);
    C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
    A = Math.cos(LatRad) * (LongRad - LongOriginRad);

    M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

    var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

    var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
    if (Lat < 0.0) {
      UTMNorthing += 10000000.0; //10000000 meter offset for
      // southern hemisphere
    }

    return {
      northing: Math.round(UTMNorthing),
      easting: Math.round(UTMEasting),
      zoneNumber: ZoneNumber,
      zoneLetter: getLetterDesignator(Lat)
    };
  }

  /**
   * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
   * class where the Zone can be specified as a single string eg."60N" which
   * is then broken down into the ZoneNumber and ZoneLetter.
   *
   * @private
   * @param {object} utm An object literal with northing, easting, zoneNumber
   *     and zoneLetter properties. If an optional accuracy property is
   *     provided (in meters), a bounding box will be returned instead of
   *     latitude and longitude.
   * @return {object} An object literal containing either lat and lon values
   *     (if no accuracy was provided), or top, right, bottom and left values
   *     for the bounding box calculated according to the provided accuracy.
   *     Returns null if the conversion failed.
   */
  function UTMtoLL(utm) {

    var UTMNorthing = utm.northing;
    var UTMEasting = utm.easting;
    var zoneLetter = utm.zoneLetter;
    var zoneNumber = utm.zoneNumber;
    // check the ZoneNummber is valid
    if (zoneNumber < 0 || zoneNumber > 60) {
      return null;
    }

    var k0 = 0.9996;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var eccPrimeSquared;
    var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
    var N1, T1, C1, R1, D, M;
    var LongOrigin;
    var mu, phi1Rad;

    // remove 500,000 meter offset for longitude
    var x = UTMEasting - 500000.0;
    var y = UTMNorthing;

    // We must know somehow if we are in the Northern or Southern
    // hemisphere, this is the only time we use the letter So even
    // if the Zone letter isn't exactly correct it should indicate
    // the hemisphere correctly
    if (zoneLetter < 'N') {
      y -= 10000000.0; // remove 10,000,000 meter offset used
      // for southern hemisphere
    }

    // There are 60 zones with zone 1 being at West -180 to -174
    LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
    // in middle of
    // zone

    eccPrimeSquared = (eccSquared) / (1 - eccSquared);

    M = y / k0;
    mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

    phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
    // double phi1 = ProjMath.radToDeg(phi1Rad);

    N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
    T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
    C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
    R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
    D = x / (N1 * k0);

    var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
    lat = radToDeg(lat);

    var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
    lon = LongOrigin + radToDeg(lon);

    var result;
    if (utm.accuracy) {
      var topRight = UTMtoLL({
        northing: utm.northing + utm.accuracy,
        easting: utm.easting + utm.accuracy,
        zoneLetter: utm.zoneLetter,
        zoneNumber: utm.zoneNumber
      });
      result = {
        top: topRight.lat,
        right: topRight.lon,
        bottom: lat,
        left: lon
      };
    }
    else {
      result = {
        lat: lat,
        lon: lon
      };
    }
    return result;
  }

  /**
   * Calculates the MGRS letter designator for the given latitude.
   *
   * @private
   * @param {number} lat The latitude in WGS84 to get the letter designator
   *     for.
   * @return {char} The letter designator.
   */
  function getLetterDesignator(lat) {
    //This is here as an error flag to show that the Latitude is
    //outside MGRS limits
    var LetterDesignator = 'Z';

    if ((84 >= lat) && (lat >= 72)) {
      LetterDesignator = 'X';
    }
    else if ((72 > lat) && (lat >= 64)) {
      LetterDesignator = 'W';
    }
    else if ((64 > lat) && (lat >= 56)) {
      LetterDesignator = 'V';
    }
    else if ((56 > lat) && (lat >= 48)) {
      LetterDesignator = 'U';
    }
    else if ((48 > lat) && (lat >= 40)) {
      LetterDesignator = 'T';
    }
    else if ((40 > lat) && (lat >= 32)) {
      LetterDesignator = 'S';
    }
    else if ((32 > lat) && (lat >= 24)) {
      LetterDesignator = 'R';
    }
    else if ((24 > lat) && (lat >= 16)) {
      LetterDesignator = 'Q';
    }
    else if ((16 > lat) && (lat >= 8)) {
      LetterDesignator = 'P';
    }
    else if ((8 > lat) && (lat >= 0)) {
      LetterDesignator = 'N';
    }
    else if ((0 > lat) && (lat >= -8)) {
      LetterDesignator = 'M';
    }
    else if ((-8 > lat) && (lat >= -16)) {
      LetterDesignator = 'L';
    }
    else if ((-16 > lat) && (lat >= -24)) {
      LetterDesignator = 'K';
    }
    else if ((-24 > lat) && (lat >= -32)) {
      LetterDesignator = 'J';
    }
    else if ((-32 > lat) && (lat >= -40)) {
      LetterDesignator = 'H';
    }
    else if ((-40 > lat) && (lat >= -48)) {
      LetterDesignator = 'G';
    }
    else if ((-48 > lat) && (lat >= -56)) {
      LetterDesignator = 'F';
    }
    else if ((-56 > lat) && (lat >= -64)) {
      LetterDesignator = 'E';
    }
    else if ((-64 > lat) && (lat >= -72)) {
      LetterDesignator = 'D';
    }
    else if ((-72 > lat) && (lat >= -80)) {
      LetterDesignator = 'C';
    }
    return LetterDesignator;
  }

  /**
   * Encodes a UTM location as MGRS string.
   *
   * @private
   * @param {object} utm An object literal with easting, northing,
   *     zoneLetter, zoneNumber
   * @param {number} accuracy Accuracy in digits (1-5).
   * @return {string} MGRS string for the given UTM location.
   */
  function encode$1(utm, accuracy) {
    // prepend with leading zeroes
    var seasting = "00000" + utm.easting,
      snorthing = "00000" + utm.northing;

    return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
  }

  /**
   * Get the two letter 100k designator for a given UTM easting,
   * northing and zone number value.
   *
   * @private
   * @param {number} easting
   * @param {number} northing
   * @param {number} zoneNumber
   * @return the two letter 100k designator for the given UTM location.
   */
  function get100kID(easting, northing, zoneNumber) {
    var setParm = get100kSetForZone(zoneNumber);
    var setColumn = Math.floor(easting / 100000);
    var setRow = Math.floor(northing / 100000) % 20;
    return getLetter100kID(setColumn, setRow, setParm);
  }

  /**
   * Given a UTM zone number, figure out the MGRS 100K set it is in.
   *
   * @private
   * @param {number} i An UTM zone number.
   * @return {number} the 100k set the UTM zone is in.
   */
  function get100kSetForZone(i) {
    var setParm = i % NUM_100K_SETS;
    if (setParm === 0) {
      setParm = NUM_100K_SETS;
    }

    return setParm;
  }

  /**
   * Get the two-letter MGRS 100k designator given information
   * translated from the UTM northing, easting and zone number.
   *
   * @private
   * @param {number} column the column index as it relates to the MGRS
   *        100k set spreadsheet, created from the UTM easting.
   *        Values are 1-8.
   * @param {number} row the row index as it relates to the MGRS 100k set
   *        spreadsheet, created from the UTM northing value. Values
   *        are from 0-19.
   * @param {number} parm the set block, as it relates to the MGRS 100k set
   *        spreadsheet, created from the UTM zone. Values are from
   *        1-60.
   * @return two letter MGRS 100k code.
   */
  function getLetter100kID(column, row, parm) {
    // colOrigin and rowOrigin are the letters at the origin of the set
    var index = parm - 1;
    var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
    var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

    // colInt and rowInt are the letters to build to return
    var colInt = colOrigin + column - 1;
    var rowInt = rowOrigin + row;
    var rollover = false;

    if (colInt > Z) {
      colInt = colInt - Z + A - 1;
      rollover = true;
    }

    if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
      colInt++;
    }

    if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
      colInt++;

      if (colInt === I) {
        colInt++;
      }
    }

    if (colInt > Z) {
      colInt = colInt - Z + A - 1;
    }

    if (rowInt > V) {
      rowInt = rowInt - V + A - 1;
      rollover = true;
    }
    else {
      rollover = false;
    }

    if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
      rowInt++;
    }

    if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
      rowInt++;

      if (rowInt === I) {
        rowInt++;
      }
    }

    if (rowInt > V) {
      rowInt = rowInt - V + A - 1;
    }

    var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
    return twoLetter;
  }

  /**
   * Decode the UTM parameters from a MGRS string.
   *
   * @private
   * @param {string} mgrsString an UPPERCASE coordinate string is expected.
   * @return {object} An object literal with easting, northing, zoneLetter,
   *     zoneNumber and accuracy (in meters) properties.
   */
  function decode(mgrsString) {

    if (mgrsString && mgrsString.length === 0) {
      throw ("MGRSPoint coverting from nothing");
    }

    var length = mgrsString.length;

    var hunK = null;
    var sb = "";
    var testChar;
    var i = 0;

    // get Zone number
    while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
      if (i >= 2) {
        throw ("MGRSPoint bad conversion from: " + mgrsString);
      }
      sb += testChar;
      i++;
    }

    var zoneNumber = parseInt(sb, 10);

    if (i === 0 || i + 3 > length) {
      // A good MGRS string has to be 4-5 digits long,
      // ##AAA/#AAA at least.
      throw ("MGRSPoint bad conversion from: " + mgrsString);
    }

    var zoneLetter = mgrsString.charAt(i++);

    // Should we check the zone letter here? Why not.
    if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
      throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
    }

    hunK = mgrsString.substring(i, i += 2);

    var set = get100kSetForZone(zoneNumber);

    var east100k = getEastingFromChar(hunK.charAt(0), set);
    var north100k = getNorthingFromChar(hunK.charAt(1), set);

    // We have a bug where the northing may be 2000000 too low.
    // How
    // do we know when to roll over?

    while (north100k < getMinNorthing(zoneLetter)) {
      north100k += 2000000;
    }

    // calculate the char index for easting/northing separator
    var remainder = length - i;

    if (remainder % 2 !== 0) {
      throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
    }

    var sep = remainder / 2;

    var sepEasting = 0.0;
    var sepNorthing = 0.0;
    var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
    if (sep > 0) {
      accuracyBonus = 100000.0 / Math.pow(10, sep);
      sepEastingString = mgrsString.substring(i, i + sep);
      sepEasting = parseFloat(sepEastingString) * accuracyBonus;
      sepNorthingString = mgrsString.substring(i + sep);
      sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
    }

    easting = sepEasting + east100k;
    northing = sepNorthing + north100k;

    return {
      easting: easting,
      northing: northing,
      zoneLetter: zoneLetter,
      zoneNumber: zoneNumber,
      accuracy: accuracyBonus
    };
  }

  /**
   * Given the first letter from a two-letter MGRS 100k zone, and given the
   * MGRS table set for the zone number, figure out the easting value that
   * should be added to the other, secondary easting value.
   *
   * @private
   * @param {char} e The first letter from a two-letter MGRS 100´k zone.
   * @param {number} set The MGRS table set for the zone number.
   * @return {number} The easting value for the given letter and set.
   */
  function getEastingFromChar(e, set) {
    // colOrigin is the letter at the origin of the set for the
    // column
    var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
    var eastingValue = 100000.0;
    var rewindMarker = false;

    while (curCol !== e.charCodeAt(0)) {
      curCol++;
      if (curCol === I) {
        curCol++;
      }
      if (curCol === O) {
        curCol++;
      }
      if (curCol > Z) {
        if (rewindMarker) {
          throw ("Bad character: " + e);
        }
        curCol = A;
        rewindMarker = true;
      }
      eastingValue += 100000.0;
    }

    return eastingValue;
  }

  /**
   * Given the second letter from a two-letter MGRS 100k zone, and given the
   * MGRS table set for the zone number, figure out the northing value that
   * should be added to the other, secondary northing value. You have to
   * remember that Northings are determined from the equator, and the vertical
   * cycle of letters mean a 2000000 additional northing meters. This happens
   * approx. every 18 degrees of latitude. This method does *NOT* count any
   * additional northings. You have to figure out how many 2000000 meters need
   * to be added for the zone letter of the MGRS coordinate.
   *
   * @private
   * @param {char} n Second letter of the MGRS 100k zone
   * @param {number} set The MGRS table set number, which is dependent on the
   *     UTM zone number.
   * @return {number} The northing value for the given letter and set.
   */
  function getNorthingFromChar(n, set) {

    if (n > 'V') {
      throw ("MGRSPoint given invalid Northing " + n);
    }

    // rowOrigin is the letter at the origin of the set for the
    // column
    var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
    var northingValue = 0.0;
    var rewindMarker = false;

    while (curRow !== n.charCodeAt(0)) {
      curRow++;
      if (curRow === I) {
        curRow++;
      }
      if (curRow === O) {
        curRow++;
      }
      // fixing a bug making whole application hang in this loop
      // when 'n' is a wrong character
      if (curRow > V) {
        if (rewindMarker) { // making sure that this loop ends
          throw ("Bad character: " + n);
        }
        curRow = A;
        rewindMarker = true;
      }
      northingValue += 100000.0;
    }

    return northingValue;
  }

  /**
   * The function getMinNorthing returns the minimum northing value of a MGRS
   * zone.
   *
   * Ported from Geotrans' c Lattitude_Band_Value structure table.
   *
   * @private
   * @param {char} zoneLetter The MGRS zone to get the min northing for.
   * @return {number}
   */
  function getMinNorthing(zoneLetter) {
    var northing;
    switch (zoneLetter) {
    case 'C':
      northing = 1100000.0;
      break;
    case 'D':
      northing = 2000000.0;
      break;
    case 'E':
      northing = 2800000.0;
      break;
    case 'F':
      northing = 3700000.0;
      break;
    case 'G':
      northing = 4600000.0;
      break;
    case 'H':
      northing = 5500000.0;
      break;
    case 'J':
      northing = 6400000.0;
      break;
    case 'K':
      northing = 7300000.0;
      break;
    case 'L':
      northing = 8200000.0;
      break;
    case 'M':
      northing = 9100000.0;
      break;
    case 'N':
      northing = 0.0;
      break;
    case 'P':
      northing = 800000.0;
      break;
    case 'Q':
      northing = 1700000.0;
      break;
    case 'R':
      northing = 2600000.0;
      break;
    case 'S':
      northing = 3500000.0;
      break;
    case 'T':
      northing = 4400000.0;
      break;
    case 'U':
      northing = 5300000.0;
      break;
    case 'V':
      northing = 6200000.0;
      break;
    case 'W':
      northing = 7000000.0;
      break;
    case 'X':
      northing = 7900000.0;
      break;
    default:
      northing = -1.0;
    }
    if (northing >= 0.0) {
      return northing;
    }
    else {
      throw ("Invalid zone letter: " + zoneLetter);
    }

  }

  function Point(x, y, z) {
    if (!(this instanceof Point)) {
      return new Point(x, y, z);
    }
    if (Array.isArray(x)) {
      this.x = x[0];
      this.y = x[1];
      this.z = x[2] || 0.0;
    } else if(typeof x === 'object') {
      this.x = x.x;
      this.y = x.y;
      this.z = x.z || 0.0;
    } else if (typeof x === 'string' && typeof y === 'undefined') {
      var coords = x.split(',');
      this.x = parseFloat(coords[0], 10);
      this.y = parseFloat(coords[1], 10);
      this.z = parseFloat(coords[2], 10) || 0.0;
    } else {
      this.x = x;
      this.y = y;
      this.z = z || 0.0;
    }
    console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
  }

  Point.fromMGRS = function(mgrsStr) {
    return new Point(toPoint(mgrsStr));
  };
  Point.prototype.toMGRS = function(accuracy) {
    return forward$t([this.x, this.y], accuracy);
  };

  var C00 = 1;
  var C02 = 0.25;
  var C04 = 0.046875;
  var C06 = 0.01953125;
  var C08 = 0.01068115234375;
  var C22 = 0.75;
  var C44 = 0.46875;
  var C46 = 0.01302083333333333333;
  var C48 = 0.00712076822916666666;
  var C66 = 0.36458333333333333333;
  var C68 = 0.00569661458333333333;
  var C88 = 0.3076171875;

  function pj_enfn(es) {
    var en = [];
    en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
    en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
    var t = es * es;
    en[2] = t * (C44 - es * (C46 + es * C48));
    t *= es;
    en[3] = t * (C66 - es * C68);
    en[4] = t * es * C88;
    return en;
  }

  function pj_mlfn(phi, sphi, cphi, en) {
    cphi *= sphi;
    sphi *= sphi;
    return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
  }

  var MAX_ITER$3 = 20;

  function pj_inv_mlfn(arg, es, en) {
    var k = 1 / (1 - es);
    var phi = arg;
    for (var i = MAX_ITER$3; i; --i) { /* rarely goes over 2 iterations */
      var s = Math.sin(phi);
      var t = 1 - es * s * s;
      //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
      //phi -= t * (t * Math.sqrt(t)) * k;
      t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
      phi -= t;
      if (Math.abs(t) < EPSLN) {
        return phi;
      }
    }
    //..reportError("cass:pj_inv_mlfn: Convergence error");
    return phi;
  }

  // Heavily based on this tmerc projection implementation

  function init$t() {
    this.x0 = this.x0 !== undefined ? this.x0 : 0;
    this.y0 = this.y0 !== undefined ? this.y0 : 0;
    this.long0 = this.long0 !== undefined ? this.long0 : 0;
    this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

    if (this.es) {
      this.en = pj_enfn(this.es);
      this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
    }
  }

  /**
      Transverse Mercator Forward  - long/lat to x/y
      long/lat in radians
    */
  function forward$s(p) {
    var lon = p.x;
    var lat = p.y;

    var delta_lon = adjust_lon(lon - this.long0);
    var con;
    var x, y;
    var sin_phi = Math.sin(lat);
    var cos_phi = Math.cos(lat);

    if (!this.es) {
      var b = cos_phi * Math.sin(delta_lon);

      if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
        return (93);
      }
      else {
        x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
        y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
        b = Math.abs(y);

        if (b >= 1) {
          if ((b - 1) > EPSLN) {
            return (93);
          }
          else {
            y = 0;
          }
        }
        else {
          y = Math.acos(y);
        }

        if (lat < 0) {
          y = -y;
        }

        y = this.a * this.k0 * (y - this.lat0) + this.y0;
      }
    }
    else {
      var al = cos_phi * delta_lon;
      var als = Math.pow(al, 2);
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
      var t = Math.pow(tq, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      al = al / Math.sqrt(con);
      var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

      x = this.a * (this.k0 * al * (1 +
        als / 6 * (1 - t + c +
        als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
        als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
        this.x0;

      y = this.a * (this.k0 * (ml - this.ml0 +
        sin_phi * delta_lon * al / 2 * (1 +
        als / 12 * (5 - t + 9 * c + 4 * cs +
        als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
        als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
        this.y0;
    }

    p.x = x;
    p.y = y;

    return p;
  }

  /**
      Transverse Mercator Inverse  -  x/y to long/lat
    */
  function inverse$s(p) {
    var con, phi;
    var lat, lon;
    var x = (p.x - this.x0) * (1 / this.a);
    var y = (p.y - this.y0) * (1 / this.a);

    if (!this.es) {
      var f = Math.exp(x / this.k0);
      var g = 0.5 * (f - 1 / f);
      var temp = this.lat0 + y / this.k0;
      var h = Math.cos(temp);
      con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
      lat = Math.asin(con);

      if (y < 0) {
        lat = -lat;
      }

      if ((g === 0) && (h === 0)) {
        lon = 0;
      }
      else {
        lon = adjust_lon(Math.atan2(g, h) + this.long0);
      }
    }
    else { // ellipsoidal form
      con = this.ml0 + y / this.k0;
      phi = pj_inv_mlfn(con, this.es, this.en);

      if (Math.abs(phi) < HALF_PI) {
        var sin_phi = Math.sin(phi);
        var cos_phi = Math.cos(phi);
        var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
        var c = this.ep2 * Math.pow(cos_phi, 2);
        var cs = Math.pow(c, 2);
        var t = Math.pow(tan_phi, 2);
        var ts = Math.pow(t, 2);
        con = 1 - this.es * Math.pow(sin_phi, 2);
        var d = x * Math.sqrt(con) / this.k0;
        var ds = Math.pow(d, 2);
        con = con * tan_phi;

        lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
          ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
          ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
          ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

        lon = adjust_lon(this.long0 + (d * (1 -
          ds / 6 * (1 + 2 * t + c -
          ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
          ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
      }
      else {
        lat = HALF_PI * sign(y);
        lon = 0;
      }
    }

    p.x = lon;
    p.y = lat;

    return p;
  }

  var names$t = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
  var tmerc = {
    init: init$t,
    forward: forward$s,
    inverse: inverse$s,
    names: names$t
  };

  function sinh(x) {
    var r = Math.exp(x);
    r = (r - 1 / r) / 2;
    return r;
  }

  function hypot(x, y) {
    x = Math.abs(x);
    y = Math.abs(y);
    var a = Math.max(x, y);
    var b = Math.min(x, y) / (a ? a : 1);

    return a * Math.sqrt(1 + Math.pow(b, 2));
  }

  function log1py(x) {
    var y = 1 + x;
    var z = y - 1;

    return z === 0 ? x : x * Math.log(y) / z;
  }

  function asinhy(x) {
    var y = Math.abs(x);
    y = log1py(y * (1 + y / (hypot(1, y) + 1)));

    return x < 0 ? -y : y;
  }

  function gatg(pp, B) {
    var cos_2B = 2 * Math.cos(2 * B);
    var i = pp.length - 1;
    var h1 = pp[i];
    var h2 = 0;
    var h;

    while (--i >= 0) {
      h = -h2 + cos_2B * h1 + pp[i];
      h2 = h1;
      h1 = h;
    }

    return (B + h * Math.sin(2 * B));
  }

  function clens(pp, arg_r) {
    var r = 2 * Math.cos(arg_r);
    var i = pp.length - 1;
    var hr1 = pp[i];
    var hr2 = 0;
    var hr;

    while (--i >= 0) {
      hr = -hr2 + r * hr1 + pp[i];
      hr2 = hr1;
      hr1 = hr;
    }

    return Math.sin(arg_r) * hr;
  }

  function cosh(x) {
    var r = Math.exp(x);
    r = (r + 1 / r) / 2;
    return r;
  }

  function clens_cmplx(pp, arg_r, arg_i) {
    var sin_arg_r = Math.sin(arg_r);
    var cos_arg_r = Math.cos(arg_r);
    var sinh_arg_i = sinh(arg_i);
    var cosh_arg_i = cosh(arg_i);
    var r = 2 * cos_arg_r * cosh_arg_i;
    var i = -2 * sin_arg_r * sinh_arg_i;
    var j = pp.length - 1;
    var hr = pp[j];
    var hi1 = 0;
    var hr1 = 0;
    var hi = 0;
    var hr2;
    var hi2;

    while (--j >= 0) {
      hr2 = hr1;
      hi2 = hi1;
      hr1 = hr;
      hi1 = hi;
      hr = -hr2 + r * hr1 - i * hi1 + pp[j];
      hi = -hi2 + i * hr1 + r * hi1;
    }

    r = sin_arg_r * cosh_arg_i;
    i = cos_arg_r * sinh_arg_i;

    return [r * hr - i * hi, r * hi + i * hr];
  }

  // Heavily based on this etmerc projection implementation

  function init$s() {
    if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
      throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
    }
    if (this.approx) {
      // When '+approx' is set, use tmerc instead
      tmerc.init.apply(this);
      this.forward = tmerc.forward;
      this.inverse = tmerc.inverse;
    }

    this.x0 = this.x0 !== undefined ? this.x0 : 0;
    this.y0 = this.y0 !== undefined ? this.y0 : 0;
    this.long0 = this.long0 !== undefined ? this.long0 : 0;
    this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

    this.cgb = [];
    this.cbg = [];
    this.utg = [];
    this.gtu = [];

    var f = this.es / (1 + Math.sqrt(1 - this.es));
    var n = f / (2 - f);
    var np = n;

    this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
    this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

    np = np * n;
    this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
    this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

    np = np * n;
    this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
    this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

    np = np * n;
    this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
    this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

    np = np * n;
    this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
    this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

    np = np * n;
    this.cgb[5] = np * (601676 / 22275);
    this.cbg[5] = np * (444337 / 155925);

    np = Math.pow(n, 2);
    this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

    this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
    this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

    this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
    this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

    np = np * n;
    this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
    this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

    np = np * n;
    this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
    this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

    np = np * n;
    this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
    this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

    np = np * n;
    this.utg[5] = np * (-20648693 / 638668800);
    this.gtu[5] = np * (212378941 / 319334400);

    var Z = gatg(this.cbg, this.lat0);
    this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
  }

  function forward$r(p) {
    var Ce = adjust_lon(p.x - this.long0);
    var Cn = p.y;

    Cn = gatg(this.cbg, Cn);
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);

    Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
    Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
    Ce = asinhy(Math.tan(Ce));

    var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];

    var x;
    var y;

    if (Math.abs(Ce) <= 2.623395162778) {
      x = this.a * (this.Qn * Ce) + this.x0;
      y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
    }
    else {
      x = Infinity;
      y = Infinity;
    }

    p.x = x;
    p.y = y;

    return p;
  }

  function inverse$r(p) {
    var Ce = (p.x - this.x0) * (1 / this.a);
    var Cn = (p.y - this.y0) * (1 / this.a);

    Cn = (Cn - this.Zb) / this.Qn;
    Ce = Ce / this.Qn;

    var lon;
    var lat;

    if (Math.abs(Ce) <= 2.623395162778) {
      var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

      Cn = Cn + tmp[0];
      Ce = Ce + tmp[1];
      Ce = Math.atan(sinh(Ce));

      var sin_Cn = Math.sin(Cn);
      var cos_Cn = Math.cos(Cn);
      var sin_Ce = Math.sin(Ce);
      var cos_Ce = Math.cos(Ce);

      Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
      Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

      lon = adjust_lon(Ce + this.long0);
      lat = gatg(this.cgb, Cn);
    }
    else {
      lon = Infinity;
      lat = Infinity;
    }

    p.x = lon;
    p.y = lat;

    return p;
  }

  var names$s = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
  var etmerc = {
    init: init$s,
    forward: forward$r,
    inverse: inverse$r,
    names: names$s
  };

  function adjust_zone(zone, lon) {
    if (zone === undefined) {
      zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

      if (zone < 0) {
        return 0;
      } else if (zone > 60) {
        return 60;
      }
    }
    return zone;
  }

  var dependsOn = 'etmerc';


  function init$r() {
    var zone = adjust_zone(this.zone, this.long0);
    if (zone === undefined) {
      throw new Error('unknown utm zone');
    }
    this.lat0 = 0;
    this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R$1;
    this.x0 = 500000;
    this.y0 = this.utmSouth ? 10000000 : 0;
    this.k0 = 0.9996;

    etmerc.init.apply(this);
    this.forward = etmerc.forward;
    this.inverse = etmerc.inverse;
  }

  var names$r = ["Universal Transverse Mercator System", "utm"];
  var utm = {
    init: init$r,
    names: names$r,
    dependsOn: dependsOn
  };

  function srat(esinp, exp) {
    return (Math.pow((1 - esinp) / (1 + esinp), exp));
  }

  var MAX_ITER$2 = 20;

  function init$q() {
    var sphi = Math.sin(this.lat0);
    var cphi = Math.cos(this.lat0);
    cphi *= cphi;
    this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
    this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
    this.phic0 = Math.asin(sphi / this.C);
    this.ratexp = 0.5 * this.C * this.e;
    this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
  }

  function forward$q(p) {
    var lon = p.x;
    var lat = p.y;

    p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
    p.x = this.C * lon;
    return p;
  }

  function inverse$q(p) {
    var DEL_TOL = 1e-14;
    var lon = p.x / this.C;
    var lat = p.y;
    var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
    for (var i = MAX_ITER$2; i > 0; --i) {
      lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
      if (Math.abs(lat - p.y) < DEL_TOL) {
        break;
      }
      p.y = lat;
    }
    /* convergence failed */
    if (!i) {
      return null;
    }
    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$q = ["gauss"];
  var gauss = {
    init: init$q,
    forward: forward$q,
    inverse: inverse$q,
    names: names$q
  };

  function init$p() {
    gauss.init.apply(this);
    if (!this.rc) {
      return;
    }
    this.sinc0 = Math.sin(this.phic0);
    this.cosc0 = Math.cos(this.phic0);
    this.R2 = 2 * this.rc;
    if (!this.title) {
      this.title = "Oblique Stereographic Alternative";
    }
  }

  function forward$p(p) {
    var sinc, cosc, cosl, k;
    p.x = adjust_lon(p.x - this.long0);
    gauss.forward.apply(this, [p]);
    sinc = Math.sin(p.y);
    cosc = Math.cos(p.y);
    cosl = Math.cos(p.x);
    k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
    p.x = k * cosc * Math.sin(p.x);
    p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
    p.x = this.a * p.x + this.x0;
    p.y = this.a * p.y + this.y0;
    return p;
  }

  function inverse$p(p) {
    var sinc, cosc, lon, lat, rho;
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    p.x /= this.k0;
    p.y /= this.k0;
    if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
      var c = 2 * Math.atan2(rho, this.R2);
      sinc = Math.sin(c);
      cosc = Math.cos(c);
      lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
      lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
    }
    else {
      lat = this.phic0;
      lon = 0;
    }

    p.x = lon;
    p.y = lat;
    gauss.inverse.apply(this, [p]);
    p.x = adjust_lon(p.x + this.long0);
    return p;
  }

  var names$p = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
  var sterea = {
    init: init$p,
    forward: forward$p,
    inverse: inverse$p,
    names: names$p
  };

  function ssfn_(phit, sinphi, eccen) {
    sinphi *= eccen;
    return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
  }

  function init$o() {
    this.coslat0 = Math.cos(this.lat0);
    this.sinlat0 = Math.sin(this.lat0);
    if (this.sphere) {
      if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
        this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
      }
    }
    else {
      if (Math.abs(this.coslat0) <= EPSLN) {
        if (this.lat0 > 0) {
          //North pole
          //trace('stere:north pole');
          this.con = 1;
        }
        else {
          //South pole
          //trace('stere:south pole');
          this.con = -1;
        }
      }
      this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
      if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
        this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
      }
      this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
      this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
      this.cosX0 = Math.cos(this.X0);
      this.sinX0 = Math.sin(this.X0);
    }
  }

  // Stereographic forward equations--mapping lat,long to x,y
  function forward$o(p) {
    var lon = p.x;
    var lat = p.y;
    var sinlat = Math.sin(lat);
    var coslat = Math.cos(lat);
    var A, X, sinX, cosX, ts, rh;
    var dlon = adjust_lon(lon - this.long0);

    if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
      //case of the origine point
      //trace('stere:this is the origin point');
      p.x = NaN;
      p.y = NaN;
      return p;
    }
    if (this.sphere) {
      //trace('stere:sphere case');
      A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
      p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
      p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
      return p;
    }
    else {
      X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
      cosX = Math.cos(X);
      sinX = Math.sin(X);
      if (Math.abs(this.coslat0) <= EPSLN) {
        ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
        rh = 2 * this.a * this.k0 * ts / this.cons;
        p.x = this.x0 + rh * Math.sin(lon - this.long0);
        p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
        //trace(p.toString());
        return p;
      }
      else if (Math.abs(this.sinlat0) < EPSLN) {
        //Eq
        //trace('stere:equateur');
        A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
        p.y = A * sinX;
      }
      else {
        //other case
        //trace('stere:normal case');
        A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
        p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
      }
      p.x = A * cosX * Math.sin(dlon) + this.x0;
    }
    //trace(p.toString());
    return p;
  }

  //* Stereographic inverse equations--mapping x,y to lat/long
  function inverse$o(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon, lat, ts, ce, Chi;
    var rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (this.sphere) {
      var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
      lon = this.long0;
      lat = this.lat0;
      if (rh <= EPSLN) {
        p.x = lon;
        p.y = lat;
        return p;
      }
      lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
      if (Math.abs(this.coslat0) < EPSLN) {
        if (this.lat0 > 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
        }
        else {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
        }
      }
      else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
      }
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      if (Math.abs(this.coslat0) <= EPSLN) {
        if (rh <= EPSLN) {
          lat = this.lat0;
          lon = this.long0;
          p.x = lon;
          p.y = lat;
          //trace(p.toString());
          return p;
        }
        p.x *= this.con;
        p.y *= this.con;
        ts = rh * this.cons / (2 * this.a * this.k0);
        lat = this.con * phi2z(this.e, ts);
        lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
        lon = this.long0;
        if (rh <= EPSLN) {
          Chi = this.X0;
        }
        else {
          Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
          lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
        }
        lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
      }
    }
    p.x = lon;
    p.y = lat;

    //trace(p.toString());
    return p;

  }

  var names$o = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
  var stere = {
    init: init$o,
    forward: forward$o,
    inverse: inverse$o,
    names: names$o,
    ssfn_: ssfn_
  };

  /*
    references:
      Formules et constantes pour le Calcul pour la
      projection cylindrique conforme à axe oblique et pour la transformation entre
      des systèmes de référence.
      http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
    */

  function init$n() {
    var phy0 = this.lat0;
    this.lambda0 = this.long0;
    var sinPhy0 = Math.sin(phy0);
    var semiMajorAxis = this.a;
    var invF = this.rf;
    var flattening = 1 / invF;
    var e2 = 2 * flattening - Math.pow(flattening, 2);
    var e = this.e = Math.sqrt(e2);
    this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
    this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
    this.b0 = Math.asin(sinPhy0 / this.alpha);
    var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
    var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
    var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
    this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
  }

  function forward$n(p) {
    var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
    var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
    var S = -this.alpha * (Sa1 + Sa2) + this.K;

    // spheric latitude
    var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

    // spheric longitude
    var I = this.alpha * (p.x - this.lambda0);

    // psoeudo equatorial rotation
    var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

    var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

    p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
    p.x = this.R * rotI + this.x0;
    return p;
  }

  function inverse$n(p) {
    var Y = p.x - this.x0;
    var X = p.y - this.y0;

    var rotI = Y / this.R;
    var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

    var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
    var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

    var lambda = this.lambda0 + I / this.alpha;

    var S = 0;
    var phy = b;
    var prevPhy = -1000;
    var iteration = 0;
    while (Math.abs(phy - prevPhy) > 0.0000001) {
      if (++iteration > 20) {
        //...reportError("omercFwdInfinity");
        return;
      }
      //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
      S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
      prevPhy = phy;
      phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
    }

    p.x = lambda;
    p.y = phy;
    return p;
  }

  var names$n = ["somerc"];
  var somerc = {
    init: init$n,
    forward: forward$n,
    inverse: inverse$n,
    names: names$n
  };

  var TOL = 1e-7;

  function isTypeA(P) {
    var typeAProjections = ['Hotine_Oblique_Mercator','Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
    var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
    
    return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
  }


  /* Initialize the Oblique Mercator  projection
      ------------------------------------------*/
  function init$m() {  
    var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,
      gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
    
    // only Type A uses the no_off or no_uoff property
    // https://github.com/OSGeo/proj.4/issues/104
    this.no_off = isTypeA(this);
    this.no_rot = 'no_rot' in this;
    
    var alp = false;
    if ("alpha" in this) {
      alp = true;
    }

    var gam = false;
    if ("rectified_grid_angle" in this) {
      gam = true;
    }

    if (alp) {
      alpha_c = this.alpha;
    }
    
    if (gam) {
      gamma = (this.rectified_grid_angle * D2R$1);
    }
    
    if (alp || gam) {
      lamc = this.longc;
    } else {
      lam1 = this.long1;
      phi1 = this.lat1;
      lam2 = this.long2;
      phi2 = this.lat2;
      
      if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL ||
          Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL ||
          Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
        throw new Error();
      }
    }
    
    var one_es = 1.0 - this.es;
    com = Math.sqrt(one_es);
    
    if (Math.abs(this.lat0) > EPSLN) {
      sinph0 = Math.sin(this.lat0);
      cosph0 = Math.cos(this.lat0);
      con = 1 - this.es * sinph0 * sinph0;
      this.B = cosph0 * cosph0;
      this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
      this.A = this.B * this.k0 * com / con;
      D = this.B * com / (cosph0 * Math.sqrt(con));
      F = D * D -1;
      
      if (F <= 0) {
        F = 0;
      } else {
        F = Math.sqrt(F);
        if (this.lat0 < 0) {
          F = -F;
        }
      }
      
      this.E = F += D;
      this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
    } else {
      this.B = 1 / com;
      this.A = this.k0;
      this.E = D = F = 1;
    }
    
    if (alp || gam) {
      if (alp) {
        gamma0 = Math.asin(Math.sin(alpha_c) / D);
        if (!gam) {
          gamma = alpha_c;
        }
      } else {
        gamma0 = gamma;
        alpha_c = Math.asin(D * Math.sin(gamma0));
      }
      this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
    } else {
      H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
      L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
      F = this.E / H;
      p = (L - H) / (L + H);
      J = this.E * this.E;
      J = (J - L * H) / (J + L * H);
      con = lam1 - lam2;
      
      if (con < -Math.pi) {
        lam2 -=TWO_PI;
      } else if (con > Math.pi) {
        lam2 += TWO_PI;
      }
      
      this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
      gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
      gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
    }
    
    this.singam = Math.sin(gamma0);
    this.cosgam = Math.cos(gamma0);
    this.sinrot = Math.sin(gamma);
    this.cosrot = Math.cos(gamma);
    
    this.rB = 1 / this.B;
    this.ArB = this.A * this.rB;
    this.BrA = 1 / this.ArB;
    this.A * this.B;
    
    if (this.no_off) {
      this.u_0 = 0;
    } else {
      this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
      
      if (this.lat0 < 0) {
        this.u_0 = - this.u_0;
      }  
    }
      
    F = 0.5 * gamma0;
    this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
    this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
  }


  /* Oblique Mercator forward equations--mapping lat,long to x,y
      ----------------------------------------------------------*/
  function forward$m(p) {
    var coords = {};
    var S, T, U, V, W, temp, u, v;
    p.x = p.x - this.lam0;
    
    if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
      W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
      
      temp = 1 / W;
      S = 0.5 * (W - temp);
      T = 0.5 * (W + temp);
      V = Math.sin(this.B * p.x);
      U = (S * this.singam - V * this.cosgam) / T;
          
      if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
        throw new Error();
      }
      
      v = 0.5 * this.ArB * Math.log((1 - U)/(1 + U));
      temp = Math.cos(this.B * p.x);
      
      if (Math.abs(temp) < TOL) {
        u = this.A * p.x;
      } else {
        u = this.ArB * Math.atan2((S * this.cosgam + V * this.singam), temp);
      }    
    } else {
      v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
      u = this.ArB * p.y;
    }
       
    if (this.no_rot) {
      coords.x = u;
      coords.y = v;
    } else {
      u -= this.u_0;
      coords.x = v * this.cosrot + u * this.sinrot;
      coords.y = u * this.cosrot - v * this.sinrot;
    }
    
    coords.x = (this.a * coords.x + this.x0);
    coords.y = (this.a * coords.y + this.y0);
    
    return coords;
  }

  function inverse$m(p) {
    var u, v, Qp, Sp, Tp, Vp, Up;
    var coords = {};
    
    p.x = (p.x - this.x0) * (1.0 / this.a);
    p.y = (p.y - this.y0) * (1.0 / this.a);

    if (this.no_rot) {
      v = p.y;
      u = p.x;
    } else {
      v = p.x * this.cosrot - p.y * this.sinrot;
      u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
    }
    
    Qp = Math.exp(-this.BrA * v);
    Sp = 0.5 * (Qp - 1 / Qp);
    Tp = 0.5 * (Qp + 1 / Qp);
    Vp = Math.sin(this.BrA * u);
    Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
    
    if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
      coords.x = 0;
      coords.y = Up < 0 ? -HALF_PI : HALF_PI;
    } else {
      coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
      coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
      
      if (coords.y === Infinity) {
        throw new Error();
      }
          
      coords.x = -this.rB * Math.atan2((Sp * this.cosgam - Vp * this.singam), Math.cos(this.BrA * u));
    }
    
    coords.x += this.lam0;
    
    return coords;
  }

  var names$m = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
  var omerc = {
    init: init$m,
    forward: forward$m,
    inverse: inverse$m,
    names: names$m
  };

  function init$l() {
    
    //double lat0;                    /* the reference latitude               */
    //double long0;                   /* the reference longitude              */
    //double lat1;                    /* first standard parallel              */
    //double lat2;                    /* second standard parallel             */
    //double r_maj;                   /* major axis                           */
    //double r_min;                   /* minor axis                           */
    //double false_east;              /* x offset in meters                   */
    //double false_north;             /* y offset in meters                   */
    
    //the above value can be set with proj4.defs
    //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

    if (!this.lat2) {
      this.lat2 = this.lat1;
    } //if lat2 is not defined
    if (!this.k0) {
      this.k0 = 1;
    }
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    // Standard Parallels cannot be equal and on opposite sides of the equator
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }

    var temp = this.b / this.a;
    this.e = Math.sqrt(1 - temp * temp);

    var sin1 = Math.sin(this.lat1);
    var cos1 = Math.cos(this.lat1);
    var ms1 = msfnz(this.e, sin1, cos1);
    var ts1 = tsfnz(this.e, this.lat1, sin1);

    var sin2 = Math.sin(this.lat2);
    var cos2 = Math.cos(this.lat2);
    var ms2 = msfnz(this.e, sin2, cos2);
    var ts2 = tsfnz(this.e, this.lat2, sin2);

    var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
      this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
    }
    else {
      this.ns = sin1;
    }
    if (isNaN(this.ns)) {
      this.ns = sin1;
    }
    this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
    this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
    if (!this.title) {
      this.title = "Lambert Conformal Conic";
    }
  }

  // Lambert Conformal conic forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$l(p) {

    var lon = p.x;
    var lat = p.y;

    // singular cases :
    if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
      lat = sign(lat) * (HALF_PI - 2 * EPSLN);
    }

    var con = Math.abs(Math.abs(lat) - HALF_PI);
    var ts, rh1;
    if (con > EPSLN) {
      ts = tsfnz(this.e, lat, Math.sin(lat));
      rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
    }
    else {
      con = lat * this.ns;
      if (con <= 0) {
        return null;
      }
      rh1 = 0;
    }
    var theta = this.ns * adjust_lon(lon - this.long0);
    p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
    p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

    return p;
  }

  // Lambert Conformal Conic inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$l(p) {

    var rh1, con, ts;
    var lat, lon;
    var x = (p.x - this.x0) / this.k0;
    var y = (this.rh - (p.y - this.y0) / this.k0);
    if (this.ns > 0) {
      rh1 = Math.sqrt(x * x + y * y);
      con = 1;
    }
    else {
      rh1 = -Math.sqrt(x * x + y * y);
      con = -1;
    }
    var theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2((con * x), (con * y));
    }
    if ((rh1 !== 0) || (this.ns > 0)) {
      con = 1 / this.ns;
      ts = Math.pow((rh1 / (this.a * this.f0)), con);
      lat = phi2z(this.e, ts);
      if (lat === -9999) {
        return null;
      }
    }
    else {
      lat = -HALF_PI;
    }
    lon = adjust_lon(theta / this.ns + this.long0);

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$l = [
    "Lambert Tangential Conformal Conic Projection",
    "Lambert_Conformal_Conic",
    "Lambert_Conformal_Conic_1SP",
    "Lambert_Conformal_Conic_2SP",
    "lcc",
    "Lambert Conic Conformal (1SP)",
    "Lambert Conic Conformal (2SP)"
  ];

  var lcc = {
    init: init$l,
    forward: forward$l,
    inverse: inverse$l,
    names: names$l
  };

  function init$k() {
    this.a = 6377397.155;
    this.es = 0.006674372230614;
    this.e = Math.sqrt(this.es);
    if (!this.lat0) {
      this.lat0 = 0.863937979737193;
    }
    if (!this.long0) {
      this.long0 = 0.7417649320975901 - 0.308341501185665;
    }
    /* if scale not set default to 0.9999 */
    if (!this.k0) {
      this.k0 = 0.9999;
    }
    this.s45 = 0.785398163397448; /* 45 */
    this.s90 = 2 * this.s45;
    this.fi0 = this.lat0;
    this.e2 = this.es;
    this.e = Math.sqrt(this.e2);
    this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
    this.uq = 1.04216856380474;
    this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
    this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
    this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
    this.k1 = this.k0;
    this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
    this.s0 = 1.37008346281555;
    this.n = Math.sin(this.s0);
    this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
    this.ad = this.s90 - this.uq;
  }

  /* ellipsoid */
  /* calculate xy from lat/lon */
  /* Constants, identical to inverse transform function */
  function forward$k(p) {
    var gfi, u, deltav, s, d, eps, ro;
    var lon = p.x;
    var lat = p.y;
    var delta_lon = adjust_lon(lon - this.long0);
    /* Transformation */
    gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
    u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
    deltav = -delta_lon * this.alfa;
    s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
    d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
    eps = this.n * d;
    ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
    p.y = ro * Math.cos(eps) / 1;
    p.x = ro * Math.sin(eps) / 1;

    if (!this.czech) {
      p.y *= -1;
      p.x *= -1;
    }
    return (p);
  }

  /* calculate lat/lon from xy */
  function inverse$k(p) {
    var u, deltav, s, d, eps, ro, fi1;
    var ok;

    /* Transformation */
    /* revert y, x*/
    var tmp = p.x;
    p.x = p.y;
    p.y = tmp;
    if (!this.czech) {
      p.y *= -1;
      p.x *= -1;
    }
    ro = Math.sqrt(p.x * p.x + p.y * p.y);
    eps = Math.atan2(p.y, p.x);
    d = eps / Math.sin(this.s0);
    s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
    u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
    deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
    p.x = this.long0 - deltav / this.alfa;
    fi1 = u;
    ok = 0;
    var iter = 0;
    do {
      p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
      if (Math.abs(fi1 - p.y) < 0.0000000001) {
        ok = 1;
      }
      fi1 = p.y;
      iter += 1;
    } while (ok === 0 && iter < 15);
    if (iter >= 15) {
      return null;
    }

    return (p);
  }

  var names$k = ["Krovak", "krovak"];
  var krovak = {
    init: init$k,
    forward: forward$k,
    inverse: inverse$k,
    names: names$k
  };

  function mlfn(e0, e1, e2, e3, phi) {
    return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
  }

  function e0fn(x) {
    return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
  }

  function e1fn(x) {
    return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
  }

  function e2fn(x) {
    return (0.05859375 * x * x * (1 + 0.75 * x));
  }

  function e3fn(x) {
    return (x * x * x * (35 / 3072));
  }

  function gN(a, e, sinphi) {
    var temp = e * sinphi;
    return a / Math.sqrt(1 - temp * temp);
  }

  function adjust_lat(x) {
    return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
  }

  function imlfn(ml, e0, e1, e2, e3) {
    var phi;
    var dphi;

    phi = ml / e0;
    for (var i = 0; i < 15; i++) {
      dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }

    //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
    return NaN;
  }

  function init$j() {
    if (!this.sphere) {
      this.e0 = e0fn(this.es);
      this.e1 = e1fn(this.es);
      this.e2 = e2fn(this.es);
      this.e3 = e3fn(this.es);
      this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
    }
  }

  /* Cassini forward equations--mapping lat,long to x,y
    -----------------------------------------------------------------------*/
  function forward$j(p) {

    /* Forward equations
        -----------------*/
    var x, y;
    var lam = p.x;
    var phi = p.y;
    lam = adjust_lon(lam - this.long0);

    if (this.sphere) {
      x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
      y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
    }
    else {
      //ellipsoid
      var sinphi = Math.sin(phi);
      var cosphi = Math.cos(phi);
      var nl = gN(this.a, this.e, sinphi);
      var tl = Math.tan(phi) * Math.tan(phi);
      var al = lam * Math.cos(phi);
      var asq = al * al;
      var cl = this.es * cosphi * cosphi / (1 - this.es);
      var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

      x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
      y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


    }

    p.x = x + this.x0;
    p.y = y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$j(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var x = p.x / this.a;
    var y = p.y / this.a;
    var phi, lam;

    if (this.sphere) {
      var dd = y + this.lat0;
      phi = Math.asin(Math.sin(dd) * Math.cos(x));
      lam = Math.atan2(Math.tan(x), Math.cos(dd));
    }
    else {
      /* ellipsoid */
      var ml1 = this.ml0 / this.a + y;
      var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
      if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
        p.x = this.long0;
        p.y = HALF_PI;
        if (y < 0) {
          p.y *= -1;
        }
        return p;
      }
      var nl1 = gN(this.a, this.e, Math.sin(phi1));

      var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
      var tl1 = Math.pow(Math.tan(phi1), 2);
      var dl = x * this.a / nl1;
      var dsq = dl * dl;
      phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
      lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

    }

    p.x = adjust_lon(lam + this.long0);
    p.y = adjust_lat(phi);
    return p;

  }

  var names$j = ["Cassini", "Cassini_Soldner", "cass"];
  var cass = {
    init: init$j,
    forward: forward$j,
    inverse: inverse$j,
    names: names$j
  };

  function qsfnz(eccent, sinphi) {
    var con;
    if (eccent > 1.0e-7) {
      con = eccent * sinphi;
      return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
    }
    else {
      return (2 * sinphi);
    }
  }

  /*
    reference
      "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
      The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
    */

  var S_POLE = 1;

  var N_POLE = 2;
  var EQUIT = 3;
  var OBLIQ = 4;

  /* Initialize the Lambert Azimuthal Equal Area projection
    ------------------------------------------------------*/
  function init$i() {
    var t = Math.abs(this.lat0);
    if (Math.abs(t - HALF_PI) < EPSLN) {
      this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
    }
    else if (Math.abs(t) < EPSLN) {
      this.mode = this.EQUIT;
    }
    else {
      this.mode = this.OBLIQ;
    }
    if (this.es > 0) {
      var sinphi;

      this.qp = qsfnz(this.e, 1);
      this.mmf = 0.5 / (1 - this.es);
      this.apa = authset(this.es);
      switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
      }
    }
    else {
      if (this.mode === this.OBLIQ) {
        this.sinph0 = Math.sin(this.lat0);
        this.cosph0 = Math.cos(this.lat0);
      }
    }
  }

  /* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
    -----------------------------------------------------------------------*/
  function forward$i(p) {

    /* Forward equations
        -----------------*/
    var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
    var lam = p.x;
    var phi = p.y;

    lam = adjust_lon(lam - this.long0);
    if (this.sphere) {
      sinphi = Math.sin(phi);
      cosphi = Math.cos(phi);
      coslam = Math.cos(lam);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
        if (y <= EPSLN) {
          return null;
        }
        y = Math.sqrt(2 / y);
        x = y * cosphi * Math.sin(lam);
        y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      }
      else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE) {
          coslam = -coslam;
        }
        if (Math.abs(phi + this.lat0) < EPSLN) {
          return null;
        }
        y = FORTPI - phi * 0.5;
        y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
        x = y * Math.sin(lam);
        y *= coslam;
      }
    }
    else {
      sinb = 0;
      cosb = 0;
      b = 0;
      coslam = Math.cos(lam);
      sinlam = Math.sin(lam);
      sinphi = Math.sin(phi);
      q = qsfnz(this.e, sinphi);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        sinb = q / this.qp;
        cosb = Math.sqrt(1 - sinb * sinb);
      }
      switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b = HALF_PI + phi;
        q = this.qp - q;
        break;
      case this.S_POLE:
        b = phi - HALF_PI;
        q = this.qp + q;
        break;
      }
      if (Math.abs(b) < EPSLN) {
        return null;
      }
      switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);
        if (this.mode === this.OBLIQ) {
          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        }
        else {
          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x = this.xmf * b * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y = coslam * ((this.mode === this.S_POLE) ? b : -b);
        }
        else {
          x = y = 0;
        }
        break;
      }
    }

    p.x = this.a * x + this.x0;
    p.y = this.a * y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$i(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var x = p.x / this.a;
    var y = p.y / this.a;
    var lam, phi, cCe, sCe, q, rho, ab;
    if (this.sphere) {
      var cosz = 0,
        rh, sinz = 0;

      rh = Math.sqrt(x * x + y * y);
      phi = rh * 0.5;
      if (phi > 1) {
        return null;
      }
      phi = 2 * Math.asin(phi);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        sinz = Math.sin(phi);
        cosz = Math.cos(phi);
      }
      switch (this.mode) {
      case this.EQUIT:
        phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
        x *= sinz;
        y = cosz * rh;
        break;
      case this.OBLIQ:
        phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y = -y;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
      }
      lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
    }
    else {
      ab = 0;
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        x /= this.dd;
        y *= this.dd;
        rho = Math.sqrt(x * x + y * y);
        if (rho < EPSLN) {
          p.x = this.long0;
          p.y = this.lat0;
          return p;
        }
        sCe = 2 * Math.asin(0.5 * rho / this.rq);
        cCe = Math.cos(sCe);
        x *= (sCe = Math.sin(sCe));
        if (this.mode === this.OBLIQ) {
          ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
          q = this.qp * ab;
          y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
        }
        else {
          ab = y * sCe / rho;
          q = this.qp * ab;
          y = rho * cCe;
        }
      }
      else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE) {
          y = -y;
        }
        q = (x * x + y * y);
        if (!q) {
          p.x = this.long0;
          p.y = this.lat0;
          return p;
        }
        ab = 1 - q / this.qp;
        if (this.mode === this.S_POLE) {
          ab = -ab;
        }
      }
      lam = Math.atan2(x, y);
      phi = authlat(Math.asin(ab), this.apa);
    }

    p.x = adjust_lon(this.long0 + lam);
    p.y = phi;
    return p;
  }

  /* determine latitude from authalic latitude */
  var P00 = 0.33333333333333333333;

  var P01 = 0.17222222222222222222;
  var P02 = 0.10257936507936507936;
  var P10 = 0.06388888888888888888;
  var P11 = 0.06640211640211640211;
  var P20 = 0.01641501294219154443;

  function authset(es) {
    var t;
    var APA = [];
    APA[0] = es * P00;
    t = es * es;
    APA[0] += t * P01;
    APA[1] = t * P10;
    t *= es;
    APA[0] += t * P02;
    APA[1] += t * P11;
    APA[2] = t * P20;
    return APA;
  }

  function authlat(beta, APA) {
    var t = beta + beta;
    return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
  }

  var names$i = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
  var laea = {
    init: init$i,
    forward: forward$i,
    inverse: inverse$i,
    names: names$i,
    S_POLE: S_POLE,
    N_POLE: N_POLE,
    EQUIT: EQUIT,
    OBLIQ: OBLIQ
  };

  function asinz(x) {
    if (Math.abs(x) > 1) {
      x = (x > 1) ? 1 : -1;
    }
    return Math.asin(x);
  }

  function init$h() {

    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e3 = Math.sqrt(this.es);

    this.sin_po = Math.sin(this.lat1);
    this.cos_po = Math.cos(this.lat1);
    this.t1 = this.sin_po;
    this.con = this.sin_po;
    this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
    this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

    this.sin_po = Math.sin(this.lat2);
    this.cos_po = Math.cos(this.lat2);
    this.t2 = this.sin_po;
    this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
    this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

    this.sin_po = Math.sin(this.lat0);
    this.cos_po = Math.cos(this.lat0);
    this.t3 = this.sin_po;
    this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
      this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
    }
    else {
      this.ns0 = this.con;
    }
    this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
    this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
  }

  /* Albers Conical Equal Area forward equations--mapping lat,long to x,y
    -------------------------------------------------------------------*/
  function forward$h(p) {

    var lon = p.x;
    var lat = p.y;

    this.sin_phi = Math.sin(lat);
    this.cos_phi = Math.cos(lat);

    var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
    var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
    var theta = this.ns0 * adjust_lon(lon - this.long0);
    var x = rh1 * Math.sin(theta) + this.x0;
    var y = this.rh - rh1 * Math.cos(theta) + this.y0;

    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$h(p) {
    var rh1, qs, con, theta, lon, lat;

    p.x -= this.x0;
    p.y = this.rh - p.y + this.y0;
    if (this.ns0 >= 0) {
      rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
      con = 1;
    }
    else {
      rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
      con = -1;
    }
    theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * p.x, con * p.y);
    }
    con = rh1 * this.ns0 / this.a;
    if (this.sphere) {
      lat = Math.asin((this.c - con * con) / (2 * this.ns0));
    }
    else {
      qs = (this.c - con * con) / this.ns0;
      lat = this.phi1z(this.e3, qs);
    }

    lon = adjust_lon(theta / this.ns0 + this.long0);
    p.x = lon;
    p.y = lat;
    return p;
  }

  /* Function to compute phi1, the latitude for the inverse of the
     Albers Conical Equal-Area projection.
  -------------------------------------------*/
  function phi1z(eccent, qs) {
    var sinphi, cosphi, con, com, dphi;
    var phi = asinz(0.5 * qs);
    if (eccent < EPSLN) {
      return phi;
    }

    var eccnts = eccent * eccent;
    for (var i = 1; i <= 25; i++) {
      sinphi = Math.sin(phi);
      cosphi = Math.cos(phi);
      con = eccent * sinphi;
      com = 1 - con * con;
      dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
      phi = phi + dphi;
      if (Math.abs(dphi) <= 1e-7) {
        return phi;
      }
    }
    return null;
  }

  var names$h = ["Albers_Conic_Equal_Area", "Albers", "aea"];
  var aea = {
    init: init$h,
    forward: forward$h,
    inverse: inverse$h,
    names: names$h,
    phi1z: phi1z
  };

  /*
    reference:
      Wolfram Mathworld "Gnomonic Projection"
      http://mathworld.wolfram.com/GnomonicProjection.html
      Accessed: 12th November 2009
    */
  function init$g() {

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.sin_p14 = Math.sin(this.lat0);
    this.cos_p14 = Math.cos(this.lat0);
    // Approximation for projecting points to the horizon (infinity)
    this.infinity_dist = 1000 * this.a;
    this.rc = 1;
  }

  /* Gnomonic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$g(p) {
    var sinphi, cosphi; /* sin and cos value        */
    var dlon; /* delta longitude value      */
    var coslon; /* cos of longitude        */
    var ksp; /* scale factor          */
    var g;
    var x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    dlon = adjust_lon(lon - this.long0);

    sinphi = Math.sin(lat);
    cosphi = Math.cos(lat);

    coslon = Math.cos(dlon);
    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
    ksp = 1;
    if ((g > 0) || (Math.abs(g) <= EPSLN)) {
      x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
      y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
    }
    else {

      // Point is in the opposing hemisphere and is unprojectable
      // We still need to return a reasonable point, so we project
      // to infinity, on a bearing
      // equivalent to the northern hemisphere equivalent
      // This is a reasonable approximation for short shapes and lines that
      // straddle the horizon.

      x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
      y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

    }
    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$g(p) {
    var rh; /* Rho */
    var sinc, cosc;
    var c;
    var lon, lat;

    /* Inverse equations
        -----------------*/
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    p.x /= this.k0;
    p.y /= this.k0;

    if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
      c = Math.atan2(rh, this.rc);
      sinc = Math.sin(c);
      cosc = Math.cos(c);

      lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
      lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
      lon = adjust_lon(this.long0 + lon);
    }
    else {
      lat = this.phic0;
      lon = 0;
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$g = ["gnom"];
  var gnom = {
    init: init$g,
    forward: forward$g,
    inverse: inverse$g,
    names: names$g
  };

  function iqsfnz(eccent, q) {
    var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
    if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
      if (q < 0) {
        return (-1 * HALF_PI);
      }
      else {
        return HALF_PI;
      }
    }
    //var phi = 0.5* q/(1-eccent*eccent);
    var phi = Math.asin(0.5 * q);
    var dphi;
    var sin_phi;
    var cos_phi;
    var con;
    for (var i = 0; i < 30; i++) {
      sin_phi = Math.sin(phi);
      cos_phi = Math.cos(phi);
      con = eccent * sin_phi;
      dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }

    //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
    return NaN;
  }

  /*
    reference:
      "Cartographic Projection Procedures for the UNIX Environment-
      A User's Manual" by Gerald I. Evenden,
      USGS Open File Report 90-284and Release 4 Interim Reports (2003)
  */
  function init$f() {
    //no-op
    if (!this.sphere) {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }

  /* Cylindrical Equal Area forward equations--mapping lat,long to x,y
      ------------------------------------------------------------*/
  function forward$f(p) {
    var lon = p.x;
    var lat = p.y;
    var x, y;
    /* Forward equations
        -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    if (this.sphere) {
      x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
      y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
    }
    else {
      var qs = qsfnz(this.e, Math.sin(lat));
      x = this.x0 + this.a * this.k0 * dlon;
      y = this.y0 + this.a * qs * 0.5 / this.k0;
    }

    p.x = x;
    p.y = y;
    return p;
  }

  /* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
      ------------------------------------------------------------*/
  function inverse$f(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon, lat;

    if (this.sphere) {
      lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
      lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
    }
    else {
      lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
      lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$f = ["cea"];
  var cea = {
    init: init$f,
    forward: forward$f,
    inverse: inverse$f,
    names: names$f
  };

  function init$e() {

    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.lat0 = this.lat0 || 0;
    this.long0 = this.long0 || 0;
    this.lat_ts = this.lat_ts || 0;
    this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

    this.rc = Math.cos(this.lat_ts);
  }

  // forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$e(p) {

    var lon = p.x;
    var lat = p.y;

    var dlon = adjust_lon(lon - this.long0);
    var dlat = adjust_lat(lat - this.lat0);
    p.x = this.x0 + (this.a * dlon * this.rc);
    p.y = this.y0 + (this.a * dlat);
    return p;
  }

  // inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$e(p) {

    var x = p.x;
    var y = p.y;

    p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
    p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
    return p;
  }

  var names$e = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
  var eqc = {
    init: init$e,
    forward: forward$e,
    inverse: inverse$e,
    names: names$e
  };

  var MAX_ITER$1 = 20;

  function init$d() {
    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
    this.e = Math.sqrt(this.es);
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
  }

  /* Polyconic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$d(p) {
    var lon = p.x;
    var lat = p.y;
    var x, y, el;
    var dlon = adjust_lon(lon - this.long0);
    el = dlon * Math.sin(lat);
    if (this.sphere) {
      if (Math.abs(lat) <= EPSLN) {
        x = this.a * dlon;
        y = -1 * this.a * this.lat0;
      }
      else {
        x = this.a * Math.sin(el) / Math.tan(lat);
        y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
      }
    }
    else {
      if (Math.abs(lat) <= EPSLN) {
        x = this.a * dlon;
        y = -1 * this.ml0;
      }
      else {
        var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
        x = nl * Math.sin(el);
        y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
      }

    }
    p.x = x + this.x0;
    p.y = y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$d(p) {
    var lon, lat, x, y, i;
    var al, bl;
    var phi, dphi;
    x = p.x - this.x0;
    y = p.y - this.y0;

    if (this.sphere) {
      if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
        lon = adjust_lon(x / this.a + this.long0);
        lat = 0;
      }
      else {
        al = this.lat0 + y / this.a;
        bl = x * x / this.a / this.a + al * al;
        phi = al;
        var tanphi;
        for (i = MAX_ITER$1; i; --i) {
          tanphi = Math.tan(phi);
          dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
          phi += dphi;
          if (Math.abs(dphi) <= EPSLN) {
            lat = phi;
            break;
          }
        }
        lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
      }
    }
    else {
      if (Math.abs(y + this.ml0) <= EPSLN) {
        lat = 0;
        lon = adjust_lon(this.long0 + x / this.a);
      }
      else {

        al = (this.ml0 + y) / this.a;
        bl = x * x / this.a / this.a + al * al;
        phi = al;
        var cl, mln, mlnp, ma;
        var con;
        for (i = MAX_ITER$1; i; --i) {
          con = this.e * Math.sin(phi);
          cl = Math.sqrt(1 - con * con) * Math.tan(phi);
          mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
          mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
          ma = mln / this.a;
          dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
          phi -= dphi;
          if (Math.abs(dphi) <= EPSLN) {
            lat = phi;
            break;
          }
        }

        //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
        cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
        lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$d = ["Polyconic", "poly"];
  var poly = {
    init: init$d,
    forward: forward$d,
    inverse: inverse$d,
    names: names$d
  };

  function init$c() {
    this.A = [];
    this.A[1] = 0.6399175073;
    this.A[2] = -0.1358797613;
    this.A[3] = 0.063294409;
    this.A[4] = -0.02526853;
    this.A[5] = 0.0117879;
    this.A[6] = -0.0055161;
    this.A[7] = 0.0026906;
    this.A[8] = -0.001333;
    this.A[9] = 0.00067;
    this.A[10] = -0.00034;

    this.B_re = [];
    this.B_im = [];
    this.B_re[1] = 0.7557853228;
    this.B_im[1] = 0;
    this.B_re[2] = 0.249204646;
    this.B_im[2] = 0.003371507;
    this.B_re[3] = -0.001541739;
    this.B_im[3] = 0.041058560;
    this.B_re[4] = -0.10162907;
    this.B_im[4] = 0.01727609;
    this.B_re[5] = -0.26623489;
    this.B_im[5] = -0.36249218;
    this.B_re[6] = -0.6870983;
    this.B_im[6] = -1.1651967;

    this.C_re = [];
    this.C_im = [];
    this.C_re[1] = 1.3231270439;
    this.C_im[1] = 0;
    this.C_re[2] = -0.577245789;
    this.C_im[2] = -0.007809598;
    this.C_re[3] = 0.508307513;
    this.C_im[3] = -0.112208952;
    this.C_re[4] = -0.15094762;
    this.C_im[4] = 0.18200602;
    this.C_re[5] = 1.01418179;
    this.C_im[5] = 1.64497696;
    this.C_re[6] = 1.9660549;
    this.C_im[6] = 2.5127645;

    this.D = [];
    this.D[1] = 1.5627014243;
    this.D[2] = 0.5185406398;
    this.D[3] = -0.03333098;
    this.D[4] = -0.1052906;
    this.D[5] = -0.0368594;
    this.D[6] = 0.007317;
    this.D[7] = 0.01220;
    this.D[8] = 0.00394;
    this.D[9] = -0.0013;
  }

  /**
      New Zealand Map Grid Forward  - long/lat to x/y
      long/lat in radians
    */
  function forward$c(p) {
    var n;
    var lon = p.x;
    var lat = p.y;

    var delta_lat = lat - this.lat0;
    var delta_lon = lon - this.long0;

    // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
    // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
    var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
    var d_lambda = delta_lon;
    var d_phi_n = 1; // d_phi^0

    var d_psi = 0;
    for (n = 1; n <= 10; n++) {
      d_phi_n = d_phi_n * d_phi;
      d_psi = d_psi + this.A[n] * d_phi_n;
    }

    // 2. Calculate theta
    var th_re = d_psi;
    var th_im = d_lambda;

    // 3. Calculate z
    var th_n_re = 1;
    var th_n_im = 0; // theta^0
    var th_n_re1;
    var th_n_im1;

    var z_re = 0;
    var z_im = 0;
    for (n = 1; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
      z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
    }

    // 4. Calculate easting and northing
    p.x = (z_im * this.a) + this.x0;
    p.y = (z_re * this.a) + this.y0;

    return p;
  }

  /**
      New Zealand Map Grid Inverse  -  x/y to long/lat
    */
  function inverse$c(p) {
    var n;
    var x = p.x;
    var y = p.y;

    var delta_x = x - this.x0;
    var delta_y = y - this.y0;

    // 1. Calculate z
    var z_re = delta_y / this.a;
    var z_im = delta_x / this.a;

    // 2a. Calculate theta - first approximation gives km accuracy
    var z_n_re = 1;
    var z_n_im = 0; // z^0
    var z_n_re1;
    var z_n_im1;

    var th_re = 0;
    var th_im = 0;
    for (n = 1; n <= 6; n++) {
      z_n_re1 = z_n_re * z_re - z_n_im * z_im;
      z_n_im1 = z_n_im * z_re + z_n_re * z_im;
      z_n_re = z_n_re1;
      z_n_im = z_n_im1;
      th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
      th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
    }

    // 2b. Iterate to refine the accuracy of the calculation
    //        0 iterations gives km accuracy
    //        1 iteration gives m accuracy -- good enough for most mapping applications
    //        2 iterations bives mm accuracy
    for (var i = 0; i < this.iterations; i++) {
      var th_n_re = th_re;
      var th_n_im = th_im;
      var th_n_re1;
      var th_n_im1;

      var num_re = z_re;
      var num_im = z_im;
      for (n = 2; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
        num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
      }

      th_n_re = 1;
      th_n_im = 0;
      var den_re = this.B_re[1];
      var den_im = this.B_im[1];
      for (n = 2; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
        den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
      }

      // Complex division
      var den2 = den_re * den_re + den_im * den_im;
      th_re = (num_re * den_re + num_im * den_im) / den2;
      th_im = (num_im * den_re - num_re * den_im) / den2;
    }

    // 3. Calculate d_phi              ...                                    // and d_lambda
    var d_psi = th_re;
    var d_lambda = th_im;
    var d_psi_n = 1; // d_psi^0

    var d_phi = 0;
    for (n = 1; n <= 9; n++) {
      d_psi_n = d_psi_n * d_psi;
      d_phi = d_phi + this.D[n] * d_psi_n;
    }

    // 4. Calculate latitude and longitude
    // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
    var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
    var lon = this.long0 + d_lambda;

    p.x = lon;
    p.y = lat;

    return p;
  }

  var names$c = ["New_Zealand_Map_Grid", "nzmg"];
  var nzmg = {
    init: init$c,
    forward: forward$c,
    inverse: inverse$c,
    names: names$c
  };

  /*
    reference
      "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
      The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
    */


  /* Initialize the Miller Cylindrical projection
    -------------------------------------------*/
  function init$b() {
    //no-op
  }

  /* Miller Cylindrical forward equations--mapping lat,long to x,y
      ------------------------------------------------------------*/
  function forward$b(p) {
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    var x = this.x0 + this.a * dlon;
    var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

    p.x = x;
    p.y = y;
    return p;
  }

  /* Miller Cylindrical inverse equations--mapping x,y to lat/long
      ------------------------------------------------------------*/
  function inverse$b(p) {
    p.x -= this.x0;
    p.y -= this.y0;

    var lon = adjust_lon(this.long0 + p.x / this.a);
    var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$b = ["Miller_Cylindrical", "mill"];
  var mill = {
    init: init$b,
    forward: forward$b,
    inverse: inverse$b,
    names: names$b
  };

  var MAX_ITER = 20;


  function init$a() {
    /* Place parameters in static storage for common use
      -------------------------------------------------*/


    if (!this.sphere) {
      this.en = pj_enfn(this.es);
    }
    else {
      this.n = 1;
      this.m = 0;
      this.es = 0;
      this.C_y = Math.sqrt((this.m + 1) / this.n);
      this.C_x = this.C_y / (this.m + 1);
    }

  }

  /* Sinusoidal forward equations--mapping lat,long to x,y
    -----------------------------------------------------*/
  function forward$a(p) {
    var x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
      -----------------*/
    lon = adjust_lon(lon - this.long0);

    if (this.sphere) {
      if (!this.m) {
        lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
      }
      else {
        var k = this.n * Math.sin(lat);
        for (var i = MAX_ITER; i; --i) {
          var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
          lat -= V;
          if (Math.abs(V) < EPSLN) {
            break;
          }
        }
      }
      x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
      y = this.a * this.C_y * lat;

    }
    else {

      var s = Math.sin(lat);
      var c = Math.cos(lat);
      y = this.a * pj_mlfn(lat, s, c, this.en);
      x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
    }

    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$a(p) {
    var lat, temp, lon, s;

    p.x -= this.x0;
    lon = p.x / this.a;
    p.y -= this.y0;
    lat = p.y / this.a;

    if (this.sphere) {
      lat /= this.C_y;
      lon = lon / (this.C_x * (this.m + Math.cos(lat)));
      if (this.m) {
        lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
      }
      else if (this.n !== 1) {
        lat = asinz(Math.sin(lat) / this.n);
      }
      lon = adjust_lon(lon + this.long0);
      lat = adjust_lat(lat);
    }
    else {
      lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
      s = Math.abs(lat);
      if (s < HALF_PI) {
        s = Math.sin(lat);
        temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
        //temp = this.long0 + p.x / (this.a * Math.cos(lat));
        lon = adjust_lon(temp);
      }
      else if ((s - EPSLN) < HALF_PI) {
        lon = this.long0;
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$a = ["Sinusoidal", "sinu"];
  var sinu = {
    init: init$a,
    forward: forward$a,
    inverse: inverse$a,
    names: names$a
  };

  function init$9() {}
  /* Mollweide forward equations--mapping lat,long to x,y
      ----------------------------------------------------*/
  function forward$9(p) {

    /* Forward equations
        -----------------*/
    var lon = p.x;
    var lat = p.y;

    var delta_lon = adjust_lon(lon - this.long0);
    var theta = lat;
    var con = Math.PI * Math.sin(lat);

    /* Iterate using the Newton-Raphson method to find theta
        -----------------------------------------------------*/
    while (true) {
      var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
      theta += delta_theta;
      if (Math.abs(delta_theta) < EPSLN) {
        break;
      }
    }
    theta /= 2;

    /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
         this is done here because of precision problems with "cos(theta)"
         --------------------------------------------------------------------------*/
    if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
      delta_lon = 0;
    }
    var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
    var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$9(p) {
    var theta;
    var arg;

    /* Inverse equations
        -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    arg = p.y / (1.4142135623731 * this.a);

    /* Because of division by zero problems, 'arg' can not be 1.  Therefore
         a number very close to one is used instead.
         -------------------------------------------------------------------*/
    if (Math.abs(arg) > 0.999999999999) {
      arg = 0.999999999999;
    }
    theta = Math.asin(arg);
    var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
    if (lon < (-Math.PI)) {
      lon = -Math.PI;
    }
    if (lon > Math.PI) {
      lon = Math.PI;
    }
    arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
    if (Math.abs(arg) > 1) {
      arg = 1;
    }
    var lat = Math.asin(arg);

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$9 = ["Mollweide", "moll"];
  var moll = {
    init: init$9,
    forward: forward$9,
    inverse: inverse$9,
    names: names$9
  };

  function init$8() {

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    // Standard Parallels cannot be equal and on opposite sides of the equator
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    this.lat2 = this.lat2 || this.lat1;
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e = Math.sqrt(this.es);
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);

    this.sinphi = Math.sin(this.lat1);
    this.cosphi = Math.cos(this.lat1);

    this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

    if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
      this.ns = this.sinphi;
    }
    else {
      this.sinphi = Math.sin(this.lat2);
      this.cosphi = Math.cos(this.lat2);
      this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
      this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
      this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
    }
    this.g = this.ml1 + this.ms1 / this.ns;
    this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
    this.rh = this.a * (this.g - this.ml0);
  }

  /* Equidistant Conic forward equations--mapping lat,long to x,y
    -----------------------------------------------------------*/
  function forward$8(p) {
    var lon = p.x;
    var lat = p.y;
    var rh1;

    /* Forward equations
        -----------------*/
    if (this.sphere) {
      rh1 = this.a * (this.g - lat);
    }
    else {
      var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
      rh1 = this.a * (this.g - ml);
    }
    var theta = this.ns * adjust_lon(lon - this.long0);
    var x = this.x0 + rh1 * Math.sin(theta);
    var y = this.y0 + this.rh - rh1 * Math.cos(theta);
    p.x = x;
    p.y = y;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$8(p) {
    p.x -= this.x0;
    p.y = this.rh - p.y + this.y0;
    var con, rh1, lat, lon;
    if (this.ns >= 0) {
      rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
      con = 1;
    }
    else {
      rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
      con = -1;
    }
    var theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * p.x, con * p.y);
    }

    if (this.sphere) {
      lon = adjust_lon(this.long0 + theta / this.ns);
      lat = adjust_lat(this.g - rh1 / this.a);
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      var ml = this.g - rh1 / this.a;
      lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
      lon = adjust_lon(this.long0 + theta / this.ns);
      p.x = lon;
      p.y = lat;
      return p;
    }

  }

  var names$8 = ["Equidistant_Conic", "eqdc"];
  var eqdc = {
    init: init$8,
    forward: forward$8,
    inverse: inverse$8,
    names: names$8
  };

  /* Initialize the Van Der Grinten projection
    ----------------------------------------*/
  function init$7() {
    //this.R = 6370997; //Radius of earth
    this.R = this.a;
  }

  function forward$7(p) {

    var lon = p.x;
    var lat = p.y;

    /* Forward equations
      -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    var x, y;

    if (Math.abs(lat) <= EPSLN) {
      x = this.x0 + this.R * dlon;
      y = this.y0;
    }
    var theta = asinz(2 * Math.abs(lat / Math.PI));
    if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
      x = this.x0;
      if (lat >= 0) {
        y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
      }
      else {
        y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
      }
      //  return(OK);
    }
    var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
    var asq = al * al;
    var sinth = Math.sin(theta);
    var costh = Math.cos(theta);

    var g = costh / (sinth + costh - 1);
    var gsq = g * g;
    var m = g * (2 / sinth - 1);
    var msq = m * m;
    var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
    if (dlon < 0) {
      con = -con;
    }
    x = this.x0 + con;
    //con = Math.abs(con / (Math.PI * this.R));
    var q = asq + g;
    con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
    if (lat >= 0) {
      //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
      y = this.y0 + con;
    }
    else {
      //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
      y = this.y0 - con;
    }
    p.x = x;
    p.y = y;
    return p;
  }

  /* Van Der Grinten inverse equations--mapping x,y to lat/long
    ---------------------------------------------------------*/
  function inverse$7(p) {
    var lon, lat;
    var xx, yy, xys, c1, c2, c3;
    var a1;
    var m1;
    var con;
    var th1;
    var d;

    /* inverse equations
      -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    con = Math.PI * this.R;
    xx = p.x / con;
    yy = p.y / con;
    xys = xx * xx + yy * yy;
    c1 = -Math.abs(yy) * (1 + xys);
    c2 = c1 - 2 * yy * yy + xx * xx;
    c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
    d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
    a1 = (c1 - c2 * c2 / 3 / c3) / c3;
    m1 = 2 * Math.sqrt(-a1 / 3);
    con = ((3 * d) / a1) / m1;
    if (Math.abs(con) > 1) {
      if (con >= 0) {
        con = 1;
      }
      else {
        con = -1;
      }
    }
    th1 = Math.acos(con) / 3;
    if (p.y >= 0) {
      lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
    }
    else {
      lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
    }

    if (Math.abs(xx) < EPSLN) {
      lon = this.long0;
    }
    else {
      lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$7 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
  var vandg = {
    init: init$7,
    forward: forward$7,
    inverse: inverse$7,
    names: names$7
  };

  function init$6() {
    this.sin_p12 = Math.sin(this.lat0);
    this.cos_p12 = Math.cos(this.lat0);
  }

  function forward$6(p) {
    var lon = p.x;
    var lat = p.y;
    var sinphi = Math.sin(p.y);
    var cosphi = Math.cos(p.y);
    var dlon = adjust_lon(lon - this.long0);
    var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
    if (this.sphere) {
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North Pole case
        p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
        p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
        return p;
      }
      else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South Pole case
        p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
        p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
        return p;
      }
      else {
        //default case
        cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
        c = Math.acos(cos_c);
        kp = c ? c / Math.sin(c) : 1;
        p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
        p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
        return p;
      }
    }
    else {
      e0 = e0fn(this.es);
      e1 = e1fn(this.es);
      e2 = e2fn(this.es);
      e3 = e3fn(this.es);
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North Pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        Ml = this.a * mlfn(e0, e1, e2, e3, lat);
        p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
        p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
        return p;
      }
      else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South Pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        Ml = this.a * mlfn(e0, e1, e2, e3, lat);
        p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
        p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
        return p;
      }
      else {
        //Default case
        tanphi = sinphi / cosphi;
        Nl1 = gN(this.a, this.e, this.sin_p12);
        Nl = gN(this.a, this.e, sinphi);
        psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
        Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
        if (Az === 0) {
          s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
        }
        else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
          s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
        }
        else {
          s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
        }
        G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
        H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
        GH = G * H;
        Hs = H * H;
        s2 = s * s;
        s3 = s2 * s;
        s4 = s3 * s;
        s5 = s4 * s;
        c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
        p.x = this.x0 + c * Math.sin(Az);
        p.y = this.y0 + c * Math.cos(Az);
        return p;
      }
    }


  }

  function inverse$6(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
    if (this.sphere) {
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      if (rh > (2 * HALF_PI * this.a)) {
        return;
      }
      z = rh / this.a;

      sinz = Math.sin(z);
      cosz = Math.cos(z);

      lon = this.long0;
      if (Math.abs(rh) <= EPSLN) {
        lat = this.lat0;
      }
      else {
        lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
        con = Math.abs(this.lat0) - HALF_PI;
        if (Math.abs(con) <= EPSLN) {
          if (this.lat0 >= 0) {
            lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
          }
          else {
            lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
          }
        }
        else {
          /*con = cosz - this.sin_p12 * Math.sin(lat);
          if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
            //no-op, just keep the lon value as is
          } else {
            var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
            lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
          }*/
          lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
        }
      }

      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      e0 = e0fn(this.es);
      e1 = e1fn(this.es);
      e2 = e2fn(this.es);
      e3 = e3fn(this.es);
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        M = Mlp - rh;
        lat = imlfn(M / this.a, e0, e1, e2, e3);
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
        p.x = lon;
        p.y = lat;
        return p;
      }
      else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        M = rh - Mlp;

        lat = imlfn(M / this.a, e0, e1, e2, e3);
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        //default case
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        Az = Math.atan2(p.x, p.y);
        N1 = gN(this.a, this.e, this.sin_p12);
        cosAz = Math.cos(Az);
        tmp = this.e * this.cos_p12 * cosAz;
        A = -tmp * tmp / (1 - this.es);
        B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
        D = rh / N1;
        Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
        F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
        psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
        lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
        sinpsi = Math.sin(psi);
        lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
        p.x = lon;
        p.y = lat;
        return p;
      }
    }

  }

  var names$6 = ["Azimuthal_Equidistant", "aeqd"];
  var aeqd = {
    init: init$6,
    forward: forward$6,
    inverse: inverse$6,
    names: names$6
  };

  function init$5() {
    //double temp;      /* temporary variable    */

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.sin_p14 = Math.sin(this.lat0);
    this.cos_p14 = Math.cos(this.lat0);
  }

  /* Orthographic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$5(p) {
    var sinphi, cosphi; /* sin and cos value        */
    var dlon; /* delta longitude value      */
    var coslon; /* cos of longitude        */
    var ksp; /* scale factor          */
    var g, x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    dlon = adjust_lon(lon - this.long0);

    sinphi = Math.sin(lat);
    cosphi = Math.cos(lat);

    coslon = Math.cos(dlon);
    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
    ksp = 1;
    if ((g > 0) || (Math.abs(g) <= EPSLN)) {
      x = this.a * ksp * cosphi * Math.sin(dlon);
      y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
    }
    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$5(p) {
    var rh; /* height above ellipsoid      */
    var z; /* angle          */
    var sinz, cosz; /* sin of z and cos of z      */
    var con;
    var lon, lat;
    /* Inverse equations
        -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    z = asinz(rh / this.a);

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
    con = Math.abs(this.lat0) - HALF_PI;
    if (Math.abs(con) <= EPSLN) {
      if (this.lat0 >= 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
      }
      else {
        lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
      }
      p.x = lon;
      p.y = lat;
      return p;
    }
    lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$5 = ["ortho"];
  var ortho = {
    init: init$5,
    forward: forward$5,
    inverse: inverse$5,
    names: names$5
  };

  // QSC projection rewritten from the original PROJ4

  /* constants */
  var FACE_ENUM = {
      FRONT: 1,
      RIGHT: 2,
      BACK: 3,
      LEFT: 4,
      TOP: 5,
      BOTTOM: 6
  };

  var AREA_ENUM = {
      AREA_0: 1,
      AREA_1: 2,
      AREA_2: 3,
      AREA_3: 4
  };

  function init$4() {

    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.lat0 = this.lat0 || 0;
    this.long0 = this.long0 || 0;
    this.lat_ts = this.lat_ts || 0;
    this.title = this.title || "Quadrilateralized Spherical Cube";

    /* Determine the cube face from the center of projection. */
    if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
      this.face = FACE_ENUM.TOP;
    } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
      this.face = FACE_ENUM.BOTTOM;
    } else if (Math.abs(this.long0) <= FORTPI) {
      this.face = FACE_ENUM.FRONT;
    } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
      this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
    } else {
      this.face = FACE_ENUM.BACK;
    }

    /* Fill in useful values for the ellipsoid <-> sphere shift
     * described in [LK12]. */
    if (this.es !== 0) {
      this.one_minus_f = 1 - (this.a - this.b) / this.a;
      this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
    }
  }

  // QSC forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$4(p) {
    var xy = {x: 0, y: 0};
    var lat, lon;
    var theta, phi;
    var t, mu;
    /* nu; */
    var area = {value: 0};

    // move lon according to projection's lon
    p.x -= this.long0;

    /* Convert the geodetic latitude to a geocentric latitude.
     * This corresponds to the shift from the ellipsoid to the sphere
     * described in [LK12]. */
    if (this.es !== 0) {//if (P->es != 0) {
      lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
    } else {
      lat = p.y;
    }

    /* Convert the input lat, lon into theta, phi as used by QSC.
     * This depends on the cube face and the area on it.
     * For the top and bottom face, we can compute theta and phi
     * directly from phi, lam. For the other faces, we must use
     * unit sphere cartesian coordinates as an intermediate step. */
    lon = p.x; //lon = lp.lam;
    if (this.face === FACE_ENUM.TOP) {
      phi = HALF_PI - lat;
      if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_0;
        theta = lon - HALF_PI;
      } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_1;
        theta = (lon > 0.0 ? lon - SPI : lon + SPI);
      } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
        area.value = AREA_ENUM.AREA_2;
        theta = lon + HALF_PI;
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta = lon;
      }
    } else if (this.face === FACE_ENUM.BOTTOM) {
      phi = HALF_PI + lat;
      if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_0;
        theta = -lon + HALF_PI;
      } else if (lon < FORTPI && lon >= -FORTPI) {
        area.value = AREA_ENUM.AREA_1;
        theta = -lon;
      } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_2;
        theta = -lon - HALF_PI;
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
      }
    } else {
      var q, r, s;
      var sinlat, coslat;
      var sinlon, coslon;

      if (this.face === FACE_ENUM.RIGHT) {
        lon = qsc_shift_lon_origin(lon, +HALF_PI);
      } else if (this.face === FACE_ENUM.BACK) {
        lon = qsc_shift_lon_origin(lon, +SPI);
      } else if (this.face === FACE_ENUM.LEFT) {
        lon = qsc_shift_lon_origin(lon, -HALF_PI);
      }
      sinlat = Math.sin(lat);
      coslat = Math.cos(lat);
      sinlon = Math.sin(lon);
      coslon = Math.cos(lon);
      q = coslat * coslon;
      r = coslat * sinlon;
      s = sinlat;

      if (this.face === FACE_ENUM.FRONT) {
        phi = Math.acos(q);
        theta = qsc_fwd_equat_face_theta(phi, s, r, area);
      } else if (this.face === FACE_ENUM.RIGHT) {
        phi = Math.acos(r);
        theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
      } else if (this.face === FACE_ENUM.BACK) {
        phi = Math.acos(-q);
        theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
      } else if (this.face === FACE_ENUM.LEFT) {
        phi = Math.acos(-r);
        theta = qsc_fwd_equat_face_theta(phi, s, q, area);
      } else {
        /* Impossible */
        phi = theta = 0;
        area.value = AREA_ENUM.AREA_0;
      }
    }

    /* Compute mu and nu for the area of definition.
     * For mu, see Eq. (3-21) in [OL76], but note the typos:
     * compare with Eq. (3-14). For nu, see Eq. (3-38). */
    mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
    t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

    /* Apply the result to the real area. */
    if (area.value === AREA_ENUM.AREA_1) {
      mu += HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      mu += SPI;
    } else if (area.value === AREA_ENUM.AREA_3) {
      mu += 1.5 * SPI;
    }

    /* Now compute x, y from mu and nu */
    xy.x = t * Math.cos(mu);
    xy.y = t * Math.sin(mu);
    xy.x = xy.x * this.a + this.x0;
    xy.y = xy.y * this.a + this.y0;

    p.x = xy.x;
    p.y = xy.y;
    return p;
  }

  // QSC inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$4(p) {
    var lp = {lam: 0, phi: 0};
    var mu, nu, cosmu, tannu;
    var tantheta, theta, cosphi, phi;
    var t;
    var area = {value: 0};

    /* de-offset */
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    /* Convert the input x, y to the mu and nu angles as used by QSC.
     * This depends on the area of the cube face. */
    nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
    mu = Math.atan2(p.y, p.x);
    if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
      area.value = AREA_ENUM.AREA_0;
    } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
      area.value = AREA_ENUM.AREA_1;
      mu -= HALF_PI;
    } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
      area.value = AREA_ENUM.AREA_2;
      mu = (mu < 0.0 ? mu + SPI : mu - SPI);
    } else {
      area.value = AREA_ENUM.AREA_3;
      mu += HALF_PI;
    }

    /* Compute phi and theta for the area of definition.
     * The inverse projection is not described in the original paper, but some
     * good hints can be found here (as of 2011-12-14):
     * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
     * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
    t = (SPI / 12) * Math.tan(mu);
    tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
    theta = Math.atan(tantheta);
    cosmu = Math.cos(mu);
    tannu = Math.tan(nu);
    cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
    if (cosphi < -1) {
      cosphi = -1;
    } else if (cosphi > +1) {
      cosphi = +1;
    }

    /* Apply the result to the real area on the cube face.
     * For the top and bottom face, we can compute phi and lam directly.
     * For the other faces, we must use unit sphere cartesian coordinates
     * as an intermediate step. */
    if (this.face === FACE_ENUM.TOP) {
      phi = Math.acos(cosphi);
      lp.phi = HALF_PI - phi;
      if (area.value === AREA_ENUM.AREA_0) {
        lp.lam = theta + HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_1) {
        lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
      } else if (area.value === AREA_ENUM.AREA_2) {
        lp.lam = theta - HALF_PI;
      } else /* area.value == AREA_ENUM.AREA_3 */ {
        lp.lam = theta;
      }
    } else if (this.face === FACE_ENUM.BOTTOM) {
      phi = Math.acos(cosphi);
      lp.phi = phi - HALF_PI;
      if (area.value === AREA_ENUM.AREA_0) {
        lp.lam = -theta + HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_1) {
        lp.lam = -theta;
      } else if (area.value === AREA_ENUM.AREA_2) {
        lp.lam = -theta - HALF_PI;
      } else /* area.value == AREA_ENUM.AREA_3 */ {
        lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
      }
    } else {
      /* Compute phi and lam via cartesian unit sphere coordinates. */
      var q, r, s;
      q = cosphi;
      t = q * q;
      if (t >= 1) {
        s = 0;
      } else {
        s = Math.sqrt(1 - t) * Math.sin(theta);
      }
      t += s * s;
      if (t >= 1) {
        r = 0;
      } else {
        r = Math.sqrt(1 - t);
      }
      /* Rotate q,r,s into the correct area. */
      if (area.value === AREA_ENUM.AREA_1) {
        t = r;
        r = -s;
        s = t;
      } else if (area.value === AREA_ENUM.AREA_2) {
        r = -r;
        s = -s;
      } else if (area.value === AREA_ENUM.AREA_3) {
        t = r;
        r = s;
        s = -t;
      }
      /* Rotate q,r,s into the correct cube face. */
      if (this.face === FACE_ENUM.RIGHT) {
        t = q;
        q = -r;
        r = t;
      } else if (this.face === FACE_ENUM.BACK) {
        q = -q;
        r = -r;
      } else if (this.face === FACE_ENUM.LEFT) {
        t = q;
        q = r;
        r = -t;
      }
      /* Now compute phi and lam from the unit sphere coordinates. */
      lp.phi = Math.acos(-s) - HALF_PI;
      lp.lam = Math.atan2(r, q);
      if (this.face === FACE_ENUM.RIGHT) {
        lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
      } else if (this.face === FACE_ENUM.BACK) {
        lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
      } else if (this.face === FACE_ENUM.LEFT) {
        lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
      }
    }

    /* Apply the shift from the sphere to the ellipsoid as described
     * in [LK12]. */
    if (this.es !== 0) {
      var invert_sign;
      var tanphi, xa;
      invert_sign = (lp.phi < 0 ? 1 : 0);
      tanphi = Math.tan(lp.phi);
      xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
      lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
      if (invert_sign) {
        lp.phi = -lp.phi;
      }
    }

    lp.lam += this.long0;
    p.x = lp.lam;
    p.y = lp.phi;
    return p;
  }

  /* Helper function for forward projection: compute the theta angle
   * and determine the area number. */
  function qsc_fwd_equat_face_theta(phi, y, x, area) {
    var theta;
    if (phi < EPSLN) {
      area.value = AREA_ENUM.AREA_0;
      theta = 0.0;
    } else {
      theta = Math.atan2(y, x);
      if (Math.abs(theta) <= FORTPI) {
        area.value = AREA_ENUM.AREA_0;
      } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_1;
        theta -= HALF_PI;
      } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_2;
        theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta += HALF_PI;
      }
    }
    return theta;
  }

  /* Helper function: shift the longitude. */
  function qsc_shift_lon_origin(lon, offset) {
    var slon = lon + offset;
    if (slon < -SPI) {
      slon += TWO_PI;
    } else if (slon > +SPI) {
      slon -= TWO_PI;
    }
    return slon;
  }

  var names$4 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
  var qsc = {
    init: init$4,
    forward: forward$4,
    inverse: inverse$4,
    names: names$4
  };

  // Robinson projection

  var COEFS_X = [
      [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
      [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
      [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
      [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
      [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
      [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
      [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
      [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
      [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
      [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
      [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
      [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
      [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
      [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
      [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
      [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
      [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
      [0.5722, -0.00906601, 0.000182, 6.24051e-06],
      [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
  ];

  var COEFS_Y = [
      [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
      [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
      [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
      [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
      [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
      [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
      [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
      [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
      [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
      [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
      [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
      [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
      [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
      [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
      [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
      [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
      [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
      [0.9761, 0.00616527, -0.000256, -4.2106e-06],
      [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
  ];

  var FXC = 0.8487;
  var FYC = 1.3523;
  var C1 = R2D/5; // rad to 5-degree interval
  var RC1 = 1/C1;
  var NODES = 18;

  var poly3_val = function(coefs, x) {
      return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
  };

  var poly3_der = function(coefs, x) {
      return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
  };

  function newton_rapshon(f_df, start, max_err, iters) {
      var x = start;
      for (; iters; --iters) {
          var upd = f_df(x);
          x -= upd;
          if (Math.abs(upd) < max_err) {
              break;
          }
      }
      return x;
  }

  function init$3() {
      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      this.long0 = this.long0 || 0;
      this.es = 0;
      this.title = this.title || "Robinson";
  }

  function forward$3(ll) {
      var lon = adjust_lon(ll.x - this.long0);

      var dphi = Math.abs(ll.y);
      var i = Math.floor(dphi * C1);
      if (i < 0) {
          i = 0;
      } else if (i >= NODES) {
          i = NODES - 1;
      }
      dphi = R2D * (dphi - RC1 * i);
      var xy = {
          x: poly3_val(COEFS_X[i], dphi) * lon,
          y: poly3_val(COEFS_Y[i], dphi)
      };
      if (ll.y < 0) {
          xy.y = -xy.y;
      }

      xy.x = xy.x * this.a * FXC + this.x0;
      xy.y = xy.y * this.a * FYC + this.y0;
      return xy;
  }

  function inverse$3(xy) {
      var ll = {
          x: (xy.x - this.x0) / (this.a * FXC),
          y: Math.abs(xy.y - this.y0) / (this.a * FYC)
      };

      if (ll.y >= 1) { // pathologic case
          ll.x /= COEFS_X[NODES][0];
          ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
      } else {
          // find table interval
          var i = Math.floor(ll.y * NODES);
          if (i < 0) {
              i = 0;
          } else if (i >= NODES) {
              i = NODES - 1;
          }
          for (;;) {
              if (COEFS_Y[i][0] > ll.y) {
                  --i;
              } else if (COEFS_Y[i+1][0] <= ll.y) {
                  ++i;
              } else {
                  break;
              }
          }
          // linear interpolation in 5 degree interval
          var coefs = COEFS_Y[i];
          var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
          // find t so that poly3_val(coefs, t) = ll.y
          t = newton_rapshon(function(x) {
              return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
          }, t, EPSLN, 100);

          ll.x /= poly3_val(COEFS_X[i], t);
          ll.y = (5 * i + t) * D2R$1;
          if (xy.y < 0) {
              ll.y = -ll.y;
          }
      }

      ll.x = adjust_lon(ll.x + this.long0);
      return ll;
  }

  var names$3 = ["Robinson", "robin"];
  var robin = {
    init: init$3,
    forward: forward$3,
    inverse: inverse$3,
    names: names$3
  };

  function init$2() {
      this.name = 'geocent';

  }

  function forward$2(p) {
      var point = geodeticToGeocentric(p, this.es, this.a);
      return point;
  }

  function inverse$2(p) {
      var point = geocentricToGeodetic(p, this.es, this.a, this.b);
      return point;
  }

  var names$2 = ["Geocentric", 'geocentric', "geocent", "Geocent"];
  var geocent = {
      init: init$2,
      forward: forward$2,
      inverse: inverse$2,
      names: names$2
  };

  var mode = {
    N_POLE: 0,
    S_POLE: 1,
    EQUIT: 2,
    OBLIQ: 3
  };

  var params = {
    h:     { def: 100000, num: true },           // default is Karman line, no default in PROJ.7
    azi:   { def: 0, num: true, degrees: true }, // default is North
    tilt:  { def: 0, num: true, degrees: true }, // default is Nadir
    long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic
    lat0:  { def: 0, num: true }                 // default is Equator, conversion to rad is automatic
  };

  function init$1() {
    Object.keys(params).forEach(function (p) {
      if (typeof this[p] === "undefined") {
        this[p] = params[p].def;
      } else if (params[p].num && isNaN(this[p])) {
        throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
      } else if (params[p].num) {
        this[p] = parseFloat(this[p]);
      }
      if (params[p].degrees) {
        this[p] = this[p] * D2R$1;
      }
    }.bind(this));

    if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {
      this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
    } else if (Math.abs(this.lat0) < EPSLN) {
      this.mode = mode.EQUIT;
    } else {
      this.mode = mode.OBLIQ;
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }

    this.pn1 = this.h / this.a;  // Normalize relative to the Earth's radius

    if (this.pn1 <= 0 || this.pn1 > 1e10) {
      throw new Error("Invalid height");
    }
    
    this.p = 1 + this.pn1;
    this.rp = 1 / this.p;
    this.h1 = 1 / this.pn1;
    this.pfact = (this.p + 1) * this.h1;
    this.es = 0;

    var omega = this.tilt;
    var gamma = this.azi;
    this.cg = Math.cos(gamma);
    this.sg = Math.sin(gamma);
    this.cw = Math.cos(omega);
    this.sw = Math.sin(omega);
  }

  function forward$1(p) {
    p.x -= this.long0;
    var sinphi = Math.sin(p.y);
    var cosphi = Math.cos(p.y);
    var coslam = Math.cos(p.x);
    var x, y;
    switch (this.mode) {
      case mode.OBLIQ:
        y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
        break;
      case mode.EQUIT:
        y = cosphi * coslam;
        break;
      case mode.S_POLE:
        y = -sinphi;
        break;
      case mode.N_POLE:
        y = sinphi;
        break;
    }
    y = this.pn1 / (this.p - y);
    x = y * cosphi * Math.sin(p.x);

    switch (this.mode) {
      case mode.OBLIQ:
        y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
        break;
      case mode.EQUIT:
        y *= sinphi;
        break;
      case mode.N_POLE:
        y *= -(cosphi * coslam);
        break;
      case mode.S_POLE:
        y *= cosphi * coslam;
        break;
    }

    // Tilt 
    var yt, ba;
    yt = y * this.cg + x * this.sg;
    ba = 1 / (yt * this.sw * this.h1 + this.cw);
    x = (x * this.cg - y * this.sg) * this.cw * ba;
    y = yt * ba;

    p.x = x * this.a;
    p.y = y * this.a;
    return p;
  }

  function inverse$1(p) {
    p.x /= this.a;
    p.y /= this.a;
    var r = { x: p.x, y: p.y };

    // Un-Tilt
    var bm, bq, yt;
    yt = 1 / (this.pn1 - p.y * this.sw);
    bm = this.pn1 * p.x * yt;
    bq = this.pn1 * p.y * this.cw * yt;
    p.x = bm * this.cg + bq * this.sg;
    p.y = bq * this.cg - bm * this.sg;

    var rh = hypot(p.x, p.y);
    if (Math.abs(rh) < EPSLN) {
      r.x = 0;
      r.y = p.y;
    } else {
      var cosz, sinz;
      sinz = 1 - rh * rh * this.pfact;
      sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
      cosz = Math.sqrt(1 - sinz * sinz);
      switch (this.mode) {
        case mode.OBLIQ:
          r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
          p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
          p.x *= sinz * this.cosph0;
          break;
        case mode.EQUIT:
          r.y = Math.asin(p.y * sinz / rh);
          p.y = cosz * rh;
          p.x *= sinz;
          break;
        case mode.N_POLE:
          r.y = Math.asin(cosz);
          p.y = -p.y;
          break;
        case mode.S_POLE:
          r.y = -Math.asin(cosz);
          break;
      }
      r.x = Math.atan2(p.x, p.y);
    }

    p.x = r.x + this.long0;
    p.y = r.y;
    return p;
  }

  var names$1 = ["Tilted_Perspective", "tpers"];
  var tpers = {
    init: init$1,
    forward: forward$1,
    inverse: inverse$1,
    names: names$1
  };

  function init() {
      this.flip_axis = (this.sweep === 'x' ? 1 : 0);
      this.h = Number(this.h);
      this.radius_g_1 = this.h / this.a;

      if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
          throw new Error();
      }

      this.radius_g = 1.0 + this.radius_g_1;
      this.C = this.radius_g * this.radius_g - 1.0;

      if (this.es !== 0.0) {
          var one_es = 1.0 - this.es;
          var rone_es = 1 / one_es;

          this.radius_p = Math.sqrt(one_es);
          this.radius_p2 = one_es;
          this.radius_p_inv2 = rone_es;

          this.shape = 'ellipse'; // Use as a condition in the forward and inverse functions.
      } else {
          this.radius_p = 1.0;
          this.radius_p2 = 1.0;
          this.radius_p_inv2 = 1.0;

          this.shape = 'sphere';  // Use as a condition in the forward and inverse functions.
      }

      if (!this.title) {
          this.title = "Geostationary Satellite View";
      }
  }

  function forward(p) {
      var lon = p.x;
      var lat = p.y;
      var tmp, v_x, v_y, v_z;
      lon = lon - this.long0;

      if (this.shape === 'ellipse') {
          lat = Math.atan(this.radius_p2 * Math.tan(lat));
          var r = this.radius_p / hypot(this.radius_p * Math.cos(lat), Math.sin(lat));

          v_x = r * Math.cos(lon) * Math.cos(lat);
          v_y = r * Math.sin(lon) * Math.cos(lat);
          v_z = r * Math.sin(lat);

          if (((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2) < 0.0) {
              p.x = Number.NaN;
              p.y = Number.NaN;
              return p;
          }

          tmp = this.radius_g - v_x;
          if (this.flip_axis) {
              p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
              p.y = this.radius_g_1 * Math.atan(v_z / tmp);
          } else {
              p.x = this.radius_g_1 * Math.atan(v_y / tmp);
              p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
          }
      } else if (this.shape === 'sphere') {
          tmp = Math.cos(lat);
          v_x = Math.cos(lon) * tmp;
          v_y = Math.sin(lon) * tmp;
          v_z = Math.sin(lat);
          tmp = this.radius_g - v_x;

          if (this.flip_axis) {
              p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
              p.y = this.radius_g_1 * Math.atan(v_z / tmp);
          } else {
              p.x = this.radius_g_1 * Math.atan(v_y / tmp);
              p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
          }
      }
      p.x = p.x * this.a;
      p.y = p.y * this.a;
      return p;
  }

  function inverse(p) {
      var v_x = -1.0;
      var v_y = 0.0;
      var v_z = 0.0;
      var a, b, det, k;

      p.x = p.x / this.a;
      p.y = p.y / this.a;

      if (this.shape === 'ellipse') {
          if (this.flip_axis) {
              v_z = Math.tan(p.y / this.radius_g_1);
              v_y = Math.tan(p.x / this.radius_g_1) * hypot(1.0, v_z);
          } else {
              v_y = Math.tan(p.x / this.radius_g_1);
              v_z = Math.tan(p.y / this.radius_g_1) * hypot(1.0, v_y);
          }

          var v_zp = v_z / this.radius_p;
          a = v_y * v_y + v_zp * v_zp + v_x * v_x;
          b = 2 * this.radius_g * v_x;
          det = (b * b) - 4 * a * this.C;

          if (det < 0.0) {
              p.x = Number.NaN;
              p.y = Number.NaN;
              return p;
          }

          k = (-b - Math.sqrt(det)) / (2.0 * a);
          v_x = this.radius_g + k * v_x;
          v_y *= k;
          v_z *= k;

          p.x = Math.atan2(v_y, v_x);
          p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
          p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
      } else if (this.shape === 'sphere') {
          if (this.flip_axis) {
              v_z = Math.tan(p.y / this.radius_g_1);
              v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1.0 + v_z * v_z);
          } else {
              v_y = Math.tan(p.x / this.radius_g_1);
              v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1.0 + v_y * v_y);
          }

          a = v_y * v_y + v_z * v_z + v_x * v_x;
          b = 2 * this.radius_g * v_x;
          det = (b * b) - 4 * a * this.C;
          if (det < 0.0) {
              p.x = Number.NaN;
              p.y = Number.NaN;
              return p;
          }

          k = (-b - Math.sqrt(det)) / (2.0 * a);
          v_x = this.radius_g + k * v_x;
          v_y *= k;
          v_z *= k;

          p.x = Math.atan2(v_y, v_x);
          p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
      }
      p.x = p.x + this.long0;
      return p;
  }

  var names = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
  var geos = {
      init: init,
      forward: forward,
      inverse: inverse,
      names: names,
  };

  function includedProjections(proj4){
    proj4.Proj.projections.add(tmerc);
    proj4.Proj.projections.add(etmerc);
    proj4.Proj.projections.add(utm);
    proj4.Proj.projections.add(sterea);
    proj4.Proj.projections.add(stere);
    proj4.Proj.projections.add(somerc);
    proj4.Proj.projections.add(omerc);
    proj4.Proj.projections.add(lcc);
    proj4.Proj.projections.add(krovak);
    proj4.Proj.projections.add(cass);
    proj4.Proj.projections.add(laea);
    proj4.Proj.projections.add(aea);
    proj4.Proj.projections.add(gnom);
    proj4.Proj.projections.add(cea);
    proj4.Proj.projections.add(eqc);
    proj4.Proj.projections.add(poly);
    proj4.Proj.projections.add(nzmg);
    proj4.Proj.projections.add(mill);
    proj4.Proj.projections.add(sinu);
    proj4.Proj.projections.add(moll);
    proj4.Proj.projections.add(eqdc);
    proj4.Proj.projections.add(vandg);
    proj4.Proj.projections.add(aeqd);
    proj4.Proj.projections.add(ortho);
    proj4.Proj.projections.add(qsc);
    proj4.Proj.projections.add(robin);
    proj4.Proj.projections.add(geocent);
    proj4.Proj.projections.add(tpers);
    proj4.Proj.projections.add(geos);
  }

  proj4.defaultDatum = 'WGS84'; //default datum
  proj4.Proj = Projection;
  proj4.WGS84 = new proj4.Proj('WGS84');
  proj4.Point = Point;
  proj4.toPoint = common;
  proj4.defs = defs;
  proj4.nadgrid = nadgrid;
  proj4.transform = transform;
  proj4.mgrs = mgrs;
  proj4.version = '__VERSION__';
  includedProjections(proj4);

  /**
   * 坐标系 枚举
   *  @enum {String}
   */
  const CRS = {
    /**
     * Web墨卡托投影坐标系
     */
    EPSG3857: "EPSG:3857",
    /**
     * WGS84地理坐标系
     */
    EPSG4326: "EPSG:4326",
    /**
     * 中国大地2000 （CGCS2000）地理坐标系
     */
    EPSG4490: "EPSG:4490",
    /**
     * CGCS2000 Gauss-Kruger Zone 平面投影，3度分带，横坐标前加带号。
     * 范围：EPSG:4513 到 EPSG:4533
     */
    CGCS2000_GK_Zone_3: "CGCS2000_GK_Zone_3",

    /**
     * CGCS2000 Gauss-Kruger Zone 平面投影，6度分带，横坐标前加带号。
     * 范围：EPSG:4491 到 EPSG:4501
     */
    CGCS2000_GK_Zone_6: "CGCS2000_GK_Zone_6",
    /**
     * CGCS2000 Gauss-Kruger CM 平面投影，3度分带，横坐标前不加带号。
     * 范围：EPSG:4534 到 EPSG:4554
     */
    CGCS2000_GK_CM_3: "CGCS2000_GK_CM_3",
    /**
     * CGCS2000 Gauss-Kruger CM 平面投影，6度分带，横坐标前不加带号。
     * 范围：EPSG:4502 到 EPSG:4512
     */
    CGCS2000_GK_CM_6: "CGCS2000_GK_CM_6"
  };

  // 定义一些常量
  const PI$1 = 3.141592653589793;

  /**
   * 坐标点类（含经度、纬度、高度）
   *
   * @param {Number|String} lng 经度值, -180 至 180
   * @param {Number|String} lat 纬度值, -90 至 90
   * @param {Number|String} [alt] 高度（单位：米）
   * @export
   * @class LngLatPoint
   */
  class LngLatPoint {
    constructor(lng, lat, alt) {
      this._lng = Number(lng || 0);
      this._lat = Number(lat || 0);
      this._alt = Number(alt || 0);
    }

    /**
     * 经度值, -180 至 180
     * @type {Number}
     */
    get lng() {
      return this._lng
    }

    set lng(lng) {
      this._lng = +lng;
      this._position = null;
    }

    /**
     * 纬度值, -180 至 180
     * @type {Number}
     */
    get lat() {
      return this._lat
    }

    set lat(lat) {
      this._lat = +lat;
      this._position = null;
    }

    /**
     * 高度（单位：米）
     * @type {Number}
     */
    get alt() {
      return this._alt || 0
    }

    set alt(alt) {
      this._alt = +alt;
      this._position = null;
    }

    /**
     * 复制一份对象
     * @return {LngLatPoint}  无
     */
    clone() {
      const position = new LngLatPoint();
      position.lng = this.lng || 0;
      position.lat = this.lat || 0;
      position.alt = this.alt || 0;
      return position
    }

    /**
     * 格式化对象内的经纬度的小数位为6位，高度小数位为1位。
     *
     * @return {LngLatPoint} 当前对象本身，可以链式调用
     */
    format() {
      this.lng = formatNum$2(this.lng, LngLatPoint.FormatLength);
      this.lat = formatNum$2(this.lat, LngLatPoint.FormatLength);
      this.alt = formatNum$2(this.alt, LngLatPoint.FormatAltLength);
      return this
    }

    /**
     * 转换为数组对象
     * @param {Boolean} [noAlt] 是否包含高度值
     * @returns {Array} 数组对象，示例[113.123456,31.123456,30.1]
     */
    toArray(noAlt) {
      this.format();
      if (noAlt) {
        return [this.lng, this.lat]
      } else {
        return [this.lng, this.lat, this.alt]
      }
    }

    /**
     * 转换为字符串对象
     * @returns {String} 符串，示例 "113.123456,31.123456,30.1"
     */
    toString() {
      this.format();
      return `${this.lng},${this.lat},${this.alt}`
    }

    /**
     * 转换为笛卡尔坐标
     * @param {Boolean} clone 是否复制
     * @returns {Cesium.Cartesian3} 笛卡尔坐标
     */
    toCartesian(clone = false) {
      if (!clone && this._position) {
        return this._position
      } else {
        return Cesium__namespace.Cartesian3.fromDegrees(this.lng, this.lat, this.alt)
      }
    }

    /**
     * 转换为 地理坐标(弧度制)
     * @returns {Cesium.Cartographic} 地理坐标(弧度制)
     */
    toCartographic() {
      return Cesium__namespace.Cartographic.fromDegrees(this.lng, this.lat, this.alt)
    }

    /**
     * 转换为 WebMercator投影平面坐标
     * @return {Number[]} WebMercator投影平面坐标,示例：[13048882.06,3741659.72]
     */
    toMercator() {
      let x = (this.lng * 20037508.34) / 180;
      let y = Math.log(Math.tan(((90 + this.lat) * PI$1) / 360)) / (PI$1 / 180);
      y = (y * 20037508.34) / 180;

      x = Number(x.toFixed(2));
      y = Number(y.toFixed(2));

      return [x, y, this.alt]
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param {LngLatPoint} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return this === other || (other instanceof LngLatPoint && this._alt === other._alt && this._lat === other._lat && this._lng === other._lng)
    }

    /**
     * 坐标是否有效范围内数据
     * @returns {Boolean}   是否有效
     */
    valid() {
      if (isNaN(this._lat) || isNaN(this._lng)) {
        return false
      }

      if (this._lat < -90 || this._lat > 90 || this._lng < -180 || this._lng > 180) {
        return false
      }

      if (this._lat === 0 && this._lng === 0 && this._alt === 0) {
        return false
      }

      return true
    }

    /**
     * 根据传入的各种对象数据，转换返回LatLngPoint对象
     *
     * @static
     * @param {String|Array|LngLatPoint|Cesium.Cartesian3|*} position 坐标位置
     * @param {Cesium.JulianDate} [time=Cesium.JulianDate.now()] Cesium坐标时，getValue传入的时间值
     * @return {LngLatPoint}  转换返回的LatLngPoint对象
     */
    static parse(position, time) {
      if (!position) {
        return new LngLatPoint()
      }
      if (position instanceof LngLatPoint) {
        return position
      }

      let result;
      if (typeof position === "string") {
        result = LngLatPoint.fromString(position);
      } else if (Array.isArray(position)) {
        result = LngLatPoint.fromArray(position);
      } else if (position instanceof LngLatPoint) {
        result = position.clone();
      } else if (Cesium__namespace.defined(position.lat) && Cesium__namespace.defined(position.lng)) {
        result = new LngLatPoint(position.lng, position.lat, position.alt);
        for (const key in position) {
          result[key] = position[key];
        }
      } else if (position instanceof Cesium__namespace.Cartesian3 || position._value || position.getValue) {
        result = LngLatPoint.fromCartesian(position, time);
        result._position = position;
      } else if (Cesium__namespace.defined(position.x) && Cesium__namespace.defined(position.y) && Cesium__namespace.defined(position.z)) {
        position = new Cesium__namespace.Cartesian3(position.x, position.y, position.z);
        result = LngLatPoint.fromCartesian(position, time);
        result._position = position;
      } else {
        result = new LngLatPoint();
        logError("坐标解析失败，请确认参数是否无误", position);
      }
      return result
    }

    /**
     * 根据数组数据，转换返回LatLngPoint对象
     * 示例：[113.123456,31.123456,30.1]
     *
     * @static
     * @param {Array} arr 坐标位置
     * @return {LngLatPoint}  转换返回的LatLngPoint对象
     */
    static fromArray(arr) {
      const position = new LngLatPoint();
      if (Array.isArray(arr)) {
        position.lng = arr[0] || 0;
        position.lat = arr[1] || 0;
        position.alt = arr[2] || 0;
      }
      return position
    }

    /**
     * 根据传入字符串，转换返回LatLngPoint对象
     * 示例："113.123456,31.123456,30.1"
     * @static
     * @param {String} str 坐标位置字符串，逗号分割。
     * @return {LngLatPoint}  转换返回的LatLngPoint对象
     */
    static fromString(str) {
      let position = new LngLatPoint();
      if (str && typeof str === "string") {
        const arr = str.split(",");
        position = this.fromArray(arr);
      }
      return position
    }

    /**
     * 根据传入的笛卡尔坐标，转换返回LatLngPoint对象
     *
     * @static
     * @param {Cesium.Cartesian3|*} cartesian 坐标位置
     * @param {Cesium.JulianDate} [time=Cesium.JulianDate.now()] Cesium坐标时，getValue传入的时间值
     * @return {LngLatPoint}  转换返回的LatLngPoint对象
     */
    static fromCartesian(cartesian, time) {
      const result = new LngLatPoint();

      let _position;
      if (cartesian) {
        if (cartesian instanceof Cesium__namespace.Cartesian3) {
          _position = cartesian;
        } else if (cartesian._value && cartesian._value instanceof Cesium__namespace.Cartesian3) {
          _position = cartesian._value;
        } else if (typeof cartesian.getValue === "function") {
          _position = cartesian.getValue(time || Cesium__namespace.JulianDate.now());
        }
      }
      if (_position) {
        const carto = Cesium__namespace.Cartographic.fromCartesian(_position);
        if (carto) {
          result.lat = Cesium__namespace.Math.toDegrees(carto.latitude);
          result.lng = Cesium__namespace.Math.toDegrees(carto.longitude);
          result.alt = carto.height;
          result.format();
        }
      }
      result._position = cartesian;
      return result
    }

    /**
     * 根据传入的地理坐标(弧度制)，转换返回LatLngPoint对象
     *
     * @static
     * @param {Cesium.Cartographic} cartographic 地理坐标(弧度制)
     * @return {LngLatPoint}  转换返回的LatLngPoint对象
     */
    static fromCartographic(cartographic) {
      const result = new LngLatPoint();
      result.lat = Cesium__namespace.Math.toDegrees(cartographic.latitude);
      result.lng = Cesium__namespace.Math.toDegrees(cartographic.longitude);
      result.alt = cartographic.height;
      return result
    }

    /**
     * 根据传入的 WebMercator投影平面坐标，转换返回LatLngPoint对象
     * @param {Number[]} arrdata WebMercator投影平面坐标，示例：[13048882.06,3741659.72]
     * @return {LngLatPoint}  转换返回的LatLngPoint对象
     */
    static fromMercator(arrdata) {
      const mx = Number(arrdata[0]);
      const my = Number(arrdata[1]);

      const x = (mx / 20037508.34) * 180;
      let y = (my / 20037508.34) * 180;
      y = (180 / PI$1) * (2 * Math.atan(Math.exp((y * PI$1) / 180)) - PI$1 / 2);

      const result = new LngLatPoint(x, y, arrdata[2] || 0);
      return result
    }

    /**
     * 根据传入的各种对象数据，转换返回Cartesian3对象
     *
     * @static
     * @param {String|Array|LngLatPoint|Cesium.Cartesian3|*} position 坐标位置
     * @param {Cesium.JulianDate} [time=Cesium.JulianDate.now()] Cesium坐标时，getValue传入的时间值
     * @return {Cesium.Cartesian3}  转换返回的Cartesian3对象
     */
    static toCartesian(position, time) {
      if (!position || position instanceof Cesium__namespace.Cartesian3) {
        return position
      }
      return LngLatPoint.parse(position, time).toCartesian(true)
    }

    /**
     * 根据传入的各种对象数据，转换返回Cartographic对象
     *
     * @static
     * @param {String|Array|LngLatPoint|Cesium.Cartesian3|*} position 坐标位置
     * @param {Cesium.JulianDate} [time=Cesium.JulianDate.now()] Cesium坐标时，getValue传入的时间值
     * @return {Cesium.Cartographic}  转换返回的Cartographic对象
     */
    static toCartographic(position, time) {
      if (!position || position instanceof Cesium__namespace.Cartographic) {
        return position
      }
      return LngLatPoint.parse(position, time).toCartographic()
    }

    /**
     * 转换返回经纬度坐标数组
     *
     * @static
     * @param {String|Array|Cesium.Cartesian3|*} value 坐标位置数组
     * @param {Boolean} [noAlt] 是否包含高度值
     * @return {Array[]} 经纬度坐标数组,示例： [123.123456,32.654321,198.7]
     */
    static toArray(value, noAlt) {
      const _point = LngLatPoint.parse(value);
      if (!_point || !_point.valid()) {
        return []
      }
      return _point.toArray(noAlt)
    }
  }

  /**
   * 经度纬度的格式化时的长度，默认为6
   * @type {Number}
   */
  LngLatPoint.FormatLength = 6;
  /**
   * 高度的格式化时的长度，默认为1
   * @type {Number}
   */
  LngLatPoint.FormatAltLength = 1;

  function formatNum$2(num, digits = 0) {
    const pow = Math.pow(10, digits);
    return Math.round(num * pow) / pow
  }

  /**
   * 坐标数组处理类
   *
   * @export
   * @class LngLatArray
   */
  class LngLatArray {
    /**
     * 根据传入的各种对象数据数组，转换返回Cartesian3数组
     *
     * @static
     * @param {String[]|Array[]|LngLatPoint[]} value 坐标位置数组
     * @param {Boolean} [clone] 是否重新生成拷贝
     * @return {Cesium.Cartesian3[]}  转换返回的Cartesian3数组
     */
    static toCartesians(value, clone) {
      if (!value || !Array.isArray(value)) {
        return value
      }

      const _positions = [];
      value.forEach(function (item) {
        if (item instanceof Cesium__namespace.Cartesian3) {
          if (clone) {
            _positions.push(item.clone());
          } else {
            _positions.push(item);
          }
          return
        }
        const _point = LngLatPoint.parse(item);
        if (!_point || !_point.valid()) {
          return
        }
        _positions.push(_point.toCartesian(true));
      });
      return _positions
    }

    /**
     * 根据传入的各种对象数据数组，转换返回LatLngPoint数组
     *
     * @static
     * @param {String[]|Array[]|Cesium.Cartesian3[]} value 坐标位置数组
     * @param {Boolean} [clone] 是否重新生成拷贝
     * @return {LngLatPoint[]}  转换返回的LatLngPoint数组
     */
    static toPoints(value, clone) {
      if (!value || !Array.isArray(value)) {
        return value
      }

      const _points = [];
      value.forEach(function (item) {
        if (item instanceof LngLatPoint && !clone) {
          _points.push(item);
          return
        }
        const _point = LngLatPoint.parse(item);
        if (!_point || !_point.valid()) {
          return
        }
        _points.push(_point);
      });
      return _points
    }

    /**
     * 根据传入的各种对象数据数组，转换返回经纬度坐标数组
     *
     * @static
     * @param {String[]|Array[]|Cesium.Cartesian3[]} value 坐标位置数组
     * @param {Boolean} [noAlt] 是否包含高度值
     * @return {Array[]} 经纬度坐标数组,示例：[ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
     */
    static toArray(value, noAlt) {
      if (!value || !Array.isArray(value)) {
        return value
      }

      const _points = [];
      value.forEach(function (item) {
        if (Array.isArray(item)) {
          _points.push(item);
          return
        }

        const _point = LngLatPoint.parse(item);
        if (!_point || !_point.valid()) {
          return
        }
        _points.push(_point.toArray(noAlt));
      });
      return _points
    }
  }

  /**
   * 坐标点的转换 相关静态方法。
   *  提供了cesium内部不同坐标系之间的坐标转换、提供了国内偏移坐标系与标准坐标的转换。
   * @module PointTrans
   */

  /**
   * 经度/纬度 十进制 转为 度分秒格式
   * @param {Number} value 经度或纬度值
   * @return {Object} 度分秒对象，如： { degree:113, minute:24, second:40 }
   */
  function degree2dms(value) {
    let fushu = 1;
    if (value < 0) {
      fushu = -1;
    }

    value = Math.abs(value);
    let degree = Math.floor(value); // 度
    const minute = Math.floor((value - degree) * 60); // 分
    const second = Math.round(((value - degree) * 3600) % 60); // 秒

    degree *= fushu;

    return {
      degree,
      minute,
      second,
      str: degree + "° " + minute + "'  " + second + '"'
    }
  }

  /**
   * 经度/纬度  度分秒 转为 十进制
   * @param {Number} degree 度
   * @param {Number} minute 分
   * @param {Number} second 秒
   * @return {Number} 十进制
   */
  function dms2degree(degree, minute, second) {
    let ten = Math.abs(degree) + minute / 60 + second / 3600;
    if (degree < 0) {
      ten *= -1;
    }
    return ten
  }

  /**
   * 根据经度值 获取CGCS2000投影坐标对应的 EPSG值
   *
   * @param {Number} lng 经度值
   * @param {Boolean} [fd6=false]  是否为6度分带， true:6度分带,false:3度分带
   * @param {Boolean} [hasAddDH=true] 横坐标前是否加带号
   * @return {String|undefined}  EPSG值
   */
  function getCGCS2000EPSGByLng(lng, fd6, hasAddDH = true) {
    let epsgID;
    if (fd6) {
      const n6 = parseInt(lng / 6) + 1; // 13到23
      if (n6 < 13 || n6 > 23) {
        return undefined
      }
      if (hasAddDH) {
        // EPSG:4491 到 EPSG:4501
        epsgID = n6 + 4478;
      } else {
        // EPSG:4502 到 EPSG:4512
        epsgID = n6 + 4489;
      }
    } else {
      const n3 = parseInt((lng - 1.5) / 3) + 1; // 25到45
      if (n3 < 25 || n3 > 45) {
        return undefined
      }
      if (hasAddDH) {
        // EPSG:4513 到 EPSG:4533
        epsgID = n3 + 4488;
      } else {
        // EPSG:4534 到 EPSG:4554
        epsgID = n3 + 4509;
      }
    }
    return "EPSG:" + epsgID
  }

  /**
   * 根据加带号的横坐标值 获取CGCS2000投影坐标对应的EPSG值
   * @param {Number} x 根据加带号的横坐标值
   * @return {String|undefined}  EPSG值
   */
  function getCGCS2000EPSGByX(x) {
    const dh = parseInt(x.toString().slice(0, 2));
    if (dh >= 13 && dh <= 23) {
      // 13到23,   EPSG:4491 到 EPSG:4501
      return "EPSG:" + (dh + 4478)
    } else if (dh >= 25 && dh <= 45) {
      // 25到45,   EPSG:4513 到 EPSG:4533
      return "EPSG:" + (dh + 4488)
    } else {
      return undefined
    }
  }

  /**
   * 使用proj4转换坐标（支持任意坐标系），
   * 坐标系 可以在 {@link http://epsg.io }进行查询，已经内置支持 EPSG:4326、EPSG:3857、EPSG:4490、EPSG:4491至4554
   *
   * @param {Number[]} arrdata 原始坐标,示例：[39396641,3882123]
   * @param {String|CRS} fromProjParams 原始坐标的坐标系，如'EPSG:4527'
   * @param {String|CRS} [toProjParams='EPSG:4326'] 转为返回的结果坐标系
   * @return {Number[]} 返回结果坐标系的对应坐标,示例：[115.866936, 35.062583]
   */
  function proj4Trans(arrdata, fromProjParams, toProjParams = "EPSG:4326") {
    if (!fromProjParams || !toProjParams || fromProjParams === toProjParams) {
      return arrdata
    }
    try {
      if (fromProjParams === CRS.CGCS2000_GK_Zone_3 || fromProjParams === CRS.CGCS2000_GK_Zone_6) {
        fromProjParams = getCGCS2000EPSGByX(arrdata[0]);
      }

      if (toProjParams === CRS.CGCS2000_GK_Zone_3) {
        toProjParams = getCGCS2000EPSGByLng(arrdata[0], false, true);
      } else if (toProjParams === CRS.CGCS2000_GK_Zone_6) {
        toProjParams = getCGCS2000EPSGByLng(arrdata[0], true, true);
      } else if (toProjParams === CRS.CGCS2000_GK_CM_3) {
        toProjParams = getCGCS2000EPSGByLng(arrdata[0], false, false);
      } else if (toProjParams === CRS.CGCS2000_GK_CM_6) {
        toProjParams = getCGCS2000EPSGByLng(arrdata[0], true, false);
      }
      if (!fromProjParams || !toProjParams || fromProjParams === toProjParams) {
        return arrdata
      }

      const arr = proj4(fromProjParams, toProjParams, arrdata);
      if (Cesium__namespace.defined(arr) && arr.length > 1 && !isNaN(arr[0]) && arr[0] !== Infinity) {
        return arr
      }
    } catch (e) {
      // console.log(e)
    }
    return arrdata
  }

  /**
   * 使用proj4转换坐标数组（支持任意坐标系），
   * 坐标系 可以在 {@link http://epsg.io }进行查询，已经内置支持 EPSG:4326、EPSG:3857、EPSG:4490、EPSG:4491至4554
   *
   * @param {Number[]} coords 原始坐标数组,示例：[[39396641,3882123],[39396623,3882134]]
   * @param {String} fromProjParams 原始坐标的坐标系，如'EPSG:4527'
   * @param {String} [toProjParams='EPSG:4326'] 转为返回的结果坐标系
   * @return {Number[]} 返回结果坐标系的对应坐标数组,示例：[[115.866936, 35.062583],[115.866923, 35.062565]]
   */
  function proj4TransArr(coords, fromProjParams, toProjParams = "EPSG:4326") {
    if (!fromProjParams || fromProjParams === toProjParams) {
      return coords
    }

    const arr = [];
    for (let i = 0, len = coords.length; i < len; i++) {
      const item = coords[i];
      if (Array.isArray(item[0])) {
        const arr2 = proj4TransArr(item, fromProjParams, toProjParams);
        if (arr2 && arr2.length > 0) {
          arr.push(arr2);
        }
      } else {
        const arr2 = proj4Trans(item, fromProjParams, toProjParams);
        if (arr2) {
          arr.push(arr2);
        }
      }
    }
    return arr
  }

  /**
   * Cesium笛卡尔空间坐标 转 经纬度坐标 ,等价于 LngLatPoint.toArray
   * 常用于转换geojson
   *
   * @param {Cesium.Cartesian3} cartesian Cesium笛卡尔空间xyz坐标
   * @param {Boolean} [noAlt] 是否包含高度值
   * @return {Number[]} 经纬度坐标,示例：[123.123456,32.654321,198.7]
   */
  function cartesian2lonlat(cartesian, noAlt) {
    return LngLatPoint.toArray(cartesian, noAlt)
  }

  /**
   * Cesium笛卡尔空间坐标数组 转 经纬度坐标数组，等价于 LngLatArray.toArray
   * 常用于转换geojson
   *
   * @export
   * @param {Cesium.Cartesian3[]} positions Cesium笛卡尔空间xyz坐标数组
   * @param {Boolean} [noAlt] 是否包含高度值
   * @return {Array[]} 经纬度坐标数组,示例：[ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
   */
  function cartesians2lonlats(positions, noAlt) {
    return LngLatArray.toArray(positions, noAlt)
  }

  /**
   * Cesium笛卡尔空间坐标 转 WebMercator投影平面坐标
   *
   * @export
   * @param {Cesium.Cartesian3} position Cesium笛卡尔空间xyz坐标
   * @return {Number[]} 墨卡托投影平面坐标,示例：[13048882,3741659,20.1]
   */
  function cartesian2mercator(position) {
    if (!position) {
      return null
    }

    const point = LngLatPoint.fromCartesian(position);
    return point.toMercator()
  }

  /**
   * Cesium笛卡尔空间坐标数组 转 WebMercator投影平面坐标数组
   *
   * @export
   * @param {Cesium.Cartesian3[]} positions Cesium笛卡尔空间xyz坐标数组
   * @return {Array[]} WebMercator投影平面坐标数组,示例：[[13048882,3741659,20.1],[13048882,3741659,21.2] ]
   */
  function cartesians2mercators(positions) {
    const arrNew = [];
    for (let i = 0, len = positions.length; i < len; i++) {
      const point = cartesian2mercator(positions[i]);
      if (point) {
        arrNew.push(point);
      }
    }
    return arrNew
  }

  /**
   * 经纬度坐标 转 Cesium笛卡尔空间xyz坐标
   *
   * @export
   * @param {Array[]} coord 经纬度坐标,示例：[123.123456,32.654321,198.7]
   * @param {Number} [defHeight=0] 默认高度
   * @return {Cesium.Cartesian3} Cesium笛卡尔空间xyz坐标
   */
  function lonlat2cartesian(coord, defHeight = 0) {
    if (!coord || coord.length < 2) {
      return null
    }
    return Cesium__namespace.Cartesian3.fromDegrees(coord[0], coord[1], coord[2] || defHeight)
  }

  /**
   * 经纬度坐标数组 转 Cesium笛卡尔空间xyz坐标数组
   *
   * @export
   * @param {Array[]} coords 经纬度坐标数组,示例：[ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
   * @param {Number} [defHeight=0] 默认高度
   * @return {Cesium.Cartesian3[]} Cesium笛卡尔空间xyz坐标数组
   */
  function lonlats2cartesians(coords, defHeight) {
    const arr = [];
    for (let i = 0, len = coords.length; i < len; i++) {
      const item = coords[i];
      if (Array.isArray(item[0])) {
        const arr2 = lonlats2cartesians(item, defHeight);
        if (arr2 && arr2.length > 0) {
          arr.push(arr2);
        }
      } else {
        const cartesian = lonlat2cartesian(item, defHeight);
        if (cartesian) {
          arr.push(cartesian);
        }
      }
    }
    return arr
  }

  /**
   * 经纬度地理坐标 转 投影平面坐标
   *
   * @export
   * @param {Number[]} lnglat 经纬度坐标,示例：[123.123456,32.654321,20.1]
   * @return {Number[]} WebMercator投影平面坐标,示例：[13048882,3741659,20.1]
   */
  function lonlat2mercator(lnglat) {
    const point = LngLatPoint.fromArray(lnglat);
    return point.toMercator()
  }

  /**
   * 经纬度地理坐标数组 转 投影平面坐标数组
   *
   * @export
   * @param {Array[]} arr 经纬度坐标数组,示例：[ [123.123456,32.654321,20.1], [111.123456,22.654321,21.2] ]
   * @return {Array[]} WebMercator投影平面坐标数组,示例：[[13048882,3741659,20.1],[13048882,3741659,21.2] ]
   */
  function lonlats2mercators(arr) {
    const arrNew = [];
    for (let i = 0, len = arr.length; i < len; i++) {
      const point = lonlat2mercator(arr[i]);
      arrNew.push(point);
    }
    return arrNew
  }

  /**
   * 投影平面坐标 转 Cesium笛卡尔空间xyz坐标
   *
   * @export
   * @param {Number[]} arr WebMercator投影平面坐标,示例：[13048882,3741659,20.1]
   * @param {Number} [height] 赋值高度
   * @return  {Cesium.Cartesian3}  Cesium笛卡尔空间xyz坐标
   */
  function mercator2cartesian(arr, height) {
    if (isNaN(arr[0]) || isNaN(arr[1])) {
      return null
    }

    const point = LngLatPoint.fromMercator(arr);
    if (Cesium__namespace.defined(height)) {
      point.alt = height;
    }
    return point.toCartesian()
  }

  /**
   * 投影平面坐标数组 转 Cesium笛卡尔空间xyz坐标数组
   *
   * @export
   * @param {Number[]} arr WebMercator投影平面坐标数组,示例：[[13048882,3741659,20.1],[13048882,3741659,21.2] ]
   * @param {Number} [height] 赋值高度
   * @return  {Cesium.Cartesian3}  Cesium笛卡尔空间xyz坐标数组
   */
  function mercators2cartesians(arr, height) {
    const arrNew = [];
    for (let i = 0, len = arr.length; i < len; i++) {
      const point = mercator2cartesian(arr[i], height);
      if (point) {
        arrNew.push(point);
      }
    }
    return arrNew
  }

  /**
   * 投影平面坐标 转 经纬度地理坐标
   *
   * @export
   * @param {Number[]} arr WebMercator投影平面坐标,示例：[13048882,3741659,20.1]
   * @return {Number[]} 经纬度坐标,示例：[123.123456,32.654321,20.1]
   */
  function mercator2lonlat(arr) {
    const point = LngLatPoint.fromMercator(arr);
    return point.toArray()
  }

  /**
   * 投影平面坐标数组 转 经纬度地理坐标数组
   *
   * @export
   * @param {Array[]} arr WebMercator投影平面坐标数组,示例：[[13048882,3741659,20.1],[13048882,3741659,21.2] ]
   * @return {Array[]} 经纬度坐标数组,示例：[ [123.123456,32.654321,20.1], [111.123456,22.654321,21.2] ]
   */
  function mercators2lonlats(arr) {
    const arrNew = [];
    for (let i = 0, len = arr.length; i < len; i++) {
      const point = mercator2lonlat(arr[i]);
      arrNew.push(point);
    }
    return arrNew
  }

  //= =======提供了百度（BD09）、国测局（GCJ02）、WGS84、Web墨卡托 4类坐标之间的转换=======
  // 传入参数 和 返回结果 均是数组：[经度,纬度]

  // 定义一些常量
  const x_PI = (3.141592653589793 * 3000.0) / 180.0;
  const PI = 3.141592653589793;
  const a = 6378245.0;
  const ee = 0.00669342162296594;

  function transformlat(lng, lat) {
    let ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));
    ret += ((20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0) / 3.0;
    ret += ((20.0 * Math.sin(lat * PI) + 40.0 * Math.sin((lat / 3.0) * PI)) * 2.0) / 3.0;
    ret += ((160.0 * Math.sin((lat / 12.0) * PI) + 320 * Math.sin((lat * PI) / 30.0)) * 2.0) / 3.0;
    return ret
  }

  function transformlng(lng, lat) {
    let ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));
    ret += ((20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0) / 3.0;
    ret += ((20.0 * Math.sin(lng * PI) + 40.0 * Math.sin((lng / 3.0) * PI)) * 2.0) / 3.0;
    ret += ((150.0 * Math.sin((lng / 12.0) * PI) + 300.0 * Math.sin((lng / 30.0) * PI)) * 2.0) / 3.0;
    return ret
  }

  // 判断是否在国内，不在国内则不做偏移
  function out_of_china(lng, lat) {
    return lng < 72.004 || lng > 137.8347 || lat < 0.8293 || lat > 55.8271 || false
  }

  /**
   * 经纬度坐标转换，
   * 百度坐标 (BD09) 转换为 国测局坐标 (GCJ02)
   *
   * @export
   * @param {Number[]} arrdata 百度坐标 (BD09)坐标数据，示例：[117.225590,31.832916]
   * @return {Number[]} 国测局坐标 (GCJ02)坐标数据，示例：[:117.22559,31.832917]
   */
  function bd2gcj(arrdata) {
    const bd_lon = Number(arrdata[0]);
    const bd_lat = Number(arrdata[1]);

    const x_pi = (3.141592653589793 * 3000.0) / 180.0;
    const x = bd_lon - 0.0065;
    const y = bd_lat - 0.006;
    const z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_pi);
    const theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_pi);
    let gg_lng = z * Math.cos(theta);
    let gg_lat = z * Math.sin(theta);

    gg_lng = Number(gg_lng.toFixed(6));
    gg_lat = Number(gg_lat.toFixed(6));
    return [gg_lng, gg_lat]
  }

  /**
   * 经纬度坐标转换，
   * 国测局坐标 (GCJ02) 转换为 百度坐标 (BD09)
   *
   * @export
   * @param {Number[]} arrdata 高德谷歌等国测局坐标 (GCJ02) 坐标数据，示例：[117.225590,31.832916]
   * @return {Number[]} 百度坐标 (BD09)坐标数据，示例：[117.232039,31.839177]
   */
  function gcj2bd(arrdata) {
    const lng = Number(arrdata[0]);
    const lat = Number(arrdata[1]);

    const z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * x_PI);
    const theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * x_PI);
    let bd_lng = z * Math.cos(theta) + 0.0065;
    let bd_lat = z * Math.sin(theta) + 0.006;

    bd_lng = Number(bd_lng.toFixed(6));
    bd_lat = Number(bd_lat.toFixed(6));
    return [bd_lng, bd_lat]
  }

  /**
   * 经纬度坐标转换，
   * 标准无偏坐标（WGS84） 转为 国测局坐标 (GCJ02)
   *
   * @export
   * @param {Number[]} arrdata 标准无偏坐标（WGS84）坐标数据，示例：[117.220102, 31.834912]
   * @return {Number[]} 国测局坐标 (GCJ02)坐标数据，示例：[117.225590,31.832916]
   */
  function wgs2gcj(arrdata) {
    const lng = Number(arrdata[0]);
    const lat = Number(arrdata[1]);

    if (out_of_china(lng, lat)) {
      return [lng, lat]
    } else {
      let dlat = transformlat(lng - 105.0, lat - 35.0);
      let dlng = transformlng(lng - 105.0, lat - 35.0);
      const radlat = (lat / 180.0) * PI;
      let magic = Math.sin(radlat);
      magic = 1 - ee * magic * magic;
      const sqrtmagic = Math.sqrt(magic);
      dlat = (dlat * 180.0) / (((a * (1 - ee)) / (magic * sqrtmagic)) * PI);
      dlng = (dlng * 180.0) / ((a / sqrtmagic) * Math.cos(radlat) * PI);
      let mglat = lat + dlat;
      let mglng = lng + dlng;

      mglng = Number(mglng.toFixed(6));
      mglat = Number(mglat.toFixed(6));
      return [mglng, mglat]
    }
  }

  /**
   * 经纬度坐标转换，
   * 国测局坐标 (GCJ02)  转换为 标准无偏坐标（WGS84）
   *
   * @export
   * @param {Number[]} arrdata 国测局坐标 (GCJ02)坐标数据，示例：[117.225590,31.832916]
   * @return {Number[]} 标准无偏坐标（WGS84）坐标数据，示例：[117.220102, 31.834912]
   */
  function gcj2wgs(arrdata) {
    const lng = Number(arrdata[0]);
    const lat = Number(arrdata[1]);

    if (out_of_china(lng, lat)) {
      return [lng, lat]
    } else {
      let dlat = transformlat(lng - 105.0, lat - 35.0);
      let dlng = transformlng(lng - 105.0, lat - 35.0);
      const radlat = (lat / 180.0) * PI;
      let magic = Math.sin(radlat);
      magic = 1 - ee * magic * magic;
      const sqrtmagic = Math.sqrt(magic);
      dlat = (dlat * 180.0) / (((a * (1 - ee)) / (magic * sqrtmagic)) * PI);
      dlng = (dlng * 180.0) / ((a / sqrtmagic) * Math.cos(radlat) * PI);

      const mglat = lat + dlat;
      const mglng = lng + dlng;

      let jd = lng * 2 - mglng;
      let wd = lat * 2 - mglat;

      jd = Number(jd.toFixed(6));
      wd = Number(wd.toFixed(6));
      return [jd, wd]
    }
  }

  /**
   * 经纬度坐标转换，
   * 百度坐标 (BD09) 转 标准无偏坐标（WGS84）
   *
   * @export
   * @param {Number[]} arrdata 百度坐标 (BD09)坐标数据，示例：[117.232039,31.839177]
   * @return {Number[]} 标准无偏坐标（WGS84）坐标数据，示例：[117.220102, 31.834912]
   */
  function bd2wgs(arrdata) {
    return gcj2wgs(bd2gcj(arrdata))
  }
  /**
   * 标准无偏坐标（WGS84）  转 百度坐标 (BD09)
   *
   * @export
   * @param {Number[]} arrdata 标准无偏坐标（WGS84）坐标数据，示例：[117.220102, 31.834912]
   * @return {Number[]} 百度坐标 (BD09)坐标数据，示例：[117.232039,31.839177]
   */
  function wgs2bd(arrdata) {
    return gcj2bd(wgs2gcj(arrdata))
  }

  var PointTrans = {
    __proto__: null,
    degree2dms: degree2dms,
    dms2degree: dms2degree,
    getCGCS2000EPSGByLng: getCGCS2000EPSGByLng,
    getCGCS2000EPSGByX: getCGCS2000EPSGByX,
    proj4Trans: proj4Trans,
    proj4TransArr: proj4TransArr,
    cartesian2lonlat: cartesian2lonlat,
    cartesians2lonlats: cartesians2lonlats,
    cartesian2mercator: cartesian2mercator,
    cartesians2mercators: cartesians2mercators,
    lonlat2cartesian: lonlat2cartesian,
    lonlats2cartesians: lonlats2cartesians,
    lonlat2mercator: lonlat2mercator,
    lonlats2mercators: lonlats2mercators,
    mercator2cartesian: mercator2cartesian,
    mercators2cartesians: mercators2cartesians,
    mercator2lonlat: mercator2lonlat,
    mercators2lonlats: mercators2lonlats,
    bd2gcj: bd2gcj,
    gcj2bd: gcj2bd,
    wgs2gcj: wgs2gcj,
    gcj2wgs: gcj2wgs,
    bd2wgs: bd2wgs,
    wgs2bd: wgs2bd
  };

  /**
   * 多语种文本配置，
   * 值为数组，对应{@link LangType}按照固定顺序排列,如：[中文简体,中文繁體,English]
   * @enum {String[]}
   * @constant
   * @example
   *  mars3d.Lang["_单击开始绘制"][mars3d.LangType.ZH] ="新的中文提示语句";
   */
  const Lang = {
    _放大: ["放大", "放大", "Zoom In"],
    _缩小: ["缩小", "縮小", "Zoom Out"],

    _查看此处坐标: ["查看此处坐标", "查看此處坐標", "Location info"],
    _位置信息: ["位置信息", "位置信息", "The location information"],
    _经度: ["经度", "經度", "Lon"],
    _纬度: ["纬度", "緯度", "Lat"],
    _海拔: ["高程", "高程", "Alt"],
    _横坐标: ["横坐标", "橫坐標", "X"],
    _纵坐标: ["纵坐标：", "縱坐標", "Y"],

    _查看当前视角: ["查看当前视角", "查看當前視角", "Camera info"],
    _当前视角信息: ["当前视角信息", "當前視角信息", "Current Camera Information"],

    _视角切换: ["视角切换", "視角切換", "Camera"],
    _禁止进入地下: ["禁止进入地下", "禁止進入地下", "Do not go underground"],
    _允许进入地下: ["允许进入地下", "允許進入地下", "Access to the ground"],
    _绕此处环绕飞行: ["绕此处环绕飞行", "繞此處環繞飛行", "Fly around here"],
    _关闭环绕飞行: ["关闭环绕飞行", "關閉環繞飛行", "Close off circling"],
    _移动到此处: ["移动到此处", "移動到此處", "Move it over here"],
    _第一视角站到此处: ["第一视角站到此处", "第一視角站到此處", "First view is here"],
    _开启键盘漫游: ["开启键盘漫游", "開啓鍵盤漫遊", "Enable keyboard roaming"],
    _关闭键盘漫游: ["关闭键盘漫游", "關閉鍵盤漫遊", "Turn off keyboard roaming"],
    _跟踪锁定: ["跟踪锁定", "跟踪鎖定", "TrackedEntity"],
    _取消锁定: ["取消锁定", "取消鎖定", "Unlocked"],

    _三维模型: ["三维模型", "三維模型", "3DTiles"],
    _显示三角网: ["显示三角网", "顯示三角網", "Display Wireframe"],
    _关闭三角网: ["关闭三角网", "關閉三角網", "Close Wireframe"],
    _显示包围盒: ["显示包围盒", "顯示包圍盒", "Display BoundingVolume"],
    _关闭包围盒: ["关闭包围盒", "關閉包圍盒", "Close BoundingVolume"],

    _地形服务: ["地形服务", "地形服務", "Terrain"],
    _开启地形: ["开启地形", "顯示地形", "Open terrain"],
    _关闭地形: ["关闭地形", "關閉地形", "Close terrain"],

    _图上标记: ["图上标记", "圖上標記", "Drawing"],
    _标记点: ["标记点", "標記點", "Mark points"],
    _标记线: ["标记线", "標記線", "Tag line"],
    _标记面: ["标记面", "標記面", "Mark surface"],
    _标记圆: ["标记圆", "標記圓", "Mark round"],
    _标记矩形: ["标记矩形", "標記矩形", "Mark rectangular"],
    _允许编辑: ["允许编辑", "允許編輯", "Allowed to edit"],
    _禁止编辑: ["禁止编辑", "禁止編輯", "Prohibit to edit"],
    _导出GeoJSON: ["导出GeoJSON", "導出GeoJSON", "Export GeoJSON"],
    _清除所有标记: ["清除所有标记", "清除所有標記", "Clear"],

    _特效效果: ["特效效果", "特效效果", "Effects"],
    _开启下雨: ["开启下雨", "開啓下雨", "Enable rain"],
    _关闭下雨: ["关闭下雨", "關閉下雨", "Close rain"],
    _开启下雪: ["开启下雪", "開啓下雪", "Enable snow"],
    _关闭下雪: ["关闭下雪", "關閉下雪", "Close snow"],
    _开启雾天气: ["开启雾天气", "開啓霧天氣", "Enable fog"],
    _关闭雾天气: ["关闭雾天气", "關閉霧天氣", "Close fog"],
    _开启泛光: ["开启泛光", "開啓泛光", "Enable bloom"],
    _关闭泛光: ["关闭泛光", "關閉泛光", "Close bloom"],
    _开启亮度: ["开启亮度", "開啓亮度", "Enable brightness"],
    _关闭亮度: ["关闭亮度", "關閉亮度", "Close brightness"],
    _开启夜视: ["开启夜视", "開啓夜視", "Enable night vision"],
    _关闭夜视: ["关闭夜视", "關閉夜視", "Close night vision"],
    _开启黑白: ["开启黑白", "開啓黑白", "Enable black and white"],
    _关闭黑白: ["关闭黑白", "關閉黑白", "Close black and white"],
    _开启拾取高亮: ["开启拾取高亮", "開啓拾取高亮", "Enable Pick highlighted"],
    _关闭拾取高亮: ["关闭拾取高亮", "關閉拾取高亮", "Close Pick highlighted"],

    _场景设置: ["场景设置", "場景設置", "Scene"],
    _开启深度监测: ["开启深度监测", "開啓深度監測", "Enable depth test against terrain"],
    _关闭深度监测: ["关闭深度监测", "關閉深度監測", "Close depth test against terrain"],
    _显示星空背景: ["显示星空背景", "顯示星空背景", "Enable skyBox"],
    _关闭星空背景: ["关闭星空背景", "關閉星空背景", "Close skyBox"],
    _开启日照阴影: ["开启日照阴影", "開啓日照陰影", "Enable shadow"],
    _关闭日照阴影: ["关闭日照阴影", "關閉日照陰影", "Close shadow"],
    _开启大气渲染: ["开启大气渲染", "開啓大氣渲染", "Enable sky atmosphere"],
    _关闭大气渲染: ["关闭大气渲染", "關閉大氣渲染", "Close sky atmosphere"],
    _场景出图: ["场景出图", "場景出圖", "Export image"],

    _图上量算: ["图上量算", "圖上量算", "Measure"],
    _删除测量: ["删除测量", "刪除測量", "Delete"],
    _角度: ["角度", "角度", "Angle"],
    _距离: ["距离", "距離", "Distance"],
    _面积: ["面积", "面積", "Area"],
    _总长: ["总长", "總長", "Total distance"],
    _起点: ["起点", "起點", "Start"],
    _高度差: ["高度差", "高度差", "Height difference"],
    _空间距离: ["空间距离", "空間距離", "Space distance"],
    _水平距离: ["水平距离", "水平距離", "Horizontal distance"],
    _正在计算体积: ["正在计算体积", "正在計算體積", "Calculating volume"],
    _填方体积: ["填方体积", "填方體積", "The volume of fill"],
    _挖方体积: ["挖方体积", "挖方體積", "Excavation volume"],
    _横切面积: ["横切面积", "橫切面積", "Crosscutting area"],
    _面上: ["面上", "面上", "Up"],
    _面下: ["面下", "面下", "Down"],

    _米: ["米", "米", "m"],
    _公里: ["公里", "公裏", "km"],
    _海里: ["海里", "海裏", "mile"],
    _丈: ["丈", "丈", "zhang"],
    _平方米: ["平方米", "平方米", "m²"],
    _平方公里: ["平方公里", "平方公裏", "km²"],
    _亩: ["亩", "畝", "mu"],
    _公顷: ["公顷", "公頃", "ha"],
    _立方米: ["方", "方", "m³"],
    _万立方米: ["万方", "万方", "wm³"],

    _单击开始绘制: ["单击开始绘制", "單擊開始繪制", "Click to start drawing"],
    _单击完成绘制: ["单击完成绘制", "單擊完成繪制", "Click to finish drawing"],
    _双击完成绘制: ["双击完成绘制", "雙擊完成繪制", "Double click to finish drawing"],
    _单击增加点: ["单击增加点", "單擊增加點", "left click add point"],
    _右击删除点: ["右击删除点", "右擊刪除點", "right click delete point"],

    _单击后激活编辑: ["单击后激活编辑", "單擊後 激活編輯", "Click to activate editing"],
    _右击菜单删除: ["右击菜单删除", "右擊菜單刪除", "Right click menu to delete"],
    _更多功能请右击: ["更多功能请右击", "更多功能請右擊", "For more functions, right click"],

    _释放后完成修改: ["释放后完成修改", "釋放後完成修改", "Complete the modification after release"],
    _该对象不允许编辑: ["该对象不允许编辑", "該對象不允許編輯", "This object does not allow editing"],
    _拖动该点后: ["拖动该点后", "拖動該點後", "Drag that point"],
    _拖动对象后: ["拖动对象后", "拖動對象後", "Drag that object"],
    _修改位置: ["修改位置", "修改位置", "Modify the position"],
    _整体平移: ["整体平移", "整體平移", "The overall translation"],
    _增加点: ["增加点", "增加點", "Add point"],
    _修改高度: ["修改高度", "修改高度", "Modify the height"],
    _修改半径: ["修改半径", "修改半徑", "Modify the radius"],
    _修改长度: ["修改长度(X方向)", "修改長度(X方向)", "Modify the length(X direction )"],
    _修改宽度: ["修改宽度(Y方向)", "修改寬度(Y方向)", "Change the width(Y direction)"],
    _修改方向: ["修改方向", "修改方向", "Change direction"],
    _修改缩放比例: ["修改缩放比例", "修改縮放比例", "Modify the Scale"],
    _无法删除不能少于最小点数: ["无法删除，点数量不能少于", "無法刪除，點數量不能少于", "Cannot delete, the number of dots cannot be less than"],
    _删除: ["删除", "刪除", "Delete"],
    _加载模型中: ["加载模型中…", "加载模型中…", "Load Model…"]
  };

  // 来源于axios库的lib\adapters\xhr.js
  function xhrAdapter(options) {
    options = {
      method: "get",
      timeout: 0,
      maxContentLength: -1,
      maxBodyLength: -1,
      params: options.queryParameters || {}, // 兼容queryParameters命名
      ...options
    };
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      let requestData = options.data;
      const requestHeaders = options.headers || {};
      const responseType = options.responseType;

      // requestHeaders["User-Connect"] = "mars2d";

      if (isFormData(requestData)) {
        delete requestHeaders["Content-Type"]; // Let the browser set it
      }

      let request = new XMLHttpRequest();
      request.open(options.method.toUpperCase(), buildURL(options.url, options.params, options.paramsSerializer), true);

      // Set the request timeout in MS
      request.timeout = options.timeout;

      function onloadend() {
        if (!request) {
          return
        }
        // Prepare the response
        const responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: transformResponse(request, responseData),
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          options: options,
          request: request
        };

        settle(
          function _resolve(value) {
            resolve(value);
          },
          function _reject(err) {
            reject(err);
          },
          response
        );

        // Clean up request
        request = null;
      }

      if ("onloadend" in request) {
        // Use onloadend if available
        request.onloadend = onloadend;
      } else {
        // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return
          }
          // readystate handler is calling before onerror or ontimeout handlers,
          // so we should call onloadend on the next 'tick'
          setTimeout(onloadend);
        };
      }

      // Handle browser request cancellation (as opposed to a manual cancellation)
      request.onabort = function handleAbort() {
        if (!request) {
          return
        }

        reject(createError("Request aborted", options, "ECONNABORTED", request));

        // Clean up request
        request = null;
      };

      // Handle low level network errors
      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(createError("Network Error", options, null, request));

        // Clean up request
        request = null;
      };

      // Handle timeout
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = "timeout of " + options.timeout + "ms exceeded";
        if (options.timeoutErrorMessage) {
          timeoutErrorMessage = options.timeoutErrorMessage;
        }
        reject(createError(timeoutErrorMessage, options, "ECONNABORTED", request));

        // Clean up request
        request = null;
      };

      // Add headers to the request
      if ("setRequestHeader" in request) {
        forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            // Remove Content-Type if data is undefined
            delete requestHeaders[key];
          } else {
            // Otherwise add header to the request
            request.setRequestHeader(key, val);
          }
        });
      }

      // Add withCredentials to request if needed
      if (!isUndefined(options.withCredentials)) {
        request.withCredentials = !!options.withCredentials;
      }

      // Add responseType to request if needed
      if (responseType && responseType !== "json") {
        request.responseType = options.responseType;
      }

      // Handle progress if needed
      if (typeof options.onDownloadProgress === "function") {
        request.addEventListener("progress", options.onDownloadProgress);
      }

      // Not all browsers support upload events
      if (typeof options.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", options.onUploadProgress);
      }

      if (!requestData) {
        requestData = null;
      }

      // Send the request
      request.send(requestData);
    })
  }

  function isString$1(val) {
    return typeof val === "string"
  }
  function isDate(val) {
    return toString.call(val) === "[object Date]"
  }
  function isObject$1(val) {
    return val !== null && typeof val === "object"
  }
  function isFormData(val) {
    return typeof FormData !== "undefined" && val instanceof FormData
  }
  function isUndefined(val) {
    return typeof val === "undefined"
  }
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams
  }

  function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === "undefined") {
      return
    }

    // Force an array if not already something iterable
    if (typeof obj !== "object") {
      /* eslint no-param-reassign:0 */
      obj = [obj];
    }

    if (Array.isArray(obj)) {
      // Iterate over array values
      for (let i = 0, l = obj.length; i < l; i++) {
        // eslint-disable-next-line no-useless-call
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          // eslint-disable-next-line no-useless-call
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }

  function encode(val) {
    return encodeURIComponent(val)
      .replace(/%3A/gi, ":")
      .replace(/%24/g, "$")
      .replace(/%2C/gi, ",")
      .replace(/%20/g, "+")
      .replace(/%5B/gi, "[")
      .replace(/%5D/gi, "]")
  }

  function trim$1(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "")
  }

  function buildURL(url, params, paramsSerializer) {
    if (!params) {
      return url
    }

    let serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      const parts = [];

      forEach(params, function serialize(val, key) {
        if (val === null || typeof val === "undefined") {
          return
        }

        if (Array.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }

        forEach(val, function parseValue(v) {
          if (isDate(v)) {
            v = v.toISOString();
          } else if (isObject$1(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + "=" + encode(v));
        });
      });

      serializedParams = parts.join("&");
    }

    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }

      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }

    return url
  }

  // Headers whose duplicates are ignored by node
  // c.f. https://nodejs.org/api/http.html#http_message_headers
  const ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];

  // Parse headers into an object
  function parseHeaders(headers) {
    const parsed = {};
    let key;
    let val;
    let i;

    if (!headers) {
      return parsed
    }

    forEach(headers.split("\n"), function parser(line) {
      i = line.indexOf(":");
      key = trim$1(line.substr(0, i)).toLowerCase();
      val = trim$1(line.substr(i + 1));

      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });

    return parsed
  }

  // Resolve or reject a Promise based on response status.
  function settle(resolve, reject, response) {
    if (!response.status || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError("Request failed with status code " + response.status, response.options, null, response.request, response));
    }
  }

  function validateStatus(status) {
    return status >= 200 && status < 300
  }

  // Create an Error with the specified message, options, error code, request and response.
  function createError(message, options, code, request, response) {
    const error = new Error(message);
    return enhanceError(error, options, code, request, response)
  }

  // Update an Error with the specified options, error code, and response.
  function enhanceError(error, options, code, request, response) {
    error.options = options;
    if (code) {
      error.code = code;
    }

    error.request = request;
    error.response = response;
    error.isAxiosError = true;

    error.toJSON = function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        options: this.options,
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      }
    };
    return error
  }

  function transformResponse(request, data) {
    if ((isString$1(data) && data.length)) {
      try {
        return JSON.parse(data)
      } catch (e) {
        // if (strictJSONParsing) {
        //   if (e.name === "SyntaxError") {
        //     throw enhanceError(e, request, "E_JSON_PARSE");
        //   }
        //   throw e;
        // }
      }
    }
    return data
  }

  const version = "3.4.2";
  const update = "2023-02-04 16:15:59"; //当前编译时间

  // eslint-disable-next-line no-new-func
  new Function('czmver',`var msg = \`%c%c 中急管(北京)网络科技有限公司 %c

  版 本 号：3.4.2     Cesium版本：\${czmver}
  编译日期：2023-02-04 16:15:59
  版权声明： 此网站版权完全属于 "中急管（北京）网络科技有限公司".
 
  
  🏠官网:  http://www.tdss.com.cn
  📞电话:  17600759545
  \`;
console.log(msg,
  'font-size: 19px;padding-left: 10px;  color: rgb(240, 133, 25);',
  'font-size: 15px;  line-height: 1.5;  font-family: "微软雅黑";color: rgb(240, 133, 25);  padding-bottom: 5px;',
  'font-size: 12px;  line-height: 1.5;  font-family: "微软雅黑";color: rgb(0, 138, 255);'  );`)(Cesium.VERSION);

  let customImage;
  function setImage(custom) {
    customImage = custom;
  }

  function addImage(scene, noTime) {
    const thisImg = customImage;
    if (!thisImg || !scene?.primitives) {
      return
    }

    const re = thisImg.rectangle || [10, 5, 88, 20];
    const viewportQuad = new Cesium__namespace.ViewportQuad();
    viewportQuad.rectangle = new Cesium__namespace.BoundingRectangle(re[0], re[1], re[2], re[3]);
    viewportQuad.material = new Cesium__namespace.Material({
      fabric: {
        type: "Image",
        uniforms: {
          color: new Cesium__namespace.Color(1.0, 1.0, 1.0, 1.0),
          image: thisImg.url
        }
      }
    });
    viewportQuad._muyao = true;
    scene.primitives.add(viewportQuad);

    // 随机10分钟-20分钟内再次校验
    if (!noTime) {
      setInterval(function () {
        try {
          if (!checkHasImage(scene)) {
            addImage(scene, true);
          }
        } catch {
          //
        }
      }, 600000 + Math.random() * 600000);
    }

    return viewportQuad
  }

  // 校验 图是否存在
  function checkHasImage(scene) {
    if (!scene?.primitives || scene.primitives.length === 0) {
      return false
    }

    for (let i = 0, len = scene.primitives.length; i < len; ++i) {
      const p = scene.primitives.get(i);
      if (p._muyao) {
        return true
      }
    }
    return false
  }

  /**
   * 常用静态方法
   * @module Util
   */

  /**
   * 判断对象是否为Number类型
   * @param {*} obj 对象
   * @returns {Boolean} 是否为Number类型
   */
  function isNumber(obj) {
    return typeof obj === "number" && obj.constructor === Number
  }

  /**
   * 判断对象是否为String类型
   * @param {*} obj 对象
   * @returns {Boolean} 是否为String类型
   */
  function isString(obj) {
    return typeof obj === "string" && obj.constructor === String
  }

  /**
   * 判断对象是否为Boolean类型
   * @param {*} obj 对象
   * @returns {Boolean} 是否为Boolean类型
   */
  function isBoolean(obj) {
    return typeof obj === "boolean" && obj.constructor === Boolean
  }

  /**
   * 判断对象是否为Object类型
   * @param {*} obj 对象
   * @returns {Boolean} 是否为Object类型
   */
  function isObject(obj) {
    return Object.prototype.toString.call(obj) === "[object Object]"
  }

  const hasOwn = {}.hasOwnProperty;

  /**
   * 判断对象是否为纯粹的Object类型
   * （所谓"纯粹的对象"，就是该对象是通过"{}"或"new Object"创建的）
   * @param {*} obj 对象
   * @returns {Boolean} 是否为Object类型
   */
  function isPlainObject(obj) {
    if (!isObject(obj)) {
      return false
    }

    // let prototype = Object.getPrototypeOf(val);
    // return prototype == null || prototype === Object.prototype;

    if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
      return false
    } else {
      return true
    }
  }

  /**
   * 判断对象是否为function方法
   * @param {*} val 对象
   * @returns {Boolean} 是否为function方法
   */
  function isFunction(val) {
    return val && typeof val === "function"
  }

  /**
   * 判断对象是否为简单类型（包括：String\Boolean\Number\Array）
   * @param {*} value 对象
   * @returns {Boolean} 是否为简单类型（包括：String\Boolean\Number\Array）
   */
  function isSimpleType(value) {
    if (value == null || value === undefined) {
      return false
    }

    if (isString(value) || isBoolean(value) || isNumber(value) || Array.isArray(value)) {
      return true
    } else {
      return false
    }
  }

  /**
   * 判断当前Cesium库 是否mars3d修改后的版本(mars3d-cesium库)
   * @type {Boolean}
   */
  const isMars3DCesium = Boolean(Cesium__namespace.ExpandByMars || Cesium__namespace.Mars3DEx);

  //= ===========字符串或值相关的处理============

  /**
   * 格式化数字，返回指定小数位的数字
   *
   * @export
   * @param {Number} num 数字
   * @param {Number} [digits=0] 小数位数
   * @return {Number} 返回digits指定小数位的数字
   */
  function formatNum$1(num, digits = 0) {
    const pow = Math.pow(10, digits);
    return Math.round(num * pow) / pow
  }

  /**
   * 按指定长度,对数字进行补零，返回指定长度的字符串
   *
   * @export
   * @param {Number|String} numStr 数字对象,示例：1234
   * @param {Number} n 指定长度，示例：8
   * @return {String} 补零后的指定长度的字符串，示例：'00001234'
   */
  function padLeft0(numStr, n) {
    numStr = String(numStr);
    let len = numStr.length;
    while (len < n) {
      numStr = "0" + numStr;
      len++;
    }
    return numStr
  }

  /**
   * 根据空格分割字符串，并返回字符串数组（会自动去掉首位空格）
   *
   * @export
   * @param {String} str 字符串
   * @return {String[]} 分割后的字符串数组
   */
  function splitWords(str) {
    return trim(str).split(/\s+/)
  }

  /**
   * 除去字符串首尾的空格
   *
   * @export
   * @param {String} str 字符串
   * @return {String} 除去首尾空格的字符串
   */
  function trim(str) {
    if (!str) {
      return
    }
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "")
  }

  /**
   * 获取字符串长度，区分中文和英文
   *
   * @export
   * @param {String} str 字符串
   * @return {Number} 字符串长度
   */
  function getStrLength(str) {
    if (!str) {
      return
    }
    return str.replace(/[\u0391-\uFFE5]/g, "00").length
  }

  // popup的字符串模板
  const templateRe = /\{ *([a-zA-Z0-9_\u4e00-\u9fa5]+) *\}/g;

  /**
   * 根据数据和格式化字符串模板，返回字符串
   *
   * @export
   * @param {String} str 格式化字符串模版，属性字段为大括号，如 {name}
   * @param {Object} data 数据对象
   * @param {Boolean} [toEmpty=false] 是否将模板中未匹配项转为空值
   * @return {String} 返回字符串
   * @example
   *  var str = mars3d.Util.template("<div>名称：{name}</div>", { name:"火星科技", date:"2017-8-25"} );
   *  //str结果为 : "<div>名称：火星科技</div>"
   */
  function template(str, data, toEmpty) {
    if (str == null || !templateRe.test(str)) {
      return str
    }

    return str.replace(templateRe, function (oldval, key, idx, all) {
      let value = data[key];
      if (!Cesium__namespace.defined(value)) {
        return toEmpty ? "" : oldval
      }

      if (isFunction(value)) {
        value = value(data);
        if (!Cesium__namespace.defined(value)) {
          return toEmpty ? "" : oldval
        }
      } else if (value.getValue && isFunction(value.getValue)) {
        value = value.getValue(Cesium__namespace.JulianDate.now());
        if (!Cesium__namespace.defined(value)) {
          return toEmpty ? "" : oldval
        }
      }

      return value
    })
  }

  /**
   * 最后一个唯一ID，在stamp方法使用的
   * @type {Number}
   */
  let lastId = 0;

  /**
   * 获取最新的全局唯一ID
   * @export
   * @return {Number} 全局唯一ID （ ++lastId ）
   */
  function getGlobalId() {
    return ++lastId
  }

  /**
   * 标记对象，给对象赋予对象的全局唯一ID（_mars3d_id值）
   * @export
   * @param {Object} obj 对象
   * @return {Number} 全局唯一ID （ ++lastId ）
   */
  function stampGlobalId(obj) {
    if (obj && isObject(obj)) {
      obj._mars3d_id = obj._mars3d_id || ++lastId;
      return obj._mars3d_id
    }
    return -1
  }

  /**
   * 获取随机唯一uuid字符串,包含数字、大写字母、小写字母
   *
   * @export
   * @param {String} [prefix='M-'] 前缀
   * @return {String} 字符串
   */
  function createGuid(prefix = "M-") {
    return prefix + Cesium__namespace.createGuid()
  }

  let callbackIndex = 0;

  /**
   *获取Popup或Tooltip格式化Html字符串
   *
   * @export
   * @param {Object} [options={}] 参数对象:
   * @param {Object} options.attr 属性值
   * @param {String|Globe.getTemplateHtml_template[]|Function|*} options.template 模版配置，支持：'all'、数组、字符串模板
   * @param {String} [options.title] 标题
   * @param {Boolean} [options.edit=false] 是否返回编辑输入框
   * @param {Number} [options.width=190] edit:true时的，编辑输入框宽度值
   * @return {String}  Html字符串
   * @example
  //template可以是'all' ，返回数据的全部属性信息
  tiles3dLayer.bindPopup(function (event) {
    var attr = event.graphic.attr
    return mars3d.Util.getTemplateHtml({ title: '桥梁', template: 'all', attr: attr })
  })

  //template可以是格式化字符串模板
  var html = mars3d.Util.getTemplateHtml({ title: '火星项目', template:  "名称：{项目名称}<br />类型：{设施类型}<br />面积：{用地面积}亩<br />位置：{具体位置}", attr: item })

  //可以是数组的template，按数组顺序构造，并转义字段名称
  //
  var html = mars3d.Util.getTemplateHtml({
    title: '塔杆',
    template: [
      { field: 'roadName', name: '所属线路' },
      { field: 'towerId', name: '杆塔编号' },
      { field: '杆塔型号', name: '杆塔型号' },
      { field: '杆塔性质', name: '杆塔性质' },
      { field: '杆塔类型', name: '杆塔类型' },
      { field: '设计单位', name: '设计单位' },
      { field: 'height', name: '海拔高度' },
    ],
    attr: item,
  })
   */
  function getTemplateHtml(options) {
    let attr = options.attr;
    if (!attr) {
      return false
    }

    const title = options.title;
    const isEdit = options.edit;
    const cfg = options.template;

    attr = getAttrVal(attr); // 取值

    if (!cfg || cfg === "all") {
      // 全部显示
      let countsok = 0;
      let inhtml = title ? '<div class="mars3d-template-titile">' + title + "</div>" : "";
      inhtml += '<div class="mars3d-template-content" >';
      for (const col in attr) {
        try {
          let showval = attr[col];
          if (col == null || showval == null) {
            continue
          }

          if (col === "Shape" || col === "FID" || col === "OBJECTID" || col === "_definitionChanged" || col === "_propertyNames") {
            continue // 不显示的字段
          }

          if (isFunction(showval)) {
            continue
          }
          if (isObject(showval)) {
            showval = JSON.stringify(getAttrVal(showval, { onlySimpleType: true }));
          }

          showval = String.prototype.trim.call(showval || "");
          if (showval === "" || showval === "Null" || showval === "Unknown") {
            continue // 不显示空值，更美观友好
          }

          inhtml += "<div><label>" + col + "</label>" + showval + "</div>";
          countsok++;
        } catch (e) {
          logError("getTemplateHtml:构造all时异常", e);
        }
      }
      inhtml += "</div>";

      if (countsok === 0) {
        return false
      }
      return inhtml
    } else if (Array.isArray(cfg)) {
      // 数组
      let countsok = 0;
      let inhtml = title ? '<div class="mars3d-template-titile">' + title + "</div>" : '<div style="height: 10px;"></div>';
      inhtml += '<div class="mars3d-template-content" >';
      for (let i = 0; i < cfg.length; i++) {
        const thisfield = cfg[i];
        if (thisfield == null) {
          continue
        }

        const col = thisfield.field;
        const className = thisfield.className || "";

        if (thisfield.type === "details" || thisfield.type === "button") {
          // 详情等button按钮
          let onclickHtml = "";
          const callback = thisfield.callback;
          if (callback) {
            const funName = "_cache_getTemplateHtml_" + callbackIndex++;
            window[funName] = function () {
              // eslint-disable-next-line no-eval
              eval(callback + "(" + JSON.stringify(attr) + ")");
            };
            onclickHtml = `onclick="${funName}();"  `;
          }

          inhtml += `<div style="text-align: center;padding: 2px 0;" >
                      <button type="button"  ${onclickHtml}
                      data-type="${col}" class="mars3d-popup-btn ${className}" >${thisfield.name || "查看详情"}</button>
                  </div>`;
          continue
        } else if (thisfield.type === "html") {
          inhtml += `<div class="${className}">${thisfield.html}</div>`;
          continue
        }

        let showval = attr[col];

        if (!isEdit) {
          // 非编辑状态隐藏空值
          if (col == null || showval == null) {
            continue
          }
          if (isFunction(showval)) {
            continue
          }
        }

        // 值
        showval = String.prototype.trim.call(showval || "");

        if (!isEdit && (thisfield.hideNull ?? true)) {
          // 非编辑状态隐藏空值
          if (showval == null || showval === "" || showval === "Null" || showval === "Unknown" || showval.length === 0) {
            continue
          }
        }

        if (thisfield.format) {
          // 使用外部 格式化js方法
          try {
            if (isFunction(thisfield.format)) {
              showval = thisfield.format(showval);
            } else {
              // eslint-disable-next-line no-eval
              showval = eval(thisfield.format + "(" + showval + ")");
            }
          } catch (e) {
            logWarn("getTemplateHtml:格式化出错", thisfield);
          }
        }

        if (isEdit) {
          switch (thisfield.type) {
            case "textarea":
              showval = `<textarea class="mars3d-popup-edititem ${className}" style="width:${options.width || 190}px;"
                        data-type="${col}"  placeholder="请输入 ${thisfield.name}"  >${showval}</textarea>`;
              break
            case "string":
            case "number":
            default:
              showval = `<input type="${thisfield.type || "text"}" class="mars3d-popup-edititem ${className}" style="width:${options.width || 190}px;"
                          data-type="${col}" value="${showval}" placeholder="请输入 ${thisfield.name}"  />`;
              break
          }
        }

        if (thisfield.unit) {
          showval += thisfield.unit;
        }

        inhtml += "<div><label>" + thisfield.name + "</label>" + showval + "</div>";
        countsok++;
      }
      inhtml += "</div>";

      if (countsok === 0) {
        return false
      }
      return inhtml
    } else if (isObject(cfg)) {
      // 对象,type区分逻辑
      switch (cfg.type) {
        case "iframe": {
          const _url = template(cfg.url, attr, true);

          const inhtml2 =
            '<iframe id="ifarm" src="' +
            _url +
            '"  style="width:' +
            (cfg.width || "300") +
            "px;height:" +
            (cfg.height || "300") +
            'px;overflow:hidden;margin:0;" scrolling="no" frameborder="0" ></iframe>';
          return inhtml2
        }
        case "javascript": {
          // 回调方法
          const callbackFun = cfg.callback;
          // eslint-disable-next-line no-eval
          return eval(callbackFun + "(" + JSON.stringify(attr) + ")")
        }
      }
    } else if (isString(cfg)) {
      // 格式化字符串
      return template(cfg, attr, true)
    } else if (isFunction(cfg)) {
      return cfg(cfg, attr)
    }
    return false
  }

  /**
   * 获取Cesium对象值的最终value值，
   * 因为cesium经常属性或绑定一层，通过本方法可以内部去判断是否有getValue或_value进行取最终value值。
   *
   * @export
   * @param {*} obj Cesium对象值
   * @param {*} [ClasName] Cesium的类名，方便识别判断
   * @param {Cesium.JulianDate} [time= Cesium.JulianDate.now()] 如果具有时间属于时，取指定的时间的值
   * @return {*} 最终value值
   */
  function getCesiumValue(obj, ClasName, time) {
    if (!obj) {
      return obj
    }
    if (ClasName) {
      if (obj instanceof ClasName) {
        return obj
      } else if (obj._value && obj._value instanceof ClasName) {
        return obj._value
      }
    }

    if (isFunction(obj.getValue)) {
      return obj.getValue(time || Cesium__namespace.JulianDate.now())
    }
    return obj
  }

  /**
   * 获取Cesium颜色对象
   * @param {String|Cesium.Color|Function} color Cesium的类名，方便识别判断
   * @param {Cesium.Color} [defval] 默认值
   * @param {Cesium.JulianDate} [time= Cesium.JulianDate.now()] 如果具有时间属于时，取指定的时间的值
   * @return {Cesium.Color} 颜色值
   */
  function getCesiumColor(color, defval, time) {
    if (color) {
      if (isFunction(color.getValue)) {
        color = color.getValue(time || Cesium__namespace.JulianDate.now());
      }

      if (isString(color)) {
        return Cesium__namespace.Color.fromCssColorString(color)
      } else if (isFunction(color)) {
        return getCesiumColor(color(time), defval)
      } else {
        return color
      }
    } else {
      return defval
    }
  }
  /**
   * 根据配置信息获取Cesium颜色对象
   * @param {Object} style 配置信息
   * @param {String|Cesium.Color} style.color 颜色值
   * @param {Number} [style.opacity] 透明度
   * @param {Boolean} [style.randomColor] 是否随机色
   * @param {Cesium.Color} [defval=Cesium.Color.YELLOW] 默认值
   * @return {Cesium.Color} 颜色值
   */
  function getColorByStyle(style, defval = Cesium__namespace.Color.YELLOW) {
    let color;
    if (style.color) {
      if (isString(style.color)) {
        color = Cesium__namespace.Color.fromCssColorString(style.color);
      } else if (isFunction(style.color)) {
        color = style.color(style);
      } else {
        color = style.color;
      }
    } else if (style.randomColor) {
      color = Cesium__namespace.Color.fromRandom({
        minimumRed: style.minimumRed ?? 0.0,
        maximumRed: style.maximumRed ?? 0.75,
        minimumGreen: style.minimumGreen ?? 0.0,
        maximumGreen: style.maximumGreen ?? 0.75,
        minimumBlue: style.minimumBlue ?? 0.0,
        maximumBlue: style.maximumBlue ?? 0.75
      });
    } else {
      color = defval;
    }
    if (!color) {
      return color
    }

    if (Cesium__namespace.defined(style.opacity)) {
      if (style.opacity < 0.0) {
        style.opacity = 0.0;
      } else if (style.opacity > 1.0) {
        style.opacity = 1.0;
      }
      color = color.withAlpha(Number(style.opacity));
    }

    if (Cesium__namespace.defined(style.globalAlpha) && style.globalAlpha !== 1) {
      color = color.withAlpha(color.alpha * style.globalAlpha); // 动态调整图层或数据的透明度时使用
    }

    return color
  }

  /**
   * 取属性值，简化Cesium内的属性，去掉getValue等，取最简的键值对。
   * 方便popup、tooltip等构造方法使用
   *
   * @export
   * @param {*} attr Cesium内的属性对象
   * @param {Object} [options={}] 参数对象:
   * @param {Boolean} options.onlySimpleType 是否只获取简易类型的对象
   * @return {Object} 最简的键值对属性对象
   */
  function getAttrVal(attr, options = {}) {
    if (!attr) {
      return attr
    }

    try {
      if (isFunction(attr.getValue)) {
        attr = attr.getValue(Cesium__namespace.JulianDate.now());
      }

      const newattr = {};
      if (attr._propertyNames && attr._propertyNames.length > 0) {
        for (const key of attr._propertyNames) {
          const showval = getOneAttrValue(key, attr[key], options);
          if (showval == null) {
            continue
          }
          newattr[key] = showval;
        }
      } else {
        for (const key in attr) {
          const showval = getOneAttrValue(key, attr[key], options);
          if (showval == null) {
            continue
          }
          newattr[key] = showval;
        }
      }
      return newattr
    } catch (e) {
      logError("getAttrVal:出错了", e);
    }
    return attr
  }

  /**
   * 取3DTile模型瓦片的feature原有属性
   * @export
   * @param {Cesium.Cesium3DTileFeature|*} feature Cesium内的属性对象
   * @return {Object} 最简的键值对属性对象
   */
  function get3DTileFeatureAttr(feature) {
    const attr = {};
    const names = feature.getPropertyIds ? feature.getPropertyIds() : feature.getPropertyNames();
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      if (!feature.hasProperty(name)) {
        continue
      }

      const val = feature.getProperty(name);
      if (val == null) {
        continue
      }
      attr[name] = val;
    }
    return attr
  }

  // 内部方法
  function getOneAttrValue(key, showval, options) {
    if (showval == null || showval === "" || showval === "Null" || showval === "Unknown") {
      return null
    }
    if (showval.getValue && typeof showval.getValue === "function" && key !== "material") {
      showval = showval.getValue(Cesium__namespace.JulianDate.now());
    }
    if (isFunction(showval)) {
      return null
    }

    if (options.onlySimpleType) {
      if (showval instanceof Cesium__namespace.Color) {
        return showval.toCssColorString()
      }
      if (isPlainObject(showval)) {
        return showval
      }
      if (!isSimpleType(showval)) {
        return null
      }
    }

    return showval
  }

  /**
   * 合并对象，对二级子属性为Object的对象也会进行融合。
   *
   * @export
   * @param {Object} dest 目标对象
   * @param {Object} sources 需要融入合并的对象
   * @return {Object} 融合后的对象
   */
  function merge(dest = {}, ...sources) {
    let i, j, len, src;
    for (j = 0, len = sources.length; j < len; j++) {
      src = sources[j];
      for (i in src) {
        if (hasMergeObject(dest[i], src[i])) {
          dest[i] = {
            ...dest[i],
            ...src[i]
          };
        } else {
          dest[i] = src[i];
        }
      }
    }
    return dest
  }

  // 是否需要合并对象
  function hasMergeObject(dest, src) {
    if (!Cesium__namespace.defined(dest) || !Cesium__namespace.defined(src)) {
      return false
    }
    if (Array.isArray(dest) || Array.isArray(src)) {
      return false
    }

    if (isPlainObject(dest) && isPlainObject(src)) {
      return true
    }

    return false
  }

  /**
   * 复制克隆对象
   *
   * @export
   * @param {Object} obj 原始对象
   * @param {String[]} [removeKeys = [] ] 不复制的属性名 数组
   * @param {Number} [level=5] 拷贝的层级最大深度,避免死循环
   * @return {Object} 克隆后的对象
   */
  function clone(obj, removeKeys = [], level = 5) {
    if (obj == null || typeof obj !== "object") {
      return obj
    }

    // Handle Date
    if (obj instanceof Date) {
      const copy = new Date();
      copy.setTime(obj.getTime());
      return copy
    }

    // Handle Array
    if (Array.isArray(obj) && level >= 0) {
      const copy = [];
      for (let i = 0, len = obj.length; i < len; ++i) {
        copy[i] = clone(obj[i], removeKeys, level - 1);
      }
      return copy
    }

    // Handle Object
    if (typeof obj === "object" && level >= 0) {
      try {
        const copy = {};
        for (const attr in obj) {
          if (isFunction(attr)) {
            continue
          }
          if (removeKeys.indexOf(attr) !== -1) {
            continue
          }

          if (obj.hasOwnProperty(attr)) {
            copy[attr] = clone(obj[attr], removeKeys, level - 1);
          }
        }
        return copy
      } catch (e) {
        logError("clone:出错了", e);
      }
    }
    return obj
  }

  /**
   * 随机获取数组中的一个元素
   *
   * @export
   * @param {Array} arr 数组
   * @return {*} 获取到的随机元素
   */
  function getArrayRandomOne(arr) {
    const n = Math.floor(Math.random() * arr.length + 1) - 1;
    return arr[n]
  }

  /**
   * 移除数组中的指定对象
   *
   * @export
   * @param {Array} arr 数组
   * @param {*} val 需要移除的数组元素对象
   * @return {Boolean} 对象是否移除成功
   */
  function removeArrayItem(arr, val) {
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] === val) {
        arr.splice(i, 1);
        return true
      }
    }
    return false
  }

  /**
   * 根据属性 和symbol配置 取style样式信息
   *
   * @param {Object} symbol symbol配置
   * @param {Object} symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
   * @param {String} [symbol.styleField] 按 styleField 属性设置不同样式。
   * @param {Object} [symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
   * @param {Function} [symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
   * @param {Object} [attr] 数据属性对象
   * @return {Object} style样式
   *
   */
  function getSymbolStyle(symbol, attr) {
    if (!symbol) {
      return {}
    }
    let styleOpt = symbol.styleOptions ? { ...symbol.styleOptions } : {};

    if (symbol.styleField && attr) {
      // 存在多个symbol，按styleField进行分类
      const styleFieldVal = attr[symbol.styleField];
      const styleOptField = symbol.styleFieldOptions[styleFieldVal];
      if (styleOptField != null) {
        styleOpt = merge(styleOpt, styleOptField);
      }
    }

    if (attr) {
      for (const key in styleOpt) {
        styleOpt[key] = template(styleOpt[key], attr);
      }
    }

    if (styleOpt.label) {
      styleOpt.label = {
        ...styleOpt.label
      };
    }
    if (styleOpt.highlight) {
      styleOpt.highlight = {
        ...styleOpt.highlight
      };
    }

    if (isFunction(symbol.callback)) {
      // 只是动态返回symbol的自定义的回调方法，返回style
      const styleOptField = symbol.callback(attr, styleOpt);
      if (styleOptField != null) {
        styleOpt = merge(styleOpt, styleOptField);
      }
    }
    return styleOpt
  }

  /**
   * geojson格式 转 arcgis服务的json格式
   *
   * @param {Object} geojson geojson格式
   * @param {String} [idAttr='OBJECTID'] id字段名称
   * @return {Object} arcgis服务的json格式
   */
  function geojsonToArcGIS(geojson, idAttr) {
    return geojsonToArcGIS$1(geojson, idAttr)
  }

  /**
   * arcgis服务的json格式 转 geojson格式
   *
   * @param {Object} arcgis arcgis服务的json格式
   * @param {String} [idAttr='OBJECTID'] id字段名称
   * @return {Object} geojson格式
   */
  function arcgisToGeoJSON(arcgis, idAttr) {
    return arcgisToGeoJSON$1(arcgis, idAttr)
  }

  /**
   * 获取GeoJSON中的features数组集合（自动判断数据来源）
   *
   * @export
   * @param {Object} geojson geojson对象
   * @return {Object[]} features数组集合
   */
  function getGeoJsonFeatures(geojson) {
    if (geojson.geometryType && geojson.geometryType.indexOf("esri") !== -1) {
      geojson = arcgisToGeoJSON(geojson);
    } else if (geojson.type === "Topology") {
      let features = [];
      for (const property in geojson.objects) {
        if (geojson.objects.hasOwnProperty(property)) {
          geojson = Cesium__namespace.topojson.feature(geojson, geojson.objects[property]);
          const temp = getGeoJsonFeatures(geojson);
          features = features.concat(temp);
        }
      }
      return features
    }

    let features;
    if (Array.isArray(geojson.features)) {
      features = geojson.features;
    } else if (Array.isArray(geojson)) {
      features = geojson;
    } else {
      features = [geojson];
    }
    return features
  }

  /**
   * GeoJSON 转为 Graphic构造参数数组（用于创建{@link BaseGraphic}）
   * style有3种方式控制: 1.传type及style参数；2.传symbol参数；3.数据本身的feature.properties.style；
   * 优先级为：1>2>3
   *
   * @export
   * @param {Object} geojson geojson对象
   * @param {Object} [options={}] 控制参数
   * @param {GraphicType|String} [options.type] 转为指定的类型
   * @param {Object} [options.style={}]  Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
   * @param {Object} [options.symbol] symbol配置，与style二选一
   * @param {GraphicType|String} [options.symbol.type] 标识数据类型
   * @param {Boolean} [options.symbol.merge] 是否合并并覆盖json中已有的style，默认不合并，仅适用symbol配置。
   * @param {Object} options.symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
   * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
   * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
   * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
   * @param {String} [options.crs]  原始数据的坐标系，如'EPSG:3857' （可以从 {@link http://epsg.io }查询）
   * @return {Object[]} Graphic构造参数数组（用于创建{@link BaseGraphic}）
   */
  function geoJsonToGraphics(geojson, options = {}) {
    const features = getGeoJsonFeatures(geojson);

    if (geojson?.crs?.properties?.name && !options.crs) {
      const crs = geojson.crs.properties.name;
      if (crs.indexOf("EPSG:") !== -1) {
        options.crs = crs;
      }
    }

    let arrGraphis = [];
    for (let i = 0, len = features.length; i < len; i++) {
      const feature = features[i];
      const arr = featureToGraphic(feature, options);
      if (arr && arr.length > 0) {
        arrGraphis = arrGraphis.concat(arr);
      }
    }
    return arrGraphis
  }

  /**
   * GeoJSON格式的Feature单个对象转为 Graphic构造参数（用于创建{@link BaseGraphic}）
   *
   * @export
   * @param {Object} feature geojson单个Feature对象
   * @param {Object} [options={}] 参数，包括：
   * @param {GraphicType|String} [options.type] 转为指定的类型
   * @param {Object} [options.style={}]  Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
   * @param {String} [options.crs]  原始数据的坐标系，如'EPSG:3857' （可以从 {@link http://epsg.io }查询）
   * @param {Function} [options.onPointTrans] 坐标转换方法，可用于对每个坐标做额外转换处理
   * @return {Object} Graphic构造参数（用于创建{@link BaseGraphic}）
   */
  function featureToGraphic(feature, options = {}) {
    let graphics = [];
    if (feature.type === "GeometryCollection") {
      feature = { geometry: feature };
    }

    const geometry = feature.geometry;
    const coords = geometry?.coordinates;

    if (!coords && !geometry) {
      return graphics
    }

    //= ===== 类型 ======
    let graphicType;
    if (options.type) {
      graphicType = options.type;
    } else if (hasType(feature?.properties?.type)) {
      graphicType = feature.properties.type;
    }

    //= ===== 处理属性 ======
    let attr = clone(feature?.properties, ["style"]) || {};
    if (attr && attr.type && attr.attr) {
      attr = attr.attr; // 兼容历史数据,V2内部标绘生产的geojson
    }

    //= ===== 处理样式 ======
    let style = {};
    if (feature.properties) {
      // 按geojson标准存储的一些样式转换处理

      // 内置的 填充颜色等
      const marker = attr["marker-symbol"];
      if (Cesium__namespace.defined(marker)) {
        style.image = marker;

        const outlineColor = attr["marker-color"];
        if (Cesium__namespace.defined(outlineColor)) {
          style.outline = true;
          style.outlineColor = outlineColor;
        }
      }

      // 内置的 填充颜色等
      const fill = attr.fill;
      if (Cesium__namespace.defined(fill) && geometry.type !== "LineString" && geometry.type !== "MultiLineString") {
        style.color = fill;

        const opacity = attr["fill-opacity"];
        if (Cesium__namespace.defined(opacity) && opacity !== 1.0) {
          style.opacity = opacity;
        }
        // 内置的 线颜色等
        const stroke = attr.stroke;
        if (Cesium__namespace.defined(stroke)) {
          style.outline = true;
          style.outlineColor = stroke;

          const width = attr["stroke-width"];
          if (Cesium__namespace.defined(width)) {
            style.outlineWidth = width;
          }
          const opacity = attr["stroke-opacity"];
          if (Cesium__namespace.defined(opacity) && opacity !== 1.0) {
            style.outlineOpacity = opacity;
          }
        }
      } else {
        // 内置的 线颜色等
        const stroke = attr.stroke;
        if (Cesium__namespace.defined(stroke)) {
          style.color = stroke;

          const width = attr["stroke-width"];
          if (Cesium__namespace.defined(width)) {
            style.width = width;
          }
          const opacity = attr["stroke-opacity"];
          if (Cesium__namespace.defined(opacity) && opacity !== 1.0) {
            style.opacity = opacity;
          }
        }
      }
    }

    if (options.style) {
      style = { ...options.style };
    } else if (isObject(feature?.properties?.style)) {
      style = { ...feature.properties.style };
    }

    // 图层有symbol配置时
    if (options.symbol) {
      if (isFunction(options.symbol)) {
        style = options.symbol(attr, style, feature) || style;
        if (style.type) {
          graphicType = style.type;
        }
      } else {
        graphicType = options.symbol.type || graphicType;
        const symbolStyle = getSymbolStyle(options.symbol, feature.properties || {});
        if (options.symbol.merge) {
          style = { ...symbolStyle, ...style }; // style优先与symbol
        } else {
          style = symbolStyle;
        }
      }
    }

    let crs = options.crs;
    if (crs === "EPSG:4326") {
      crs = null;
    }

    // 坐标转换处理
    function onPointTrans(coord) {
      if (crs) {
        coord = proj4Trans(coord, crs);
      }

      if (options.onPointTrans) {
        return options.onPointTrans(coord)
      } else {
        return coord
      }
    }
    function onArrPointTrans(coords) {
      if (!options.onPointTrans && !crs) {
        return coords
      }

      const arr = [];
      for (let i = 0, len = coords.length; i < len; i++) {
        const item = coords[i];
        if (Array.isArray(item[0])) {
          const arr2 = onArrPointTrans(item);
          if (arr2 && arr2.length > 0) {
            arr.push(arr2);
          }
        } else {
          const arr2 = onPointTrans(item);
          if (arr2) {
            arr.push(arr2);
          }
        }
      }
      return arr
    }

    // 其他graphic构造参数的处理
    function onInitGraphicOptions(graphic, attr) {
      eachGraphicType(function (type) {
        if (isObject(attr[type])) {
          graphic[type] = attr[type];
          delete attr[type];
        }
      });
    }

    //= ===== 按类型处理坐标和graphic ======
    let i, len;
    switch (geometry.type) {
      case "Point": {
        if (!graphicType || !isPointType(graphicType)) {
          graphicType = style.image ? "billboardP" : "pointP";
        }
        const graphic = {
          type: graphicType,
          position: onPointTrans(coords),
          style: style,
          attr: attr
        };
        onInitGraphicOptions(graphic, attr);
        graphics.push(graphic);
        break
      }
      case "MultiPoint": {
        if (!graphicType || !isPointType(graphicType)) {
          graphicType = style.image ? "billboardP" : "pointP";
        }

        for (i = 0, len = coords.length; i < len; i++) {
          const graphic = {
            type: graphicType,
            position: onPointTrans(coords[i]),
            style: style,
            attr: attr
          };
          onInitGraphicOptions(graphic, attr);
          graphics.push(graphic);
        }
        break
      }
      case "LineString": {
        if (!graphicType) {
          graphicType = "polylineP";
        }

        const graphic = {
          type: graphicType,
          positions: onArrPointTrans(coords),
          style: style,
          attr: attr
        };
        onInitGraphicOptions(graphic, attr);
        graphics.push(graphic);
        break
      }
      case "MultiLineString": {
        if (!graphicType) {
          graphicType = "polylineP";
        }

        let maxPoly;
        const thisGraphics = [];
        for (i = 0, len = coords.length; i < len; i++) {
          const graphic = {
            type: graphicType,
            positions: onArrPointTrans(coords[i]),
            style: style,
            attr: attr
          };
          onInitGraphicOptions(graphic, attr);
          graphics.push(graphic);
          thisGraphics.push(graphic);

          if (!maxPoly || maxPoly.positions.length < graphic.positions.length) {
            maxPoly = graphic;
          }
        }
        if (maxPoly) {
          maxPoly.isMultiMax = true;
          if (style.label && !style.label.showAll) {
            for (i = 0, len = thisGraphics.length; i < len; i++) {
              const graphic = thisGraphics[i];
              if (maxPoly === graphic) {
                continue
              }
              graphic.style = { ...graphic.style }; // clone
              delete graphic.style.label;
            }
          }
        }

        break
      }
      case "Polygon": {
        if (!graphicType) {
          graphicType = "polygonP";
        }

        if (graphicType.startsWith("polygon")) {
          const graphic = {
            type: graphicType,
            positions: onArrPointTrans(coords.length === 1 ? coords[0] : coords),
            style: style,
            attr: attr
          };
          onInitGraphicOptions(graphic, attr);
          graphics.push(graphic);
        } else {
          for (i = 0, len = coords.length; i < len; i++) {
            const thisCoor = coords[i];
            const graphic = {
              type: graphicType,
              positions: onArrPointTrans(thisCoor.length === 1 ? thisCoor[0] : thisCoor),
              style: style,
              attr: attr
            };
            onInitGraphicOptions(graphic, attr);
            graphics.push(graphic);
          }
        }
        break
      }
      case "MultiPolygon": {
        if (!graphicType) {
          graphicType = "polygonP";
        }
        let maxPoly;
        const thisGraphics = [];
        for (i = 0, len = coords.length; i < len; i++) {
          const thisCoor = coords[i];
          const graphic = {
            type: graphicType,
            positions: onArrPointTrans(thisCoor.length === 1 ? thisCoor[0] : thisCoor),
            style: style,
            attr: attr
          };
          onInitGraphicOptions(graphic, attr);
          graphics.push(graphic);
          thisGraphics.push(graphic);

          if (!maxPoly || maxPoly.positions.length < graphic.positions.length) {
            maxPoly = graphic;
          }
        }
        if (maxPoly) {
          maxPoly.isMultiMax = true;
          if (style.label && !style.label.showAll) {
            for (i = 0, len = thisGraphics.length; i < len; i++) {
              const graphic = thisGraphics[i];
              if (maxPoly === graphic) {
                continue
              }
              graphic.style = { ...graphic.style }; // clone
              delete graphic.style.label;
            }
          }
        }

        break
      }
      case "GeometryCollection": {
        for (let i = 0, len = geometry.geometries.length; i < len; i++) {
          const layers = featureToGraphic(
            {
              type: "Feature",
              geometry: geometry.geometries[i],
              properties: feature.properties
            },
            options
          );
          if (layers && layers.length > 0) {
            graphics = graphics.concat(layers);
          }
        }
        break
      }

      default:
        logError("Invalid GeoJSON object.", feature);
    }
    return graphics
  }

  //= ======================

  /**
   * 根据当前高度获取地图层级
   *
   * @export
   * @param {Number} altitude 高度值
   * @return {Number} 地图层级,通常为 0-21
   */
  function heightToZoom(altitude) {
    const A = 40487.57;
    const B = 0.00007096758;
    const C = 91610.74;
    const D = -40467.74;

    return Math.round(D + (A - D) / (1 + Math.pow(altitude / C, B)))
  }

  /**
   * 根据图层的config的配置信息，自动加上代理等配置返回Resource对象
   *
   * @export
   * @param {Object} config 图层的配置信息
   * @param {String} config.url  url地址
   * @param {String} [config.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [config.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [config.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'}
   * @param {Object} [config.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' }
   * @return {Cesium.Resource} Resource对象
   */
  function getUrlResource(config) {
    if (!config.url) {
      return config
    }

    let resource;
    if (config.url instanceof Cesium__namespace.Resource) {
      const resource = config.url;
      if (config.headers) {
        resource.headers = config.headers;
      }
      if (config.proxy) {
        resource.proxy = new Cesium__namespace.DefaultProxy(config.proxy);
      }
      if (config.templateValues) {
        resource.setTemplateValues(config.templateValues);
      }
      if (config.queryParameters) {
        resource.setQueryParameters(config.queryParameters);
      }
      return resource
    } else {
      if (config.templateValues) {
        config.url = template(config.url, config.templateValues);
      }
      resource = new Cesium__namespace.Resource({
        url: config.url,
        queryParameters: config.queryParameters,
        templateValues: config.templateValues,
        headers: config.headers,
        proxy: config.proxy ? new Cesium__namespace.DefaultProxy(config.proxy) : null
      });
    }
    return resource
  }

  /**
   * 文字转base64图片
   *
   * @export
   * @param {String} text 文字内容
   * @param {Object} [textStyle={}] 参数对象:
   * @param {String} [textStyle.font='10px sans-serif'] 使用的CSS字体。
   * @param {String} [textStyle.textBaseline='bottom'] 文本的基线。
   * @param {Boolean} [textStyle.fill=true] 是否填充文本。
   * @param {Cesium.Color} [textStyle.fillColor=Cesium.Color.WHITE] 填充颜色。
   * @param {Boolean} [textStyle.stroke=false] 是否描边文本。
   * @param {Number} [textStyle.strokeWidth=1] 文本描边的宽度。
   * @param {Cesium.Color} [textStyle.strokeColor=Cesium.Color.BLACK] 文本描边的颜色。
   * @param {Boolean} [textStyle.background=false] 是否背景色。
   * @param {Cesium.Color} [textStyle.backgroundColor=Cesium.Color.TRANSPARENT] 画布的背景色。
   * @param {Number} [textStyle.padding=0] 要在文本周围添加的填充的像素大小。
   * @param {Boolean} [textStyle.outline=false] 是否边框
   * @param {Number} [textStyle.outlineWidth=4] 边框的宽度。
   * @param {Cesium.Color} [textStyle.outlineColor=fillColor] 矩形边框的颜色。
   *
   * @returns {HTMLCanvasElement} canvas对象
   */
  function getTextImage(text, textStyle = {}) {
    if (!textStyle.background) {
      textStyle.backgroundColor = Cesium__namespace.Color.TRANSPARENT;
    }
    const canvas = Cesium__namespace.writeTextToCanvas(text, textStyle);
    if (canvas) {
      if (textStyle.outline) {
        const cWidth = canvas.width;
        const cHeight = canvas.height;
        const context = canvas.getContext("2d");

        // 绘制边框
        if (textStyle.outlineColor) {
          context.strokeStyle = textStyle.outlineColor.toCssColorString();
        } else if (textStyle.fillColor) {
          context.strokeStyle = textStyle.fillColor.toCssColorString();
        } else {
          context.strokeStyle = "#ffffff";
        }
        const lineWidth = textStyle.outlineWidth || 4;
        context.lineWidth = lineWidth;
        context.strokeRect(lineWidth / 2, lineWidth / 2, cWidth - lineWidth, cHeight - lineWidth);
      }
      return canvas
    } else {
      return null
    }
  }

  const circleImage = {};

  /**
   * 获取用于EntityCluster聚合的圆形图标对象
   *
   * @export
   * @param {Number} count 数字
   * @param {Object} [options={}] 参数对象:
   *
   * @param {Number} [options.radius=26] 圆形图标的整体半径大小（单位：像素）
   * @param {String} [options.color='rgba(181, 226, 140, 0.6)'] 圆形图标的背景颜色
   * @param {Number} [options.opacity=0.5] 圆形图标的透明度
   *
   * @param {Number} [options.borderWidth=5] 圆形图标的边框宽度（单位：像素），0不显示
   * @param {String} [options.borderColor='rgba(110, 204, 57, 0.5)'] 圆形图标的边框背景颜色
   * @param {Number} [options.borderOpacity=0.6] 圆形图标边框的透明度
   *
   * @param {String} [options.fontColor='#ffffff'] 数字的颜色
   *
   * @returns {String} base64图片对象，包含 data URI 的DOMString。
   */
  function getCircleImage(count, options = {}) {
    const inCircleRadius = options.radius ?? 26;
    const outCircleRadius = inCircleRadius + (options.borderWidth ?? 5);

    let colorIn;
    let colorOut;
    if (options.color) {
      colorIn = options.color;
      colorOut = options.borderColor || colorIn;
    } else {
      const opacity = options.opacity ?? 0.6;
      const borderOpacity = options.borderOpacity ?? opacity * 0.8;
      if (count < 10) {
        colorIn = "rgba(110, 204, 57, " + opacity + ")";
        colorOut = "rgba(181, 226, 140, " + borderOpacity + ")";
      } else if (count < 100) {
        colorIn = "rgba(240, 194, 12,  " + opacity + ")";
        colorOut = "rgba(241, 211, 87, " + borderOpacity + ")";
      } else {
        colorIn = "rgba(241, 128, 23,  " + opacity + ")";
        colorOut = "rgba(253, 156, 115, " + borderOpacity + ")";
      }
    }

    const _key = `${count}_${outCircleRadius}_${inCircleRadius}_${colorIn}`;
    if (!circleImage[_key]) {
      const thisSize = outCircleRadius * 2;

      const circleCanvas = document.createElement("canvas");
      circleCanvas.width = thisSize;
      circleCanvas.height = thisSize;
      const circleCtx = circleCanvas.getContext("2d");

      circleCtx.fillStyle = "#ffffff00";
      circleCtx.globalAlpha = 0.0;
      circleCtx.fillRect(0, 0, thisSize, thisSize);

      // 圆形底色 (外圈)
      if (inCircleRadius !== outCircleRadius) {
        circleCtx.globalAlpha = 1.0;
        circleCtx.beginPath();
        circleCtx.arc(outCircleRadius, outCircleRadius, outCircleRadius, 0, Math.PI * 2, true);
        circleCtx.closePath();
        circleCtx.fillStyle = colorOut;
        circleCtx.fill();
      }

      // 圆形底色(内圈)
      circleCtx.globalAlpha = 1.0;
      circleCtx.beginPath();
      circleCtx.arc(outCircleRadius, outCircleRadius, inCircleRadius, 0, Math.PI * 2, true);
      circleCtx.closePath();
      circleCtx.fillStyle = colorIn;
      circleCtx.fill();

      // 数字文字
      circleCtx.font = options.font || inCircleRadius * 0.9 + "px bold normal"; // 设置字体
      circleCtx.fillStyle = options.fontColor || "#ffffff"; // 设置颜色
      circleCtx.textAlign = "center"; // 设置水平对齐方式
      circleCtx.textBaseline = "middle"; // 设置垂直对齐方式
      circleCtx.fillText(count, outCircleRadius, outCircleRadius); // 绘制文字（参数：要写的字，x坐标，y坐标）

      circleImage[_key] = circleCanvas.toDataURL("image/png");
    }
    return circleImage[_key]
  }

  function download(fileName, blob) {
    const aLink = document.createElement("a");
    aLink.download = fileName;
    aLink.href = URL.createObjectURL(blob);
    document.body.appendChild(aLink);
    aLink.click();
    document.body.removeChild(aLink);
  }

  function base64Img2Blob(code) {
    const parts = code.split(";base64,");
    const contentType = parts[0].split(":")[1];
    const raw = window.atob(parts[1]);
    const rawLength = raw.length;

    const uInt8Array = new Uint8Array(rawLength);
    for (let i = 0; i < rawLength; ++i) {
      uInt8Array[i] = raw.charCodeAt(i);
    }
    return new Blob([uInt8Array], { type: contentType })
  }

  /**
   *导出下载图片文件
   *
   * @export
   * @param {String} name 图片文件名称，不需要后缀名
   * @param {String} base64 图片内容，base64格式
   * @return {void}  无
   */
  function downloadBase64Image(name, base64) {
    const blob = base64Img2Blob(base64);
    download(name + ".png", blob);
  }

  /**
   *导出下载文本文件
   *
   * @export
   * @param {String} fileName 文件完整名称，需要含后缀名
   * @param {String} string 文本内容
   * @return {void}  无
   */
  function downloadFile(fileName, string) {
    const blob = new Blob([string]);
    download(fileName, blob);
  }

  /**
   * 获取浏览器类型及版本
   *
   * @export
   * @return {Object} 浏览器类型及版本,示例：{ type: 'Chrome', version: 71 }
   */
  function getExplorerInfo() {
    let ver;
    const explorer = window.navigator.userAgent.toLowerCase();

    if (explorer.indexOf("msie") >= 0) {
      ver = Number(explorer.match(/msie ([\d]+)/)[1]);
      return { type: "IE", version: ver }
    } else if (explorer.indexOf("firefox") >= 0) {
      ver = Number(explorer.match(/firefox\/([\d]+)/)[1]);
      return { type: "Firefox", version: ver }
    } else if (explorer.indexOf("chrome") >= 0) {
      ver = Number(explorer.match(/chrome\/([\d]+)/)[1]);
      return { type: "Chrome", version: ver }
    } else if (explorer.indexOf("opera") >= 0) {
      ver = Number(explorer.match(/opera.([\d]+)/)[1]);
      return { type: "Opera", version: ver }
    } else if (explorer.indexOf("Safari") >= 0) {
      ver = Number(explorer.match(/version\/([\d]+)/)[1]);
      return { type: "Safari", version: ver }
    }
    return { type: explorer, version: -1 }
  }

  /**
   *检测当前浏览器是否支持WebGL
   *
   * @export
   * @return {Boolean} 是否支持WebGL
   */
  function webglreport() {
    const exinfo = getExplorerInfo();
    if (exinfo.type === "IE" && exinfo.version < 11) {
      return false
    }

    try {
      let glContext;
      const canvas = document.createElement("canvas");
      const requestWebgl2 = typeof WebGL2RenderingContext !== "undefined";
      if (requestWebgl2) {
        glContext = canvas.getContext("webgl2") || canvas.getContext("experimental-webgl2") || undefined;
      }
      if (glContext == null) {
        glContext = canvas.getContext("webgl") || canvas.getContext("experimental-webgl") || undefined;
      }
      if (glContext == null) {
        return false
      }
    } catch (e) {
      return false
    }
    return true
  }

  /**
   * 执行检测浏览器不支持webgl后的alert错误提示弹窗
   *
   * @export
   * @return {void}  无
   */
  function webglerror() {
    if (window?.layer?.open) {
      window.layer.open({
        type: 1,
        title: "当前浏览器不支持WebGL功能",
        closeBtn: 0,
        shadeClose: false,
        resize: false,
        area: ["530px", "170px"], // 宽高
        content:
          '<div style="margin: 20px;color: #333;"><h3>系统检测到您使用的浏览器不支持WebGL功能！</h3>  <p>1、请您检查浏览器版本，安装使用最新版chrome、火狐或IE11以上浏览器！</p> <p>2、WebGL支持取决于GPU支持，请保证客户端电脑已安装显卡驱动程序！</p></div>'
      });
    } else {
      alert("系统检测到您使用的浏览器不支持WebGL功能");
    }
  }

  /**
   *获取当前页面的url中的?传入参数对象集合
   *
   * @export
   * @return {Object} 参数名与参数值的键值对
   */
  function getRequest() {
    const url = location.search; // 获取url中"?"符后的字串
    const theRequest = {};
    if (url.indexOf("?") !== -1) {
      const str = url.substr(1);
      const strs = str.split("&");
      for (let i = 0; i < strs.length; i++) {
        theRequest[strs[i].split("=")[0]] = decodeURI(strs[i].split("=")[1]);
      }
    }
    return theRequest
  }

  /**
   * 获取当前页面的url中的?传入的指定参数值
   *
   * @export
   * @param {String} name 指定参数名称
   * @return {String} 获取到的参数值
   */
  function getRequestByName(name) {
    const reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
    const r = window.location.search.substr(1).match(reg);
    if (r != null) {
      return decodeURI(r[2])
    }
    return null
  }

  let _isPCBroswer;

  /**
   *当前是否是PC电脑浏览器。
   *
   * @export
   * @return {Boolean} 是否是PC电脑浏览器。
   */
  function isPCBroswer() {
    if (!Cesium__namespace.defined(_isPCBroswer)) {
      const userAgentInfo = navigator.userAgent.toLowerCase();
      const Agents = ["android", "phone", "iphone", "ipad", "ipod", "symbianos"];
      _isPCBroswer = true;
      for (let v = 0; v < Agents.length; v++) {
        if (userAgentInfo.indexOf(Agents[v]) > 0) {
          _isPCBroswer = false;
          break
        }
      }
    }
    return _isPCBroswer
  }

  /**
   * 执行alert弹窗（手动单击确定关闭窗口）
   *
   * @export
   * @param {String} msg 弹窗内的内容
   * @param {String} [title] 弹窗的标题
   * @return {void}  无
   */
  function alert(msg, title) {
    if (window.globalAlert) {
      window.globalAlert(msg, title); // 注意参数顺序
    } else if (window.layer) {
      // 此方法需要引用layer.js
      window.layer.alert(msg, {
        title: title || "提示",
        skin: "layui-layer-lan layer-mars-dialog",
        closeBtn: 0,
        anim: 0
      });
    } else if (window.toastr) {
      window.toastr.info(msg, title); // 此方法需要引用toastr
    } else {
      window.alert(msg);
    }
  }

  /**
   * 执行msg提示窗（自动消失）
   *
   * @export
   * @param {String} msg 弹窗内的内容
   * @return {void}  无
   */
  function msg(msg) {
    if (window.globalMsg) {
      window.globalMsg(msg);
    } else if (window.toastr) {
      window.toastr.info(msg); // 此方法需要引用toastr
    } else if (window.layer) {
      window.layer.msg(msg); // 此方法需要引用layer.js
    } else {
      window.alert(msg);
    }
  }

  /**
   * 将 时间 转化为指定格式的字符串
   *
   * @export
   * @param {Date} date 时间
   * @param {String} fmt 格式模版，月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q) 可以用 1-2 个占位符; 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字).
   * @return {String} 指定格式的字符串
   * @example
   * mars3d.Util.formatDate(date,"yyyy-MM-dd HH:mm:ss") ==> 2017-08-25 08:08:00
   * mars3d.Util.formatDate(date,"yyyy-MM-dd HH:mm:ss.S") ==> 2017-08-25 08:08:00.423
   * mars3d.Util.formatDate(date,"yyyy-M-d HH:mm:ss") ==> 2017-8-5 08:08:00
   */
  function formatDate(date, fmt) {
    const o = {
      "M+": date.getMonth() + 1, // 月份
      "d+": date.getDate(), // 日
      "h+": date.getHours() % 12 === 0 ? 12 : date.getHours() % 12, // 小时
      "H+": date.getHours(), // 小时
      "m+": date.getMinutes(), // 分
      "s+": date.getSeconds(), // 秒
      "q+": Math.floor((date.getMonth() + 3) / 3), // 季度
      S: date.getMilliseconds() // 毫秒
    };
    if (/(y+)/.test(fmt)) {
      fmt = fmt.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length));
    }

    for (const k in o) {
      if (new RegExp("(" + k + ")").test(fmt)) {
        fmt = fmt.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
      }
    }
    return fmt
  }

  /**
   * 格式化时长
   * @export
   * @param {Number} strtime 时长
   * @return {String} 格式化字符串，如XX小时XX分钟
   */
  function formatTime(strtime) {
    strtime = Number(strtime) || 0;

    if (strtime < 60) {
      return strtime.toFixed(0) + "秒"
    } else if (strtime >= 60 && strtime < 3600) {
      const miao = Math.floor(strtime % 60);
      return Math.floor(strtime / 60) + "分钟" + (miao !== 0 ? miao + "秒" : "")
    } else {
      strtime = Math.floor(strtime / 60); // 秒转分钟
      return Math.floor(strtime / 60) + "小时" + Math.floor(strtime % 60) + "分钟"
    }
  }

  /**
   * 请求服务返回JSON结果
   *
   * @param {Object} options 请求参数
   * @param {String} options.url 服务URL地址
   * @param {Object} [options.queryParameters] 与请求一起发送的 URL 参数,例如 {id: 1987 }
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' }
   * @param {String} [options.method="get"] 请求类型
   * @return {Promise<Object>} 返回Promise异步处理结果，对象为JSON数据
   */
  function fetchJson(options) {
    options = replaceOnlineUrlDomain(options);
    if (options.method === "post") {
      options.data = options.queryParameters;
      delete options.queryParameters;
      return Cesium__namespace.Resource.post(options)
    } else {
      return Cesium__namespace.Resource.fetchJson(options)
    }
  }

  /**
   * 请求服务返回结果，方法是基于axios库精简的
   *
   * @param {Object} options 请求参数
   * @param {String} options.url 服务URL地址
   * @param {Object} [options.queryParameters] 与请求一起发送的 URL 参数,例如 {id: 1987 }
   * @param {String} [options.method="get"] 请求类型
   * @param {Number} [options.timeout=0] 是否超时
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' }
   * @return {Promise<Object>} 返回Promise异步处理结果，对象为response对象
   */
  function sendAjax(options) {
    options = replaceOnlineUrlDomain(options);

    if (options.method === "post") {
      options.data = options.queryParameters;
      delete options.queryParameters;
    }

    return xhrAdapter(options)
      .then((res) => {
        const result = res?.data;
        return result
      })
      .catch((err) => {
        console.log(err);
        logError("axios请求出错", err);
      })
  }

  /**
   * 根据设置的lang参数，获取当前key对应语言的文本内容。
   * @param {String} key  文本key
   * @param {LangType} langType  使用的语言
   * @return {void}  lang参数指定的对应文本内容
   */
  function getLangText(key, langType = 0) {
    const thisItem = Lang[key];
    if (!thisItem) {
      return key
    }

    const langText = thisItem[langType] || key;
    return langText
  }

  /**
   * 进入全屏
   * @export
   * @param {HTMLElement} container 指定DOM元素，如 map.container
   * @returns {boolean} 是否全屏
   */
  function requestFullscreen(container) {
    Cesium__namespace.Fullscreen.requestFullscreen(container);
    return Cesium__namespace.Fullscreen.enabled
  }

  /**
   * 退出全屏
   * @export
   * @returns {boolean} 是否全屏
   */
  function exitFullscreen() {
    Cesium__namespace.Fullscreen.exitFullscreen();
    return Cesium__namespace.Fullscreen.enabled
  }

  // 官网在线url的处理
  function replaceOnlineUrlDomain(options) {
    if (!options.url || !isString(options.url)) {
      return options
    }

    if (window?.location?.hostname?.indexOf && window.location.hostname.indexOf("mars3d.cn") === -1) {
      return options
    }
    if (options.url.indexOf("data.mars3d.cn") === -1 || options.url.indexOf("/tile/") !== -1) {
      return options
    }

    options.url = options.url.replace("data.mars3d.cn", "data1.mars3d.cn");
    return options
  }

  var Util = {
    __proto__: null,
    isNumber: isNumber,
    isString: isString,
    isBoolean: isBoolean,
    isObject: isObject,
    isPlainObject: isPlainObject,
    isFunction: isFunction,
    isSimpleType: isSimpleType,
    isMars3DCesium: isMars3DCesium,
    formatNum: formatNum$1,
    padLeft0: padLeft0,
    splitWords: splitWords,
    trim: trim,
    getStrLength: getStrLength,
    template: template,
    get lastId () { return lastId; },
    getGlobalId: getGlobalId,
    stampGlobalId: stampGlobalId,
    createGuid: createGuid,
    getTemplateHtml: getTemplateHtml,
    getCesiumValue: getCesiumValue,
    getCesiumColor: getCesiumColor,
    getColorByStyle: getColorByStyle,
    getAttrVal: getAttrVal,
    get3DTileFeatureAttr: get3DTileFeatureAttr,
    merge: merge,
    clone: clone,
    getArrayRandomOne: getArrayRandomOne,
    removeArrayItem: removeArrayItem,
    getSymbolStyle: getSymbolStyle,
    geojsonToArcGIS: geojsonToArcGIS,
    arcgisToGeoJSON: arcgisToGeoJSON,
    getGeoJsonFeatures: getGeoJsonFeatures,
    geoJsonToGraphics: geoJsonToGraphics,
    featureToGraphic: featureToGraphic,
    heightToZoom: heightToZoom,
    getUrlResource: getUrlResource,
    getTextImage: getTextImage,
    getCircleImage: getCircleImage,
    downloadBase64Image: downloadBase64Image,
    downloadFile: downloadFile,
    getExplorerInfo: getExplorerInfo,
    webglreport: webglreport,
    webglerror: webglerror,
    getRequest: getRequest,
    getRequestByName: getRequestByName,
    isPCBroswer: isPCBroswer,
    alert: alert,
    msg: msg,
    formatDate: formatDate,
    formatTime: formatTime,
    fetchJson: fetchJson,
    sendAjax: sendAjax,
    getLangText: getLangText,
    requestFullscreen: requestFullscreen,
    exitFullscreen: exitFullscreen,
    replaceOnlineUrlDomain: replaceOnlineUrlDomain,
    setImage: setImage
  };

  Object.defineProperties(Cesium__namespace.ColorMaterialProperty.prototype, {
    globalAlpha: {
      set: function (value) {
        this._globalAlpha = value;

        const color = getCesiumColor(this.color, Cesium__namespace.Color.WHITE);
        if (!Cesium__namespace.defined(this._color_alpha)) {
          this._color_alpha = color.alpha;
        }
        this.color = color.withAlpha(this._color_alpha * value);
      },
      get: function () {
        return this._globalAlpha ?? 1.0
      }
    }
  });

  Object.defineProperties(Cesium__namespace.GridMaterialProperty.prototype, {
    globalAlpha: {
      set: function (value) {
        this._globalAlpha = value;
      },
      get: function () {
        return this._globalAlpha ?? 1.0
      }
    }
  });
  const getValue_old$5 = Cesium__namespace.GridMaterialProperty.prototype.getValue;

  Cesium__namespace.GridMaterialProperty.prototype.getValue = function (time, result) {
    result = getValue_old$5.bind(this)(time, result);
    if (this.globalAlpha !== 1.0) {
      if (result.color) {
        result.color.alpha *= this.globalAlpha;
      }
      if (result.cellAlpha) {
        result.cellAlpha *= this.globalAlpha;
      }
    }
    return result
  };

  Object.defineProperties(Cesium__namespace.ImageMaterialProperty.prototype, {
    globalAlpha: {
      set: function (value) {
        this._globalAlpha = value;

        const color = getCesiumColor(this.color, Cesium__namespace.Color.WHITE);
        if (!Cesium__namespace.defined(this._color_alpha)) {
          this._color_alpha = color.alpha;
        }
        this.color = color.withAlpha(this._color_alpha * value);
      },
      get: function () {
        return this._globalAlpha ?? 1.0
      }
    }
  });

  Object.defineProperties(Cesium__namespace.PolylineArrowMaterialProperty.prototype, {
    globalAlpha: {
      set: function (value) {
        this._globalAlpha = value;
      },
      get: function () {
        return this._globalAlpha ?? 1.0
      }
    }
  });
  const getValue_old$4 = Cesium__namespace.PolylineArrowMaterialProperty.prototype.getValue;

  Cesium__namespace.PolylineArrowMaterialProperty.prototype.getValue = function (time, result) {
    result = getValue_old$4.bind(this)(time, result);
    if (result.color && this.globalAlpha !== 1.0) {
      result.color.alpha *= this.globalAlpha;
    }
    return result
  };

  Object.defineProperties(Cesium__namespace.PolylineDashMaterialProperty.prototype, {
    globalAlpha: {
      set: function (value) {
        this._globalAlpha = value;
      },
      get: function () {
        return this._globalAlpha ?? 1.0
      }
    }
  });
  const getValue_old$3 = Cesium__namespace.PolylineDashMaterialProperty.prototype.getValue;

  Cesium__namespace.PolylineDashMaterialProperty.prototype.getValue = function (time, result) {
    result = getValue_old$3.bind(this)(time, result);
    if (this.globalAlpha !== 1.0) {
      if (result.color) {
        result.color.alpha *= this.globalAlpha;
      }
      if (result.gapColor) {
        result.gapColor.alpha *= this.globalAlpha;
      }
    }
    return result
  };

  Object.defineProperties(Cesium__namespace.PolylineGlowMaterialProperty.prototype, {
    globalAlpha: {
      set: function (value) {
        this._globalAlpha = value;
      },
      get: function () {
        return this._globalAlpha ?? 1.0
      }
    }
  });
  const getValue_old$2 = Cesium__namespace.PolylineGlowMaterialProperty.prototype.getValue;

  Cesium__namespace.PolylineGlowMaterialProperty.prototype.getValue = function (time, result) {
    result = getValue_old$2.bind(this)(time, result);
    if (result.color && this.globalAlpha !== 1.0) {
      result.color.alpha *= this.globalAlpha;
    }
    return result
  };

  Object.defineProperties(Cesium__namespace.PolylineOutlineMaterialProperty.prototype, {
    globalAlpha: {
      set: function (value) {
        this._globalAlpha = value;
      },
      get: function () {
        return this._globalAlpha ?? 1.0
      }
    }
  });
  const getValue_old$1 = Cesium__namespace.PolylineOutlineMaterialProperty.prototype.getValue;

  Cesium__namespace.PolylineOutlineMaterialProperty.prototype.getValue = function (time, result) {
    result = getValue_old$1.bind(this)(time, result);
    if (this.globalAlpha !== 1.0) {
      if (result.color) {
        result.color.alpha *= this.globalAlpha;
      }
      if (result.outlineColor) {
        result.outlineColor.alpha *= this.globalAlpha;
      }
    }
    return result
  };

  Object.defineProperties(Cesium__namespace.StripeMaterialProperty.prototype, {
    globalAlpha: {
      set: function (value) {
        this._globalAlpha = value;
      },
      get: function () {
        return this._globalAlpha ?? 1.0
      }
    }
  });
  const getValue_old = Cesium__namespace.StripeMaterialProperty.prototype.getValue;

  Cesium__namespace.StripeMaterialProperty.prototype.getValue = function (time, result) {
    result = getValue_old.bind(this)(time, result);
    if (this.globalAlpha !== 1.0) {
      if (result.evenColor) {
        result.evenColor.alpha *= this.globalAlpha;
      }
      if (result.oddColor) {
        result.oddColor.alpha *= this.globalAlpha;
      }
    }
    return result
  };

  // 常用的坐标系内置下，proj4已经内置了EPSG:4326、EPSG:3857、EPSG:4269
  // 以下配置，可以从 http://epsg.io 查询

  // China Geodetic Coordinate System 2000
  proj4.defs("EPSG:4490", "+proj=longlat +ellps=GRS80 +no_defs");

  // Zone横坐标前加带号， 6度分带

  // CGCS2000 / Gauss-Kruger zone 13, bounds : 73.62 35.42 78.01 41.07
  proj4.defs("EPSG:4491", "+proj=tmerc +lat_0=0 +lon_0=75 +k=1 +x_0=13500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger zone 14, bounds : 77.98 29.16 84.0 47.23
  proj4.defs("EPSG:4492", "+proj=tmerc +lat_0=0 +lon_0=81 +k=1 +x_0=14500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger zone 15, bounds :84.0 27.32 90.0 49.18
  proj4.defs("EPSG:4493", "+proj=tmerc +lat_0=0 +lon_0=87 +k=1 +x_0=15500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger zone 16, bounds :90.0 27.71 96.01 47.9
  proj4.defs("EPSG:4494", "+proj=tmerc +lat_0=0 +lon_0=93 +k=1 +x_0=16500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger zone 17
  proj4.defs("EPSG:4495", "+proj=tmerc +lat_0=0 +lon_0=99 +k=1 +x_0=17500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger zone 18
  proj4.defs("EPSG:4496", "+proj=tmerc +lat_0=0 +lon_0=105 +k=1 +x_0=18500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger zone 19
  proj4.defs("EPSG:4497", "+proj=tmerc +lat_0=0 +lon_0=111 +k=1 +x_0=19500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger zone 20
  proj4.defs("EPSG:4498", "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=20500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger zone 21
  proj4.defs("EPSG:4499", "+proj=tmerc +lat_0=0 +lon_0=123 +k=1 +x_0=21500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger zone 22
  proj4.defs("EPSG:4500", "+proj=tmerc +lat_0=0 +lon_0=129 +k=1 +x_0=22500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger zone 23
  proj4.defs("EPSG:4501", "+proj=tmerc +lat_0=0 +lon_0=135 +k=1 +x_0=23500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");

  // Zone 横坐标前加带号， 3度分带

  // CGCS2000 / 3-degree Gauss-Kruger zone 25 , bounds:  73.62 35.81  76.5 40.65
  proj4.defs("EPSG:4513", "+proj=tmerc +lat_0=0 +lon_0=75 +k=1 +x_0=25500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 26 , bounds:  76.5 31.03  79.5 41.83
  proj4.defs("EPSG:4514", "+proj=tmerc +lat_0=0 +lon_0=78 +k=1 +x_0=26500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 27 , bounds:  79.5 29.95 82.51 45.88
  proj4.defs("EPSG:4515", "+proj=tmerc +lat_0=0 +lon_0=81 +k=1 +x_0=27500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 28
  proj4.defs("EPSG:4516", "+proj=tmerc +lat_0=0 +lon_0=84 +k=1 +x_0=28500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 29
  proj4.defs("EPSG:4517", "+proj=tmerc +lat_0=0 +lon_0=87 +k=1 +x_0=29500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 30
  proj4.defs("EPSG:4518", "+proj=tmerc +lat_0=0 +lon_0=90 +k=1 +x_0=30500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 31
  proj4.defs("EPSG:4519", "+proj=tmerc +lat_0=0 +lon_0=93 +k=1 +x_0=31500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 32
  proj4.defs("EPSG:4520", "+proj=tmerc +lat_0=0 +lon_0=96 +k=1 +x_0=32500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 33
  proj4.defs("EPSG:4521", "+proj=tmerc +lat_0=0 +lon_0=99 +k=1 +x_0=33500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 34
  proj4.defs("EPSG:4522", "+proj=tmerc +lat_0=0 +lon_0=102 +k=1 +x_0=34500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 35
  proj4.defs("EPSG:4523", "+proj=tmerc +lat_0=0 +lon_0=105 +k=1 +x_0=35500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 36
  proj4.defs("EPSG:4524", "+proj=tmerc +lat_0=0 +lon_0=108 +k=1 +x_0=36500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 37
  proj4.defs("EPSG:4525", "+proj=tmerc +lat_0=0 +lon_0=111 +k=1 +x_0=37500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 38
  proj4.defs("EPSG:4526", "+proj=tmerc +lat_0=0 +lon_0=114 +k=1 +x_0=38500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 39
  proj4.defs("EPSG:4527", "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=39500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 40
  proj4.defs("EPSG:4528", "+proj=tmerc +lat_0=0 +lon_0=120 +k=1 +x_0=40500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 41
  proj4.defs("EPSG:4529", "+proj=tmerc +lat_0=0 +lon_0=123 +k=1 +x_0=41500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 42
  proj4.defs("EPSG:4530", "+proj=tmerc +lat_0=0 +lon_0=126 +k=1 +x_0=42500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 43
  proj4.defs("EPSG:4531", "+proj=tmerc +lat_0=0 +lon_0=129 +k=1 +x_0=43500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 44
  proj4.defs("EPSG:4532", "+proj=tmerc +lat_0=0 +lon_0=132 +k=1 +x_0=44500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger zone 45
  proj4.defs("EPSG:4533", "+proj=tmerc +lat_0=0 +lon_0=135 +k=1 +x_0=45500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");

  // CM 横坐标前不加带号， 6度分带

  // CGCS2000 / Gauss-Kruger CM 75E
  proj4.defs("EPSG:4502", "+proj=tmerc +lat_0=0 +lon_0=75 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger CM 81E
  proj4.defs("EPSG:4503", "+proj=tmerc +lat_0=0 +lon_0=81 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger CM 87E
  proj4.defs("EPSG:4504", "+proj=tmerc +lat_0=0 +lon_0=87 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger CM 93E
  proj4.defs("EPSG:4505", "+proj=tmerc +lat_0=0 +lon_0=93 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger CM 99E
  proj4.defs("EPSG:4506", "+proj=tmerc +lat_0=0 +lon_0=99 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger CM 105E
  proj4.defs("EPSG:4507", "+proj=tmerc +lat_0=0 +lon_0=105 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger CM 111E
  proj4.defs("EPSG:4508", "+proj=tmerc +lat_0=0 +lon_0=111 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger CM 117E
  proj4.defs("EPSG:4509", "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger CM 123E
  proj4.defs("EPSG:4510", "+proj=tmerc +lat_0=0 +lon_0=123 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger CM 129E
  proj4.defs("EPSG:4511", "+proj=tmerc +lat_0=0 +lon_0=129 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / Gauss-Kruger CM 135E
  proj4.defs("EPSG:4512", "+proj=tmerc +lat_0=0 +lon_0=135 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");

  // CM 横坐标前不加带号， 3度分带

  // CGCS2000 / 3-degree Gauss-Kruger CM 75E, bounds: 73.62 35.81 76.5 40.65
  proj4.defs("EPSG:4534", "+proj=tmerc +lat_0=0 +lon_0=75 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 78E, bounds: 76.5 31.03 79.5 41.83
  proj4.defs("EPSG:4535", "+proj=tmerc +lat_0=0 +lon_0=78 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 81E, bounds: 79.5 29.95 82.51 45.88
  proj4.defs("EPSG:4536", "+proj=tmerc +lat_0=0 +lon_0=81 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 84E
  proj4.defs("EPSG:4537", "+proj=tmerc +lat_0=0 +lon_0=84 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 87E
  proj4.defs("EPSG:4538", "+proj=tmerc +lat_0=0 +lon_0=87 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 90E
  proj4.defs("EPSG:4539", "+proj=tmerc +lat_0=0 +lon_0=90 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 93E
  proj4.defs("EPSG:4540", "+proj=tmerc +lat_0=0 +lon_0=93 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 96E
  proj4.defs("EPSG:4541", "+proj=tmerc +lat_0=0 +lon_0=96 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 99E
  proj4.defs("EPSG:4542", "+proj=tmerc +lat_0=0 +lon_0=99 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 102E
  proj4.defs("EPSG:4543", "+proj=tmerc +lat_0=0 +lon_0=102 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 105E
  proj4.defs("EPSG:4544", "+proj=tmerc +lat_0=0 +lon_0=105 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 108E
  proj4.defs("EPSG:4545", "+proj=tmerc +lat_0=0 +lon_0=108 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 111E
  proj4.defs("EPSG:4546", "+proj=tmerc +lat_0=0 +lon_0=111 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 114E
  proj4.defs("EPSG:4547", "+proj=tmerc +lat_0=0 +lon_0=114 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 117E
  proj4.defs("EPSG:4548", "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 120E
  proj4.defs("EPSG:4549", "+proj=tmerc +lat_0=0 +lon_0=120 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 123E
  proj4.defs("EPSG:4550", "+proj=tmerc +lat_0=0 +lon_0=123 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 126E
  proj4.defs("EPSG:4551", "+proj=tmerc +lat_0=0 +lon_0=126 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 129E
  proj4.defs("EPSG:4552", "+proj=tmerc +lat_0=0 +lon_0=129 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 132E
  proj4.defs("EPSG:4553", "+proj=tmerc +lat_0=0 +lon_0=132 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");
  // CGCS2000 / 3-degree Gauss-Kruger CM 135E
  proj4.defs("EPSG:4554", "+proj=tmerc +lat_0=0 +lon_0=135 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs");

  /**
   * 基础类，SDK中几乎所有类的基类，都是继承该基类的。
   * @param {Object} [options] 参数名称
   *
   * @export
   * @class BaseClass
   */
  class BaseClass {
    constructor(options) {
      /**
       * 当前类的构造参数
       * @type {Object}
       * @readonly
       */
      this.options = options;

      /**
       *  设置事件的启用和禁用状态
       * @type {Boolean}
       */
      this.enabledEvent = options?.enabledEvent ?? true;
    }

    /**
     * 销毁当前对象
     *
     * @param {Boolean} [noDel=false] false:会自动delete释放所有属性，true：不delete绑定的变量
     * @return {void}  无
     *
     */
    destroy(noDel) {
      if (!noDel) {
        // 删除所有绑定的数据
        for (const i in this) {
          delete this[i];
        }
      }
    }

    /**
     * 绑定指定类型事件监听器,
     * 支持在监听中调用 event.stopPropagation(); 组织事件冒泡
     *
     * @param {EventType|String|EventType[]|String[]|Object} types 事件类型
     * @param {Function} fn 绑定的监听器回调方法
     * @param {Object} [context]  侦听器的上下文(this关键字将指向的对象)。
     * @return {BaseClass} 当前对象本身,可以链式调用
     *
     */
    on(types, fn, context) {
      if (!types) {
        logError("绑定事件时传入了空值", fn);
        return this
      }

      if (Array.isArray(types)) {
        for (let i = 0, len = types.length; i < len; i++) {
          this._on(types[i], fn, context);
        }
      } else if (isObject(types)) {
        for (const type in types) {
          this._on(type, types[type], fn);
        }
      } else {
        types = splitWords(types);
        for (let i = 0, len = types.length; i < len; i++) {
          this._on(types[i], fn, context);
        }
      }
      this._onEventHook && this._onEventHook(types);

      return this
    }

    /**
     * 解除绑定指定类型事件监听器
     *
     * @param {EventType|String|EventType[]} [types] 事件类型,未传值时解绑所有事件
     * @param {Function} [fn] 绑定的监听器回调方法,未传值时解绑所有指定类型对应事件
     * @param {Object} [context]  侦听器的上下文(this关键字将指向的对象)。
     * @return {BaseClass} 当前对象本身,可以链式调用
     *
     */
    off(types, fn, context) {
      if (!types) {
        delete this._events;
      } else if (Array.isArray(types)) {
        for (let i = 0, len = types.length; i < len; i++) {
          this._off(types[i], fn, context);
        }
      } else if (isObject(types)) {
        for (const type in types) {
          this._off(type, types[type], fn);
        }
      } else {
        types = splitWords(types);

        for (let i = 0, len = types.length; i < len; i++) {
          this._off(types[i], fn, context);
        }
      }

      return this
    }

    _on(type, fn, context) {
      this._events = this._events || {};

      /* get/init listeners for type */
      let typeListeners = this._events[type];
      if (!typeListeners) {
        typeListeners = [];
        this._events[type] = typeListeners;
      }

      if (context === this) {
        // Less memory footprint.
        context = undefined;
      }
      const newListener = { fn: fn, ctx: context };
      const listeners = typeListeners;

      // check if fn already there
      for (let i = 0, len = listeners.length; i < len; i++) {
        if (listeners[i].fn === fn && listeners[i].ctx === context) {
          return
        }
      }

      listeners.push(newListener);
    }

    _off(type, fn, context) {
      let listeners, i, len;

      if (!this._events) {
        return
      }

      listeners = this._events[type];

      if (!listeners) {
        return
      }

      if (!fn) {
        // Set all removed listeners to noop so they are not called if remove happens in fire
        for (i = 0, len = listeners.length; i < len; i++) {
          listeners[i].fn = falseFn;
        }
        // clear all listeners for a type if function isn't specified
        delete this._events[type];
        return
      }

      if (context === this) {
        context = undefined;
      }

      if (listeners) {
        // find fn and remove it
        for (i = 0, len = listeners.length; i < len; i++) {
          const l = listeners[i];
          if (l.ctx !== context) {
            continue
          }
          if (l.fn === fn) {
            // set the removed listener to noop so that's not called if remove happens in fire
            l.fn = falseFn;

            if (this._firingCount) {
              /* copy array in case events are being fired */
              this._events[type] = listeners = listeners.slice();
            }
            listeners.splice(i, 1);

            return
          }
        }
      }
    }

    /**
     * 触发指定类型的事件。
     *
     * @param {EventType|String} type 事件类型
     * @param {Object} [data] 传输的数据或对象，可在事件回调方法中event对象中获取进行使用
     * @param {BaseClass} [propagate] 将事件传播给父类 (用addEventParent设置)
     * @return {BaseClass} 当前对象本身,可以链式调用
     *
     */
    fire(type, data, propagate) {
      if (!this.listens(type, propagate) || !this.enabledEvent) {
        return this
      }

      const event = {
        sourceTarget: this, // 会被data的相同值覆盖
        ...data,
        type: type,
        target: this,
        stopPropagation: function () {
          this._stopPropagation = true;
        }
      };

      if (this._events) {
        const listeners = this._events[type];

        if (listeners) {
          this._firingCount = this._firingCount + 1 || 1;
          for (let i = 0, len = listeners.length; i < len; i++) {
            const l = listeners[i];
            l.fn.call(l.ctx || this, event);
          }

          this._firingCount--;
        }
      }

      if (propagate && !event._stopPropagation) {
        this._propagateEvent(event);
      }

      return this
    }

    /**
     * 是否有绑定指定的事件
     *
     * @param {EventType|String} type 事件类型
     * @param {BaseClass} [propagate] 是否判断指定的父类 (用addEventParent设置的)
     * @return {Boolean} 是否存在
     *
     */
    listens(type, propagate) {
      const listeners = this._events && this._events[type];
      if (listeners && listeners.length) {
        return true
      }

      if (propagate) {
        // also check parents for listeners if event propagates
        for (const id in this._eventParents) {
          if (this._eventParents[id].listens(type, propagate)) {
            return true
          }
        }
      }
      return false
    }

    /**
     * 绑定一次性执行的指定类型事件监听器
     * 与on类似，监听器只会被触发一次，然后被删除。
     *
     * @param {EventType|String|EventType[]} types 事件类型
     * @param {Function} fn 绑定的监听器回调方法
     * @param {Object} [context]  侦听器的上下文(this关键字将指向的对象)。
     * @return {BaseClass} 当前对象本身,可以链式调用
     *
     */
    once(types, fn, context) {
      if (isObject(types)) {
        for (const type in types) {
          this.once(type, types[type], fn);
        }
        return this
      }

      const handler = bind(() => {
        this.off(types, fn, context).off(types, handler, context);
      }, this);

      // add a listener that's executed once and removed after that
      return this.on(types, fn, context).on(types, handler, context)
    }

    /**
     * 添加抛出事件到父类，它将接收传播的事件
     *
     * @param {Object} obj 父类对象
     * @return {BaseClass} 当前对象本身,可以链式调用
     *
     */
    addEventParent(obj) {
      this._eventParents = this._eventParents || {};
      this._eventParents[stampGlobalId(obj)] = obj;
      return this
    }

    /**
     * 移除抛出事件到父类
     *
     * @param {Object} obj 父类对象
     * @return {BaseClass} 当前对象本身,可以链式调用
     *
     */
    removeEventParent(obj) {
      if (this._eventParents) {
        delete this._eventParents[stampGlobalId(obj)];
      }
      return this
    }

    /**
     * 是否绑定了抛出事件到指定父类
     *
     * @param {Object} obj 父类对象
     * @return {BaseClass} 当前对象本身,可以链式调用
     *
     */
    hasEventParent(obj) {
      if (this._eventParents && this._eventParents[stampGlobalId(obj)]) {
        return true
      } else {
        return false
      }
    }

    _propagateEvent(e) {
      for (const id in this._eventParents) {
        const target = this._eventParents[id];
        if (this._filterPropagateEvent(target, e)) {
          target.fire(e.type, { layer: e.target, propagatedFrom: e.target, ...e }, true);
        }
      }
    }

    // 子类按需筛选向上抛出事件
    _filterPropagateEvent(target, e) {
      return true
    }
  }

  function falseFn() {
    return false
  }

  function bind(fn, obj) {
    const slice = Array.prototype.slice;

    if (fn.bind) {
      return fn.bind.apply(fn, slice.call(arguments, 1))
    }

    const args = slice.call(arguments, 2);

    return function () {
      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments)
    }
  }

  /**
   * 状态 枚举
   *  @enum {String}
   */
  const State = {
    /**
     * 初始化
     */
    INITIALIZED: "inited",
    /**
     * 已添加到地图上
     */
    ADDED: "added",
    /**
     * 已移除地图
     */
    REMOVED: "removed",
    /**
     * 已销毁对象
     */
    DESTROY: "destroy"
  };

  /**
   * 事件类型 枚举（所有事件统一的入口）
   * @enum {String}
   */
  const EventType = {
    /**
     * 添加对象(本身)
     */
    add: "add",
    /**
     * 移除对象(本身)
     */
    remove: "remove",

    /**
     * 对象中添加了一项内容
     */
    addItem: "addItem",
    /**
     * 对象中移除了一项内容
     */
    removeItem: "removeItem",

    /**
     *添加矢量数据时[图层上监听时使用]
     */
    addGraphic: "addGraphic",
    /**
     *移除矢量数据时[图层上监听时使用]
     */
    removeGraphic: "removeGraphic",
    /**
     * 添加图层[map上监听时使用]
     */
    addLayer: "addLayer",
    /**
     * 移除图层[map上监听时使用]
     */
    removeLayer: "removeLayer",

    /**
     * 地图上添加控件
     */
    addControl: "addControl",
    /**
     * 从地图上移除控件
     */
    removeControl: "removeControl",

    /**
     * 地图上添加Effect特效
     */
    addEffect: "addEffect",
    /**
     * 从地图上移除Effect特效
     */
    removeEffect: "removeEffect",

    /**
     *更新了对象
     */
    update: "update",

    /**
     *更新了坐标位置
     */
    updatePosition: "updatePosition",

    /**
     *更新了style对象
     */
    updateStyle: "updateStyle",
    /**
     *更新了attr对象
     */
    updateAttr: "updateAttr",

    /**
     *显示了对象
     */
    show: "show",
    /**
     *隐藏了对象
     */
    hide: "hide",

    /**
     * 开始
     */
    start: "start",
    /**
     * 变化了
     */
    change: "change",
    /**
     *多个数据异步分析时，完成其中一个时的回调事件
     */
    endItem: "endItem",
    /**
     *多个数据异步分析时，完成所有的回调事件
     */
    end: "end",
    /**
     * 完成
     */
    stop: "stop",

    /**
     * 完成加载，但未做任何其他处理前
     */
    loadBefore: "loadBefore",
    /**
     * 完成加载，执行所有内部处理后
     */
    load: "load",
    /**
     * 出错了
     */
    error: "error",
    /**
     * 完成加载配置信息
     */
    loadConfig: "loadConfig",

    /**
     * popup弹窗打开后
     */
    popupOpen: "popupOpen",
    /**
     * popup弹窗关闭
     */
    popupClose: "popupClose",

    /**
     * tooltip弹窗打开后
     */
    tooltipOpen: "tooltipOpen",
    /**
     * tooltip弹窗关闭
     */
    tooltipClose: "tooltipClose",

    /**
     * 右键菜单 打开后
     */
    contextMenuOpen: "contextMenuOpen",
    /**
     * 右键菜单 关闭
     */
    contextMenuClose: "contextMenuClose",
    /**
     * 右键菜单 单击某一项后
     */
    contextMenuClick: "contextMenuClick",

    /**
     * highlight高亮后
     */
    highlightOpen: "highlightOpen",
    /**
     * highlight关闭后
     */
    highlightClose: "highlightClose",

    /**
     * 左键单击  鼠标事件
     */
    click: "click",
    /**
     * 左键单击到矢量或模型数据时 鼠标事件
     */
    clickGraphic: "clickGraphic",

    /**
     * 左键单击到wms或arcgis瓦片服务的对应矢量数据时
     */
    clickTileGraphic: "clickTileGraphic",
    /**
     * 左键单击地图空白（未单击到矢量或模型数据）时 鼠标事件
     */
    clickMap: "clickMap",
    /**
     * 左键双击  鼠标事件
     */
    dblClick: "dblClick",
    /**
     * 左键鼠标按下 鼠标事件
     */
    leftDown: "leftDown",
    /**
     * 左键鼠标按下后释放   鼠标事件
     */
    leftUp: "leftUp",
    /**
     * 鼠标移动   鼠标事件
     */
    mouseMove: "mouseMove",
    /**
     * 鼠标移动（拾取目标，并延迟处理） 鼠标事件
     */
    mouseMoveTarget: "mouseMoveTarget",
    /**
     * 鼠标滚轮滚动  鼠标事件
     */
    wheel: "wheel",
    /**
     * 右键单击 鼠标事件
     */
    rightClick: "rightClick",
    /**
     * 右键鼠标按下  鼠标事件
     */
    rightDown: "rightDown",
    /**
     * 右键鼠标按下后释放   鼠标事件
     */
    rightUp: "rightUp",
    /**
     * 中键单击 鼠标事件
     */
    middleClick: "middleClick",
    /**
     * 中键鼠标按下  鼠标事件
     */
    middleDown: "middleDown",
    /**
     * 中键鼠标按下后释放 鼠标事件
     */
    middleUp: "middleUp",
    /**
     * 在触摸屏上两指缩放开始 鼠标事件
     */
    pinchStart: "pinchStart",
    /**
     * 在触摸屏上两指缩放结束  鼠标事件
     */
    pinchEnd: "pinchEnd",
    /**
     * 在触摸屏上两指移动 鼠标事件
     */
    pinchMove: "pinchMove",
    /**
     * 鼠标按下 [左中右3键都触发] 鼠标事件
     */
    mouseDown: "mouseDown",
    /**
     * 鼠标按下后释放 [左中右3键都触发] 鼠标事件
     */
    mouseUp: "mouseUp",
    /**
     * 鼠标移入 鼠标事件
     */
    mouseOver: "mouseOver",
    /**
     * 鼠标移出 鼠标事件
     */
    mouseOut: "mouseOut",
    /**
     * 按键按下 键盘事件
     */
    keydown: "keydown",
    /**
     * 按键按下后释放 键盘事件
     */
    keyup: "keyup",

    /**
     * 开始绘制 标绘事件
     */
    drawStart: "drawStart",
    /**
     * 正在移动鼠标中，绘制过程中鼠标移动了点 标绘事件
     */
    drawMouseMove: "drawMouseMove",
    /**
     * 绘制过程中增加了点 标绘事件
     */
    drawAddPoint: "drawAddPoint",
    /**
     * 绘制过程中删除了最后一个点 标绘事件
     */
    drawRemovePoint: "drawRemovePoint",
    /**
     * 创建完成 标绘事件
     */
    drawCreated: "drawCreated",
    /**
     * 开始编辑 标绘事件
     */
    editStart: "editStart",
    /**
     * 移动鼠标按下左键（LEFT_DOWN）标绘事件
     */
    editMouseDown: "editMouseDown",
    /**
     *正在移动鼠标中，正在编辑拖拽修改点中（MOUSE_MOVE） 标绘事件
     */
    editMouseMove: "editMouseMove",
    /**
     *编辑修改了点（LEFT_UP）标绘事件
     */
    editMovePoint: "editMovePoint",
    /**
     * 编辑新增了点 标绘事件
     */
    editAddPoint: "editAddPoint",
    /**
     * 编辑删除了点 标绘事件
     */
    editRemovePoint: "editRemovePoint",
    /**
     * 图上编辑修改了相关style属性 标绘事件
     */
    editStyle: "editStyle",
    /**
     * 停止编辑 标绘事件
     */
    editStop: "editStop",
    /**
     * 标绘事件
     */
    move: "move",

    /**
     * 3dtiles模型，模型瓦片初始化完成
     * 该回调只执行一次
     */
    initialTilesLoaded: "initialTilesLoaded",
    /**
     * 3dtiles模型,当前批次模型加载完成
     * 该回调会执行多次，视角变化后重新加载一次完成后都会回调
     */
    allTilesLoaded: "allTilesLoaded",

    /**
     * 栅格瓦片图层，添加单个瓦片，开始加载瓦片（请求前）
     */
    addTile: "addTile",
    /**
     * 栅格瓦片图层，添加单个瓦片 加载瓦片完成
     */
    addTileSuccess: "addTileSuccess",
    /**
     * 栅格瓦片图层，添加单个瓦片 加载瓦片出错了
     */
    addTileError: "addTileError",
    /**
     * 栅格瓦片图层，移除单个瓦片
     */
    removeTile: "removeTile",
    /**
     * 相机开启移动前 场景事件
     */
    cameraMoveStart: "cameraMoveStart",
    /**
     *相机移动完成后 场景事件
     */
    cameraMoveEnd: "cameraMoveEnd",
    /**
     * 相机位置完成 场景事件
     */
    cameraChanged: "cameraChanged",
    /**
     * 场景更新前 场景事件
     */
    preUpdate: "preUpdate",
    /**
     * 场景更新后 场景事件
     */
    postUpdate: "postUpdate",
    /**
     * 场景渲染前 场景事件
     */
    preRender: "preRender",
    /**
     * 场景渲染后 场景事件
     */
    postRender: "postRender",

    /**
     * 场景渲染失败（需要刷新页面）
     */
    renderError: "renderError",

    /**
     * 场景模式(2D/3D/哥伦布)变换前 场景事件
     */
    morphStart: "morphStart",
    /**
     * 完成场景模式(2D/3D/哥伦布)变换 场景事件
     */
    morphComplete: "morphComplete",
    /**
     * 时钟跳动 场景事件
     */
    clockTick: "clockTick",

    /**
     * 地形变化  事件
     */
    terrainChange: "terrainChange",
    /**
     *地形初始化加载layer.json失败 事件
     */
    terrainLoadError: "terrainLoadError",
    /**
     * 地形初始化加载layer.json完成  事件
     */
    terrainLoadSuccess: "terrainLoadSuccess",

    /**
     * 地图中瓦片加载进度变化  事件
     */
    tileLoadProgress: "tileLoadProgress"
  };

  /**
   * Thing对象(如特效、分析、管理类等) 的基类
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class BaseThing
   * @extends {BaseClass}
   *
   * @see [支持的事件类型]{@link BaseThing.EventType}
   */
  class BaseThing extends BaseClass {
    constructor(options = {}) {
      if (isBoolean(options)) {
        options = { enabled: options };
      }

      super(options);

      this._id = options.id ?? createGuid();
      this._enabled = options.enabled ?? true;
      this._state = State.INITIALIZED;

      this.options = options;
    }

    //= ========= 对外属性 ==========

    /**
     * 当前对象的状态
     *
     * @type {State}
     * @readonly
     *
     */
    get state() {
      return this._state
    }

    /**
     * 是否已添加到地图
     *
     * @type {Boolean}
     * @readonly
     *
     */
    get isAdded() {
      return this._state === State.ADDED
    }

    /**
     * 对象的id标识
     * @type {String|Number}
     * @readonly
     */
    get id() {
      return this._id
    }

    set id(id) {
      this.options.id = id;
    }

    // 兼容v3.4之前历史版本
    get uuid() {
      return this._id
    }

    /**
     *  设置对象的启用和禁用状态。
     * @type {Boolean}
     *
     */
    get enabled() {
      return this._enabled
    }

    set enabled(val) {
      if (this._enabled === val) {
        return
      }
      this._enabled = val;
      this._enabledHook && this._enabledHook(val);
    }

    /**
     * 添加到地图上，同 map.addThing
     *
     * @param {Map} map 地图对象
     * @return {BaseThing} 当前对象本身，可以链式调用
     *
     */
    addTo(map) {
      if (map && map.addThing) {
        map.addThing(this);
      }
      return this
    }

    /**
     * 从地图上移除，同map.removeThing
     *
     * @param {Boolean} [destroy] 是否调用destroy释放
     * @return {void}  无
     */
    remove(destroy) {
      if (this._map) {
        this._map.removeThing(this, destroy);
      }
    }

    /**
     * 添加到地图上的钩子方法
     *
     * @param {Map} map 地图对象
     * @return {void}  无
     * @private
     */
    _onAdd(map) {
      if (this._state === State.ADDED) {
        return
      }
      this._map = map;

      if (this.options.eventParent) {
        this.addEventParent(this.options.eventParent);
      } else if (this.options?.eventParent === false) ; else {
        this.addEventParent(map);
      }

      if (this._mountedHook) {
        if (!this._createOK) {
          this._mountedHook();
          this._createOK = true;
        }
      }
      this._addedBaseHook && this._addedBaseHook();
      this._addedHook && this._addedHook();

      this._state = State.ADDED;
      this.fire(EventType.add);
    }

    /**
     * 从地图上移除的钩子方法
     *
     * @return {void}  无
     * @private
     */
    _onRemove() {
      if (this._state !== State.ADDED) {
        return
      }

      if (!this._map) {
        return
      }
      this._removedBaseHook && this._removedBaseHook();
      this._removedHook && this._removedHook();

      this._state = State.REMOVED;

      this.fire(EventType.remove);

      if (this.options?.eventParent) {
        this.removeEventParent(this.options.eventParent);
      } else if (this.options?.eventParent === false) ; else {
        this.removeEventParent(this._map);
      }

      this._map = null;
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     *
     * @abstract
     * @return {void}  无
     */
    _mountedHook() {}

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */
    _addedHook() {}

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */
    _removedHook() {}

    // 销毁
    destroy(noDel) {
      if (this._state !== State.REMOVED) {
        this.clear && this.clear();
        this.remove();
      }
      super.destroy(noDel);
    }
  }

  /**
   * @typedef {Object} BaseThing.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} add 添加对象
   * @property {String} remove 移除对象
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.add, function (event) {
   *   console.log('添加了对象', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * Thing对象(如特效、分析、管理类等)组，可以用于将多个Thing对象组合起来方便控制
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Object[]} [options.things] 子Thing对象数组
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   *
   * @export
   * @class GroupThing
   * @extends {BaseThing}
   */
  class GroupThing extends BaseThing {
    constructor(options = {}) {
      super(options);
      this._arrThing = [];
    }

    /**
     * 子Thing对象对象数组
     *
     * @type {BaseThing[]}
     * @readonly
     */
    get arrThing() {
      return this._arrThing
    }

    /**
     * 是否空组 ，空组目前就Thing对象管理用于Thing对象分组节点（虚拟节点）。
     *
     * @type {Boolean}
     * @readonly
     */
    get hasEmptyGroup() {
      return this.length === 0
    }

    /**
     * 是否有子Thing对象
     *
     * @type {Boolean}
     * @readonly
     */
    get hasChildThing() {
      return this.length > 0
    }

    /**
     * 子Thing对象的个数
     *
     * @type {Number}
     * @readonly
     */
    get length() {
      if (this.options.things?.length > 0) {
        return this.options.things.length
      } else {
        return this._arrThing.length
      }
    }

    //
    _enabledHook(value) {
      this.eachThing((thing) => {
        thing.enabled = value;
      }, this);
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this.addChildsToMap();
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.removeMapChilds();
    }

    /**
     *  添加所有子对象到map上
     * @return {GroupThing} 当前对象本身，可以链式调用
     */
    addChildsToMap() {
      this.eachThing((thing) => {
        this._map.addThing(thing);
      }, this);
    }

    /**
     *  将所有子对象从map中移除
     * @return {GroupThing} 当前对象本身，可以链式调用
     */
    removeMapChilds() {
      this.eachThing((thing) => {
        this._map.removeThing(thing);
      }, this);
    }

    /**
     * 添加子Thing对象，并绑定关联关系。
     *
     * @param {BaseThing} childthing 子Thing对象对象
     * @return {GroupThing} 当前对象本身，可以链式调用
     */
    addThing(childthing) {
      if (childthing.parent) {
        childthing.removeEventParent(childthing.parent);
        childthing.parent = null;
      }
      childthing.parent = this;
      childthing.options.eventParent = this;
      this._arrThing.push(childthing);

      if (this.isAdded && !childthing.isAdded) {
        this._map.addThing(childthing);
      } else {
        childthing.removeEventParent(this._map);
        childthing.addEventParent(this);
      }

      return this
    }

    /**
     * 移除子Thing对象，并解除关联关系。
     *
     * @param {BaseThing} childthing 子Thing对象对象
     * @return {GroupThing} 当前对象本身，可以链式调用
     */
    removeThing(childthing) {
      childthing.parent = null;
      childthing.removeEventParent(this);
      removeArrayItem(this._arrThing, childthing);

      if (this._map && childthing.isAdded) {
        this._map.removeThing(childthing);
      }

      return this
    }

    /**
     * 遍历每一个子Thing对象并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} [context] 侦听器的上下文(this关键字将指向的对象)。
     * @return {GroupThing} 当前对象本身,可以链式调用
     */
    eachThing(method, context) {
      if (!this._arrThing) {
        return
      }
      this._arrThing.forEach((thing) => {
        method.call(context, thing);
      });
      return this
    }

    /**
     * 获取所有内置子Thing对象对象
     * @return {BaseThing[]} 所有子Thing对象对象
     */
    getThings() {
      return this._arrThing
    }

    /**
     * 获取地图所有的子Thing对象对象(包括pid和id关联的Thing对象)
     * @return {BaseThing[]} 所有子Thing对象对象
     */
    getInMapChilds() {
      const arr = this._arrThing || [];
      this._map.eachThing((thing) => {
        if (thing.pid !== this.id) {
          return
        }
        if (this._arrThing.indexOf(thing) !== -1) {
          return
        }

        arr.push(thing);
      }, this);
      return arr
    }

    /**
     * 根据ID或取Thing对象
     *
     * @param {String|Number} id Thing对象id或uuid
     * @return {BaseThing|*} Thing对象对象
     */
    getThingById(id) {
      const things = this._arrThing;
      if (!this._arrThing || this._arrThing.length === 0) {
        return
      }
      for (let i = 0, len = things.length; i < len; i++) {
        const thing = things[i];
        if (thing.id === id) {
          return thing
        }
      }
      return undefined
    }

    // 销毁释放对象
    destroy(noDel) {
      this.eachThing((thing) => {
        if (thing?.destroy) {
          thing.destroy(noDel);
        }
      }, this);
      super.destroy(noDel);
    }
  }

  var GroundSkyBoxFS = "uniform samplerCube u_cubeMap;\nvarying vec3 v_texCoord;\n\nvoid main() {\n  vec4 color = textureCube(u_cubeMap, normalize(v_texCoord));\n  gl_FragColor = vec4(czm_gammaCorrect(color).rgb, czm_morphTime);\n}\n"; // eslint-disable-line

  var GroundSkyBoxVS = "attribute vec3 position;\nuniform mat3 u_rotateMatrix;\nvarying vec3 v_texCoord;\n\nvoid main() {\n  vec3 p = czm_viewRotation * u_rotateMatrix * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));//【火星科技marsgis.cn】 Hao 2019-9-18   天空盒\n  gl_Position = czm_projection * vec4(p, 1.0);\n  v_texCoord = position.xyz;\n}\n"; // eslint-disable-line

  /**
   * 近地天空盒, 在场景周围绘制星星等太空背景。
   * 天空盒子是用真正的赤道平均春分点(TEME)轴定义的。仅在3D中支持。当转换为2D或哥伦布视图时，天空盒会淡出。
   * 天空盒子的大小不能超过{@link Cesium.Scene#maximumCubeMapSize}。
   *
   * @param {Object} options 对象，具有以下属性:
   * @param {Object} [options.sources] 天空盒的6个立方体映射面的图片url
   * @param {String} [options.sources.positiveX] 映射面的图片url
   * @param {String} [options.sources.negativeX] 映射面的图片url
   * @param {String} [options.sources.positiveY] 映射面的图片url
   * @param {String} [options.sources.negativeY] 映射面的图片url
   * @param {String} [options.sources.positiveZ] 映射面的图片url
   * @param {String} [options.sources.negativeZ] 映射面的图片url
   * @param {Boolean} [options.show=true] 是否显示
   *
   * @export
   * @class GroundSkyBox
   * @extends {Cesium.SkyBox}
   * @example
   * map.scene.skyBox = new mars3d.GroundSkyBox({
   *   sources : {
   *     positiveX : 'skybox_px.png',
   *     negativeX : 'skybox_nx.png',
   *     positiveY : 'skybox_py.png',
   *     negativeY : 'skybox_ny.png',
   *     positiveZ : 'skybox_pz.png',
   *     negativeZ : 'skybox_nz.png'
   *   }
   * });
   */
  class GroundSkyBox extends Cesium__namespace.SkyBox {
    constructor(options) {
      super(options);

      this._skyboxMatrix3 = new Cesium__namespace.Matrix3();
    }

    // 内部渲染的方法
    update(frameState, useHdr) {
      const that = this;

      if (!this.show) {
        return undefined
      }

      if (frameState.mode !== Cesium__namespace.SceneMode.SCENE3D && frameState.mode !== Cesium__namespace.SceneMode.MORPHING) {
        return undefined
      }

      // The sky box is only rendered during the render pass; it is not pickable, it doesn't cast shadows, etc.
      if (!frameState.passes.render) {
        return undefined
      }

      const context = frameState.context;

      if (this._sources !== this.sources) {
        this._sources = this.sources;
        const sources = this.sources;

        // >>includeStart('debug', pragmas.debug);
        if (
          !Cesium__namespace.defined(sources.positiveX) ||
          !Cesium__namespace.defined(sources.negativeX) ||
          !Cesium__namespace.defined(sources.positiveY) ||
          !Cesium__namespace.defined(sources.negativeY) ||
          !Cesium__namespace.defined(sources.positiveZ) ||
          !Cesium__namespace.defined(sources.negativeZ)
        ) {
          throw new Cesium__namespace.DeveloperError(
            "this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties."
          )
        }

        if (
          typeof sources.positiveX !== typeof sources.negativeX ||
          typeof sources.positiveX !== typeof sources.positiveY ||
          typeof sources.positiveX !== typeof sources.negativeY ||
          typeof sources.positiveX !== typeof sources.positiveZ ||
          typeof sources.positiveX !== typeof sources.negativeZ
        ) {
          throw new Cesium__namespace.DeveloperError("this.sources properties must all be the same type.")
        }
        // >>includeEnd('debug');

        if (typeof sources.positiveX === "string") {
          // Given urls for cube-map images.  Load them.
          Cesium__namespace.loadCubeMap(context, this._sources).then(function (cubeMap) {
            that._cubeMap = that._cubeMap && that._cubeMap.destroy();
            that._cubeMap = cubeMap;
          });
        } else {
          this._cubeMap = this._cubeMap && this._cubeMap.destroy();
          this._cubeMap = new Cesium__namespace.CubeMap({
            context: context,
            source: sources
          });
        }
      }

      const command = this._command;

      if (!Cesium__namespace.defined(command.vertexArray)) {
        command.uniformMap = {
          u_cubeMap: () => {
            return that._cubeMap
          },
          // 【火星科技marsgis.cn】 Hao 2019-9-18   近地天空盒
          u_rotateMatrix: () => {
            command.modelMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(frameState.camera._positionWC);
            return Cesium__namespace.Matrix4.getMatrix3(command.modelMatrix, this._skyboxMatrix3)
          }
          // 【火星科技marsgis.cn】 Hao 2019-9-18   近地天空盒
        };

        const geometry = Cesium__namespace.BoxGeometry.createGeometry(
          Cesium__namespace.BoxGeometry.fromDimensions({
            dimensions: new Cesium__namespace.Cartesian3(2.0, 2.0, 2.0),
            vertexFormat: Cesium__namespace.VertexFormat.POSITION_ONLY
          })
        );
        const attributeLocations = (this._attributeLocations = Cesium__namespace.GeometryPipeline.createAttributeLocations(geometry));

        command.vertexArray = Cesium__namespace.VertexArray.fromGeometry({
          context: context,
          geometry: geometry,
          attributeLocations: attributeLocations,
          bufferUsage: Cesium__namespace.BufferUsage.STATIC_DRAW
        });

        command.renderState = Cesium__namespace.RenderState.fromCache({
          blending: Cesium__namespace.BlendingState.ALPHA_BLEND
        });
      }

      if (!Cesium__namespace.defined(command.shaderProgram) || this._useHdr !== useHdr) {
        const fs = new Cesium__namespace.ShaderSource({
          defines: [useHdr ? "HDR" : ""],
          sources: [GroundSkyBoxFS]
        });
        command.shaderProgram = Cesium__namespace.ShaderProgram.fromCache({
          context: context,
          vertexShaderSource: GroundSkyBoxVS,
          fragmentShaderSource: fs,
          attributeLocations: this._attributeLocations
        });
        this._useHdr = useHdr;
      }

      if (!Cesium__namespace.defined(this._cubeMap)) {
        return undefined
      }

      return command
    }
  }

  var MultipleSkyBoxFS = "uniform samplerCube u_cubeMap;\nuniform samplerCube u_cubeMap2;\nuniform samplerCube u_cubeMap3;\nuniform float u_select;\nvarying vec3 v_texCoord;\n\nvoid main() {\n  vec4 fragColor;\n  if(u_select <= 1.0) {\n    vec4 color = textureCube(u_cubeMap, normalize(v_texCoord));\n    color = vec4(czm_gammaCorrect(color).rgb, czm_morphTime);\n    vec4 color2 = textureCube(u_cubeMap2, normalize(v_texCoord));\n    color2 = vec4(czm_gammaCorrect(color2).rgb, czm_morphTime);\n    fragColor = mix(color, color2, u_select);\n  }\n  if(u_select > 1.0) {\n    vec4 color = textureCube(u_cubeMap2, normalize(v_texCoord));\n    color = vec4(czm_gammaCorrect(color).rgb, czm_morphTime);\n    vec4 color2 = textureCube(u_cubeMap3, normalize(v_texCoord));\n    color2 = vec4(czm_gammaCorrect(color2).rgb, czm_morphTime);\n    fragColor = mix(color, color2, u_select - 1.0);\n  }\n  gl_FragColor = fragColor;\n}\n"; // eslint-disable-line

  var MultipleSkyBoxVS = "attribute vec3 position;\nvarying vec3 v_texCoord;\nuniform mat3 u_rotateMatrix;\n\nvoid main() {\n  vec3 p = czm_viewRotation * u_rotateMatrix * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));\n  gl_Position = czm_projection * vec4(p, 1.0);\n  v_texCoord = position.xyz;\n}\n"; // eslint-disable-line

  /**
   * 3个天空盒（可以平滑过度）, 在场景周围绘制星星等太空背景。
   * 天空盒子是用真正的赤道平均春分点(TEME)轴定义的。仅在3D中支持。当转换为2D或哥伦布视图时，天空盒会淡出。
   * 天空盒子的大小不能超过{@link Cesium.Scene#maximumCubeMapSize}。
   *
   * @param {Object} options 对象，具有以下属性:
   * @param {Object} [options.sources] 天空盒的6个立方体映射面的图片url
   * @param {String} [options.sources.positiveX] 映射面的图片url
   * @param {String} [options.sources.negativeX] 映射面的图片url
   * @param {String} [options.sources.positiveY] 映射面的图片url
   * @param {String} [options.sources.negativeY] 映射面的图片url
   * @param {String} [options.sources.positiveZ] 映射面的图片url
   * @param {String} [options.sources.negativeZ] 映射面的图片url
   *
   * @param {Object} [options.sources2] 天空盒的6个立方体映射面的图片url
   * @param {String} [options.sources2.positiveX] 映射面的图片url
   * @param {String} [options.sources2.negativeX] 映射面的图片url
   * @param {String} [options.sources2.positiveY] 映射面的图片url
   * @param {String} [options.sources2.negativeY] 映射面的图片url
   * @param {String} [options.sources2.positiveZ] 映射面的图片url
   * @param {String} [options.sources2.negativeZ] 映射面的图片url
   *
   * @param {Object} [options.sources3] 天空盒的6个立方体映射面的图片url
   * @param {String} [options.sources3.positiveX] 映射面的图片url
   * @param {String} [options.sources3.negativeX] 映射面的图片url
   * @param {String} [options.sources3.positiveY] 映射面的图片url
   * @param {String} [options.sources3.negativeY] 映射面的图片url
   * @param {String} [options.sources3.positiveZ] 映射面的图片url
   * @param {String} [options.sources3.negativeZ] 映射面的图片url
   *
   * @param {Number} [options.select=0.0] 当前选择生效的天空盒，取值范围：0.0-2.0 , 当为 0 时显示sources、为 1 时显示sources2、为 2 时显示sources3，中间值过渡
   * @param {Boolean} [options.show=true] 是否显示
   *
   * @export
   * @class MultipleSkyBox
   * @extends {Cesium.SkyBox}
   * @example
    map.scene.skyBox = new mars3d.MultipleSkyBox({
      sources: {
        positiveX: "./img/skybox/1/px.png",
        negativeX: "./img/skybox/1/nx.png",
        positiveY: "./img/skybox/1/pz.png",
        negativeY: "./img/skybox/1/nz.png",
        positiveZ: "./img/skybox/1/py.png",
        negativeZ: "./img/skybox/1/ny.png",
      },
      sources2: {
        positiveX: "./img/skybox/2/px.png",
        negativeX: "./img/skybox/2/nx.png",
        positiveY: "./img/skybox/2/pz.png",
        negativeY: "./img/skybox/2/nz.png",
        positiveZ: "./img/skybox/2/py.png",
        negativeZ: "./img/skybox/2/ny.png",
      },
      sources3: {
        positiveX: "./img/skybox/3/px.png",
        negativeX: "./img/skybox/3/nx.png",
        positiveY: "./img/skybox/3/pz.png",
        negativeY: "./img/skybox/3/nz.png",
        positiveZ: "./img/skybox/3/py.png",
        negativeZ: "./img/skybox/3/ny.png",
      },
    });
   */
  class MultipleSkyBox extends Cesium__namespace.SkyBox {
    constructor(options) {
      super(options);

      this.sources2 = options.sources2;
      this.sources3 = options.sources3;
      this._sources2 = undefined;
      this._sources3 = undefined;
      this._cubeMap2 = undefined;
      this._cubeMap3 = undefined;
      this._skyboxMatrix3 = new Cesium__namespace.Matrix3();

      /**
       * 当前选择生效的天空盒，取值范围：0.0-2.0, 当为 0 时显示sources、为 1 时显示sources2、为 2 时显示sources3，中间值过渡
       * @type {Number}
       * @default 0.0
       */
      this.select = options.select || 0.0;
    }

    // 内部渲染的方法
    update (frameState, useHdr) {
      const that = this;

      if (!this.show) {
        return undefined
      }

      if (frameState.mode !== Cesium__namespace.SceneMode.SCENE3D && frameState.mode !== Cesium__namespace.SceneMode.MORPHING) {
        return undefined
      }

      if (!frameState.passes.render) {
        return undefined
      }

      const context = frameState.context;

      if (this._sources !== this.sources) {
        this._sources = this.sources;
        const sources = this.sources;

        this._sources2 = this.sources2;
        const sources2 = this.sources2;

        this._sources3 = this.sources3;
        const sources3 = this.sources3;

        if (
          !Cesium__namespace.defined(sources.positiveX) ||
          !Cesium__namespace.defined(sources.negativeX) ||
          !Cesium__namespace.defined(sources.positiveY) ||
          !Cesium__namespace.defined(sources.negativeY) ||
          !Cesium__namespace.defined(sources.positiveZ) ||
          !Cesium__namespace.defined(sources.negativeZ)
        ) {
          throw new Cesium__namespace.DeveloperError(
            "this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties."
          )
        }

        if (
          typeof sources.positiveX !== typeof sources.negativeX ||
          typeof sources.positiveX !== typeof sources.positiveY ||
          typeof sources.positiveX !== typeof sources.negativeY ||
          typeof sources.positiveX !== typeof sources.positiveZ ||
          typeof sources.positiveX !== typeof sources.negativeZ
        ) {
          throw new Cesium__namespace.DeveloperError("this.sources properties must all be the same type.")
        }

        if (typeof sources.positiveX === "string") {
          // Given urls for cube-map images.  Load them.
          Cesium__namespace.loadCubeMap(context, this._sources).then(function (cubeMap) {
            that._cubeMap = that._cubeMap && that._cubeMap.destroy();
            that._cubeMap = cubeMap;
          });
          Cesium__namespace.loadCubeMap(context, this._sources2).then(function (cubeMap2) {
            that._cubeMap2 = that._cubeMap2 && that._cubeMap2.destroy();
            that._cubeMap2 = cubeMap2;
          });
          Cesium__namespace.loadCubeMap(context, this._sources3).then(function (cubeMap3) {
            that._cubeMap3 = that._cubeMap3 && that._cubeMap3.destroy();
            that._cubeMap3 = cubeMap3;
          });
        } else {
          this._cubeMap = this._cubeMap && this._cubeMap.destroy();
          this._cubeMap = new Cesium__namespace.CubeMap({
            context: context,
            source: sources
          });

          this._cubeMap2 = this._cubeMap2 && this._cubeMap2.destroy();
          this._cubeMap2 = new Cesium__namespace.CubeMap({
            context: context,
            source: sources2
          });

          this._cubeMap3 = this._cubeMap3 && this._cubeMap3.destroy();
          this._cubeMap3 = new Cesium__namespace.CubeMap({
            context: context,
            source: sources3
          });
        }
      }

      const command = this._command;

      command.modelMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(frameState.camera._positionWC);
      if (!Cesium__namespace.defined(command.vertexArray)) {
        command.uniformMap = {
          u_cubeMap: function () {
            return that._cubeMap
          },
          u_cubeMap2: function () {
            return that._cubeMap2
          },
          u_cubeMap3: function () {
            return that._cubeMap3
          },
          u_select: () => {
            return this.select
          },
          u_rotateMatrix: () => {
            // return Cesium.Matrix4.getRotation(command.modelMatrix, this._skyboxMatrix3)
            command.modelMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(frameState.camera._positionWC);
            return Cesium__namespace.Matrix4.getMatrix3(command.modelMatrix, this._skyboxMatrix3)
          }
        };

        const geometry = Cesium__namespace.BoxGeometry.createGeometry(
          Cesium__namespace.BoxGeometry.fromDimensions({
            dimensions: new Cesium__namespace.Cartesian3(2.0, 2.0, 2.0),
            vertexFormat: Cesium__namespace.VertexFormat.POSITION_ONLY
          })
        );
        const attributeLocations = (this._attributeLocations = Cesium__namespace.GeometryPipeline.createAttributeLocations(geometry));

        command.vertexArray = Cesium__namespace.VertexArray.fromGeometry({
          context: context,
          geometry: geometry,
          attributeLocations: attributeLocations,
          bufferUsage: Cesium__namespace.BufferUsage._DRAW
        });

        command.renderState = Cesium__namespace.RenderState.fromCache({
          blending: Cesium__namespace.BlendingState.ALPHA_BLEND
        });
      }

      if (!Cesium__namespace.defined(command.shaderProgram) || this._useHdr !== useHdr) {
        const fs = new Cesium__namespace.ShaderSource({
          defines: [useHdr ? "HDR" : ""],
          sources: [MultipleSkyBoxFS]
        });
        command.shaderProgram = Cesium__namespace.ShaderProgram.fromCache({
          context: context,
          vertexShaderSource: MultipleSkyBoxVS,
          fragmentShaderSource: fs,
          attributeLocations: this._attributeLocations
        });
        this._useHdr = useHdr;
      }

      if (!Cesium__namespace.defined(this._cubeMap)) {
        return undefined
      }
      if (!Cesium__namespace.defined(this._cubeMap2)) {
        return undefined
      }
      if (!Cesium__namespace.defined(this._cubeMap3)) {
        return undefined
      }
      return command
    };

    isDestroyed () {
      return false
    }

    destroy () {
      const command = this._command;
      command.vertexArray = command.vertexArray && command.vertexArray.destroy();
      command.shaderProgram = command.shaderProgram && command.shaderProgram.destroy();

      this._cubeMap = this._cubeMap && this._cubeMap.destroy();
      this._cubeMap2 = this._cubeMap2 && this._cubeMap2.destroy();
      this._cubeMap3 = this._cubeMap3 && this._cubeMap3.destroy();
      return this.destroyObject(this)
    }

  }

  /**
   * 局部坐标系 与 世界坐标系 转换控制类
   *
   * @param {Cesium.Cartesian3} center 局部坐标的中心点对应的世界坐标
   * @param {Cesium.Transforms.LocalFrameToFixedFrame} [fixedFrameTransform] 局部坐标系的轴方向
   * @export
   * @class LocalWorldTransform
   */
  class LocalWorldTransform {
    constructor(center, fixedFrameTransform) {
      fixedFrameTransform = fixedFrameTransform || Cesium__namespace.Transforms.eastNorthUpToFixedFrame;

      this._matrix = fixedFrameTransform(center);
      this._inverseMatrix = Cesium__namespace.Matrix4.inverseTransformation(this._matrix, new Cesium__namespace.Matrix4());
    }

    /**
     * 局部坐标 转换成对应的 世界坐标
     *
     * @param {Cesium.Cartesian3} localPoint 局部坐标
     * @param {Cesium.Cartesian3} [result] 世界坐标
     * @return {Cesium.Cartesian3} 世界坐标
     */
    localToWorld(localPoint, result) {
      if (!result) {
        result = new Cesium__namespace.Cartesian3();
      }
      Cesium__namespace.Matrix4.multiplyByPoint(this._matrix, localPoint, result);
      return result
    }

    /**
     * 世界坐标 转换成对应的 局部坐标
     *
     * @param {Cesium.Cartesian3} worldPoint 世界坐标
     * @param {Cesium.Cartesian3} [result] 局部坐标
     * @return {Cesium.Cartesian3} 局部坐标
     */
    worldToLocal(worldPoint, result) {
      if (!result) {
        result = new Cesium__namespace.Cartesian3();
      }
      Cesium__namespace.Matrix4.multiplyByPoint(this._inverseMatrix, worldPoint, result);
      return result
    }
  }

  /**
   * 国内偏移坐标系 枚举
   *  @enum {String}
   */
  const ChinaCRS = {
    /**
     * 标准无偏坐标系
     */
    WGS84: "WGS84",
    /**
     * 国测局(GCJ02)偏移坐标系
     */
    GCJ02: "GCJ02",
    /**
     * 百度(BD09) 偏移坐标系
     */
    BAIDU: "BD09"
  };

  /**
   * SDK中涉及到的所有第3方地图服务的Token令牌key，
   * 【重要提示：为了避免后期失效，请全部重新赋值换成自己的key】
   * @module Token
   */

  /**
   * Cesium官方的Ion服务key，
   * 官网： {@link https://cesium.com/ion/signin/}
   * @type {String}
   * @constant
   *
   * @see IonLayer
   * @see TerrainLayer
   */
  let ion =
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlZDJjMTcwNS04ZDVmLTQzNWQtYWUyZC0yMTJkMDkyMzkyMjMiLCJpZCI6MTQ4MiwiaWF0IjoxNjQ4NDQ2OTIwfQ.7e1QUkx_k-mZBxKz9tV8a5TFEorrlLlkfcVNNPzfTQY";

  /**
   * 更新Cesium官方的Ion服务key
   * @param {String} item token值
   * @return {void}
   */
  function updateIon(item) {
    ion = item;
    Cesium__namespace.Ion.defaultAccessToken = item;
  }

  /**
   * mapbox地图key，
   * 官网：{@link https://account.mapbox.com}
   * @type {String}
   * @constant
   *
   * @see MapboxLayer
   */
  let mapbox = "sk.eyJ1IjoibWFyc2dpcyIsImEiOiJjbDFhYXQ3a2EwaHF6M2NvdnhmdjR6ajZ2In0.-sahm9R0QuPP3pAihJHC4A";

  /**
   * 更新mapbox地图key
   * @param {String} item token值
   * @return {void}
   */
  function updateMapbox(item) {
    mapbox = item;
  }

  /**
   * 微软Bing地图key，
   * 官网： {@link https://www.bingmapsportal.com/Application}
   * @type {String}
   * @constant
   *
   * @see BingLayer
   */
  let bing = "Am5SdKm6pNdkP1P5zuUOMZwleCHeA7GD5vuQgZ3xBUbEMBeQ5cQ1WN4B8xqqV1Vt";

  /**
   * 更新微软Bing地图key
   * @param {String} item token值
   * @return {void}
   */
  function updateBing(item) {
    bing = item;
  }

  /**
   * 天地图key数组，
   * 官网： {@link https://console.tianditu.gov.cn/api/key}
   * @type {String[]}
   * @constant
   *
   * @see TdtLayer
   * @see TdtDmLayer
   * @see TdtTerrainProvider
   */
  const tiandituArr = ["789e558be762ff832392a0393fd8a4f1"];

  /**
   * 天地图key，
   * @type {String}
   * @constant
   *
   * @see TdtLayer
   * @see TdtDmLayer
   * @see TdtTerrainProvider
   */
  let tianditu = tiandituArr[0];

  /**
   * 更新天地图key
   * @param {String|String[]} item token值
   * @return {void}
   */
  function updateTianditu(item) {
    tiandituArr.splice(0, tiandituArr.length);

    if (Array.isArray(item)) {
      item.forEach((element) => {
        tiandituArr.push(element);
      });
    } else {
      tiandituArr.push(item);
    }
    tianditu = tiandituArr[0];
  }

  /**
   * 高德key数组，
   * 官网： {@link https://console.amap.com/dev/key/app}
   * @type {String[]}
   * @constant
   *
   * @see GaodePOI
   * @see GaodeRoute
   * @see GeodePoiLayer
   * @see GaodePOIGeocoder
   */
  const gaodeArr = ["616e615727a1134331ff9459856653f1"];

  /**
   * 高德key，
   * @type {String}
   * @constant
   *
   * @see GaodePOI
   * @see GaodeRoute
   * @see GeodePoiLayer
   * @see GaodePOIGeocoder
   */
  let gaode = gaodeArr[0];

  /**
   * 更新高德key
   * @param {String|String[]} item token值
   * @return {void}
   */
  function updateGaode(item) {
    gaodeArr.splice(0, gaodeArr.length);

    if (Array.isArray(item)) {
      item.forEach((element) => {
        gaodeArr.push(element);
      });
    } else {
      gaodeArr.push(item);
    }
    gaode = gaodeArr[0];
  }

  /**
   * 百度key数组，
   * 官网： {@link http://lbsyun.baidu.com/apiconsole/key#/home}
   * @type {String[]}
   * @constant
   *
   * @see BaiduPOI
   */
  const baiduArr = ["LvhIlDXT60I3NePicXWQT5K0eHFCR4hD"];

  /**
   * 百度key，
   * @type {String}
   * @constant
   *
   * @see BaiduPOI
   */
  let baidu = baiduArr[0];

  /**
   * 更新百度key
   * @param {String|String[]} item token值
   * @return {void}
   */
  function updateBaidu(item) {
    baiduArr.splice(0, baiduArr.length);

    if (Array.isArray(item)) {
      item.forEach((element) => {
        baiduArr.push(element);
      });
    } else {
      baiduArr.push(item);
    }
    baidu = baiduArr[0];
  }

  /**
   * 更新所有SDK涉及的第3放Token值（如果具体使用类中传入时，已传入值优先）
   * @param {Object} token 集合
   * @param {String|String[]} [token.tianditu] 天地图
   * @param {String|String[]} [token.gaode] 高德
   * @param {String|String[]} [token.baidu] 百度
   * @param {String} [token.ion] Ion服务
   * @param {String} [token.mapbox] mapbox地图
   * @param {String} [token.bing] 微软Bing地图
   * @return {void}
   */
  function updateAll(token) {
    if (token.tianditu) {
      updateTianditu(token.tianditu);
    }
    if (token.gaode) {
      updateGaode(token.gaode);
    }
    if (token.baidu) {
      updateBaidu(token.baidu);
    }
    if (token.ion) {
      updateIon(token.ion);
    }
    if (token.mapbox) {
      updateMapbox(token.mapbox);
    }
    if (token.bing) {
      updateBing(token.bing);
    }
  }

  var Token = {
    __proto__: null,
    get ion () { return ion; },
    updateIon: updateIon,
    get mapbox () { return mapbox; },
    updateMapbox: updateMapbox,
    get bing () { return bing; },
    updateBing: updateBing,
    tiandituArr: tiandituArr,
    get tianditu () { return tianditu; },
    updateTianditu: updateTianditu,
    gaodeArr: gaodeArr,
    get gaode () { return gaode; },
    updateGaode: updateGaode,
    baiduArr: baiduArr,
    get baidu () { return baidu; },
    updateBaidu: updateBaidu,
    updateAll: updateAll
  };

  /**
   * 材质 类型枚举
   * @module MaterialType
   * @example
  //Entity矢量对象
  let graphic = new mars3d.graphic.PolylineEntity({
    positions: [
      [117.169646, 31.769171],
      [117.194579, 31.806466],
    ],
    style: {
      width: 5,
      material: mars3d.MaterialUtil.createMaterialProperty(mars3d.MaterialType.LineFlow, {
        color: '#00ff00',
        image: 'img/textures/line-pulse.png',
        speed: 5,
      }),
    },
  })
  graphicLayer.addGraphic(graphic)

  //Primitive矢量对象
  var primitive = new mars3d.graphic.PolylinePrimitive({
    positions: [
      [117.348938, 31.805369, 7.63],
      [117.429496, 31.786715, 8.41],
    ],
    style: {
      width: 5,
      material: mars3d.MaterialUtil.createMaterial(mars3d.MaterialType.LineFlow, {
        color: '#1a9850',
        image: 'img/textures/line-arrow.png',
        speed: 10,
      }),
    },
  })
  graphicLayer.addGraphic(primitive)
   *
   */

  /// ///////////////////////////////////////////////

  /**
   * 通用：纯色颜色 ，也是默认的材质
   * @type {String}
   * @constant
   * @readonly
   * @property {Cesium.Color}  [color=Cesium.Color.WHITE] 颜色
   *
   * @see Cesium.Material.ColorType
   * @see Cesium.ColorMaterialProperty
   */
  const Color$2 = Cesium__namespace.Material.ColorType;

  /// ///////////////////////////////////////////////

  /**
   * 线：虚线
   * @type {String}
   * @constant
   * @readonly
   * @property {Cesium.Color} [color=Cesium.Color.WHITE] 颜色
   * @property {Cesium.Color} [gapColor=Cesium.Color.TRANSPARENT] 虚线间隔颜色，默认为透明
   * @property {Number} [dashLength=16.0] 虚线间隔长度，以像素为单位
   * @property {Number} [dashPattern=255.0] 指定的16位模式
   *
   * @see Cesium.Material.PolylineDashType
   * @see Cesium.PolylineDashMaterialProperty
   */
  const PolylineDash = Cesium__namespace.Material.PolylineDashType;

  /**
   * 线：衬色线
   * @type {String}
   * @constant
   * @readonly
   * @property {Cesium.Color} [color=Cesium.Color.WHITE] 主颜色
   * @property {Cesium.Color} [outlineColor=Cesium.Color.BLACK] 衬色颜色
   * @property {Number} [outlineWidth=1.0] 衬色宽度，以像素为单位
   *
   *
   * @see Cesium.Material.PolylineOutlineType
   * @see Cesium.PolylineOutlineMaterialProperty
   */
  const PolylineOutline = Cesium__namespace.Material.PolylineOutlineType;

  /**
   * 线：箭头
   * @type {String}
   * @constant
   * @readonly
   * @property {Cesium.Color}  [color=Cesium.Color.WHITE] 颜色
   *
   * @see Cesium.Material.PolylineArrowType
   * @see Cesium.PolylineArrowMaterialProperty
   */
  const PolylineArrow = Cesium__namespace.Material.PolylineArrowType;

  /**
   * 线：高亮线
   * @type {String}
   * @constant
   * @readonly
   * @property {Cesium.Color} [color=Cesium.Color.WHITE] 颜色
   * @property {Number} [glowPower=0.25] 高亮强度,占总线宽的百分比表示。
   * @property {Number} [taperPower=1.0] 渐变效果强度,占总行长的百分比表示。如果1.0或更高，则不使用锥度效应。
   *
   *
   * @see Cesium.Material.PolylineGlowType
   * @see Cesium.PolylineGlowMaterialProperty
   */
  const PolylineGlow = Cesium__namespace.Material.PolylineGlowType;

  /**
   * 线状: 流动图片（适用于线和墙）
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {String} image 背景图片URL
   * @property {Cesium.Color} [color=new Cesium.Color(1, 0, 0, 1.0)] 背景图片颜色
   * @property {Cesium.Cartesian2} [repeat=new Cesium.Cartesian2(1.0, 1.0)] 横纵方向重复次数
   * @property {Number} [speed=10] 速度，值越大越快
   * @property {Boolean} [axisY=false] 是否Y轴朝上
   * @property {Boolean} [hasImage2=false] 是否有2张图片的混合模式
   * @property {String} [image2=Cesium.Material.DefaultImageId] 第2张背景图片URL地址
   * @property {Cesium.Color} [color2=new Cesium.Color(1, 1, 1)] 第2张背景图片颜色
   *
   * @see mars3d.MaterialType.LineFlow
   * @see LineFlowMaterialProperty
   */
  const LineFlow = "LineFlow";

  /**
   * 线状: 流动颜色
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
   * @property {Number} [speed=2] 速度，值越大越快
   * @property {Number} [percent=0.04] 比例
   * @property {Number} [alpha=0.1] 透明程度 0.0-1.0
   * @property {Number} [startTime=0] 开始的时间
   *
   * @see mars3d.MaterialType.LineFlowColor
   * @see LineFlowColorMaterialProperty
   */
  const LineFlowColor = "LineFlowColor";

  /**
   * 线状: OD线
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color=new Cesium.Color(1, 0, 0, 1.0)] 运动对象的颜色
   * @property {Cesium.Color} [bgColor] 线的背景颜色
   * @property {Number} [speed=20] 速度，值越大越快
   * @property {Number} [startTime=0] 开始的时间
   * @property {Number} [bidirectional=0]  运行形式,可选值：0 正向运动 1 反向运动 2 双向运动
   *
   * @see mars3d.MaterialType.ODLine
   * @see ODLineMaterialProperty
   */
  const ODLine = "ODLine";

  /**
   * 线状: 闪烁线
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color=new Cesium.Color(1.0, 0.0, 0.0, 0.7)] 线颜色
   * @property {Number} [speed=10] 速度，值越大越快
   *
   * @see mars3d.MaterialType.LineFlicker
   * @see LineFlickerMaterialProperty
   */
  const LineFlicker = "LineFlicker";

  /**
   * 线状: 轨迹线
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color=new Cesium.Color(1.0, 0.0, 0.0, 0.7)] 线颜色
   * @property {Number} [speed=5.0] 速度，值越大越快
   *
   * @see mars3d.MaterialType.LineTrail
   * @see LineTrailMaterialProperty
   */
  const LineTrail = "LineTrail";

  /**
   * 线状: 泛光线
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color= Cesium.Color.ORANGE] 泛光颜色
   * @property {Number} [glow=1.0] 泛光强度
   * @property {Number} [speed=5.0] 速度，值越大越快
   *
   * @see mars3d.MaterialType.LineBloom
   * @see LineBloomMaterialProperty
   */
  const LineBloom = "LineBloom";

  /**
   * 线状: 数字流动线
   * @type {String}
   * @constant
   * @readonly
   * @property {String} image 背景图片URL
   * @property {Cesium.Color} [color=new Cesium.Color(1, 0, 0, 1.0)] 背景图片颜色
   * @property {Number} [speed=10] 速度，值越大越快
   * @property {Number} [glow=10.0] 高亮强度
   * @property {Number} [flowGlow=1.0] 流动高亮强度
   * @property {Number} [segment=3.0] 分段数
   *
   *
   * @see mars3d.MaterialType.DigitalFlow
   * @see DigitalFlowMaterialProperty
   */
  const DigitalFlow = "DigitalFlow";

  /// /////////////////墙体独有////////////////////////////
  /**
   * 墙体: 走马灯效果
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {String} [image=Cesium.Material.DefaultImageId] 背景图片URL
   * @property {Cesium.Color} [color=new Cesium.Color(1.0, 0.0, 0.0, 0.7)] 颜色
   * @property {Number} [count=1] 数量
   * @property {Number} [speed=5.0] 速度，值越大越快
   * @property {Boolean} [reverse=false] 方向往上，false是往下，true是往上
   * @property {Boolean} [bloom=false] 是否泛光
   * @property {Boolean} [axisY=false] 是否Y轴朝上
   *
   * @see mars3d.MaterialType.WallScroll
   * @see WallScrollMaterialProperty
   */
  const WallScroll = "WallScroll";

  /// /////////////////面状////////////////////////////

  /**
   * 面状：图片
   * @type {String}
   * @constant
   * @readonly
   * @property {String|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image 图片对象或图片地址
   * @property {Cesium.Cartesian2} [repeat=new Cesium.Cartesian2(1.0, 1.0)] 指定图像在每个方向上重复的次数
   * @property {Cesium.Color} [color=Cesium.Color.WHITE] 应用于图像的颜色，也可以使用白色来控制透明度
   * @property {Boolean} [transparent=false] 当图像具有透明度时设置为true (例如当png具有透明部分时)
   *
   * @see Cesium.Material.ImageType
   * @see Cesium.ImageMaterialProperty
   */
  const Image$1 = Cesium__namespace.Material.ImageType;


  /**
   * 面状：图片2 (没有加载完成前的白色闪烁，但也不支持纯白色的图片)
   * @type {String}
   * @constant
   * @readonly
   * @property {String|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image 图片对象或图片地址
   * @property {Number} [opacity=1.0] 透明度
   * @property {Cesium.Color} [color= Cesium.Color.WHITE] 颜色
   *
   * @see mars3d.MaterialType.Image2
   * @see Image2MaterialProperty
   */
  const Image2 = "Image2";

  /**
   * 面状: 文字贴图
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {String} text 文本内容
   * @property {String} [font_family = "楷体"] 字体, 可选项：微软雅黑,宋体,楷体,隶书,黑体 等
   * @property {Number} [font_size = 30] 字体大小
   * @property {String} [font_weight = "normal"] 是否加粗, 可选项：bold (解释：是),normal (解释：否)
   * @property {String} [font_style = "normal"] 是否斜体, 可选项：italic (解释：是),normal (解释：否)
   * @property {string} [font='30px normal normal 楷体'] 上叙4个属性的一次性指定CSS字体的属性
   * @property {Cesium.Color} [color=new Cesium.Color(1.0, 1.0, 0.0, 1.0)] 文本颜色
   * @property {Boolean} [stroke=true] 是否描边文本
   * @property {Cesium.Color} [strokeColor=new Cesium.Color(1.0, 1.0, 1.0, 0.8)] 描边的颜色
   * @property {Number} [strokeWidth=2] 描边的宽度
   * @property {Cesium.Color} [backgroundColor=new Cesium.Color(1.0, 1.0, 1.0, 0.1)] 画布的背景色
   * @property {Number} [padding=10] 要在文本周围添加的填充的像素大小
   * @property {String} [textBaseline='top'] 文本的基线
   *
   * @see TextMaterial
   * @see TextMaterialProperty
   */
  const Text = "Text";

  /**
   * 面状：网格
   * @type {String}
   * @constant
   * @readonly
   * @property {Cesium.Color} [color=Cesium.Color.WHITE] 网格颜色
   * @property {Number} [cellAlpha=0.1] 填充透明度
   * @property {Cesium.Cartesian2} [lineCount=new Cesium.Cartesian2(8, 8)] 网格线的数量
   * @property {Cesium.Cartesian2} [lineThickness=new Cesium.Cartesian2(1.0, 1.0)]  网格宽度
   * @property {Cesium.Cartesian2} [lineOffset=new Cesium.Cartesian2(0.0, 0.0)] 偏移量，沿每个轴的起始偏移量
   *
   * @see Cesium.Material.GridType
   * @see Cesium.GridMaterialProperty
   */
  const Grid = Cesium__namespace.Material.GridType;

  /**
   * 面状：棋盘
   * @type {String}
   * @constant
   * @readonly
   * @property {Cesium.Color} [lightColor=Cesium.Color.WHITE] 主色
   * @property {Cesium.Color} [darkColor=Cesium.Color.BLACK] 衬色，棋盘中另外一个颜色
   * @property {Cesium.Cartesian2} [repeat=new Cesium.Cartesian2(2.0, 2.0)] 数量，在每个方向重复的次数
   *
   * @see Cesium.Material.CheckerboardType
   * @see Cesium.CheckerboardMaterialProperty
   */
  const Checkerboard = Cesium__namespace.Material.CheckerboardType;

  /**
   * 面状：条纹
   * @type {String}
   * @constant
   * @readonly
   * @property {Cesium.Color} [evenColor=Cesium.Color.WHITE] 主色
   * @property {Cesium.Color} [oddColor=Cesium.Color.BLACK] 衬色，条纹中另外一个颜色
   * @property {Number} [repeat=1] 数量，条纹重复的次数
   * @property {Cesium.StripeOrientation} [orientation=Cesium.StripeOrientation.HORIZONTAL] 条纹方向,横向还是纵向
   * @property {Number} [offset=0] 起始位置
   *
   * @see Cesium.Material.StripeType
   * @see Cesium.StripeMaterialProperty
   */
  const Stripe = Cesium__namespace.Material.StripeType;

  /**
   * 面状： 渐变面
   * @type {String}
   * @constant
   * @readonly
   * @property {Cesium.Color} [color=new Cesium.Color(1.0, 1.0, 0.0, 0.5)] 颜色
   * @property {Number} [alphaPower=1.5] 透明度系数
   * @property {Number} [diffusePower=1.6] 漫射系数
   * @property {Cesium.Cartesian2} [center=new Cesium.Cartesian2(0.5, 0.5)] 渐变位置，默认在中心
   *
   * @see mars3d.MaterialType.PolyGradient
   * @see PolyGradientMaterialProperty
   */
  const PolyGradient = "PolyGradient";

  /**
   * 面状： 柏油路面效果
   * @type {String}
   * @constant
   * @readonly
   * @property {Cesium.Color} [color=new Cesium.Color(0.15, 0.15, 0.15, 1.0)] 沥青的颜色
   * @property {Number} [size=0.02] 块大小
   * @property {Number} [frequency=0.2] 粗糙度
   *
   * @see mars3d.MaterialType.PolyAsphalt
   * @see PolyAsphaltMaterialProperty
   */
  const PolyAsphalt = "PolyAsphalt";

  /**
   *  面状：混合
   * @type {String}
   * @constant
   * @readonly
   * @property {Cesium.Color} [evenColor=new Cesium.Color(1.0, 1.0, 1.0, 0.5)] 浅色的颜色
   * @property {Cesium.Color} [oddColor= new Cesium.Color(0.0, 0.0, 1.0, 0.5)] 深色的颜色
   * @property {Number} [frequency=10.0] 频率
   *
   * @see mars3d.MaterialType.PolyBlob
   * @see PolyBlobMaterialProperty
   */
  const PolyBlob = "PolyBlob";

  /**
   * 面状：碎石面
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [evenColor=new Cesium.Color(0.25, 0.25, 0.25, 0.75)] 浅色的颜色
   * @property {Cesium.Color} [oddColor= new Cesium.Color(0.75, 0.75, 0.75, 0.75)] 深色的颜色
   * @property {Number} [frequency=10.0] 频率
   *
   * @see mars3d.MaterialType.PolyFacet
   * @see PolyFacetMaterialProperty
   */
  const PolyFacet = "PolyFacet";

  /**
   * 面状：草地面
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [evenColor=new Cesium.Color(0.25, 0.4, 0.1, 1.0)] 草地的颜色
   * @property {Cesium.Color} [oddColor= new Cesium.Color(0.1, 0.1, 0.1, 1.0)] 泥土的颜色
   * @property {Number} [frequency=1.5] 斑块分布
   *
   * @see mars3d.MaterialType.PolyGrass
   * @see PolyGrassMaterialProperty
   */
  const PolyGrass = "PolyGrass";

  /**
   *  面状：木材面
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [evenColor=new Cesium.Color(0.6, 0.3, 0.1, 1.0)] 浅色的颜色
   * @property {Cesium.Color} [oddColor= new Cesium.Color(0.4, 0.2, 0.07, 1.0)] 深色的颜色
   * @property {Number} [frequency=3.0] 环频率
   * @property {Cesium.Cartesian2} [noiseScale= new Cesium.Cartesian2(0.7, 0.5)] 噪波比例
   * @property {Number} [grainFrequency=27.0] 颗粒的频率
   *
   * @see mars3d.MaterialType.PolyWood
   * @see PolyWoodMaterialProperty
   */
  const PolyWood = "PolyWood";

  /**
   * 面状: 霓虹灯材质
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color= new Cesium.Color(2, 1, 0.0, 0.8)] 颜色
   * @property {Number} [repeat=30] 圈数量
   * @property {Number} [frameRate=60] 每秒刷新次数
   *
   * @see mars3d.MaterialType.NeonLight
   * @see NeonLightMaterialProperty
   */
  const NeonLight = "NeonLight";

  /**
   * 面状：水面材质
   * @type {String}
   * @constant
   * @readonly
   * @property {String}  specularMap 图片路径，镜面反射纹理材质图片
   * @property {String}  [normalMap=Cesium.Material.DefaultImageId] 图片路径，水正常扰动的法线图材质图片
   * @property {Cesium.Color}  [baseWaterColor=new Cesium.Color(0.2, 0.3, 0.6, 1.0)] 基础颜色
   * @property {Cesium.Color}  [blendColor=new Cesium.Color(0.0, 1.0, 0.699, 1.0)] 混合颜色，从水中混合到非水域时使用的rgba颜色对象
   * @property {Number}  [frequency=100] 波数
   * @property {Number}  [animationSpeed=0.01] 动画速度
   * @property {Number}  [amplitude=10] 水波振幅
   * @property {Number}  [specularIntensity=0.5] 镜面反射强度
   * @property {Number}  [fadeFactor=1.0] 衰减因子
   *
   * @see Cesium.Material.WaterType
   * @see WaterMaterialProperty
   */
  const Water$1 = Cesium__namespace.Material.WaterType;

  /**
   * 面状：带蓝色光线波纹的水面材质
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {String}  specularMap 图片路径，镜面反射纹理材质图片
   * @property {String}  [normalMap=Cesium.Material.DefaultImageId] 图片路径，水正常扰动的法线图材质图片
   * @property {Number} [alpha=0.2] 透明度
   *
   * @see mars3d.MaterialType.WaterLight
   * @see WaterLightMaterialProperty
   */
  const WaterLight = "WaterLight";

  /// /////////////////矩形////////////////////////////

  /**
   * 矩形面： 轮播图
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {String} image 图片URL
   * @property {Cesium.Color} [color=Cesium.Color.WHITE] 颜色和透明度
   * @property {Number} [speed=10] 速度，值越大越快
   * @property {Boolean} [pure=false] 是否纯色
   *
   * @see mars3d.MaterialType.RectSlide
   * @see RectSlideMaterialProperty
   */
  const RectSlide = "RectSlide";

  /// /////////////////圆形////////////////////////////

  /**
   * 圆形: 放大扩散线
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color=new Cesium.Color(1.0, 1.0, 0.0, 1.0)] 扫描线颜色
   * @property {Number} [speed=10] 扫描速度，值越大越快
   *
   * @see mars3d.MaterialType.ScanLine
   * @see ScanLineMaterialProperty
   */
  const ScanLine = "ScanLine";

  /**
   * 圆形: 扫描半径
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {String} image 扫描图片URL地址
   * @property {Cesium.Color} [color=new Cesium.Color(1.0, 0.0, 0.0, 1.0)] 颜色
   *
   * @see mars3d.MaterialType.CircleScan
   * @see CircleScanMaterialProperty
   */
  const CircleScan = "CircleScan";

  /**
   * 圆形: 波纹扩散
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color=new Cesium.Color(1.0, 1.0, 0.0, 1.0)] 颜色
   * @property {Number} [speed=10] 速度，值越大越快
   * @property {Number} [count=1] 圆圈个数
   * @property {Number} [gradient=0.1] 透明度的幂方（0-1）,0表示无虚化效果，1表示虚化成均匀渐变
   *
   * @see mars3d.MaterialType.CircleWave
   * @see CircleWaveMaterialProperty
   */
  const CircleWave = "CircleWave";

  /**
   * 圆形: 雷达线 (圆+旋转半径线)
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color=new Cesium.Color(0.0, 1.0, 1.0, 0.7)] 颜色
   * @property {Number} [speed=5.0] 速度，值越大越快
   *
   * @see mars3d.MaterialType.RadarLine
   * @see RadarLineMaterialProperty
   */
  const RadarLine = "RadarLine";

  /**
   * 圆形: 波纹雷达扫描
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color=new Cesium.Color(0.0, 1.0, 1.0, 0.7)] 颜色
   * @property {Number} [speed=5.0] 速度，值越大越快
   *
   * @see mars3d.MaterialType.RadarWave
   * @see RadarWaveMaterialProperty
   */
  const RadarWave = "RadarWave";

  /// /////////////////圆锥////////////////////////////

  /**
   * 圆锥: 条纹扩散
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color= new Cesium.Color(2, 1, 0.0, 0.8)] 颜色
   * @property {Number} [repeat=30] 圈数量
   * @property {Number} [thickness=0.3] 圈的宽度比例
   * @property {Number} [speed=10] 速度，值越大越快
   *
   * @see mars3d.MaterialType.CylinderWave
   * @see CylinderWaveMaterialProperty
   */
  const CylinderWave = "CylinderWave";

  /// /////////////////球体////////////////////////////
  /**
   * 球体: 电弧球体
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color=new Cesium.Color(0.0, 1.0, 1.0, 0.7)] 颜色
   * @property {Number} [speed=5.0] 速度，值越大越快
   *
   * @see mars3d.MaterialType.EllipsoidElectric
   * @see EllipsoidElectricMaterialProperty
   */
  const EllipsoidElectric = "EllipsoidElectric";

  /**
   * 球体: 波纹球体
   * @type {String}
   * @constant
   * @readonly
   *
   * @property {Cesium.Color} [color=new Cesium.Color(0.0, 1.0, 1.0, 0.7)] 颜色
   * @property {Number} [speed=5.0] 速度，值越大越快
   *
   * @see mars3d.MaterialType.EllipsoidWave
   * @see EllipsoidWaveMaterialProperty
   */
  const EllipsoidWave = "EllipsoidWave";

  var MaterialType$1 = {
    __proto__: null,
    Color: Color$2,
    PolylineDash: PolylineDash,
    PolylineOutline: PolylineOutline,
    PolylineArrow: PolylineArrow,
    PolylineGlow: PolylineGlow,
    LineFlow: LineFlow,
    LineFlowColor: LineFlowColor,
    ODLine: ODLine,
    LineFlicker: LineFlicker,
    LineTrail: LineTrail,
    LineBloom: LineBloom,
    DigitalFlow: DigitalFlow,
    WallScroll: WallScroll,
    Image: Image$1,
    Image2: Image2,
    Text: Text,
    Grid: Grid,
    Checkerboard: Checkerboard,
    Stripe: Stripe,
    PolyGradient: PolyGradient,
    PolyAsphalt: PolyAsphalt,
    PolyBlob: PolyBlob,
    PolyFacet: PolyFacet,
    PolyGrass: PolyGrass,
    PolyWood: PolyWood,
    NeonLight: NeonLight,
    Water: Water$1,
    WaterLight: WaterLight,
    RectSlide: RectSlide,
    ScanLine: ScanLine,
    CircleScan: CircleScan,
    CircleWave: CircleWave,
    RadarLine: RadarLine,
    RadarWave: RadarWave,
    CylinderWave: CylinderWave,
    EllipsoidElectric: EllipsoidElectric,
    EllipsoidWave: EllipsoidWave
  };

  /**
   * 图层类型
   * @enum {String}
   *
   * @property {String} tdt 天地图在线地图,对应类为：{@link TdtLayer }
   * @property {String} baidu 百度在线地图,对应类为：{@link BaiduLayer }
   * @property {String} gaode 高德在线地图,对应类为：{@link GaodeLayer }
   * @property {String} tencent 腾讯在线地图,对应类为：{@link TencentLayer}
   * @property {String} osm OSM在线地图,对应类为：{@link OsmLayer}
   * @property {String} google 谷歌在线地图,对应类为：{@link GoogleLayer }
   * @property {String} bing 微软Bing地图,对应类为：{@link BingLayer}
   * @property {String} mapbox Mapbox在线地图,对应类为：{@link MapboxLayer }
   * @property {String} ion Cesium Ion在线地图,对应类为：{@link IonLayer }
   *
   * @property {String} image  单张图片,对应类为：{@link ImageLayer}
   * @property {String} xyz 标准XYZ金字塔,对应类为：{@link XyzLayer }
   * @property {String} arcgis ArcGIS服务,对应类为：{@link ArcGisLayer}
   * @property {String} arcgis_tile ArcGIS瓦片服务（使用XYZ瓦片方式请求读取）,对应类为：{@link ArcGisTileLayer}
   * @property {String} arcgis_cache  ArcGIS生成的金字塔瓦片数据 ,对应类为：{@link ArcGisCacheLayer}
   * @property {String} wms OGC标准的WMS服务,对应类为：{@link WmsLayer }
   * @property {String} wmts OGC标准的WMTS服务,对应类为：{@link WmtsLayer }
   * @property {String} tms 由MapTiler、GDAL2Tiles等生成的瓦片数据图层,对应类为：{@link TmsLayer }
   * @property {String} gee GoogleEarth Enterprise 地图服务,对应类为：{@link GeeLayer}
   *
   * @property {String} tileinfo 瓦片信息（一般用于测试）,对应类为：{@link TileInfoLayer}
   * @property {String} grid 网格线（一般用于无地图模式）,对应类为：{@link  GridLayer}
   *
   * @property {String} terrain 地形服务,对应类为：{@link TerrainLayer}
   * @property {String} group 图层组,对应类为：{@link GroupLayer}
   *
   * @property {String} graphic 矢量数据图层,对应类为：{@link GraphicLayer}
   * @property {String} graphicGroup 矢量数据图层组,对应类为：{@link GraphicGroupLayer }
   * @property {String} geojson GeoJson格式数据（使用Graphic渲染）,对应类为：{@link GeoJsonLayer }
   *
   * @property {String} lodGraphic LOD分层分块加载矢量数据,对应类为：{@link LodGraphicLayer }
   * @property {String} wfs OGC标准的WFS服务,对应类为：{@link WfsLayer }
   * @property {String} arcgis_wfs ArcGIS Feature Server服务（分块分层加载）,对应类为：{@link ArcGisWfsLayer }
   * @property {String} arcgis_wfs_single  ArcGIS Feature Server服务（一次性加载，适合小数据）,对应类为：{@link ArcGisWfsSingleLayer}
   *
   * @property {String} tileset或3dtiles  3dtiles三维模型图层,对应类为：{@link TilesetLayer }
   *
   * @property {String} czmGeojson GeoJson数据图层(Cesium原生加载渲染),对应类为：{@link CzmGeoJsonLayer }
   * @property {String} kml  kml数据图层(Cesium原生加载渲染),对应类为：{@link KmlLayer }
   * @property {String} czml czml数据图层(Cesium原生加载渲染),对应类为：{@link CzmlLayer }
   *
   * @property {String} graticule 经纬网,对应类为：{@link GraticuleLayer }
   * @property {String} gaodePOI 高德POI服务,对应类为：{@link GeodePoiLayer }
   * @property {String} osmBuildings OSM在线三维白膜服务,对应类为：{@link OsmBuildingsLayer }
   * @property {String} tdt_dm 天地图三维地名【mars3d-tdt插件】,对应类为：{@link TdtDmLayer }
   *
   * @property {String} supermap_s3m 超图S3M图层【mars3d-supermap插件】,对应类为：{@link S3MLayer }
   * @property {String} supermap_img 超图影像切片图层【mars3d-supermap插件】,对应类为：{@link SmImgLayer }
   * @property {String} supermap_mvt 超图MVT矢量瓦片图层【mars3d-supermap插件】,对应类为：{@link SmMvtLayer }
   *
   * @property {String} mapv MapV图层【mars3d-mapv插件】,对应类为：{@link MapVLayer}
   * @property {String} echarts Echarts图层【mars3d-echarts插件】,对应类为：{@link EchartsLayer }
   * @property {String} heat 热力图图层【mars3d-heat插件】,对应类为：{@link HeatLayer }
   * @property {String} canvasWind canvas风场图层【mars3d-wind插件】,对应类为：{@link CanvasWindLayer }
   * @property {String} wind 风场图层【mars3d-wind插件】,对应类为：{@link WindLayer }
   *
   *
   */
  const LayerType = {};

  /**
   * 控件类型
   * @enum {String}
   *
   * @property {String} clockAnimate 时钟及其动画的管理控制 控件,对应类为：{@link ClockAnimate }
   * @property {String} compass 导航球 控件,对应类为：{@link Compass }
   * @property {String} distanceLegend 比例尺 控件,对应类为：{@link DistanceLegend }
   * @property {String} locationBar 信息状态栏 控件,对应类为：{@link LocationBar }
   * @property {String} mapSplit 卷帘对比 控件,对应类为：{@link MapSplit }
   * @property {String} mouseDownView 鼠标按下指示图标 控件,对应类为：{@link MouseDownView }
   * @property {String} overviewMap 鹰眼地图 控件,对应类为：{@link OverviewMap }
   * @property {String} zoom 放大缩小按钮控件,对应类为：{@link Zoom }
   *
   */
  const ControlType = {};

  /**
   * 特效类型
   * @enum {String}
   *
   * @property {String} blackAndWhite 黑白效果,对应类为：{@link BlackAndWhiteEffect }
   * @property {String} bloom 泛光效果,对应类为：{@link BloomEffect }
   * @property {String} brightness  亮度特效,对应类为：{@link BrightnessEffect }
   * @property {String} depthOfField 景深特效,对应类为：{@link DepthOfFieldEffect }
   * @property {String} fog 雾 特效,对应类为：{@link FogEffect }
   * @property {String} inverted 倒影效果,对应类为：{@link InvertedEffect }
   * @property {String} mosaic 马赛克效果,对应类为：{@link MosaicEffect }
   * @property {String} nightVision 夜视效果,对应类为：{@link NightVisionEffect }
   * @property {String} outline 轮廓线描边效果,对应类为：{@link OutlineEffect }
   * @property {String} rain 下雨 特效,对应类为：{@link RainEffect }
   * @property {String} snow 下雪 特效,对应类为：{@link SnowEffect }
   * @property {String} snowCover 地面积雪 特效,对应类为：{@link SnowCoverEffect }
   *
   *
   */
  const EffectType = {};

  /**
   * 语言类型  枚举
   *  @enum {String}
   */
  const LangType = {
    /**
     * 简体中文
     */
    ZH: 0,
    /**
     * 繁体中文(香港、台湾等地区)
     */
    ZHHK: 1,
    /**
     * English英文  en
     */
    EN: 2
  };

  /**
   * 相机旋转的类型
   *  @enum {Number}
   */
  const MoveType = {
    /**
     * 向屏幕中心靠近
     */
    ENLARGE: 0,
    /**
     * 向屏幕中心远离
     */
    NARROW: 1,
    /**
     * 相机原地左旋转
     */
    LEFT_ROTATE: 2,
    /**
     * 相机原地右旋转
     */
    RIGHT_ROTATE: 3,
    /**
     * 相机原地上旋转
     */
    TOP_ROTATE: 4,
    /**
     * 相机原地下旋转
     */
    BOTTOM_ROTATE: 5
  };

  /**
   * 裁剪模型类型
   *  @enum {Number}
   */
  const ClipType = {
    /** z水平面, 切底部 */
    Z: 1,
    /** z水平面，切顶部 */
    ZR: 2,
    /** x垂直面,切西向 */
    X: 3,
    /** x垂直面,切东向 */
    XR: 4,
    /** y垂直面, 切南向 */
    Y: 5,
    /** y垂直面，切北向 */
    YR: 6
  };

  /**
   * SDK内部使用的一些图标配置，方便外部覆盖(建议Map构造前覆盖)。
   * 如：默认右键菜单
   * @enum {String}
   * @constant
   */
  const Icon = {
    /**
     * 删除
     * @type {String}
     */
    Delete: "fa fa-trash-o",
    /**
     * 查看此处坐标
     * @type {String}
     */
    Coordinates: "fa fa-info-circle",
    /**
     * 查看当前视角
     * @type {String}
     */
    CameraInfo: "fa fa-camera-retro",
    /**
     * 视角切换
     * @type {String}
     */
    Camera: "fa fa-street-view",
    /**
     * 禁止进入地下
     * @type {String}
     */
    UndergroundNo: "fa fa-ban",
    /**
     * 允许进入地下
     * @type {String}
     */
    UndergroundYes: "fa fa-sort-amount-desc",
    /**
     * 绕此处环绕飞行
     * @type {String}
     */
    RotatePointStart: "fa fa-retweet",
    /**
     * 关闭环绕飞行
     * @type {String}
     */
    RotatePointStop: "fa fa-remove",
    /**
     * 移动到此处
     * @type {String}
     */
    FlyToPoint: "fa fa-send-o",
    /**
     *第一视角站到此处
     * @type {String}
     */
    FirstPerspective: "fa fa-male",
    /**
     *开启键盘漫游
     * @type {String}
     */
    KeyboardRoamYes: "fa fa-keyboard-o",
    /**
     *关闭键盘漫游
     * @type {String}
     */
    KeyboardRoamNo: "fa fa-keyboard-o",
    /**
     *跟踪锁定
     * @type {String}
     */
    TrackedEntityYes: "fa fa-lock",
    /**
     *取消锁定
     * @type {String}
     */
    TrackedEntityNo: "fa fa-unlock-alt",
    /**
     *三维模型
     * @type {String}
     */
    Tileset: "fa fa-building-o",
    /**
     * 显示模型三角网
     * @type {String}
     */
    TilesetWireframeYes: "fa fa-connectdevelop",
    /**
     *关闭模型三角网
     * @type {String}
     */
    TilesetWireframeNo: "fa fa-connectdevelop",
    /**
     * 显示模型包围盒
     * @type {String}
     */
    TilesetBoundingVolumeYes: "fa fa-codepen",
    /**
     * 关闭模型包围盒
     * @type {String}
     */
    TilesetBoundingVolumeNo: "fa fa-codepen",
    /**
     *地形服务
     * @type {String}
     */
    Terrain: "fa fa-globe",
    /**
     * 开启地形
     * @type {String}
     */
    TerrainYes: "fa fa-medium",
    /**
     *关闭地形
     * @type {String}
     */
    TerrainNo: "fa fa-medium",
    /**
     *显示地形三角网
     * @type {String}
     */
    TerrainWireframeYes: "fa fa-connectdevelop",
    /**
     * 关闭地形三角网
     * @type {String}
     */
    TerrainWireframeNo: "fa fa-connectdevelop",
    /**
     * 图上量算
     * @type {String}
     */
    Measure: "fa fa-share-alt",
    /**
     * 距离
     * @type {String}
     */
    MeasureDistance: "fa fa-minus",
    /**
     * 面积
     * @type {String}
     */
    MeasureArea: "fa fa-medium",
    /**
     * 高度差
     * @type {String}
     */
    MeasureHeight: "fa fa-sort-amount-asc",
    /**
     * 角度
     * @type {String}
     */
    MeasureAngle: "fa fa-road",
    /**
     * 图上标记
     * @type {String}
     */
    Draw: "fa fa-eyedropper",
    /**
     * 标记点
     * @type {String}
     */
    DrawPoint: "fa fa-map-marker",
    /**
     * 标记线
     * @type {String}
     */
    DrawPolyline: "fa fa-reorder",
    /**
     * 标记面
     * @type {String}
     */
    DrawPolygon: "fa fa-medium",
    /**
     * 标记圆
     * @type {String}
     */
    DrawCircle: "fa fa-genderless",
    /**
     * 标记矩形
     * @type {String}
     */
    DrawRectangle: "fa fa-retweet",
    /**
     * 允许编辑
     * @type {String}
     */
    DrawEditYes: "fa fa-pencil",
    /**
     * 禁止编辑
     * @type {String}
     */
    DrawEditNo: "fa fa-pencil-square",
    /**
     * 导出GeoJSON
     * @type {String}
     */
    DrawDownJson: "fa fa-file-text-o",
    /**
     * 特效效果
     * @type {String}
     */
    Effect: "fa fa-rss",
    /**
     * 开启下雨
     * @type {String}
     */
    RainEffectYes: "fa fa-tint",
    /**
     * 关闭下雨
     * @type {String}
     */
    RainEffectNo: "fa fa-tint",
    /**
     * 开启下雪
     * @type {String}
     */
    SnowEffectYes: "fa fa-yelp",
    /**
     *
     * @type {String}
     */
    SnowEffectNo: "fa fa-yelp",
    /**
     * 开启雾天气
     * @type {String}
     */
    FogEffectYes: "fa fa-spinner",
    /**
     * 关闭雾天气
     * @type {String}
     */
    FogEffectNo: "fa fa-spinner",
    /**
     *开启泛光
     * @type {String}
     */
    BloomEffectYes: "fa fa-bullseye",
    /**
     * 关闭泛光
     * @type {String}
     */
    BloomEffectNo: "fa fa-bullseye",
    /**
     * 开启亮度
     * @type {String}
     */
    BrightnessEffectYes: "fa fa-trello",
    /**
     * 关闭亮度
     * @type {String}
     */
    BrightnessEffectNo: "fa fa-trello",
    /**
     * 开启夜视
     * @type {String}
     */
    NightVisionEffectYes: "fa fa-dashboard",
    /**
     * 关闭夜视
     * @type {String}
     */
    NightVisionEffectNo: "fa fa-dashboard",
    /**
     * 开启黑白
     * @type {String}
     */
    BlackAndWhiteEffectYes: "fa fa-star-half-full",
    /**
     * 关闭黑白
     * @type {String}
     */
    BlackAndWhiteEffectNo: "fa fa-star-half-full",
    /**
     * 开启拾取高亮
     * @type {String}
     */
    OutlineEffectYes: "fa fa-ticket",
    /**
     * 关闭拾取高亮
     * @type {String}
     */
    OutlineEffectNo: "fa fa-ticket",
    /**
     * 场景设置
     * @type {String}
     */
    Scene: "fa fa-gear",
    /**
     *开启深度监测
     * @type {String}
     */
    DepthTestYes: "fa fa-eye-slash",
    /**
     * 关闭深度监测
     * @type {String}
     */
    DepthTestNo: "fa fa-eye",
    /**
     * 显示星空背景
     * @type {String}
     */
    SkyBoxYes: "fa fa-moon-o",
    /**
     * 关闭星空背景
     * @type {String}
     */
    SkyBoxNo: "fa fa-moon-o",
    /**
     * 开启日照阴影
     * @type {String}
     */
    ShadowYes: "fa fa-sun-o",
    /**
     * 关闭日照阴影
     * @type {String}
     */
    ShadowNo: "fa fa-sun-o",
    /**
     * 开启大气渲染
     * @type {String}
     */
    SkyAtmosphereYes: "fa fa-soundcloud",
    /**
     * 关闭大气渲染
     * @type {String}
     */
    SkyAtmosphereNo: "fa fa-soundcloud",
    /**
     * 场景出图
     * @type {String}
     */
    ExpImage: "fa fa-download"
  };

  /**
   * DOM操作 相关静态方法类
   * @module DomUtil
   */

  /**
   * 创建一个tagName的HTML元素，将其class设置为className，并可选择将其添加到container元素中
   *
   * @export
   * @param {String} tagName 元素类型，比如 div
   * @param {String} [className] 附加的class样式名
   * @param {HTMLElement|HTMLDivElement|null} [container] 添加到指定的父节点(可选)
   * @return {HTMLElement|HTMLDivElement|*} 创建好的DOM元素
   */
  function create$3(tagName, className, container) {
    const el = document.createElement(tagName);
    el.className = className || "";
    if (container) {
      container.appendChild(el);
    }
    return el
  }

  /**
   * 创建svg元素
   *
   * @export
   * @param {Number} width 宽度
   * @param {Number} height 高度
   * @param {String} path url路径
   * @param {HTMLElement} container 添加到指定的父节点(可选)
   * @return {SVGElement} 创建的svg元素
   */
  function createSvg(width, height, path, container) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg:svg");
    svg.setAttribute("class", "svg-path");
    svg.setAttribute("width", width);
    svg.setAttribute("height", height);
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathEl.setAttribute("d", path);
    svg.appendChild(pathEl);
    if (container) {
      container.appendChild(svg);
    }
    return svg
  }

  /**
   *  创建Video元素
   *
   * @export
   * @param {String} url url地址
   * @param {String} [type] 视频类型
   * @param {String} [className] 样式名称
   * @param {HTMLElement} [container]  添加到指定的父节点(可选)
   * @return {HTMLVideoElement} 创建的Video元素
   */
  function createVideo(url, type, className, container) {
    const videoEle = create$3("video", className, container);
    videoEle.setAttribute("autoplay", true);
    videoEle.setAttribute("loop", true);
    videoEle.setAttribute("crossorigin", true);

    if (!type) {
      type = url.substring(url.lastIndexOf(".") + 1, url.length);
    }
    const source = create$3("source", "", videoEle);
    source.setAttribute("src", url);
    source.setAttribute("type", `video/${type}`);
    return videoEle
  }

  /**
   * 返回给定DOM id的元素，或者返回元素本身
   *
   * @export
   * @param {String|HTMLElement} id  dom的id
   * @return {HTMLElement} DOM元素
   */
  function get(id) {
    return typeof id === "string" ? document.getElementById(id) : id
  }

  /**
   * 将HTML字符串解析为DOM
   * @param {String} domStr HTML字符串
   * @param {Boolean} [withWrapper] 是否返回DIV父节点
   * @param {String} [className] 指定加上的样式名称
   * @returns {HTMLDivElement|NodeListOf<ChildNode>} 解析后的DOM元素
   */
  function parseDom(domStr, withWrapper, className) {
    const el = document.createElement("div");
    if (className) {
      el.className = className;
    }
    el.innerHTML = domStr;
    return withWrapper ? el : el.childNodes
  }

  /**
   * 从其父元素中移除元素
   *
   * @export
   * @param {HTMLElement|String} el DOM元素或元素ID
   * @return {void}  无
   */
  function remove(el) {
    el = get(el);
    if (!el) {
      return
    }
    const parent = el.parentNode;
    if (parent) {
      parent.removeChild(el);
    }
  }

  /**
   * 删除所有子元素
   *
   * @export
   * @param {HTMLElement} el DOM元素
   * @return {void}  无
   */
  function empty(el) {
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
  }

  /**
   * 返回元素上某个样式属性的值
   *
   * @export
   * @param {HTMLElement} el 指定的DOM元素
   * @param {String} style 样式名称
   * @return {String|null} 样式的值
   */
  function getStyle(el, style) {
    let value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

    if ((!value || value === "auto") && document.defaultView) {
      const css = document.defaultView.getComputedStyle(el, null);
      value = css ? css[style] : null;
    }
    return value === "auto" ? null : value
  }

  /**
   * 判断元素是否有指定class样式
   *
   * @export
   * @param {HTMLElement} el DOM元素
   * @param {String} name class样式名称
   * @return {Boolean}  包含返回`true`,不包含返回`false`
   */
  function hasClass(el, name) {
    if (!el) {
      return false
    }
    if (el.classList !== undefined) {
      return el.classList.contains(name)
    }
    const className = getClass$3(el);
    return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className)
  }

  /**
   * 在元素上添加指定的name的calss样式
   *
   * @export
   * @param {HTMLElement} el DOM元素
   * @param {String} name class样式名称
   * @return {void}  无
   */
  function addClass(el, name) {
    if (!el) {
      return
    }

    if (el.classList !== undefined) {
      const classes = splitWords(name);
      for (let i = 0, len = classes.length; i < len; i++) {
        el.classList.add(classes[i]);
      }
    } else if (!hasClass(el, name)) {
      const className = getClass$3(el);
      setClass(el, (className ? className + " " : "") + name);
    }
  }

  /**
   * 在元素上移除指定的name的calss样式
   *
   * @export
   * @param {HTMLElement} el DOM元素
   * @param {String} name class样式名称
   * @return {void}  无
   */
  function removeClass(el, name) {
    if (!el) {
      return
    }
    if (el.classList !== undefined) {
      el.classList.remove(name);
    } else {
      setClass(el, trim((" " + getClass$3(el) + " ").replace(" " + name + " ", " ")));
    }
  }

  /**
   * 在元素上赋值设置指定的name的calss样式
   *
   * @export
   * @param {HTMLElement} el DOM元素
   * @param {String} name class样式名称
   * @return {void}  无
   */
  function setClass(el, name) {
    if (!el.className || !el.className.baseVal) {
      el.className = name;
    } else {
      // in case of SVG element
      el.className.baseVal = name;
    }
  }

  /**
   * 获取dom元素上的class样式名称
   *
   * @export
   * @param {HTMLElement} el DOM元素
   * @return {String} class样式名称
   */
  function getClass$3(el) {
    // Check if the element is an SVGElementInstance and use the correspondingElement instead
    // (Required for linked SVG elements in IE11.)
    if (el.correspondingElement) {
      el = el.correspondingElement;
    }
    return el.className?.baseVal ? el.className.baseVal : el.className
  }

  /**
   * 复制canvas对象
   *
   * @export
   * @param {HTMLCanvasElement } oldCanvas 原canvas对象
   * @return {HTMLCanvasElement } 复制后的canvas对象
   */
  function copyCanvas(oldCanvas) {
    const imageData = oldCanvas.getContext("2d").getImageData(0, 0, oldCanvas.width, oldCanvas.height);
    const canvas = document.createElement("canvas");
    canvas.width = oldCanvas.width;
    canvas.height = oldCanvas.height;

    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.putImageData(imageData, 0, 0);

    return canvas
  }

  var DomUtil = {
    __proto__: null,
    create: create$3,
    createSvg: createSvg,
    createVideo: createVideo,
    get: get,
    parseDom: parseDom,
    remove: remove,
    empty: empty,
    getStyle: getStyle,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    setClass: setClass,
    getClass: getClass$3,
    copyCanvas: copyCanvas
  };

  // 取屏幕中心点坐标
  function getCenter(scene) {
    const canvas = scene.canvas;
    const center = new Cesium__namespace.Cartesian2(canvas.clientWidth / 2, canvas.clientHeight / 2);

    const ray = scene.camera.getPickRay(center);
    let target = scene.globe.pick(ray, scene);
    if (!target) {
      target = scene.camera.pickEllipsoid(center);
    }
    if (target) {
      return LngLatPoint.fromCartesian(target)
    } else {
      return undefined
    }
  }

  // 提取地球视域边界
  function getExtent(map, options = {}) {
    const extent = { xmin: 70, xmax: 140, ymin: 0, ymax: 55, height: 0 };

    // 得到当前三维场景
    const scene = map.scene;

    // 得到当前三维场景的椭球体
    const ellipsoid = scene.globe.ellipsoid;
    const canvas = scene.canvas;

    // canvas左上角
    const car3_lt = map.camera.pickEllipsoid(new Cesium__namespace.Cartesian2(0, 0), ellipsoid);
    if (car3_lt) {
      // 在椭球体上
      const carto_lt = ellipsoid.cartesianToCartographic(car3_lt);
      extent.xmin = Cesium__namespace.Math.toDegrees(carto_lt.longitude);
      extent.ymax = Cesium__namespace.Math.toDegrees(carto_lt.latitude);
      extent.height = Math.max(extent.height, carto_lt.height);
    } else {
      // 不在椭球体上
      const xMax = canvas.width / 2;
      const yMax = canvas.height / 2;

      let car3_lt2;
      // 这里每次10像素递加，一是10像素相差不大，二是为了提高程序运行效率
      for (let yIdx = 0; yIdx <= yMax; yIdx += 10) {
        const xIdx = yIdx <= xMax ? yIdx : xMax;
        car3_lt2 = map.camera.pickEllipsoid(new Cesium__namespace.Cartesian2(xIdx, yIdx), ellipsoid);
        if (car3_lt2) {
          break
        }
      }
      if (car3_lt2) {
        const carto_lt = ellipsoid.cartesianToCartographic(car3_lt2);
        extent.xmin = Cesium__namespace.Math.toDegrees(carto_lt.longitude);
        extent.ymax = Cesium__namespace.Math.toDegrees(carto_lt.latitude);
        extent.height = Math.max(extent.height, carto_lt.height);
      }
    }

    // canvas右下角
    const car3_rb = map.camera.pickEllipsoid(new Cesium__namespace.Cartesian2(canvas.width, canvas.height), ellipsoid);
    if (car3_rb) {
      // 在椭球体上
      const carto_rb = ellipsoid.cartesianToCartographic(car3_rb);
      extent.xmax = Cesium__namespace.Math.toDegrees(carto_rb.longitude);
      extent.ymin = Cesium__namespace.Math.toDegrees(carto_rb.latitude);
      extent.height = Math.max(extent.height, carto_rb.height);
    } else {
      // 不在椭球体上
      const xMax = canvas.width / 2;
      const yMax = canvas.height / 2;

      let car3_rb2;
      // 这里每次10像素递减，一是10像素相差不大，二是为了提高程序运行效率
      for (let yIdx = canvas.height; yIdx >= yMax; yIdx -= 10) {
        const xIdx = yIdx >= xMax ? yIdx : xMax;
        car3_rb2 = map.camera.pickEllipsoid(new Cesium__namespace.Cartesian2(xIdx, yIdx), ellipsoid);
        if (car3_rb2) {
          break
        }
      }
      if (car3_rb2) {
        const carto_rb = ellipsoid.cartesianToCartographic(car3_rb2);
        extent.xmax = Cesium__namespace.Math.toDegrees(carto_rb.longitude);
        extent.ymin = Cesium__namespace.Math.toDegrees(carto_rb.latitude);
        extent.height = Math.max(extent.height, carto_rb.height);
      }
    }

    if (!extent) {
      return
    }

    // 交换
    if (extent.xmax < extent.xmin) {
      const temp = extent.xmax;
      extent.xmax = extent.xmin;
      extent.xmin = temp;
    }
    if (extent.ymax < extent.ymin) {
      const temp = extent.ymax;
      extent.ymax = extent.ymin;
      extent.ymin = temp;
    }

    if (Cesium__namespace.defined(options.scale) && options.scale !== 1) {
      const scale = options.scale - 1;
      extent.xmin -= scale;
      extent.xmax += scale;
      extent.ymin -= scale;
      extent.ymax += scale;
    }

    // 截取长度
    if (options.formatNum) {
      extent.xmin = formatNum$1(extent.xmin, LngLatPoint.FormatLength);
      extent.xmax = formatNum$1(extent.xmax, LngLatPoint.FormatLength);
      extent.ymin = formatNum$1(extent.ymin, LngLatPoint.FormatLength);
      extent.ymax = formatNum$1(extent.ymax, LngLatPoint.FormatLength);
    }

    return extent
  }

  // 提取相机视角范围参数
  function getCameraView(camera, options) {
    const position = camera.positionCartographic;

    const bookmark = {};
    bookmark.lat = formatNum$1(Cesium__namespace.Math.toDegrees(position.latitude), LngLatPoint.FormatLength);
    bookmark.lng = formatNum$1(Cesium__namespace.Math.toDegrees(position.longitude), LngLatPoint.FormatLength);

    if (options?.simplify ?? true) {
      bookmark.alt = formatNum$1(position.height, 0);
      bookmark.heading = formatNum$1(Cesium__namespace.Math.toDegrees(camera.heading || 0) % 360, 0);
      bookmark.pitch = formatNum$1(Cesium__namespace.Math.toDegrees(camera.pitch || 0) % 360, 0);
    } else {
      bookmark.alt = formatNum$1(position.height, LngLatPoint.FormatAltLength);
      bookmark.heading = formatNum$1(Cesium__namespace.Math.toDegrees(camera.heading || 0) % 360, 1);
      bookmark.pitch = formatNum$1(Cesium__namespace.Math.toDegrees(camera.pitch || 0) % 360, 1);
      bookmark.roll = formatNum$1(Cesium__namespace.Math.toDegrees(camera.roll || 0) % 360, 1);
    }
    return bookmark
  }

  // 截图，导出地图场景图片
  function expImage(viewer, options = {}) {
    return new Promise((resolve, reject) => {
      options.download = options.download ?? true;
      options.type = options.type ?? "image/jpeg";

      let width, height;

      viewer.render();
      const imgdata = viewer.canvas.toDataURL(options.type, options.encoderOptions);

      if (Cesium__namespace.defined(options.width) || Cesium__namespace.defined(options.height)) {
        // 指定了高或宽度后，图片压缩处理
        const image = new Image();
        image.onload = function () {
          // 图片压缩处理

          if (Cesium__namespace.defined(options.width)) {
            width = options.width;
            height = options.height || Math.round((width * viewer.canvas.height) / viewer.canvas.width);
          } else {
            height = options.height;
            width = Math.round((height * viewer.canvas.width) / viewer.canvas.height);
          }

          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(image, 0, 0, width, height);
          const imgdataNew = canvas.toDataURL(options.type, options.encoderOptions);

          if (!options.filename) {
            options.filename = "场景出图_" + width + "x" + height;
          }
          if (options.download) {
            downloadBase64Image(options.filename, imgdataNew);
          }
          const result = {
            image: imgdataNew,
            width: width,
            height: height
          };
          if (options.callback) {
            options.callback(result); // 兼容v3.4之前版本callback
          }
          resolve(result);
        };
        image.src = imgdata;
      } else {
        // 高清原图
        height = viewer.canvas.height;
        width = viewer.canvas.width;

        if (!options.filename) {
          options.filename = "场景出图_" + width + "x" + height;
        }
        if (options.download) {
          downloadBase64Image(options.filename, imgdata);
        }
        const result = {
          image: imgdata,
          width: width,
          height: height
        };
        if (options.callback) {
          options.callback(result); // 兼容v3.4之前版本callback
        }
        resolve(result);
      }
    })
  }

  // 获取坐标点处的3dtiles模型，用于计算贴地时进行判断（和视角有关系，不一定精确）
  function pick3DTileset(scene, positions) {
    if (!positions) {
      return null
    }

    if (positions instanceof Cesium__namespace.Cartesian3) {
      positions = [positions];
    }

    for (let i = 0, len = positions.length; i < len; ++i) {
      const position = positions[i];
      const coorPX = Cesium__namespace.SceneTransforms.wgs84ToWindowCoordinates(scene, position);
      if (!Cesium__namespace.defined(coorPX)) {
        continue
      }

      const pickedObject = scene.pick(coorPX, 10, 10);
      if (Cesium__namespace.defined(pickedObject) && Cesium__namespace.defined(pickedObject.primitive) && pickedObject.primitive instanceof Cesium__namespace.Cesium3DTileset) {
        // Cesium.defined(pickedObject.primitive.isCesium3DTileset)
        return pickedObject.primitive
      }
    }

    return null
  }

  // 【单个点】 异步计算 单个点 贴地(或贴模型)
  class SurfacePoint {
    constructor(options) {
      this.options = options;
      this.scene = options.map ? options.map.scene : options.scene;

      if (!this.scene) {
        logError(`SurfacePoint: 请传入scene参数`, this.options);
      }

      this._point = LngLatPoint.parse(options.position);
      if (this._point) {
        this._position = this._point.toCartesian();
        this._cartographic = this._point.toCartographic();
        this._height_original = this._point.alt;
      }
    }

    start() {
      return new Promise((resolve, reject) => {
        this._promise = { resolve, reject };

        if (!this._point) {
          resolve({ height: 0 });
          return
        }

        const _has3dtiles = this.options.has3dtiles ?? Cesium__namespace.defined(pick3DTileset(this.scene, this._position));
        const _hasTerrain = Boolean(this.scene.terrainProvider._layers); // 是否有地形

        this._has3dtiles = _has3dtiles;
        this._hasTerrain = _hasTerrain;

        if (!_hasTerrain && !_has3dtiles) {
          // 无地形和无模型时，直接返回
          this.end(0);
          return
        }

        // 开始分析
        if (_has3dtiles) {
          this.clampTo3DTileset();
        } else {
          this.clampToTerrain();
        }
      })
    }

    clampTo3DTileset() {
      this.scene.clampToHeightMostDetailed([this._position.clone()], this.options.objectsToExclude, 0.05).then((clampedPositions) => {
        const clampedPt = clampedPositions[0];
        if (Cesium__namespace.defined(clampedPt)) {
          const cartiles = Cesium__namespace.Cartographic.fromCartesian(clampedPt);
          const heightTiles = cartiles.height;
          if (Cesium__namespace.defined(heightTiles) && heightTiles > -1000) {
            this.end(heightTiles);
            return
          }
        }
        this.clampToTerrain();
      });
    }

    clampToTerrain() {
      Cesium__namespace.sampleTerrainMostDetailed(this.scene.terrainProvider, [this._cartographic]).then((samples) => {
        const positionSurface = samples[0];
        let heightTerrain;
        if (Cesium__namespace.defined(positionSurface) && Cesium__namespace.defined(positionSurface.height)) {
          heightTerrain = positionSurface.height;
        } else {
          heightTerrain = this.scene.globe.getHeight(this._cartographic) || 0;
        }
        this.end(heightTerrain);
      });
    }

    end(height) {
      if (this.options.callback) {
        this.options.callback(height); // 兼容v3.4之前版本callback
      }
      this._point.alt = height;

      this._promise.resolve({
        height: height,
        height_original: this._height_original,
        point: this._point,
        position: Cesium__namespace.Cartesian3.fromRadians(this._cartographic.longitude, this._cartographic.latitude, height),
        position_original: this._position,
        has3dtiles: this._has3dtiles,
        hasTerrain: this._hasTerrain
      });
    }
  }

  /**
   * 单个坐标或位置矩阵相关的处理 静态方法
   * @module PointUtil
   */

  /**
   * 获取PointTrans中对应的坐标转换方法
   * srcCoordType 转 dstCoordType 对应的方法名称
   *
   * @param {ChinaCRS} srcCoordType 原始的坐标系
   * @param {ChinaCRS} dstCoordType 转换后的坐标系
   * @return {Function} PointTrans中对应的坐标转换方法
   */
  function getTransFun(srcCoordType, dstCoordType) {
    if (!srcCoordType || !dstCoordType) {
      return false
    }

    srcCoordType = crsName2FunName(srcCoordType);
    dstCoordType = crsName2FunName(dstCoordType);

    if (dstCoordType === srcCoordType) {
      return false
    }

    const funname = srcCoordType + "2" + dstCoordType;
    if (!PointTrans[funname]) {
      return false
    }
    return PointTrans[funname]
  }

  function crsName2FunName(crsName) {
    switch (crsName) {
      case ChinaCRS.GCJ02:
        return "gcj"
      case ChinaCRS.BAIDU:
        return "bd"
      case ChinaCRS.WGS84:
      default:
        return "wgs"
    }
  }

  /**
   * 获取position的最终value值，
   * 因为cesium经常属性或绑定一层，通过该方法可以内部去判断是否有getValue或_value进行取最终value值。
   *
   * @export
   * @param {Cesium.Cartesian3|Cesium.SampledPositionProperty|*} position 各种位置属性对象
   * @param {Cesium.JulianDate} [time=Cesium.JulianDate.now()] 指定的时间值
   * @return {Cesium.Cartesian3} 具体的Cartesian3对象坐标值
   */
  function getPositionValue(position, time) {
    if (!position) {
      return position
    }

    let _position;
    if (position instanceof Cesium__namespace.Cartesian3) {
      _position = position;
    } else if (position._value && position._value instanceof Cesium__namespace.Cartesian3) {
      _position = position._value;
    } else if (typeof position.getValue === "function") {
      _position = position.getValue(time || Cesium__namespace.JulianDate.now());
    }

    return _position
  }

  /**
   * 获取 坐标数组 中 最高高程值
   *
   * @export
   * @param {Cesium.Cartesian3[]|LngLatPoint[]|Array} positions 笛卡尔坐标数组
   * @param {Number} [defaultVal=0] 默认高程值
   * @return {Number} 最高高程值
   */
  function getMaxHeight(positions, defaultVal = 0) {
    if (positions == null || positions.length === 0) {
      return defaultVal
    }

    let maxHeight = defaultVal;
    for (let i = 0; i < positions.length; i++) {
      const tempCarto = LngLatPoint.parse(positions[i]);
      if (i === 0) {
        maxHeight = tempCarto.alt;
      }
      if (tempCarto.alt > maxHeight) {
        maxHeight = tempCarto.alt;
      }
    }
    return formatNum(maxHeight, LngLatPoint.FormatAltLength)
  }

  function formatNum(num, digits = 0) {
    const pow = Math.pow(10, digits);
    return Math.round(num * pow) / pow
  }

  /**
   * 获取 坐标数组 中 最低高程值
   *
   * @export
   * @param {Cesium.Cartesian3[]} positions 笛卡尔坐标数组
   * @param {Number} [defaultVal=0] 默认高程值
   * @return {Number} 最低高程值
   */
  function getMinHeight(positions, defaultVal = 0) {
    if (positions == null || positions.length === 0) {
      return defaultVal
    }

    let minHeight = defaultVal;
    for (let i = 0; i < positions.length; i++) {
      const tempCarto = Cesium__namespace.Cartographic.fromCartesian(positions[i]);
      if (i === 0) {
        minHeight = tempCarto.height;
      }
      if (tempCarto.height < minHeight) {
        minHeight = tempCarto.height;
      }
    }
    return formatNum(minHeight, LngLatPoint.FormatAltLength)
  }

  /**
   * 对坐标（或坐标数组）增加 指定的海拔高度值
   *
   * @export
   * @param {Cesium.Cartesian3|Cesium.Cartesian3[]} positions 笛卡尔坐标数组
   * @param {number} [addHeight=0] 增加的海拔高度值
   * @return {Cesium.Cartesian3|Cesium.Cartesian3[]} 增加高度后的坐标（或坐标数组）
   */
  function addPositionsHeight(positions, addHeight = 0) {
    addHeight = Number(addHeight);

    if (isNaN(addHeight) || addHeight === 0) {
      return positions
    }

    if (Array.isArray(positions)) {
      const arr = [];
      for (let i = 0, len = positions.length; i < len; i++) {
        const car = Cesium__namespace.Cartographic.fromCartesian(positions[i]);
        const point = Cesium__namespace.Cartesian3.fromRadians(car.longitude, car.latitude, car.height + addHeight);
        arr.push(point);
      }
      return arr
    } else {
      const car = Cesium__namespace.Cartographic.fromCartesian(positions);
      return Cesium__namespace.Cartesian3.fromRadians(car.longitude, car.latitude, car.height + addHeight)
    }
  }

  /**
   * 对坐标（或坐标数组）赋值修改为 指定的海拔高度值
   *
   * @export
   * @param {Cesium.Cartesian3|Cesium.Cartesian3[]} positions 笛卡尔坐标数组
   * @param {number} [height=0] 增加的海拔高度值
   * @return {Cesium.Cartesian3|Cesium.Cartesian3[]} 增加高度后的坐标（或坐标数组）
   */
  function setPositionsHeight(positions, height = 0) {
    if (!positions) {
      return positions
    }

    if (Array.isArray(positions)) {
      const arr = [];
      for (let i = 0, len = positions.length; i < len; i++) {
        const car = Cesium__namespace.Cartographic.fromCartesian(positions[i]);
        const point = Cesium__namespace.Cartesian3.fromRadians(car.longitude, car.latitude, height);
        arr.push(point);
      }
      return arr
    } else {
      const car = Cesium__namespace.Cartographic.fromCartesian(positions);
      return Cesium__namespace.Cartesian3.fromRadians(car.longitude, car.latitude, height)
    }
  }

  /**
   * 获取 坐标 的 贴地高度
   * （非精确计算，根据当前加载的地形和模型数据情况有关,准确计算请用getSurfaceHeight方法）
   *
   * @export
   * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {Cesium.Cartesian3|LngLatPoint} position 坐标
   * @param {Object} [options={}] 参数对象:
   * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
   * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   * @param  {Number} [options.width = 0.1] Width of the intersection volume in meters.
   * @return {Number} 贴地高度
   */
  function getHeight(scene, position, options = {}) {
    const point = LngLatPoint.parse(position);
    if (!scene || !point) {
      return 0
    }
    const _position = point.toCartesian();

    const _has3dtiles = options.has3dtiles ?? Cesium__namespace.defined(pick3DTileset(scene, _position));
    const _hasTerrain = Boolean(scene.terrainProvider._layers); // 是否有地形

    if (!_hasTerrain && !_has3dtiles) {
      // 无地形和无模型时，直接返回
      return 0
    }

    const _cartographic = point.toCartographic();

    // 取贴模型高度
    if (_has3dtiles) {
      const heightTiles = scene.sampleHeight(_cartographic, options.objectsToExclude, options.width);
      if (Cesium__namespace.defined(heightTiles) && heightTiles > -1000) {
        return heightTiles
      }
    }

    const heightTerrain = scene.globe.getHeight(_cartographic);
    if (Cesium__namespace.defined(heightTerrain) && heightTerrain > -1000) {
      return heightTerrain
    }
    return 0
  }

  /**
   * 异步精确计算坐标的 贴地(或贴模型)高度
   * @export
   * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {Cesium.Cartesian3|LngLatPoint} position 坐标
   * @param {Object} [options={}] 参数对象:
   * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）, 默认内部根据点的位置自动判断（但可能不准）
   * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   * @return {Promise<Object>} 异步计算完成的Promise
   */
  function getSurfaceHeight(scene, position, options = {}) {
    options.scene = scene;
    options.position = position;
    return new SurfacePoint(options).start()
  }

  /**
   * 异步精确计算坐标的 贴地形高度
   * @export
   * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {Cesium.Cartesian3|LngLatPoint} position 坐标
   * @return {Promise<Object>} 异步计算完成的Promise
   */
  function getSurfaceTerrainHeight(scene, position) {
    const options = {
      scene: scene,
      position: position,
      has3dtiles: false
    };
    return new SurfacePoint(options).start()
  }

  /**
   * 计算 贴地(或贴模型)高度 坐标
   * （非精确计算，根据当前加载的地形和模型数据情况有关）
   *
   * @export
   * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {Cesium.Cartesian3} position 坐标
   * @param {Object} [options={}] 参数对象，具有以下属性:
   * @param {Boolean} [options.relativeHeight=fasle]  是否在地形上侧的高度，在对象具备Cesium.HeightReference.RELATIVE_TO_GROUND时，可以设置为ture
   * @param {Number} [options.maxHeight] 可以限定最高高度，当计算的结果大于maxHeight时，原样返回，可以屏蔽计算误差的数据。
   * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
   * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，
   * @return {Cesium.Cartesian3} 贴地坐标
   */
  function getSurfacePosition(scene, position, options = {}) {
    if (!position) {
      return position
    }

    if (scene.scene) {
      scene = scene.scene;
    }

    let height = getHeight(scene, position, options);

    if (height !== 0 || (Cesium__namespace.defined(options.maxHeight) && height <= options.maxHeight)) {
      const carto = Cesium__namespace.Cartographic.fromCartesian(position);
      if (options.relativeHeight) {
        height += carto.height; // Cesium.HeightReference.RELATIVE_TO_GROUND时
      }

      const positionNew = Cesium__namespace.Cartesian3.fromRadians(carto.longitude, carto.latitude, height);
      return positionNew
    }
    return position
  }

  function hasPickedModel(pickedObject, noPickEntity) {
    if (Cesium__namespace.defined(pickedObject.id)) {
      // entity
      const entity = pickedObject.id;
      if (entity._noMousePick) {
        return entity
      } // 排除标识不拾取的对象
      if (noPickEntity && entity === noPickEntity) {
        return entity
      }
    }

    if (Cesium__namespace.defined(pickedObject.primitive)) {
      // primitive
      const primitive = pickedObject.primitive;
      if (primitive._noMousePick) {
        return primitive
      } // 排除标识不拾取的对象
      if (noPickEntity && primitive === noPickEntity) {
        return primitive
      }
    }

    if (Cesium__namespace.defined(pickedObject.tileset)) {
      // tileset
      const tileset = pickedObject.tileset;
      if (tileset._noMousePick) {
        return tileset
      } // 排除标识不拾取的对象
      if (noPickEntity && tileset === noPickEntity) {
        return tileset
      }
    }

    return null
  }

  /**
   * 获取 屏幕XY坐标 对应的 笛卡尔三维坐标
   *
   * @export
   * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {Cesium.Cartesian2} position 屏幕XY坐标（如鼠标所在位置)
   * @param {*} noPickEntity 排除的不拾取矢量对象，主要用于绘制中，排除对自己本身的拾取
   * @return {Cesium.Cartesian3}  笛卡尔三维坐标
   *
   *
   * @example
   *
   * //Cesium原生鼠标单击事件
   * var handler = new Cesium.ScreenSpaceEventHandler(map.scene.canvas);
   * handler.setInputAction(function (event) {
   *   var cartesian = mars3d.PointUtil.getCurrentMousePosition(map.scene, event.position);
   *   //继续写其他代码
   * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
   */
  function getCurrentMousePosition(scene, position, noPickEntity) {
    let cartesian;

    // 在模型上提取坐标
    let pickedObject;
    try {
      pickedObject = scene.pick(position, 5, 5);
    } catch (e) {
      logWarn("getCurrentMousePosition: scene.pick 拾取时异常", e);
    }

    if (scene.pickPositionSupported && Cesium__namespace.defined(pickedObject)) {
      // pickPositionSupported :判断是否支持深度拾取,不支持时无法进行鼠标交互绘制

      const pcEntity = hasPickedModel(pickedObject, noPickEntity);
      if (pcEntity) {
        if (pcEntity.billboard || pcEntity.point || pcEntity.label) {
          return getPositionValue(pcEntity.position)
        }

        if (pcEntity.show) {
          pcEntity.show = false; // 先隐藏被排除的noPickEntity对象
          scene.requestRender();
          cartesian = getCurrentMousePosition(scene, position, noPickEntity);
          pcEntity.show = true; // 还原被排除的noPickEntity对象
          if (cartesian) {
            return cartesian
          }
        }
        if (!scene.globe.show) {
          return scene.pickPosition(position) // 只取模型上的时候
        }
      } else {
        // 点状对象直接返回其本身。
        if (Cesium__namespace.defined(pickedObject.id)) {
          const entity = pickedObject.id;
          if ((entity.billboard || entity.point || entity.label) && !entity.model) {
            return getPositionValue(entity.position)
          }
        }

        cartesian = scene.pickPosition(position);
        if (Cesium__namespace.defined(cartesian)) {
          const cartographic = Cesium__namespace.Cartographic.fromCartesian(cartesian);
          if (cartographic.height >= 0) {
            return cartesian
          }

          // 不是entity时，支持3dtiles地下
          if (!Cesium__namespace.defined(pickedObject.id) && cartographic.height >= -5000) {
            return cartesian
          }
        }
      }
    }

    // 超图s3m数据拾取
    if (Cesium__namespace.defined(Cesium__namespace.S3MTilesLayer)) {
      cartesian = scene.pickPosition(position);
      if (Cesium__namespace.defined(cartesian)) {
        return cartesian
      }
    }

    // onlyPickModelPosition是在 Map 中定义的对外属性
    // 通过 map.onlyPickModelPosition 进行修改
    if (scene.onlyPickModelPosition) {
      // 只取模型上的时候，不继续读取了
      return cartesian
    }

    // 1. globe.pick的结果相对稳定准确，不论地形深度检测开启与否，不论加载的是默认地形还是别的地形数据；
    // 2. scene.pickPosition只有在开启地形深度检测，且不使用默认地形时是准确的。
    // 注意点： 1. globe.pick只能求交地形； 2. scene.pickPosition不仅可以求交地形，还可以求交除地形以外其他所有写深度的物体。

    // 提取鼠标点的地理坐标
    if (scene.mode === Cesium__namespace.SceneMode.SCENE3D) {
      // 三维模式下
      const pickRay = scene.camera.getPickRay(position);
      cartesian = scene.globe.pick(pickRay, scene);
      if (!cartesian) {
        cartesian = scene.camera.pickEllipsoid(position, scene.globe.ellipsoid); // scene.globe.show=false时
      }
    } else {
      // 二维模式下
      cartesian = scene.camera.pickEllipsoid(position, scene.globe.ellipsoid);
    }

    if (Cesium__namespace.defined(cartesian) && scene.camera.positionCartographic.height < 10000) {
      const cartographic = Cesium__namespace.Cartographic.fromCartesian(cartesian);
      if (cartographic.height < -5000) {
        return null // 屏蔽无效值
      }
    }

    return cartesian
  }

  /**
   * 获取 屏幕XY坐标 对应的 地形上的笛卡尔三维坐标（不拾取模型、矢量数据等）
   *
   * @export
   * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {Cesium.Cartesian2} position 屏幕XY坐标（如鼠标所在位置)
   * @return {Cesium.Cartesian3}  笛卡尔三维坐标
   */
  function getCurrentMouseTerrainPosition(scene, position) {
    let cartesian;

    // 提取鼠标点的地理坐标
    if (scene.mode === Cesium__namespace.SceneMode.SCENE3D) {
      // 三维模式下
      const pickRay = scene.camera.getPickRay(position);
      cartesian = scene.globe.pick(pickRay, scene);
      if (!cartesian) {
        cartesian = scene.camera.pickEllipsoid(position, scene.globe.ellipsoid); // scene.globe.show=false时
      }
    } else {
      // 二维模式下
      cartesian = scene.camera.pickEllipsoid(position, scene.globe.ellipsoid);
    }
    return cartesian
  }

  /**
   * 求2点的中间点（贴地表）
   *
   * @export
   * @param {Cesium.Cartesian3|LngLatPoint} mpt1 点1坐标
   * @param {Cesium.Cartesian3|LngLatPoint} mpt2 点2坐标
   * @return {Cesium.Cartesian3} 2个点是否为重复的点
   */
  function getMidpoint(mpt1, mpt2) {
    if (!mpt2 || !mpt1) {
      return undefined
    }
    const startPosition = LngLatPoint.toCartographic(mpt1);
    const endPosition = LngLatPoint.toCartographic(mpt2);
    const height = (startPosition.height + endPosition.height) / 2;
    const mc = new Cesium__namespace.EllipsoidGeodesic(startPosition, endPosition).interpolateUsingFraction(0.5);
    return Cesium__namespace.Cartesian3.fromRadians(mc.longitude, mc.latitude, height)
  }

  /**
   * 判断2个点是否为重复的点，比如标绘中的双击会偶尔产生2个重复点
   *
   * @export
   * @param {Cesium.Cartesian3} mpt1 点1坐标
   * @param {Cesium.Cartesian3} mpt2 点2坐标
   * @return {Boolean} 2个点是否为重复的点
   */
  function isRepeatPoint(mpt1, mpt2) {
    if (!mpt2 || !mpt1) {
      return false
    }
    if (Math.abs(mpt1.x - mpt2.x) < 0.1 && Math.abs(mpt1.y - mpt2.y) < 0.1 && Math.abs(mpt1.z - mpt2.z) < 0.1) {
      return true
    } else {
      return false
    }
  }

  /**
   * 获取 点point1 绕 点center 的地面法向量 旋转顺时针angle角度 后的 新坐标
   *
   * @export
   * @param {Cesium.Cartesian3} center 中心点坐标
   * @param {Cesium.Cartesian3} point1 点坐标
   * @param {Number} angle 旋转角度,顺时针方向 0-360度
   * @return {Cesium.Cartesian3} 计算得到的新坐标
   */
  function getRotateCenterPoint(center, point1, angle) {
    // 计算center的地面法向量
    const chicB = Cesium__namespace.Cartographic.fromCartesian(center);
    chicB.height = 0;
    const dB = Cesium__namespace.Cartographic.toCartesian(chicB);
    let normaB = Cesium__namespace.Cartesian3.subtract(dB, center, new Cesium__namespace.Cartesian3());
    normaB = Cesium__namespace.Cartesian3.normalize(normaB, new Cesium__namespace.Cartesian3());

    // 构造基于center的法向量旋转90度的矩阵
    const Q = Cesium__namespace.Quaternion.fromAxisAngle(normaB, Cesium__namespace.Math.toRadians(angle));
    const m3 = Cesium__namespace.Matrix3.fromQuaternion(Q);
    const inverseMatrix = Cesium__namespace.Matrix4.fromRotationTranslation(m3);

    // 计算point1点相对center点的坐标A1
    const A1 = Cesium__namespace.Cartesian3.subtract(point1, center, new Cesium__namespace.Cartesian3());

    // 对A1应用旋转矩阵
    const p = Cesium__namespace.Matrix4.multiplyByPoint(inverseMatrix, A1, new Cesium__namespace.Cartesian3());
    // 新点的坐标
    const pointNew = Cesium__namespace.Cartesian3.add(p, center, new Cesium__namespace.Cartesian3());

    return pointNew
  }

  /**
   * 求 p1指向p2方向线上，距离p1或p2指定长度的 新的点
   *
   * @export
   * @param {Cesium.Cartesian3} p1 起点坐标
   * @param {Cesium.Cartesian3} p2 终点坐标
   * @param {Number} len  指定的距离，addBS为false时：len为距离起点p1的距离，addBS为true时：len为距离终点p2的距离
   * @param {Boolean} [addBS=false]  标识len的参考目标
   * @return {Cesium.Cartesian3}  计算得到的新坐标
   */
  function getOnLinePointByLen(p1, p2, len, addBS) {
    const mtx4 = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(p1);
    const mtx4_inverser = Cesium__namespace.Matrix4.inverse(mtx4, new Cesium__namespace.Matrix4());
    p1 = Cesium__namespace.Matrix4.multiplyByPoint(mtx4_inverser, p1, new Cesium__namespace.Cartesian3());
    p2 = Cesium__namespace.Matrix4.multiplyByPoint(mtx4_inverser, p2, new Cesium__namespace.Cartesian3());

    const substrct = Cesium__namespace.Cartesian3.subtract(p2, p1, new Cesium__namespace.Cartesian3());

    const dis = Cesium__namespace.Cartesian3.distance(p1, p2);
    let scale = len / dis; // 求比例
    if (addBS) {
      scale += 1;
    }

    let newP = Cesium__namespace.Cartesian3.multiplyByScalar(substrct, scale, new Cesium__namespace.Cartesian3());
    newP = Cesium__namespace.Matrix4.multiplyByPoint(mtx4, newP, new Cesium__namespace.Cartesian3());
    return newP
  }

  /**
   * 根据 坐标位置、hpr方向、偏移距离，计算目标点坐标
   *
   * @export
   * @param {Cesium.Cartesian3|LngLatPoint} position 坐标位置
   * @param {Cesium.Cartesian3} offest 偏移距离值, xyz值的单位：米
   * @param {Cesium.HeadingPitchRoll} hpr 方向值
   * @param {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
   * @param {Cesium.Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
   * @return {Cesium.Cartesian3} 目标点坐标
   */
  function getPositionByHprAndOffset(position, offest, hpr, ellipsoid, fixedFrameTransform) {
    position = LngLatPoint.toCartesian(position);
    if (!hpr) {
      hpr = new Cesium__namespace.HeadingPitchRoll();
    }
    const orientation = Cesium__namespace.Transforms.headingPitchRollQuaternion(position, hpr, ellipsoid, fixedFrameTransform);

    const matrix = Cesium__namespace.Matrix4.fromRotationTranslation(
      Cesium__namespace.Matrix3.fromQuaternion(orientation, new Cesium__namespace.Matrix3()),
      position,
      new Cesium__namespace.Matrix4()
    );
    const result = Cesium__namespace.Matrix4.multiplyByPoint(matrix, offest, new Cesium__namespace.Cartesian3());
    return result
  }

  /**
   * 根据观察点的方向角度和距离，计算目标点坐标
   *
   * @export
   * @param {Cesium.Cartesian3|LngLatPoint} position 观察点坐标
   * @param {Number} angle 方向角度 (正东方向为0,顺时针到360度)
   * @param {Number} radius 半径距离
   * @return {Cesium.Cartesian3} 目标点坐标
   */
  function getPositionByDirectionAndLen(position, angle, radius) {
    position = LngLatPoint.toCartesian(position);

    const matrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(position);

    // 旋转
    const mz = Cesium__namespace.Matrix3.fromRotationZ(Cesium__namespace.Math.toRadians(360 - (angle || 0)));
    const rotationZ = Cesium__namespace.Matrix4.fromRotationTranslation(mz);
    Cesium__namespace.Matrix4.multiply(matrix, rotationZ, matrix);

    const result = Cesium__namespace.Matrix4.multiplyByPoint(matrix, new Cesium__namespace.Cartesian3(radius, 0, 0), new Cesium__namespace.Cartesian3());
    return result
  }

  /**
   * 根据观察点的hpr方向和距离，计算目标点坐标
   *
   * @export
   * @param {Cesium.Cartesian3|LngLatPoint} position 观察点坐标
   * @param {Cesium.HeadingPitchRoll} hpr 方向值
   * @param {Number} radiusZ 半径距离
   * @return {Cesium.Cartesian3} 目标点坐标
   */
  function getPositionByHprAndLen(position, hpr, radiusZ) {
    position = LngLatPoint.toCartesian(position);

    const orientation = Cesium__namespace.Transforms.headingPitchRollQuaternion(position, hpr);
    const matrix = Cesium__namespace.Matrix4.fromRotationTranslation(
      Cesium__namespace.Matrix3.fromQuaternion(orientation, new Cesium__namespace.Matrix3()),
      position,
      new Cesium__namespace.Matrix4()
    );
    const result = Cesium__namespace.Matrix4.multiplyByPoint(matrix, new Cesium__namespace.Cartesian3(0, 0, -radiusZ), new Cesium__namespace.Cartesian3());
    return result
  }

  /**
   *  按观察点坐标和orientation方向，求观察点射向地球与地球的交点
   *
   * @export
   * @param {Cesium.Cartesian3} position 观察点坐标
   * @param {Cesium.HeadingPitchRoll|Cesium.Quaternion} orientation HeadingPitchRoll方向 或 四元数实例
   * @param {Boolean} reverse 是否翻转射线方向
   * @param {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
   * @return {Cesium.Cartesian3} 射线与地球的交点
   */
  function getRayEarthPosition(position, orientation, reverse, ellipsoid) {
    if (!position || !orientation) {
      return
    }

    if (orientation instanceof Cesium__namespace.HeadingPitchRoll) {
      orientation = Cesium__namespace.Transforms.headingPitchRollQuaternion(position, orientation);
    }

    const matrix = Cesium__namespace.Matrix4.fromRotationTranslation(
      Cesium__namespace.Matrix3.fromQuaternion(orientation, new Cesium__namespace.Matrix3()),
      position,
      new Cesium__namespace.Matrix4()
    );
    return getRayEarthPositionByMatrix(matrix, reverse, ellipsoid)
  }

  /**
   *  按转换矩阵，求观察点射向地球与地球的交点
   *
   * @export
   * @param {Cesium.Matrix4} matrix 转换矩阵
   * @param {Boolean} reverse 是否翻转射线方向
   * @param {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
   * @return {Cesium.Cartesian3} 射线与地球的交点
   */
  function getRayEarthPositionByMatrix(matrix, reverse, ellipsoid) {
    const scratchWC = new Cesium__namespace.Cartesian3();
    const scratchRay = new Cesium__namespace.Ray();

    Cesium__namespace.Matrix4.multiplyByPoint(matrix, Cesium__namespace.Cartesian3.ZERO, scratchWC);
    scratchWC.clone(scratchRay.origin);

    const bottomCenter = new Cesium__namespace.Cartesian3(0, 0, reverse ? -100 : 100);
    const groundPosition = extend2Earth(bottomCenter, matrix, scratchRay, ellipsoid);
    return groundPosition
  }

  // 求地球交点【内部】
  function extend2Earth(positionLC, matrix, ray, ellipsoid) {
    ellipsoid = ellipsoid || Cesium__namespace.Ellipsoid.WGS84;

    const scratchWC = new Cesium__namespace.Cartesian3();
    Cesium__namespace.Matrix4.multiplyByPoint(matrix, positionLC, scratchWC);

    // 取延长线与地球相交的点
    Cesium__namespace.Cartesian3.subtract(scratchWC, ray.origin, ray.direction);
    Cesium__namespace.Cartesian3.normalize(ray.direction, ray.direction);

    // Get the first intersection point of a ray and an ellipsoid.
    const intersection = Cesium__namespace.IntersectionTests.rayEllipsoid(ray, ellipsoid);
    let point = null;
    if (intersection) {
      point = Cesium__namespace.Ray.getPoint(ray, intersection.start);
    }
    if (point) {
      try {
        const scratchCartographic2 = new Cesium__namespace.Cartographic();
        Cesium__namespace.Cartographic.fromCartesian(point, null, scratchCartographic2);
      } catch (e) {
        return null
      }
    }
    return point
  }

  /**
   * 根据 position位置 和 orientation四元数实例 求 Heading Pitch Roll方向
   *
   * @export
   * @param {Cesium.Cartesian3} position 位置坐标
   * @param {Cesium.Quaternion} orientation 四元数实例
   * @param {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
   * @param {Cesium.Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
   * @return {Cesium.HeadingPitchRoll} Heading Pitch Roll方向
   */
  function getHeadingPitchRollByOrientation(position, orientation, ellipsoid, fixedFrameTransform) {
    if (!Cesium__namespace.defined(orientation) || !Cesium__namespace.defined(position)) {
      return new Cesium__namespace.HeadingPitchRoll()
    }

    const matrix = Cesium__namespace.Matrix4.fromRotationTranslation(
      Cesium__namespace.Matrix3.fromQuaternion(orientation, new Cesium__namespace.Matrix3()),
      position,
      new Cesium__namespace.Matrix4()
    );
    const hpr = getHeadingPitchRollByMatrix(matrix, ellipsoid, fixedFrameTransform);
    return hpr
  }

  /**
   * 根据matrix转换矩阵 求 Heading Pitch Roll角度
   *
   * @export
   * @param {Cesium.Matrix4} matrix 转换矩阵
   * @param {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
   * @param {Cesium.Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
   * @param {Cesium.HeadingPitchRoll} [result] 可以先实例化返回的 Heading Pitch Roll角度对象
   * @return {Cesium.HeadingPitchRoll} Heading Pitch Roll角度
   */
  function getHeadingPitchRollByMatrix(matrix, ellipsoid, fixedFrameTransform, result) {
    return Cesium__namespace.Transforms.fixedFrameToHeadingPitchRoll(matrix, ellipsoid, fixedFrameTransform, result)
  }

  /**
   * 求 localStart点 到 localEnd点的 Heading Pitch Roll方向
   *
   * @export
   * @param {Cesium.Cartesian3|LngLatPoint} localStart 起点坐标
   * @param {Cesium.Cartesian3|LngLatPoint} localEnd 终点坐标
   * @param {Cesium.Ellipsoid} [ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
   * @param {Cesium.Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
   * @return {Cesium.HeadingPitchRoll} Heading Pitch Roll方向
   */
  function getHeadingPitchRollForLine(localStart, localEnd, ellipsoid, fixedFrameTransform) {
    localStart = LngLatPoint.toCartesian(localStart);
    localEnd = LngLatPoint.toCartesian(localEnd);

    ellipsoid = ellipsoid || Cesium__namespace.Ellipsoid.WGS84;

    const cartesian3 = new Cesium__namespace.Cartesian3();
    const matrix4Scratch2 = new Cesium__namespace.Matrix4();
    const rotationScratch = new Cesium__namespace.Matrix3();

    const velocity = Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(localEnd, localStart, cartesian3), cartesian3);
    Cesium__namespace.Transforms.rotationMatrixFromPositionVelocity(localStart, velocity, ellipsoid, rotationScratch);
    const modelMatrix = Cesium__namespace.Matrix4.fromRotationTranslation(rotationScratch, localStart, matrix4Scratch2);

    Cesium__namespace.Matrix4.multiplyTransformation(modelMatrix, Cesium__namespace.Axis.Z_UP_TO_X_UP, modelMatrix);

    const hpr = getHeadingPitchRollByMatrix(modelMatrix, ellipsoid, fixedFrameTransform);
    return hpr
  }

  var PointUtil = {
    __proto__: null,
    getTransFun: getTransFun,
    getPositionValue: getPositionValue,
    getMaxHeight: getMaxHeight,
    getMinHeight: getMinHeight,
    addPositionsHeight: addPositionsHeight,
    setPositionsHeight: setPositionsHeight,
    getHeight: getHeight,
    getSurfaceHeight: getSurfaceHeight,
    getSurfaceTerrainHeight: getSurfaceTerrainHeight,
    getSurfacePosition: getSurfacePosition,
    getCurrentMousePosition: getCurrentMousePosition,
    getCurrentMouseTerrainPosition: getCurrentMouseTerrainPosition,
    getMidpoint: getMidpoint,
    isRepeatPoint: isRepeatPoint,
    getRotateCenterPoint: getRotateCenterPoint,
    getOnLinePointByLen: getOnLinePointByLen,
    getPositionByHprAndOffset: getPositionByHprAndOffset,
    getPositionByDirectionAndLen: getPositionByDirectionAndLen,
    getPositionByHprAndLen: getPositionByHprAndLen,
    getRayEarthPosition: getRayEarthPosition,
    getRayEarthPositionByMatrix: getRayEarthPositionByMatrix,
    extend2Earth: extend2Earth,
    getHeadingPitchRollByOrientation: getHeadingPitchRollByOrientation,
    getHeadingPitchRollByMatrix: getHeadingPitchRollByMatrix,
    getHeadingPitchRollForLine: getHeadingPitchRollForLine
  };

  // 【线面】异步计算多点 贴地(或贴模型)
  class SurfacePoints {
    constructor(options) {
      this.options = options;
      this.scene = options.map ? options.map.scene : options.scene;

      if (!this.scene) {
        logError(`SurfacePoints: 请传入scene参数`, this.options);
      }

      this.positions = LngLatArray.toCartesians(this.options.positions);
    }

    start() {
      return new Promise((resolve, reject) => {
        this._promise = { resolve, reject };

        if (this.positions == null || this.positions.length === 0) {
          // 无数据
          this.end(this.positions);
          return
        }

        const _has3dtiles = this.options.has3dtiles ?? Cesium__namespace.defined(pick3DTileset(this.scene, this.positions)); // 是否在3ditiles上面
        const _hasTerrain = Boolean(this.scene.terrainProvider._layers); // 是否有地形

        this._has3dtiles = _has3dtiles;
        this._hasTerrain = _hasTerrain;

        if (!_hasTerrain && !_has3dtiles) {
          // 无地形和无模型时，直接返回
          this.end(this.positions);
          return
        }

        // 开始分析
        if (_has3dtiles) {
          this.clampTo3DTileset(this.positions);
        } else {
          this.clampToTerrain(this.positions);
        }
      })
    }

    clampTo3DTileset(positions) {
      const positionsClone = [];
      for (let i = 0, len = positions.length; i < len; ++i) {
        positionsClone.push(positions[i].clone());
      }
      this.scene.clampToHeightMostDetailed(positionsClone, this.options.objectsToExclude).then((clampedCartesians) => {
        clampedCartesians = this.removeNullData(clampedCartesians);
        if (clampedCartesians.length > 0) {
          this.end(clampedCartesians);
        } else {
          this.clampToTerrain(positions);
        }
      });
    }

    clampToTerrain(positions) {
      const ellipsoid = this.scene.globe.ellipsoid;
      const cartographicArray = ellipsoid.cartesianArrayToCartographicArray(positions);

      // 用于缺少地形数据时，赋值的高度
      const tempHeight = Cesium__namespace.Cartographic.fromCartesian(positions[0]).height;

      Cesium__namespace.sampleTerrainMostDetailed(this.scene.terrainProvider, cartographicArray).then((samples) => {
        samples = this.removeNullData(samples);

        let noHeight = false;
        const offset = this.options.offset ?? 0; // 增高高度，便于可视

        for (let i = 0; i < samples.length; ++i) {
          if (samples[i].height == null) {
            noHeight = true;
            samples[i].height = tempHeight;
          } else {
            samples[i].height = offset + samples[i].height;
          }
        }

        const raisedPositions = ellipsoid.cartographicArrayToCartesianArray(samples);
        this.end(raisedPositions, noHeight);
      });
    }

    end(raisedPositions, noHeight) {
      if (this.options.callback) {
        this.options.callback(raisedPositions, noHeight, this.positions); // 兼容v3.4之前版本callback
      }

      this._promise.resolve({
        positions: raisedPositions,
        positions_original: this.positions,
        noHeight: noHeight,
        has3dtiles: this._has3dtiles,
        hasTerrain: this._hasTerrain
      });
    }

    removeNullData(samples) {
      const arrNew = [];
      for (let i = 0; i < samples.length; ++i) {
        if (samples[i] != null) {
          arrNew.push(samples[i]);
        }
      }
      return arrNew
    }
  }

  /**
   * 多个点 或 线面数据 相关处理 静态方法
   * @module PolyUtil
   */

  /**
   * 求坐标数组的中心点
   *
   * @export
   * @param {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]} arr 坐标数组
   * @param {Number} height 指定中心点的高度值，默认为所有点的最高高度
   * @return {Cesium.Cartesian3} 中心点坐标
   */
  function centerOfMass(arr, height) {
    if (!arr || arr.length === 0) {
      return
    }
    const positions = LngLatArray.toCartesians(arr);

    try {
      if (positions.length === 1) {
        return positions[0]
      } else if (positions.length === 2) {
        return getMidpoint(positions[0], positions[1])
      }

      if (height == null) {
        height = getMaxHeight(positions);
      }

      const boundingSphere = Cesium__namespace.BoundingSphere.fromPoints(positions);
      const ptcenter = setPositionsHeight(boundingSphere.center, height);

      return ptcenter
    } catch (e) {
      return positions[Math.floor(positions.length / 2)]
    }
  }

  /**
   * 缓冲分析，求指定 点线面geojson对象 按width半径的 缓冲面对象
   *
   * @export
   * @param {Object} geojson geojson格式对象
   * @param {Number} width 缓冲半径,单位：米
   * @param {Number} [steps=8] 缓冲步幅
   * @return {Object} 缓冲面对象，geojson格式
   */
  function buffer(geojson, width = 1, steps = 8) {
    if (!hasTurf(turf.buffer)) {
      return geojson
    }

    try {
      if (geojson?.geometry?.type === "Polygon") {
        geojson.geometry.coordinates[0].push(geojson.geometry.coordinates[0][0]);
      }

      // API: http://turfjs.org/docs/#buffer
      geojson = turf.buffer(geojson, width, { units: "meters", steps: steps });
    } catch (e) {
      logError("PolyUtil buffer:缓冲分析异常", e);
    }
    return geojson
  }

  /**
   * 缓冲分析，坐标数组围合面，按width半径的 缓冲新的坐标
   *
   * @export
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} points 坐标数组
   * @param {Number} width 缓冲半径,单位：米
   * @param {Number} [steps=8] 缓冲步幅
   * @return {LngLatPoint[]} 缓冲后的新坐标数组
   */
  function bufferPoints(points, width = 1, steps = 8) {
    try {
      const coordinates = LngLatArray.toArray(points);
      if (coordinates[0][0] !== coordinates[coordinates.length - 1][0] && coordinates[0][1] !== coordinates[coordinates.length - 1][1]) {
        coordinates.push(coordinates[0]);
      }

      // API: http://turfjs.org/docs/#buffer
      const polygon = {
        type: "Feature",
        geometry: { type: "Polygon", coordinates: [coordinates] }
      };
      const geojson = turf.buffer(polygon, width, { units: "meters", steps: steps });

      return LngLatArray.toPoints(geojson.geometry.coordinates[0])
    } catch (e) {
      logError("PolyUtil buffer:缓冲分析异常", e);
    }
    return points
  }

  /**
   * 求坐标数组的矩形范围内 按 splitNum网格数插值的 granularity值
   *
   * @export
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} positions 坐标数组
   * @param {Number} [splitNum=10] splitNum网格数
   * @return {Number} granularity值
   */
  function getGranularity(positions, splitNum = 10) {
    const recta = Cesium__namespace.Rectangle.fromCartesianArray(LngLatArray.toCartesians(positions));
    let granularity = Math.max(recta.height, recta.width);
    granularity /= splitNum;
    return granularity
  }

  /**
   * 面内进行贴地(或贴模型)插值, 返回三角网等计算结果 的回调方法
   * @callback interPolygonResult
   * @param {Object} [options={}] 参数对象:
   * @param {Object[]} options.list  三角网对象数组，每个对象包含三角形的3个顶点(point1\point2\point3)相关值
   * @param {Number} options.maxHeight 面内最大高度
   * @param {Number} options.minHeight 面内最小高度
   * @param {Number} options.granularity 面内按splitNum网格数插值的granularity值
   * @param {Boolean} options.has3dtiles 是否贴模型
   * @param {Boolean} options.hasTerrain 是否贴地形
   */

  /**
   * 面内进行贴地(或贴模型)插值, 返回三角网等计算结果
   *
   * @export
   * @param {Object} [options={}] 参数对象:
   * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标数组
   * @param {Number} [options.splitNum=10] 插值数，横纵等比分割的网格个数
   * @param {Boolean} [options.exact=false]  是否进行精确计算
   * @param {Boolean} [options.has3dtiles]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
   * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   * @param {Boolean} [options.onlyPoint=false] truea时，返回结果中只返回点，不返回三角网
   * @return {Promise<interPolygonResult>} 异步计算完成的Promise
   */
  function interPolygon(options) {
    const scene = options.scene;
    const positions = LngLatArray.toCartesians(options.positions, true); // 坐标数组
    const granularity = getGranularity(positions, options.splitNum); // splitNum分割的个数

    return new Promise((resolve, reject) => {
      const positionsNew = []; // 插值求面的三角网

      const polygonGeometry = new Cesium__namespace.PolygonGeometry.fromPositions({
        positions: positions,
        vertexFormat: Cesium__namespace.PerInstanceColorAppearance.FLAT_VERTEX_FORMAT,
        granularity: granularity
      });
      const geom = new Cesium__namespace.PolygonGeometry.createGeometry(polygonGeometry);

      let i0, i1, i2;
      let cartesian1, cartesian2, cartesian3;
      for (let i = 0; i < geom.indices.length; i += 3) {
        i0 = geom.indices[i];
        i1 = geom.indices[i + 1];
        i2 = geom.indices[i + 2];

        // 三角形 点1
        cartesian1 = new Cesium__namespace.Cartesian3(
          geom.attributes.position.values[i0 * 3],
          geom.attributes.position.values[i0 * 3 + 1],
          geom.attributes.position.values[i0 * 3 + 2]
        );
        positionsNew.push(cartesian1);

        // 三角形 点2
        cartesian2 = new Cesium__namespace.Cartesian3(
          geom.attributes.position.values[i1 * 3],
          geom.attributes.position.values[i1 * 3 + 1],
          geom.attributes.position.values[i1 * 3 + 2]
        );
        positionsNew.push(cartesian2);

        // 三角形 点3
        cartesian3 = new Cesium__namespace.Cartesian3(
          geom.attributes.position.values[i2 * 3],
          geom.attributes.position.values[i2 * 3 + 1],
          geom.attributes.position.values[i2 * 3 + 2]
        );
        positionsNew.push(cartesian3);
      }

      let maxHeight = 0;
      let minHeight = 9999;
      const onlyPoint = options.onlyPoint ?? false; // 只返回点，不需要三角网时

      // 格式化每个点
      function onFormatPoint(position, noHeight) {
        let height;
        let point;
        let pointDM;
        let carto;

        if (noHeight) {
          delete options.callback;
          height = getHeight(scene, position, options);

          carto = Cesium__namespace.Cartographic.fromCartesian(position);
          point = Cesium__namespace.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0);
          pointDM = Cesium__namespace.Cartesian3.fromRadians(carto.longitude, carto.latitude, height);
        } else {
          carto = Cesium__namespace.Cartographic.fromCartesian(position);
          height = carto.height;

          point = Cesium__namespace.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0);
          pointDM = position;
        }

        if (maxHeight < height) {
          maxHeight = height;
        }
        if (minHeight > height) {
          minHeight = height;
        }

        return {
          height: height,
          point: point,
          pointDM: pointDM
        }
      }

      function interCallback(result) {
        const arrSJW = [];
        let obj1, obj2, obj3;
        for (let i = 0; i < result.positions.length; i += 3) {
          // 三角形 点1
          obj1 = onFormatPoint(result.positions[i], result.noHeight);
          // 三角形 点2
          obj2 = onFormatPoint(result.positions[i + 1], result.noHeight);
          // 三角形 点3
          obj3 = onFormatPoint(result.positions[i + 2], result.noHeight);

          if (onlyPoint) {
            // 只返回点，不需要三角网
            addPointFoyArrOnly(arrSJW, obj1);
            addPointFoyArrOnly(arrSJW, obj2);
            addPointFoyArrOnly(arrSJW, obj3);
          } else {
            // 常规返回，三角网
            arrSJW.push({ point1: obj1, point2: obj2, point3: obj3 });
          }
        }

        if (Cesium__namespace.defined(options.minHeight)) {
          minHeight = Math.max(options.minHeight, minHeight);
          maxHeight = Math.max(maxHeight, minHeight);
        }

        // 记录返回数据
        result.granularity = granularity;
        result.maxHeight = maxHeight;
        result.minHeight = minHeight;
        result.list = arrSJW; // 三角网

        if (options.callback) {
          options.callback(result); // 兼容v3.4之前版本callback
        }

        resolve(result);
      }

      // 是否异步求精确高度
      if (options.exact) {
        // 求高度
        computeSurfacePoints({
          scene: scene,
          positions: positionsNew,
          has3dtiles: options.has3dtiles
        }).then(interCallback);
      } else {
        interCallback({
          positions: positionsNew,
          noHeight: true,
          has3dtiles: options.has3dtiles,
          hasTerrain: options.hasTerrain
        });
      }
    })
  }

  // 判断坐标点是否在数组内
  function addPointFoyArrOnly(arr, newItem) {
    let isIn = false;
    const point = newItem.point;
    for (let z = 0; z < arr.length; z++) {
      const item = arr[z].point;
      if (point.x === item.x && point.y === item.y && point.z === item.z) {
        isIn = true;
        break
      }
    }
    if (!isIn) {
      arr.push(newItem);
    }
  }

  /**
   * 计算面内最大、最小高度值
   *
   * @export
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} positions 坐标数组
   * @param {Cesium.Scene} scene  三维地图场景对象，一般用map.scene
   * @param {Object} [options={}] 参数对象:
   * @param {Number} [options.splitNum=10] 插值数，横纵等比分割的网格个数
   * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
   * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   * @return {Promise<Object>} 异步计算完成的Promise，结果示例：{ maxHeight: 100, minHeight: 21 }
   */
  function getHeightRange(positions, scene, options) {
    return interPolygon({
      positions: positions,
      scene: scene,
      ...options
    })
  }

  /**
   * 计算三角形面积（空间平面）
   *
   * @export
   * @param {Cesium.Cartesian3} pos1 三角形顶点坐标1
   * @param {Cesium.Cartesian3} pos2 三角形顶点坐标2
   * @param {Cesium.Cartesian3} pos3 三角形顶点坐标3
   * @return {Number} 面积，单位：平方米
   * @private
   */
  function getTriangleArea$1(pos1, pos2, pos3) {
    const a = Cesium__namespace.Cartesian3.distance(pos1, pos2);
    const b = Cesium__namespace.Cartesian3.distance(pos2, pos3);
    const c = Cesium__namespace.Cartesian3.distance(pos3, pos1);
    const S = (a + b + c) / 2;
    return Math.sqrt(S * (S - a) * (S - b) * (S - c))
  }

  /**
   * 面内进行贴地(或贴模型)插值, 返回三角网等计算结果 的回调方法
   * @callback VolumeResult
   * @param {Object} [options={}] 参数对象:
   * @param {Object[]} options.list  三角网对象数组，每个对象包含三角形的3个顶点(point1\point2\point3)相关值
   * @param {Number} options.maxHeight 面内最大高度
   * @param {Number} options.minHeight 面内最小高度
   * @param {Number} options.granularity 面内按splitNum网格数插值的granularity值
   * @param {Boolean} options.has3dtiles 是否贴模型
   * @param {Boolean} options.hasTerrain 是否贴地形
   *
   * @param {Number} options.totalArea 总面积(横截面/投影底面)，执行updateVolumeByMinHeight后赋值
   * @param {Number} options.totalVolume  总体积，执行updateVolumeByMinHeight后赋值
   *
   * @param {Number} options.digVolume  挖方体积，执行updateVolume后赋值
   * @param {Number} options.fillVolume  填方体积，执行updateVolume后赋值
   */

  /**
   * 体积计算
   *
   * @export
   * @param {Object} [options={}] 参数对象:
   * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标数组
   * @param {Boolean} [options.exact=false]  是否进行精确计算
   * @param {Number} [options.splitNum=10] 插值数，横纵等比分割的网格个数
   * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
   * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   * @return {Promise<VolumeResult>} 异步计算完成的Promise
   */
  function computeVolume(options) {
    return interPolygon(options).then((result) => {
      return updateVolumeByMinHeight(result)
    })
  }

  /**
   * 根据 minHeight最低底面高度 计算（或重新计算）填挖方体积
   *
   * @export
   * @param {interPolygonResult} resultInter 插值完的对象
   * @return {VolumeResult} 计算完成的填挖方体积
   */
  function updateVolumeByMinHeight(resultInter) {
    const minHeight = resultInter.minHeight;

    let totalArea = 0; // 总面积(横截面/投影底面)
    let totalVolume = 0; // 总体积

    for (let i = 0, len = resultInter.list.length; i < len; i++) {
      const item = resultInter.list[i];

      const pt1 = item.point1;
      const pt2 = item.point2;
      const pt3 = item.point3;

      // 横截面面积
      const bottomArea = getTriangleArea$1(pt1.point, pt2.point, pt3.point);
      item.area = bottomArea;
      totalArea += bottomArea;

      let height1 = pt1.height;
      let height2 = pt2.height;
      let height3 = pt3.height;
      if (height1 < minHeight) {
        height1 = minHeight;
      }
      if (height2 < minHeight) {
        height2 = minHeight;
      }
      if (height3 < minHeight) {
        height3 = minHeight;
      }

      // 挖方体积 （横截面面积 * 3个点的平均高）
      const cutVolume = (bottomArea * (height1 - minHeight + height2 - minHeight + height3 - minHeight)) / 3;
      item.cutVolume = cutVolume;
      totalVolume = totalVolume + cutVolume;
    }

    resultInter.totalArea = totalArea; // 总面积(横截面/投影底面)
    resultInter.totalVolume = totalVolume; // 总体积

    return resultInter
  }

  /**
   * 根据 基准面高度 重新计算填挖方体积
   *
   * @export
   * @param {VolumeResult} resultInter 插值完的对象
   * @param {Number} cutHeight 基准面高度
   * @return {VolumeResult} 重新计算填挖方体积后的对象
   */
  function updateVolume(resultInter, cutHeight) {
    if (!resultInter) {
      return
    }

    const minHeight = resultInter.minHeight;
    const totalVolume = resultInter.totalVolume; // 总体积

    if (cutHeight <= minHeight) {
      resultInter.fillVolume = 0; // 填方体积
      resultInter.digVolume = totalVolume; // 挖方体积

      return resultInter
    }

    let totalV = 0; // 底部到基准面的总体积
    let totalBottomV = 0; // 挖方体积
    for (let i = 0, len = resultInter.list.length; i < len; i++) {
      const item = resultInter.list[i];

      // 底部到基准面的总体积
      totalV += item.area * (cutHeight - minHeight);

      const pt1 = item.point1;
      const pt2 = item.point2;
      const pt3 = item.point3;

      let height1 = pt1.height;
      let height2 = pt2.height;
      let height3 = pt3.height;
      if (height1 < cutHeight) {
        height1 = cutHeight;
      }
      if (height2 < cutHeight) {
        height2 = cutHeight;
      }
      if (height3 < cutHeight) {
        height3 = cutHeight;
      }

      // 挖方体积 （横截面面积 * 3个点的平均高）
      totalBottomV += (item.area * (height1 - cutHeight + height2 - cutHeight + height3 - cutHeight)) / 3;
    }

    resultInter.digVolume = totalBottomV; // 挖方体积
    resultInter.fillVolume = totalV - (totalVolume - totalBottomV); // 填方体积

    return resultInter
  }

  /**
   * 获取 圆（或椭圆）边线上的坐标点数组
   *
   * @export
   * @param {Object} options 参数对象:
   * @param {Cesium.Cartesian3|LngLatPoint} options.position  圆的中心坐标
   * @param {Number} [options.radius]  如是圆时，半径（单位：米）
   * @param {Number} [options.semiMajorAxis]  椭圆时的 长半轴半径（单位：米）
   * @param {Number} [options.semiMinorAxis]   椭圆时的 短半轴半径（单位：米）
   * @param {Number} [options.count=1]  象限内点的数量，返回的总数为 count*4
   * @param {Number} [options.granularity]  granularity值,与count二选一
   * @param {Number} [options.rotation=0]  旋转的角度
   * @return {Cesium.Cartesian3[]}  边线上的坐标点数组
   */
  function getEllipseOuterPositions(options) {
    let position = options.position;
    if (!position) {
      return null
    }
    position = LngLatPoint.toCartesian(position);

    const semiMajorAxis = options.semiMajorAxis ?? options.radius;
    const semiMinorAxis = options.semiMinorAxis ?? options.radius;

    if (!semiMajorAxis || !semiMinorAxis) {
      return [position, position, position]
    }

    const rotation = (options.rotation, 0);
    let granularity = options.granularity || Cesium__namespace.Math.RADIANS_PER_DEGREE;
    if (options.count) {
      granularity = Math.PI / (16 * options.count); // 点的数量，总数为count*4
    }

    // 获取椭圆上的坐标点数组
    const cep = Cesium__namespace.EllipseGeometryLibrary.computeEllipsePositions(
      {
        center: position,
        semiMajorAxis: semiMajorAxis, // 长半轴
        semiMinorAxis: semiMinorAxis, // 短半轴
        rotation: rotation,
        granularity: granularity
      },
      true,
      true
    );

    const arr = cep.outerPositions;
    const positions = [];
    for (let i = 0, len = arr.length; i < len; i += 3) {
      // 长半轴上的坐标点
      const pt = new Cesium__namespace.Cartesian3(arr[i], arr[i + 1], arr[i + 2]);
      positions.push(pt);
    }
    return positions
  }

  /**
   * 格式化Rectangle矩形对象,返回经纬度值
   *
   * @export
   * @param {Cesium.Rectangle} rectangle 矩形对象
   * @param  {Number} [digits=6] 经纬度保留的小数位数
   * @return {Object} 返回经纬度值，示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
   */
  function formatRectangle(rectangle, digits = LngLatPoint.FormatLength) {
    let west = formatNum$1(Cesium__namespace.Math.toDegrees(rectangle.west), digits);
    let east = formatNum$1(Cesium__namespace.Math.toDegrees(rectangle.east), digits);
    let north = formatNum$1(Cesium__namespace.Math.toDegrees(rectangle.north), digits);
    let south = formatNum$1(Cesium__namespace.Math.toDegrees(rectangle.south), digits);

    if (west > east) {
      const temp = west;
      west = east;
      east = temp;
    }

    if (south > north) {
      const temp = south;
      south = north;
      north = temp;
    }

    return {
      xmin: west,
      xmax: east,
      ymin: south,
      ymax: north
    }
  }

  /**
   * 计算geojson的边界范围
   * @export
   * @param {Object} [geojson] Geojson对象
   * @return {Object} 返回经纬度值，示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
   */
  function getExtentByGeoJSON(geojson) {
    // 判断tur库是否存在
    if (!hasTurf(turf.bbox)) {
      return null
    }

    const bbox = turf.bbox(geojson);
    if (bbox) {
      return { xmin: bbox[0], ymin: bbox[1], xmax: bbox[2], ymax: bbox[3] }
    }
    return null
  }

  /**
   * 获取 坐标数组 的 矩形边界值
   *
   * @export
   * @param {Cesium.Cartesian3[]|String[]|Array[]|LngLatPoint[]} positions 坐标数组
   * @param {Boolean} [isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
   * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
   */
  function getRectangle(positions, isFormat) {
    if (!positions) {
      return null
    }

    // 剔除null值的数据
    for (let i = positions.length - 1; i >= 0; i--) {
      if (!Cesium__namespace.defined(positions[i])) {
        positions.splice(i, 1);
      }
    }

    positions = LngLatArray.toCartesians(positions);

    const rectangle = Cesium__namespace.Rectangle.fromCartesianArray(positions);
    if (isFormat) {
      return formatRectangle(rectangle)
    } else {
      return rectangle
    }
  }

  /**
   * 获取坐标点数组的外接矩形的 4个顶点坐标点（数组）
   *
   * @export
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} positions  坐标点数组
   * @param {Number} [rotation=0]  旋转的角度，弧度值
   * @return {Cesium.Cartesian3[]} 4个顶点坐标点
   */
  function getPositionsRectVertex(positions, rotation = 0) {
    positions = LngLatArray.toCartesians(positions);
    const rectangle = Cesium__namespace.Rectangle.fromCartesianArray(positions);
    const height = getMaxHeight(positions);

    const arr = getRectangleOuterPositions({
      rectangle: rectangle,
      rotation: rotation,
      height: height
    });
    return arr
  }

  /**
   * 获取矩形（含旋转角度）的边线上的4个顶点坐标点数组
   *
   * @export
   * @param {Object} [options] 参数对象:
   * @param {Cesium.Rectangle} options.rectangle  矩形对象
   * @param {Number} [options.rotation=0]  旋转的角度，弧度值
   * @param {Number} [options.height=0]  坐标的高度
   * @param {Number} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE]  granularity值
   * @param {Cesium.Ellipsoid} [options.ellipsoid=Cesium.Ellipsoid.WGS84] 变换中使用固定坐标系的椭球。
   * @return {Cesium.Cartesian3[]} 边线上的4个顶点坐标点数组
   */
  function getRectangleOuterPositions(options) {
    const rectangle = options.rectangle;
    const rotation = options.rotation ?? 0.0;
    const height = options.height ?? 0.0;

    if (rotation === 0) {
      return [
        Cesium__namespace.Cartesian3.fromRadians(rectangle.west, rectangle.south, height),
        Cesium__namespace.Cartesian3.fromRadians(rectangle.east, rectangle.south, height),
        Cesium__namespace.Cartesian3.fromRadians(rectangle.east, rectangle.north, height),
        Cesium__namespace.Cartesian3.fromRadians(rectangle.west, rectangle.north, height)
      ]
    }

    const granularity = options.granularity ?? Cesium__namespace.Math.RADIANS_PER_DEGREE;

    const rectangleScratch = new Cesium__namespace.Rectangle();
    const nwScratch = new Cesium__namespace.Cartographic();
    const computedOptions = Cesium__namespace.RectangleGeometryLibrary.computeOptions(rectangle, granularity, rotation, 0, rectangleScratch, nwScratch);

    const w_height = computedOptions.height;
    const w_width = computedOptions.width;
    const ellipsoid = options.ellipsoid ?? Cesium__namespace.Ellipsoid.WGS84;

    let scratchRectanglePoints = [new Cesium__namespace.Cartesian3(), new Cesium__namespace.Cartesian3(), new Cesium__namespace.Cartesian3(), new Cesium__namespace.Cartesian3()];

    Cesium__namespace.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, 0, scratchRectanglePoints[0]);
    Cesium__namespace.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, w_width - 1, scratchRectanglePoints[1]);

    Cesium__namespace.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, w_height - 1, w_width - 1, scratchRectanglePoints[2]);

    Cesium__namespace.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, w_height - 1, 0, scratchRectanglePoints[3]);

    if (height !== 0) {
      scratchRectanglePoints = setPositionsHeight(scratchRectanglePoints, height);
    }

    return scratchRectanglePoints
  }

  /**
   * 根据传入中心点、高宽或角度，计算矩形面的顶点坐标。
   *
   * @export
   * @param {Object} [options] 参数对象:
   * @param {Cesium.Cartesian3|LngLatPoint} options.center  中心坐标
   * @param {Number} [options.width]  矩形的宽度，单位：米
   * @param {Number} [options.height]  矩形的高度，单位：米
   * @param {Number} [options.rotation=0]  旋转的角度
   * @param {Number} [options.originX=0.5]  中心点所在的位置x轴方向比例，取值范围：0.1-1.0
   * @param {Number} [options.originY=0.5]  中心点所在的位置y轴方向比例，取值范围：0.1-1.0
   * @return {Cesium.Cartesian3[]}  矩形面的顶点坐标数组
   */
  function getRectPositionsByCenter(options) {
    const center = LngLatPoint.toCartesian(options.center);
    const width = options.width;
    const height = options.height;
    const rotation = options.rotation ?? 0;
    const originX = options.originX ?? 0.5;
    const originY = options.originY ?? 0.5;

    const scratchEnuMatrix = new Cesium__namespace.Matrix4();
    const scratchRotationQuat = new Cesium__namespace.Quaternion();
    const scratchSrtMatrix = new Cesium__namespace.Matrix4();

    const localPositions = [
      Cesium__namespace.Cartesian3.fromElements(-originX, -originY, 0.0),
      Cesium__namespace.Cartesian3.fromElements(1.0 - originX, -originY, 0.0),
      Cesium__namespace.Cartesian3.fromElements(1.0 - originX, 1.0 - originY, 0.0),
      Cesium__namespace.Cartesian3.fromElements(-originX, 1.0 - originY, 0.0)
    ];

    const enuMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(center, Cesium__namespace.Ellipsoid.WGS84, scratchEnuMatrix);

    const rotationQuat = Cesium__namespace.Quaternion.fromAxisAngle(Cesium__namespace.Cartesian3.UNIT_Z, rotation, scratchRotationQuat);
    const cmftqrs = Cesium__namespace.Matrix4.fromTranslationQuaternionRotationScale;
    const srtMatrix = cmftqrs(Cesium__namespace.Cartesian3.ZERO, rotationQuat, Cesium__namespace.Cartesian3.fromElements(width, height), scratchSrtMatrix);

    const modelMatrix = Cesium__namespace.Matrix4.multiply(enuMatrix, srtMatrix, srtMatrix);

    const result = [];
    localPositions.forEach(function (lp, index) {
      if (typeof result[index] === "undefined") {
        result[index] = new Cesium__namespace.Cartesian3();
      }
      Cesium__namespace.Matrix4.multiplyByPoint(modelMatrix, lp, result[index]);
    });

    return result
  }

  /**
   * 判断点是否 多边形内
   *
   * @param {Cesium.Cartesian3|LngLatPoint} position 需要判断的点
   * @param {Cesium.Cartesian3[]|LngLatPoint[]} coordinates 多边形的边界点
   * @return {Boolean} 是否在多边形内
   */
  function isInPoly(position, coordinates) {
    if (!hasTurf(turf.booleanPointInPolygon)) {
      return false
    }

    const pt = {
      type: "Feature",
      geometry: { type: "Point", coordinates: LngLatPoint.parse(position).toArray() }
    };
    const poly = { type: "Polygon", coordinates: [LngLatArray.toArray(coordinates)] };
    return turf.booleanPointInPolygon(pt, poly) // turf插件计算的
  }

  /**
   * 求贝塞尔曲线坐标
   *
   * @export
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} positions 坐标数组
   * @param {Boolean} [closure=fasle] 是否闭合曲线
   * @return {Cesium.Cartesian3[]} 坐标数组
   */
  function getBezierCurve(positions, closure) {
    if (!positions || positions.length < 3) {
      return positions
    }

    const coordinates = LngLatArray.toArray(positions);
    if (closure) {
      // 闭合曲线
      coordinates.push(coordinates[0]);
    }
    const defHeight = coordinates[coordinates.length - 1][2];

    // 判断tur库是否存在
    if (!hasTurf(turf.bezierSpline)) {
      return positions
    }

    const curved = turf.bezierSpline({
      type: "Feature",
      geometry: {
        type: "LineString",
        coordinates: coordinates
      }
    });
    const result = lonlats2cartesians(curved.geometry.coordinates, defHeight);
    if (closure) {
      result.push(result[0]);
    }
    return result
  }

  /**
   * 对路线进行平面等比插值，高度：指定的固定height值 或 按贴地高度。
   *
   * @export
   * @param {Object} [options={}] 参数对象:
   * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标数组
   * @param {Number} [options.splitNum=100] 插值数，等比分割的个数
   * @param {Number} [options.minDistance] 插值最小间隔(单位：米)，优先级高于splitNum
   * @param {Number} [options.height=0] 坐标的高度
   * @param {Boolean} [options.surfaceHeight=true] 是否计算贴地高度 （非精确计算，根据当前加载的地形和模型数据情况有关）
   * @return {Cesium.Cartesian3[]} 插值后的路线坐标数组
   */
  function interPolyline(options) {
    const positions = LngLatArray.toCartesians(options.positions);
    const scene = options.scene;

    let granularity = getGranularity(positions, options.splitNum || (options.has3dtiles ? 10 : 100));
    if (granularity <= 0) {
      granularity = null;
    }

    const flatPositions = Cesium__namespace.PolylinePipeline.generateArc({
      positions: positions,
      height: options.height, // 未传入时，内部默认为0
      minDistance: options.minDistance, // 插值间隔(米)，优先级高于granularity
      granularity: granularity // splitNum分割的个数
    });

    const arr = [];
    for (let i = 0; i < flatPositions.length; i += 3) {
      let position = Cesium__namespace.Cartesian3.unpack(flatPositions, i);
      if (scene && (options.surfaceHeight ?? true)) {
        delete options.callback;
        const height = getHeight(scene, position, options);
        const car = Cesium__namespace.Cartographic.fromCartesian(position);
        position = Cesium__namespace.Cartesian3.fromRadians(car.longitude, car.latitude, height);
      }
      arr.push(position);
    }
    return arr
  }

  /**
   * 对路线进行按空间等比插值，高度：高度值按各点的高度等比计算
   * 比如：用于航线的插值运算
   *
   * @export
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} positions 坐标数组
   * @param {Object} [options={}] 参数对象:
   * @param {Number} [options.splitNum] 插值数，等比分割的个数，默认不插值
   * @param {Number|String} [options.minDistance] 插值时的最小间隔(单位：米)，优先级高于splitNum,如果传"auto"，自动计算坐标中最小的2点距离
   * @return {Cesium.Cartesian3[]} 插值后的坐标对象
   */
  function interLine(positions, options = {}) {
    if (!positions || positions.length < 2) {
      return positions
    }
    positions = LngLatArray.toCartesians(positions);

    let granularity;
    if (options.splitNum && !Cesium__namespace.defined(options.minDistance)) {
      // splitNum分割的个数
      granularity = getGranularity(positions, options.splitNum);
      if (granularity <= 0) {
        granularity = null;
      }
    }

    if (options.minDistance === "auto") {
      // 如果传"auto"，自动计算坐标中最小的2点距离
      let minDistance = Number.MAX_VALUE;
      for (let index = 1, length = positions.length; index < length; index++) {
        minDistance = Math.min(minDistance, Cesium__namespace.Cartesian3.distance(positions[index - 1], positions[index]));
      }
      options.minDistance = minDistance;
    }

    const arr = [positions[0]];
    for (let index = 1, length = positions.length; index < length; index++) {
      const startP = positions[index - 1];
      const endP = positions[index];

      const interPositions = Cesium__namespace.PolylinePipeline.generateArc({
        positions: [startP, endP],
        minDistance: options.minDistance, // 插值间隔(米)，优先级高于granularity
        granularity: granularity // splitNum分割的个数
      });

      // 剖面的数据
      const h1 = Cesium__namespace.Cartographic.fromCartesian(startP).height;
      const h2 = Cesium__namespace.Cartographic.fromCartesian(endP).height;
      const hstep = (h2 - h1) / interPositions.length;

      for (let i = 3, len = interPositions.length; i < len; i += 3) {
        let position = Cesium__namespace.Cartesian3.unpack(interPositions, i);

        const car = Cesium__namespace.Cartographic.fromCartesian(position);

        const height = Number((h1 + hstep * i).toFixed(1));
        position = Cesium__namespace.Cartesian3.fromRadians(car.longitude, car.latitude, height);

        arr.push(position);
      }
    }
    return arr
  }

  /**
   * 求路线的贴地线坐标（插值）
   *
   * @export
   * @param {Object} [options={}] 参数对象:
   * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {Cesium.Cartesian3[]|LngLatPoint[]} options.positions 坐标数组
   * @param {Number} [options.splitNum=100] 插值数，等比分割的个数
   * @param {Number} [options.minDistance] 插值最小间隔(单位：米)，优先级高于splitNum
   * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
   * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   * @param {Number} [options.offset=0]  可以按需增加偏移高度（单位：米），便于可视
   * @return {Promise<Object>} 异步计算完成的Promise, 等价于callback
   */
  function computeSurfaceLine(options) {
    // 线中间插值
    const positions = interPolyline({
      ...options,
      surfaceHeight: false // 不用重复计算高度
    });

    const positionsClone = [];
    for (let i = 0, len = positions.length; i < len; ++i) {
      positionsClone.push(positions[i].clone());
    }
    options.positions = positionsClone;

    return new SurfacePoints(options).start()
  }

  /**
   * 求 多个点 的的贴地新坐标（不插值）
   *
   * @export
   * @param {Object} [options={}] 参数对象:
   * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {Cesium.Cartesian3[]|LngLatPoint[]} options.positions 坐标数组
   * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
   * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   * @param {Number} [options.offset=0]  可以按需增加偏移高度（单位：米），便于可视
   * @return {Promise<Object>} 异步计算完成的Promise, 等价于callback
   */
  function computeSurfacePoints(options) {
    return new SurfacePoints(options).start()
  }

  /**
   * 异步分段分步计算贴地距离中，每计算完成2个点之间的距离后 的回调方法
   * @callback computeStepSurfaceLine_endItem
   * @param {Cesium.Cartesian3[]} raisedPositions  当前2个点之间的 贴地坐标数组
   * @param {Boolean} noHeight  是否计算贴地高度失败，true时标识计算失败了
   * @param {Number} index  坐标数组的index顺序
   */

  /**
   * 异步分段分步计算贴地距离中，每计算完成2个点之间的距离后 的回调方法
   * @callback computeStepSurfaceLine_end
   * @param {Array[]} arrStepPoints  二维数组坐标集合，各分段2点之间的贴地点数组的集合
   */

  /**
   * 按2个坐标点分段分步来计算，求路线的贴地线坐标（插值）
   *
   * @export
   * @param {Object} [options={}] 参数对象:
   * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标数组
   * @param {Number} [options.splitNum=100] 插值数，等比分割的个数
   * @param {Number} [options.minDistance] 插值最小间隔(单位：米)，优先级高于splitNum
   * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
   * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   * @param {Number} [options.offset=0]  可以按需增加偏移高度（单位：米），便于可视
   * @param {computeStepSurfaceLine_endItem} options.endItem  异步计算高度完成后 的回调方法
   * @param {computeStepSurfaceLine_end} options.end  异步计算高度完成后 的回调方法
   * @return {Promise<*>} 异步计算完成的Promise,同callback
   */
  function computeStepSurfaceLine(options) {
    const positions = options.positions;
    const arrStepPoints = [];

    const params = {};
    for (const key in options) {
      if (key === "positions" || key === "callback" || key === "end" || key === "endItem") {
        continue
      }
      params[key] = options[key];
    }

    return new Promise((resolve, reject) => {
      let index = 0;
      const allcount = positions.length - 1;
      function getLineFD() {
        if (index >= allcount) {
          if (options.callback) {
            options.callback(arrStepPoints); // 兼容v3.4之前版本callback
          }
          if (options.end) {
            options.end(arrStepPoints);
          }
          resolve(arrStepPoints);
          return
        }

        // 线中间插值
        params.positions = interPolyline({
          ...options,
          positions: [positions[index], positions[index + 1]],
          surfaceHeight: false // 不用重复计算高度
        });

        new SurfacePoints(params).start().then((result) => {
          if (options.endItem) {
            options.endItem(result.positions, result.noHeight, index);
          }
          arrStepPoints.push(result.positions);

          index++;
          getLineFD();
        });
      }
      getLineFD();
    })
  }

  /**
   * 计算2点间的 曲线链路的点集（空中曲线）
   *
   * @export
   * @param {Cesium.Cartesian3|LngLatPoint} startPoint 开始节点
   * @param {Cesium.Cartesian3|LngLatPoint} endPoint 结束节点
   * @param {Number} angularityFactor 曲率
   * @param {Number} numOfSingleLine 点集数量
   * @return {Cesium.Cartesian3[]}  曲线坐标数组
   */
  function getLinkedPointList(startPoint, endPoint, angularityFactor, numOfSingleLine) {
    const result = [];

    startPoint = LngLatPoint.toCartesian(startPoint);
    endPoint = LngLatPoint.toCartesian(endPoint);

    const startPosition = Cesium__namespace.Cartographic.fromCartesian(startPoint);
    const endPosition = Cesium__namespace.Cartographic.fromCartesian(endPoint);

    const startLon = (startPosition.longitude * 180) / Math.PI;
    const startLat = (startPosition.latitude * 180) / Math.PI;
    const endLon = (endPosition.longitude * 180) / Math.PI;
    const endLat = (endPosition.latitude * 180) / Math.PI;

    const dist = Math.sqrt((startLon - endLon) * (startLon - endLon) + (startLat - endLat) * (startLat - endLat));

    // var dist = Cesium.Cartesian3.distance(startPoint, endPoint);
    const angularity = dist * angularityFactor;

    const startVec = Cesium__namespace.Cartesian3.clone(startPoint);
    const endVec = Cesium__namespace.Cartesian3.clone(endPoint);

    const startLength = Cesium__namespace.Cartesian3.distance(startVec, Cesium__namespace.Cartesian3.ZERO);
    const endLength = Cesium__namespace.Cartesian3.distance(endVec, Cesium__namespace.Cartesian3.ZERO);

    Cesium__namespace.Cartesian3.normalize(startVec, startVec);
    Cesium__namespace.Cartesian3.normalize(endVec, endVec);

    if (Cesium__namespace.Cartesian3.distance(startVec, endVec) === 0) {
      return result
    }

    // var cosOmega = Cesium.Cartesian3.dot(startVec, endVec);
    // var omega = Math.acos(cosOmega);

    const omega = Cesium__namespace.Cartesian3.angleBetween(startVec, endVec);

    result.push(startPoint);
    for (let i = 1; i < numOfSingleLine - 1; i++) {
      const t = (i * 1.0) / (numOfSingleLine - 1);
      const invT = 1 - t;

      const startScalar = Math.sin(invT * omega) / Math.sin(omega);
      const endScalar = Math.sin(t * omega) / Math.sin(omega);

      const startScalarVec = Cesium__namespace.Cartesian3.multiplyByScalar(startVec, startScalar, new Cesium__namespace.Cartesian3());
      const endScalarVec = Cesium__namespace.Cartesian3.multiplyByScalar(endVec, endScalar, new Cesium__namespace.Cartesian3());

      let centerVec = Cesium__namespace.Cartesian3.add(startScalarVec, endScalarVec, new Cesium__namespace.Cartesian3());

      const ht = t * Math.PI;
      const centerLength = startLength * invT + endLength * t + Math.sin(ht) * angularity;
      centerVec = Cesium__namespace.Cartesian3.multiplyByScalar(centerVec, centerLength, centerVec);

      result.push(centerVec);
    }

    result.push(endPoint);

    return result
  }

  /**
   * 计算平行线
   *
   * @export
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} positions 原始线的坐标数组
   * @param {Number} offset 偏移的距离（单位米），正负决定方向
   * @return {Cesium.Cartesian3[]}  平行线坐标数组
   */
  function getOffsetLine(positions, offset) {
    positions = LngLatArray.toCartesians(positions);

    const arrNew = [];
    for (let i = 1; i < positions.length; i++) {
      const point1 = positions[i - 1];
      const point2 = positions[i];

      const dir12 = Cesium__namespace.Cartesian3.subtract(point1, point2, new Cesium__namespace.Cartesian3());
      const dir21left = Cesium__namespace.Cartesian3.cross(point1, dir12, new Cesium__namespace.Cartesian3());

      const p1offset = computedOffsetData(point1, dir21left, offset * 1000);
      const p2offset = computedOffsetData(point2, dir21left, offset * 1000);

      if (i === 1) {
        arrNew.push(p1offset);
      }
      arrNew.push(p2offset);
    }
    return arrNew
  }

  function computedOffsetData(ori, dir, wid) {
    const currRay = new Cesium__namespace.Ray(ori, dir);
    return Cesium__namespace.Ray.getPoint(currRay, wid, new Cesium__namespace.Cartesian3())
  }

  /**
   * 截取路线指定最大长度的新路线，
   * 在最后一个点往前截取maxDistance长度。
   * 应用场景： 航迹的 “尾巴线” 的运算
   *
   * @export
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} positions 路线坐标
   * @param {Number} maxDistance  最大的截取长度
   * @param {Object} [options={}] 参数对象:
   * @param {Boolean} [options.point=false] 为true时 只返回计算的maxDistance处的坐标
   * @return {Cesium.Cartesian3[]|Cesium.Cartesian3}  指定长度的坐标数组 ，options.point为true时，只返回数组的第1个点。
   */
  function sliceByMaxDistance(positions, maxDistance, options = {}) {
    if (positions.length < 2) {
      if (options.point) {
        if (positions.length === 1) {
          return positions[0]
        } else {
          return undefined
        }
      } else {
        return positions
      }
    }

    positions = LngLatArray.toCartesians(positions);

    for (let i = positions.length - 1; i >= 1; i--) {
      const pt1 = positions[i];
      const pt2 = positions[i - 1];
      const distance = Cesium__namespace.Cartesian3.distance(pt1, pt2);
      maxDistance -= distance;

      if (maxDistance === 0) {
        if (options.point) {
          return pt1
        } else {
          return positions.slice(i)
        }
      } else if (maxDistance < 0) {
        maxDistance += distance;
        // 求指定长度拼接上去
        const newpt = getOnLinePointByLen(pt1, pt2, maxDistance);
        if (options.point) {
          return newpt
        } else {
          return [newpt].concat(positions.slice(i))
        }
      }
    }

    if (options.point) {
      return positions[positions.length - 1]
    } else {
      return positions
    }
  }

  // 判断tur库是否存在 start
  function hasTurf(fun) {
    try {
      if (!fun) {
        throw new Error("turf.js 不存在")
      }
      return true
    } catch (e) {
      logError("该方法依赖turf库，请引入turf库。", e, fun);
      return false
    }
  }

  /**
   * 求 坐标点 的 外包围凸体面(简化只保留边界线坐标)
   *
   * @export
   * @param {Array[]} coordinates 经纬度坐标数组,示例：[ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
   * @return {Array[]} 经纬度坐标数组,示例：[ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
   */
  function convex(coordinates) {
    if (coordinates.length > 0) {
      // 判断tur库是否存在
      if (!hasTurf(turf.convex)) {
        return coordinates
      }

      const pts = [];
      for (let i = 0; i < coordinates.length; i++) {
        pts.push({
          type: "Feature",
          geometry: { type: "Point", coordinates: coordinates[i] }
        });
      }
      // 求外包围凸体
      const hull = turf.convex({ type: "FeatureCollection", features: pts });
      if (hull) {
        const coords = hull?.geometry?.coordinates;
        if (coords && coords.length > 0) {
          coordinates = coords[0];
        }
      }
    }
    return coordinates
  }

  /**
   * 在 指定bbox区域 内生成 指定数量(概略) 的网格坐标点，
   * 目前常用于生成坐标点，测试数据量
   *
   * @export
   * @param {Number[]} bbox 区域范围，如：[116.984788, 31.625909, 117.484068, 32.021504]
   * @param {Number} count 数量(概略)，返回坐标接近此数字
   * @param {Number} [alt=0] 高度值
   * @returns {Object} 坐标集合 ,如： {points:[LngLatPoint,LngLatPoint], size: 500 }
   */
  function getGridPoints(bbox, count, alt) {
    // 判断tur库是否存在
    if (!hasTurf(turf.pointGrid)) {
      return []
    }

    const distance =
      Cesium__namespace.Cartesian3.distance(Cesium__namespace.Cartesian3.fromDegrees(bbox[0], bbox[1]), Cesium__namespace.Cartesian3.fromDegrees(bbox[2], bbox[3])) /
      (Math.sqrt(2) * 1000);
    const gridSize = distance / Math.sqrt(count);

    const geojson = turf.pointGrid(bbox, gridSize, { units: "kilometers" });

    const arrPoint = [];
    geojson.features.forEach((feature) => {
      const coor = feature.geometry.coordinates;
      arrPoint.push(new LngLatPoint(coor[0], coor[1], alt));
    });

    return {
      points: arrPoint,
      radius: Math.floor((gridSize * 1000) / 2)
    }
  }

  var PolyUtil = {
    __proto__: null,
    centerOfMass: centerOfMass,
    buffer: buffer,
    bufferPoints: bufferPoints,
    getGranularity: getGranularity,
    interPolygon: interPolygon,
    getHeightRange: getHeightRange,
    computeVolume: computeVolume,
    updateVolumeByMinHeight: updateVolumeByMinHeight,
    updateVolume: updateVolume,
    getEllipseOuterPositions: getEllipseOuterPositions,
    formatRectangle: formatRectangle,
    getExtentByGeoJSON: getExtentByGeoJSON,
    getRectangle: getRectangle,
    getPositionsRectVertex: getPositionsRectVertex,
    getRectangleOuterPositions: getRectangleOuterPositions,
    getRectPositionsByCenter: getRectPositionsByCenter,
    isInPoly: isInPoly,
    getBezierCurve: getBezierCurve,
    interPolyline: interPolyline,
    interLine: interLine,
    computeSurfaceLine: computeSurfaceLine,
    computeSurfacePoints: computeSurfacePoints,
    computeStepSurfaceLine: computeStepSurfaceLine,
    getLinkedPointList: getLinkedPointList,
    getOffsetLine: getOffsetLine,
    sliceByMaxDistance: sliceByMaxDistance,
    convex: convex,
    getGridPoints: getGridPoints
  };

  /**
   * 图上量算 的 常用静态方法
   * @module MeasureUtil
   */

  /**
   * 求坐标数组的空间距离
   *
   * @export
   * @param {Cesium.Cartesian3[]|LngLatPoint[]} positions 坐标数组
   * @param {Boolean} [closure] 是否闭合，如求面的周长时，传入true
   * @return {Number} 距离（单位：米）
   */
  function getDistance(positions, closure) {
    const len = positions.length;
    if (!Cesium__namespace.defined(positions) || len < 2) {
      return 0
    }

    positions = LngLatArray.toCartesians(positions);

    let distance = 0;
    for (let i = 1; i < len; i++) {
      distance += Cesium__namespace.Cartesian3.distance(positions[i - 1], positions[i]);
    }

    if (closure) {
      distance += Cesium__namespace.Cartesian3.distance(positions[0], positions[len - 1]);
    }

    return distance
  }

  /**
   * 求坐标数组的 距离（地球表面弧度的）,
   * 比如北京到纽约（不能穿过球心，是贴地表的线的距离）
   *
   * @export
   * @param {Cesium.Cartesian3[]|LngLatPoint[]} positions 坐标数组
   * @return {Number} 距离（单位：米）
   */
  function getSurfaceDistance(positions) {
    if (!Cesium__namespace.defined(positions) || positions.length < 2) {
      return 0
    }
    positions = LngLatArray.toCartesians(positions);

    let distance = 0;
    for (let i = 1, len = positions.length; i < len; i++) {
      const c1 = Cesium__namespace.Cartographic.fromCartesian(positions[i - 1]);
      const c2 = Cesium__namespace.Cartographic.fromCartesian(positions[i]);
      const geodesic = new Cesium__namespace.EllipsoidGeodesic();
      geodesic.setEndPoints(c1, c2);
      let s = geodesic.surfaceDistance;
      s = Math.sqrt(Math.pow(s, 2) + Math.pow(c2.height - c1.height, 2));
      distance += s;
    }
    return distance
  }

  /**
   * 异步计算贴地距离中，每计算完成2个点之间的距离后 的回调方法
   * @callback getClampDistance_endItem
   * @param {Object} options 参数对象，具有以下属性:
   * @param {Number} options.index  坐标数组的index顺序
   * @param {Cesium.Cartesian3[]} options.positions  当前2个点之间的 贴地坐标数组
   * @param {Number} options.distance  当前2个点之间的 贴地距离
   * @param {Number[]} options.arrDistance  已计算完成从第0点到index点的 每一段的长度数组
   * @param {Number} options.all_distance   已计算完成从第0点到index点的 贴地距离
   */

  /**
   * 异步计算贴地距离完成 的回调方法
   * @callback getClampDistance_callback
   * @param {Number} all_distance 路线的全部距离，单位：米
   * @param {Array} arrDistance 每2个点间的 每一段的长度数组
   */

  /**
   * 异步计算贴地(地表或模型表面)距离，单位：米
   *
   * @export
   * @param {Cesium.Cartesian3[]|LngLatPoint[]} positions 坐标数组
   * @param {Object} options 参数对象，具有以下属性:
   * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {Number} [options.splitNum=100]  插值数，将线段分割的个数
   * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
   * @param {getClampDistance_endItem} options.endItem  异步计算贴地距离中，每计算完成2个点之间的距离后 的回调方法
   * @param {getClampDistance_endItem} options.end 异步计算完成的 回调方法
   * @return {Promise<Object>} 异步计算完成的Promise
   */
  function getClampDistance(positions, options) {
    let all_distance = 0;
    const arrDistance = [];

    return new Promise((resolve, reject) => {
      computeStepSurfaceLine({
        scene: options.scene,
        positions: positions,
        splitNum: options.splitNum,
        has3dtiles: options.has3dtiles,
        // 计算每个分段后的回调方法
        endItem: function (raisedPositions, noHeight, index) {
          let distance = getSurfaceDistance(raisedPositions);
          if (noHeight && options.disTerrainScale) {
            distance = distance * options.disTerrainScale; // 求高度失败，概略估算值
          }
          all_distance += distance;

          arrDistance.push(distance);

          if (options.endItem) {
            options.endItem({
              index: index,
              positions: raisedPositions,
              distance: distance,
              arrDistance: arrDistance,
              all_distance: all_distance
            });
          }
        },
        // 计算全部完成的回调方法
        end: function (result) {
          if (options.callback) {
            options.callback(all_distance); // 兼容v3.4之前版本callback
          }
          if (options.end) {
            options.end(all_distance);
          }
          resolve({
            distance: all_distance,
            arrDistance: arrDistance,
            arrPositions: result
          });
        }
      });
    })
  }

  /**
   * 计算面积（空间平面）
   *
   * @export
   * @param {Cesium.Cartesian3[]|LngLatPoint[]} positions 坐标数组
   * @return {Number} 面积，单位：平方米
   */
  function getArea(positions) {
    if (!positions || !Array.isArray(positions) || positions.length < 3) {
      return 0
    }
    positions = LngLatArray.toCartesians(positions);

    const geometry = Cesium__namespace.CoplanarPolygonGeometry.createGeometry(
      Cesium__namespace.CoplanarPolygonGeometry.fromPositions({
        positions: positions,
        vertexFormat: Cesium__namespace.VertexFormat.POSITION_ONLY
      })
    );
    let result = 0;
    if (!geometry) {
      return result
    }
    const flatPositions = geometry.attributes.position.values;
    const indices = geometry.indices;
    for (let i = 0; i < indices.length; i += 3) {
      const p0 = Cesium__namespace.Cartesian3.unpack(flatPositions, indices[i] * 3, new Cesium__namespace.Cartesian3());
      const p1 = Cesium__namespace.Cartesian3.unpack(flatPositions, indices[i + 1] * 3, new Cesium__namespace.Cartesian3());
      const p2 = Cesium__namespace.Cartesian3.unpack(flatPositions, indices[i + 2] * 3, new Cesium__namespace.Cartesian3());
      result += getTriangleArea(p0, p1, p2);
    }
    return result
  }

  /**
   * 求坐标数组的 横切平面的面积（基于turf.area）
   * @export
   * @param {Cesium.Cartesian3[]|LngLatPoint[]} positions 坐标数组
   * @return {Number} 距离（单位：米）
   */
  function getSurfaceArea(positions) {
    if (!positions || !Array.isArray(positions) || positions.length < 3) {
      return 0
    }
    const coordinates = LngLatArray.toArray(positions);

    if (coordinates.length > 0) {
      coordinates.push(coordinates[0]);
    }

    // API: http://turfjs.org/docs/#area
    const area = turf.area({
      type: "Feature",
      geometry: {
        type: "Polygon",
        coordinates: [coordinates]
      }
    });
    return area
  }

  /**
   * 计算三角形面积（空间平面）
   *
   * @export
   * @param {Cesium.Cartesian3} pos1 三角形顶点坐标1
   * @param {Cesium.Cartesian3} pos2 三角形顶点坐标2
   * @param {Cesium.Cartesian3} pos3 三角形顶点坐标3
   * @return {Number} 面积，单位：平方米
   */
  function getTriangleArea(pos1, pos2, pos3) {
    // let a = Cesium.Cartesian3.distance(pos1, pos2)
    // let b = Cesium.Cartesian3.distance(pos2, pos3)
    // let c = Cesium.Cartesian3.distance(pos3, pos1)
    // let S = (a + b + c) / 2
    // return Math.sqrt(S * (S - a) * (S - b) * (S - c))

    const v0 = Cesium__namespace.Cartesian3.subtract(pos1, pos2, new Cesium__namespace.Cartesian3());
    const v1 = Cesium__namespace.Cartesian3.subtract(pos3, pos2, new Cesium__namespace.Cartesian3());
    const cross = Cesium__namespace.Cartesian3.cross(v0, v1, v0);
    return Cesium__namespace.Cartesian3.magnitude(cross) * 0.5
  }

  /**
   * 计算贴地面积(单位：平方米)
   *
   * @export
   * @param {Cesium.Cartesian3[]|LngLatPoint[]} positions 坐标数组
   * @param {Object} options 参数对象，具有以下属性:
   * @param {Cesium.Scene} options.scene  三维地图场景对象，一般用map.scene或viewer.scene
   * @param {Number} [options.splitNum=10]  插值数，将面分割的网格数
   * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
   * @param {Boolean} [options.exact]  是否进行精确计算
   * @return {Promise<Object>} 异步计算完成的Promise
   */
  function getClampArea(positions, options) {
    return interPolygon({ positions: positions, ...options }).then((resultInter) => {
      let area = 0; // 总面积(贴地三角面)
      for (let i = 0, len = resultInter.list.length; i < len; i++) {
        const item = resultInter.list[i];
        const pt1 = item.point1;
        const pt2 = item.point2;
        const pt3 = item.point3;
        area += getTriangleArea(pt1.pointDM, pt2.pointDM, pt3.pointDM); // 求面积
      }
      resultInter.area = area;

      if (options.callback) {
        options.callback(area, resultInter); // 兼容v3.4之前版本callback
      }
      return resultInter
    })
  }

  /**
   * 计算2点的角度值，角度已正北为0度，顺时针为正方向
   *
   * @export
   * @param {Cesium.Cartesian3} startPosition 需要计算的点
   * @param {Cesium.Cartesian3} endPosition 目标点，以该点为参考中心。
   * @param {Boolean} [isNorthZero=false]  是否正东为0时的角度（如方位角）
   * @return {Number} 返回角度值，0-360度
   */
  function getAngle(startPosition, endPosition, isNorthZero) {
    // 获取该位置的默认矩阵
    let mat = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(endPosition); // 中心点 矩阵
    mat = Cesium__namespace.Matrix4.getMatrix3(mat, new Cesium__namespace.Matrix3());

    const xaxis = Cesium__namespace.Matrix3.getColumn(mat, 0, new Cesium__namespace.Cartesian3());
    const yaxis = Cesium__namespace.Matrix3.getColumn(mat, 1, new Cesium__namespace.Cartesian3());
    const zaxis = Cesium__namespace.Matrix3.getColumn(mat, 2, new Cesium__namespace.Cartesian3());
    // 计算该位置 和  position 的 角度值
    let dir = Cesium__namespace.Cartesian3.subtract(startPosition, endPosition, new Cesium__namespace.Cartesian3());
    if (isNaN(dir.x) || isNaN(dir.y) || isNaN(dir.z) || dir.equals(Cesium__namespace.Cartesian3.ZERO)) {
      return 0
    }

    // z crosss (dirx cross z) 得到在 xy平面的向量
    dir = Cesium__namespace.Cartesian3.cross(dir, zaxis, dir);
    dir = Cesium__namespace.Cartesian3.cross(zaxis, dir, dir);
    dir = Cesium__namespace.Cartesian3.normalize(dir, dir);

    let heading = Cesium__namespace.Cartesian3.angleBetween(xaxis, dir);
    const ay = Cesium__namespace.Cartesian3.angleBetween(yaxis, dir);
    if (ay > Math.PI * 0.5) {
      heading = 2 * Math.PI - heading;
    }
    let hDegrees = 360 - Cesium__namespace.Math.toDegrees(heading) - 180; // 转换为: 正东为0时，顺时针为正方向
    if (isNorthZero) {
      hDegrees += 90; // 转换为：以北为0度
    }
    if (hDegrees < 0) {
      hDegrees = hDegrees + 360;
    } else if (hDegrees > 360) {
      hDegrees = hDegrees - 360;
    }
    return hDegrees
  }

  /**
   * 格式化显示距离值, 可指定单位
   *
   * @export
   * @param {Number} val  距离值，米
   * @param {Object} [options] 参数：
   * @param {String} [options.unit='auto'] 计量单位, 可选值：auto、m、km、mile、zhang 。auto时根据距离值自动选用k或km
   * @param {LangType} [options.lang=0]  使用的语言
   * @param {Number} [options.decimal=2]  保留的小数位
   * @return {String} 带单位的格式化距离值字符串，如：20.17 米
   */
  function formatDistance(val, options = {}) {
    if (val == null) {
      return ""
    }

    val = Number(val);
    if (isNaN(val) || val === 0) {
      return ""
    }

    if (isString(options)) {
      options = { unit: options };
    } // 兼容历史参数

    if (options.unit == null || options.unit === "auto") {
      if (val < 1000) {
        options.unit = "m";
      } else {
        options.unit = "km";
      }
    }
    options.decimal = options.decimal ?? 2;

    let valstr = "";
    switch (options.unit) {
      case "km":
        valstr = (val * 0.001).toFixed(options.decimal) + getLangText("_公里", options.lang);
        break
      case "mile":
        valstr = (val * 0.00054).toFixed(options.decimal) + getLangText("_海里", options.lang);
        break
      case "zhang":
        valstr = (val * 0.3).toFixed(options.decimal) + getLangText("_丈", options.lang);
        break
      case "m":
      default:
        valstr = val.toFixed(options.decimal) + getLangText("_米", options.lang);
        break
    }
    return valstr
  }

  /**
   * 格式化显示面积值, 可指定单位
   *
   * @export
   * @param {Number} val 面积值，平方米
   * @param {Object} [options] 参数：
   * @param {String} [options.unit='auto'] 计量单位，可选值：auto、m、km、mu、ha 。auto时根据面积值自动选用m或km
   * @param {LangType} [options.lang=0]  使用的语言
   * @param {Number} [options.decimal=2]  保留的小数位
   * @return {String} 带单位的格式化面积值字符串，如：20.21 平方公里
   */
  function formatArea(val, options = {}) {
    if (val == null) {
      return ""
    }

    val = Number(val);
    if (isNaN(val) || val === 0) {
      return ""
    }
    if (isString(options)) {
      options = { unit: options };
    } // 兼容历史参数

    if (options.unit == null || options.unit === "auto") {
      if (val < 1000000) {
        options.unit = "m";
      } else {
        options.unit = "km";
      }
    }
    options.decimal = options.decimal ?? 2;

    let valstr = "";
    switch (options.unit) {
      case "km":
        valstr = (val / 1000000).toFixed(options.decimal) + getLangText("_平方公里", options.lang);
        break
      case "mu":
        valstr = (val * 0.0015).toFixed(options.decimal) + getLangText("_亩", options.lang);
        break
      case "ha":
        valstr = (val * 0.0001).toFixed(options.decimal) + getLangText("_公顷", options.lang);
        break
      case "m":
      default:
        valstr = val.toFixed(options.decimal) + getLangText("_平方米", options.lang);
        break
    }

    return valstr
  }

  /**
   * 格式化显示体积值, 可指定单位
   *
   * @export
   * @param {Number} val 体积值，立方米
   * @param {Object} [options] 参数：
   * @param {String} [options.unit='auto'] 计量单位，当前无用，备用参数
   * @param {LangType} [options.lang=0]  使用的语言
   * @param {Number} [options.decimal=2]  保留的小数位
   * @return {String} 带单位的格式化体积值字符串，如：20.21 方
   */
  function formatVolume(val, options = {}) {
    if (val == null) {
      return ""
    }
    val = Number(val);
    if (isNaN(val) || val === 0) {
      return ""
    }

    options.decimal = options.decimal ?? 2;

    if (options.lang === LangType.EN) {
      return val.toFixed(options.decimal) + getLangText("_立方米", options.lang)
    }

    if (val < 10000) {
      return val.toFixed(options.decimal) + getLangText("_立方米", options.lang)
    } else {
      return (val / 10000).toFixed(options.decimal) + getLangText("_万立方米", options.lang)
    }
  }

  var MeasureUtil = {
    __proto__: null,
    getDistance: getDistance,
    getSurfaceDistance: getSurfaceDistance,
    getClampDistance: getClampDistance,
    getArea: getArea,
    getSurfaceArea: getSurfaceArea,
    getTriangleArea: getTriangleArea,
    getClampArea: getClampArea,
    getAngle: getAngle,
    formatDistance: formatDistance,
    formatArea: formatArea,
    formatVolume: formatVolume
  };

  /**
   * 矢量数据材质
   * @module MaterialUtil
   */

  /**
   * 注册自定义的材质
   * @export
   * @param {String} type 类型名称
   * @param {Object} materialTemplate 材质模版
   * @returns {void}
   */
  function register$3(type, materialTemplate) {
    if (Cesium__namespace.Material._materialCache.getMaterial(type)) {
      logError(`MaterialUtil register: ${type}类型已存在`, materialTemplate);
    }
    MaterialTypes[type] = type;
    Cesium__namespace.Material[type + "Type"] = type;
    if (materialTemplate.fabric) {
      materialTemplate.fabric.type = type;
    }
    Cesium__namespace.Material._materialCache.addMaterial(type, materialTemplate);
  }

  const OptsConverClass = {};

  function registerOptsConver(type, mClass) {
    if (OptsConverClass[type]) {
      logError(`MaterialUtil registerOptsConver: ${type}类型已存在`, mClass);
    }
    OptsConverClass[type] = mClass;
  }

  // 材质属性类集合（按类型）
  const MaterialClass = {};
  const MaterialTypes = {};

  // 注册 自定义的材质类
  function registerClass(type, mClass) {
    if (MaterialTypes[type]) {
      logError(`MaterialUtil registerClass: ${type}类型已存在`, mClass);
    }
    MaterialClass[type] = mClass;
    MaterialTypes[type] = type;
  }

  // 材质属性类集合（按类型）
  const MaterialPropertyClass = {};

  // 注册 材质属性类
  function registerPropertyClass(type, propertyClass) {
    if (MaterialPropertyClass[type]) {
      logError(`MaterialUtil registerPropertyClass: ${type}属性类型已存在`, propertyClass);
    }
    MaterialPropertyClass[type] = propertyClass;
  }

  /**
   * 创建 材质属性（用于Entity）
   * @param {MaterialType} type 材质类型
   * @param {Object} options 创建参数,具体对照{@link MaterialType}的注释说明
   * @returns {BaseMaterialProperty} 材质属性对象
   */
  function createMaterialProperty(type, options) {
    const ThisPropertyClass = MaterialPropertyClass[type];
    if (ThisPropertyClass) {
      const optsConver = OptsConverClass[type] || OptsConverClass.default;
      if (optsConver) {
        options.materialType = type;
        options = optsConver.toCesiumVal(options, {}, true);
      }

      const material = new ThisPropertyClass(options);
      material._mars_type = type;
      material.options = options;
      return material
    } else {
      logWarn("createMaterialProperty:未找到该类型的对应材质属性", type);
    }
  }

  /**
   * 创建 材质（用于Primitive）
   * @param {MaterialType} type 材质类型
   * @param {Object} options 创建参数,具体对照{@link MaterialType}的注释说明
   * @returns {Cesium.Material} 材质对象
   */
  function createMaterial(type, options) {
    if (!type) {
      logError("createMaterial：请指定mars3d.MaterialType类型");
      return
    }
    const optsConver = OptsConverClass[type] || OptsConverClass.default;
    if (optsConver) {
      options.materialType = type;
      options = optsConver.toCesiumVal(options);
    }

    let material;
    const ThisClass = MaterialClass[type];
    if (ThisClass) {
      material = new ThisClass(options);
    } else {
      material = Cesium__namespace.Material.fromType(type, options);
    }
    material.options = options;
    material._mars_type = type;
    return material
  }

  /**
   * 是否存在指定材质
   * @param {MaterialType} type 材质类型
   * @param {Boolean} [property] 是否属性材质
   * @returns {Boolean} 是否存在
   */
  function hasMaterial(type, property) {
    if (property) {
      return Boolean(MaterialPropertyClass[type])
    } else {
      return Boolean(MaterialTypes[type])
    }
  }

  /**
   * 将材质对象转为Josn简单对象，用于保存。
   *
   * @param {Cesium.Material|BaseMaterialProperty} material 材质对象
   * @param {Object} style 附加到的目标对象
   * @return {Object} json简单对象
   */
  function toJSON(material, style = {}) {
    let type;
    if (material._mars_type) {
      type = material._mars_type;
    } else if (material?._template?.type) {
      type = material._template.type;
    } else if (material?.getType) {
      type = material.getType();
    }

    if (!type) {
      if (material instanceof Cesium__namespace.Color) {
        type = "Color";
      } else if (material instanceof HTMLVideoElement) {
        // style.materialType = material
        // style.materialOptions = { image: material }
        return
      } else {
        logWarn("toJSON：未识别的材质类型", material);
      }
    }

    const optsConver = OptsConverClass[type] || OptsConverClass.default;
    if (optsConver) {
      style.materialType = type;
      style.materialOptions = optsConver.toJSON(material);
    }

    return style
  }

  /**
   * 将材质对象参数转为Josn简单对象，用于保存。
   *
   * @param {String} materialType 材质对象
   * @param {Object} materialOptions 复杂对象
   * @return {Object} json简单对象
   */
  function toJSONByType(materialType, materialOptions) {
    const optsConver = OptsConverClass[materialType] || OptsConverClass.default;
    if (optsConver) {
      return optsConver.toJSON(materialOptions)
    } else {
      return materialOptions
    }
  }

  var MaterialUtil = {
    __proto__: null,
    register: register$3,
    registerOptsConver: registerOptsConver,
    registerClass: registerClass,
    registerPropertyClass: registerPropertyClass,
    createMaterialProperty: createMaterialProperty,
    createMaterial: createMaterial,
    hasMaterial: hasMaterial,
    toJSON: toJSON,
    toJSONByType: toJSONByType
  };

  /**
   * 矢量数据标绘编辑相关常量
   * @module DrawUtil
   */

  /**
   * 拖拽点分类
   * @type {Number}
   */
  const PointType = {
    Control: 1, // 位置控制
    MoveAll: 2, // 整体平移(如线面)
    AddMidPoint: 3, // 辅助增加新点
    MoveHeight: 4, // 上下移动高度
    EditAttr: 5, // 辅助修改属性（如半径）
    EditRotation: 6 // 旋转角度修改
  };

  /**
   * 拖拽点颜色
   * @type {Cesium.Color}
   * @example
  mars3d.DrawUtil.PointColor.Control = '#1c197d' //位置控制拖拽点
  mars3d.DrawUtil.PointColor.MoveAll = '#8c003a' //整体平移(如线面)拖拽点
  mars3d.DrawUtil.PointColor.MoveHeight = '#9500eb' //上下移动高度的拖拽点
  mars3d.DrawUtil.PointColor.EditAttr = '#f73163' //辅助修改属性（如半径）的拖拽点
  mars3d.DrawUtil.PointColor.AddMidPoint = 'rgba(4,194,201,0.3)' //增加新点，辅助拖拽点
   */
  const PointColor = {
    Control: "#1c197d", // 位置控制拖拽点
    MoveAll: "#8c003a", // 整体平移(如线面)拖拽点
    MoveHeight: "#9500eb", // 上下移动高度的拖拽点
    EditAttr: "#f531e8", // 辅助修改属性（如半径）的拖拽点
    AddMidPoint: "rgba(4,194,201,0.3)" // 增加新点，辅助拖拽点
  };

  // 编辑点的公共样式
  let defaultEditStyle = {
    pixelSize: 12,
    outline: true,
    outlineColor: "rgba(255,255,255,0.5)",
    outlineWidth: 2,
    scaleByDistance: new Cesium__namespace.NearFarScalar(1000, 1, 1000000, 0.5),
    disableDepthTestDistance: Number.POSITIVE_INFINITY // 不被遮挡
  };

  /**
   * 设置编辑点的样式（color颜色除外）
   * @param {PointPrimitive.StyleOptions} value 像素
   * @returns {void} 无
   */
  function setPointStyle(value) {
    defaultEditStyle = merge(defaultEditStyle, value);
  }

  function getEditPointStyle(type) {
    const attr = { ...defaultEditStyle };
    switch (type) {
      case PointType.AddMidPoint:
        attr.color = PointColor.AddMidPoint;
        attr.outlineColor = "rgba(255,255,255,0.4)";
        break
      case PointType.MoveAll:
        attr.color = PointColor.MoveAll;
        break
      case PointType.MoveHeight:
        attr.color = PointColor.MoveHeight;
        break
      case PointType.EditAttr:
        attr.color = PointColor.EditAttr;
        break
      case PointType.Control:
      default:
        attr.color = PointColor.Control;
        break
    }
    return attr
  }

  var DrawUtil = {
    __proto__: null,
    PointType: PointType,
    PointColor: PointColor,
    setPointStyle: setPointStyle,
    getEditPointStyle: getEditPointStyle
  };

  /**
   * 地形类型
   * @enum {String}
   */
  const TerrainType = {
    /**
     * 无地形
     */
    NONE: "none",
    /**
     * 标准xyz瓦片地形
     */
    XYZ: "xyz",
    /**
     * arcgis地形
     */
    ARCGIS: "arcgis",
    /**
     * ION在线地形(cesium官方服务)
     */
    ION: "ion",
    /**
     * GoogleEarth Enterprise 地形服务
     */
    GEE: "gee",
    /**
     * VR 地形
     */
    VR: "vr"
  };

  // 用于国测局坐标系下的相关瓦片纠偏处理
  class GCJMercatorTilingScheme extends Cesium__namespace.WebMercatorTilingScheme {
    constructor(options) {
      super(options);

      const dstCoordType = options.mapChinaCRS; // map地图的坐标系
      const srcCoordType = options.chinaCRS; // layer图层的坐标系（默认与地图一致）
      const Map2CrsLayerCrs = getTransFun(dstCoordType, srcCoordType);
      const LayerCrs2MapCrs = getTransFun(srcCoordType, dstCoordType);

      if (Map2CrsLayerCrs) {
        const projection = new Cesium__namespace.WebMercatorProjection();
        this._projection.project = function (cartographic, result) {
          result = Map2CrsLayerCrs([Cesium__namespace.Math.toDegrees(cartographic.longitude), Cesium__namespace.Math.toDegrees(cartographic.latitude)]);
          result = projection.project(new Cesium__namespace.Cartographic(Cesium__namespace.Math.toRadians(result[0]), Cesium__namespace.Math.toRadians(result[1])));
          return new Cesium__namespace.Cartesian2(result.x, result.y)
        };
        this._projection.unproject = function (cartesian, result) {
          const cartographic = projection.unproject(cartesian);
          result = LayerCrs2MapCrs([Cesium__namespace.Math.toDegrees(cartographic.longitude), Cesium__namespace.Math.toDegrees(cartographic.latitude)]);
          return new Cesium__namespace.Cartographic(Cesium__namespace.Math.toRadians(result[0]), Cesium__namespace.Math.toRadians(result[1]))
        };
      }
    }
  }

  /**
   * 图层相关 静态方法
   * @module LayerUtil
   */

  // 图层集合（按类型）
  const LayerClass = {};

  /**
   * 注册图层类
   *
   * @export
   * @param {String} type 图层类型
   * @param {BaseLayer} layerClass 图层类
   * @return {void}  无
   */
  function register$2(type, layerClass) {
    if (LayerClass[type]) {
      logError(`register: ${type}类型已存在`, layerClass);
    }
    LayerType[type] = type;
    LayerClass[type] = layerClass;

    layerClass.type = type; // 静态属性
    layerClass.prototype._type = type; // 对象属性
  }

  /**
   * 根据 图层类型 获取 图层类
   * @param {LayerType} type 图层类型
   * @returns {BaseLayer|undefined} 图层类
   */
  function getClass$2(type) {
    return LayerClass[type]
  }

  /**
   * 创建图层工厂方法
   *
   * @export
   * @param {Object} options 图层参数，包括：
   * @param {LayerType} options.type 图层类型
   * @param {Object} options.其他 具体见各{@link LayerType}对应的图层类的构造方法参数
   * @param {Object} [templateValues] url模版
   * @return {BaseLayer} 创建完成的图层对象
   */
  function create$2(options, templateValues) {
    const ThisLayer = getClass$2(options.type);

    if (ThisLayer) {
      if (templateValues) {
        options.templateValues = templateValues;
      }
      const layer = new ThisLayer(options);
      return layer
    } else {
      logWarn("配置中的图层未处理", options);
    }
  }

  // 转换图层配置参数
  function converOptions(options) {
    const optionsNew = {};
    // 预处理参数
    for (const key in options) {
      let value = options[key];
      if (value == null) {
        continue
      }

      switch (key) {
        case "crs":
          value = (value + "").toUpperCase();
          if (value === CRS.EPSG4326 || value === "4326" || value === "EPSG4326") {
            optionsNew.crs = CRS.EPSG4326;
            optionsNew.tilingScheme = new Cesium__namespace.GeographicTilingScheme({
              numberOfLevelZeroTilesX: options.numberOfLevelZeroTilesX || 2,
              numberOfLevelZeroTilesY: options.numberOfLevelZeroTilesY || 1
            });
          } else if (value === CRS.EPSG4490 || value === "4490" || value === "EPSG4490") {
            optionsNew.crs = CRS.EPSG4490;
            optionsNew.tilingScheme = new Cesium__namespace.GeographicTilingScheme({
              numberOfLevelZeroTilesX: options.numberOfLevelZeroTilesX || 2,
              numberOfLevelZeroTilesY: options.numberOfLevelZeroTilesY || 1
            });
          } else {
            optionsNew.crs = CRS.EPSG3857;
            optionsNew.tilingScheme = new Cesium__namespace.WebMercatorTilingScheme({
              numberOfLevelZeroTilesX: options.numberOfLevelZeroTilesX || 1,
              numberOfLevelZeroTilesY: options.numberOfLevelZeroTilesY || 1
            });
          }
          break
        case "chinaCRS": {
          if (options.mapChinaCRS !== options.chinaCRS) {
            optionsNew.tilingScheme = new GCJMercatorTilingScheme({
              mapChinaCRS: options.mapChinaCRS || ChinaCRS.WGS84,
              chinaCRS: options.chinaCRS,
              numberOfLevelZeroTilesX: options.numberOfLevelZeroTilesX || 1,
              numberOfLevelZeroTilesY: options.numberOfLevelZeroTilesY || 1
            });
          }
          break
        }
        case "rectangle":
          if (
            Cesium__namespace.defined(value) &&
            Cesium__namespace.defined(value.xmin) &&
            Cesium__namespace.defined(value.xmax) &&
            Cesium__namespace.defined(value.ymin) &&
            Cesium__namespace.defined(value.ymax)
          ) {
            optionsNew.rectangle = Cesium__namespace.Rectangle.fromDegrees(value.xmin, value.ymin, value.xmax, value.ymax);
          } else {
            optionsNew.rectangle = value;
          }
          break
        case "bbox":
          optionsNew.rectangle = Cesium__namespace.Rectangle.fromDegrees(value[0], value[1], value[2], value[3]); // [xmin,ymin,xmax,ymax]
          break
        default:
          // 直接赋值
          optionsNew[key] = value;
          break
      }
    }

    // 4490坐标系z值是+1的
    if (optionsNew.crs === CRS.EPSG4490 && optionsNew.url) {
      optionsNew.url = optionsNew.url.replace(/\{z\}/gm, "{z4490}");
      optionsNew.url = optionsNew.url.replace(/\{arc_z\}/gm, "{arc_z4490}");
      optionsNew.url = optionsNew.url.replace(/\{arc_Z\}/gm, "{arc_Z4490}");
    }
    if (options.tms) {
      optionsNew.url = optionsNew.url.replace(/\{y\}/gm, "{reverseY}");
    }
    if (options.minimumLevel > 0) {
      optionsNew.minimumTerrainLevel = options.minimumLevel; // 避免卡顿
    }

    if (optionsNew.url) {
      optionsNew.url = getUrlResource(optionsNew);
    }

    return optionsNew
  }

  // 瓦片图层ImageryProvider（按类型）
  const ImageryProviderClass = {};

  /**
   * 注册ImageryProvider类
   *
   * @export
   * @param {String} type Provider类型
   * @param {*} layerClass  ImageryProvider类
   * @return {void}  无
   *
   * @function
   */
  function registerImageryProvider(type, layerClass) {
    if (ImageryProviderClass[type]) {
      logError(`registerImageryProvider: ${type}类型已存在`);
    }
    ImageryProviderClass[type] = layerClass;
  }

  function getProviderClass(type) {
    return ImageryProviderClass[type]
  }

  /**
   * 创建地图底图ImageryProvider的工厂方法
   *
   * @param {Object} options Provider参数，具体见各Provider类的构造方法参数说明
   * @return {*} ImageryProvider类
   * @function
   */
  function createImageryProvider$k(options) {
    const ThisLayerProvider = getProviderClass(options.type);

    if (ThisLayerProvider) {
      const provider = new ThisLayerProvider(options);
      if (!provider.options) {
        provider.options = options; // 绑定记录下
      }

      if (Cesium__namespace.defined(options.invertColor)) {
        provider.invertColor = options.invertColor; // 是否反向颜色
      }
      if (Cesium__namespace.defined(options.filterColor)) {
        provider.filterColor = getCesiumColor(options.filterColor); // 滤镜颜色
      }

      return provider
    } else {
      logWarn("createImageryProvider：存在未识别的图层", options);
    }
  }

  /**
   * 获取baseLayerPicker使用的绑定图层列表配置，
   * 用于将config.json的配置basemaps数据转换为imageryProviderViewModels
   *
   * @export
   * @param {Object[]} arrLayer basemaps配置
   * @param {Object} [templateValues] url模版，用于替换Url中的模板值的键/值对
   * @return {Object} 转换后的 imageryProviderViewModels数组 和 显示图层的index(selectedIndex)
   */
  function getImageryProviderViewModels(arrLayer, templateValues) {
    const providerViewModels = [];
    let selectedIndex = -1;

    for (let i = 0; i < arrLayer.length; i++) {
      const item = arrLayer[i];
      if (item.type === "group" && item.layers == null) {
        continue
      }
      if (templateValues) {
        item.templateValues = templateValues;
      }
      if (item.show) {
        selectedIndex = providerViewModels.length;
      }
      providerViewModels.push(createProviderViewModel(item, i));
    }

    return {
      imageryProviderViewModels: providerViewModels,
      selectedIndex: selectedIndex
    }
  }

  function createProviderViewModel(item, i) {
    window._temp_mars3d_createImageryProvider = createImageryProvider$k;

    const funName = `window._temp_mars3d_basemaps${i}`;

    // eslint-disable-next-line no-new-func
    new Function(`
    ${funName} = function (item) {
      item = item || ${JSON.stringify(getAttrVal(item, { onlySimpleType: true }))};
      if (item.type === "group") {
        const arrVec = []
        for (let index = 0; index < item.layers.length; index++) {
          const item2 = item.layers[index]
          if (item.templateValues) {
            item2.templateValues = item.templateValues
          }
          const temp = window._temp_mars3d_createImageryProvider(item2)
          if (temp == null) {
            continue
          }
          arrVec.push(temp)
        }
        return arrVec
      } else {
        return window._temp_mars3d_createImageryProvider(item)
      }
    }`)();

    return new Cesium__namespace.ProviderViewModel({
      name: item.name || "",
      tooltip: item.name || "",
      iconUrl: item.icon || "",
      category: item.category || "",
      data: item,
      // eslint-disable-next-line no-eval
      creationFunction: eval(funName),
      endFunction: function (layer) {
        // if (Array.isArray(layer)) {
        // } else {
        // }
      }
    })
  }

  const _ellipsoid = new Cesium__namespace.EllipsoidTerrainProvider({
    ellipsoid: Cesium__namespace.Ellipsoid.WGS84
  });

  /**
   * 创建 无地形的 标准椭球体对象
   *
   * @export
   * @return {Cesium.EllipsoidTerrainProvider} 无地形 标准椭球体对象
   */
  function getNoTerrainProvider() {
    return _ellipsoid
  }

  // 地形图层Provider（按类型）
  const TerrainProviderClass = {};

  /**
   * 注册TerrainProvider类
   *
   * @export
   * @param {String} type Provider类型
   * @param {*} layerClass  TerrainProvider类
   * @return {void}  无
   *
   * @function
   */
  function registerTerrainProvider(type, layerClass) {
    if (TerrainProviderClass[type]) {
      logError(`registerTerrainProvider: ${type}类型已存在`);
    }
    TerrainProviderClass[type] = layerClass;
  }

  function getTerrainProviderClass(type) {
    return TerrainProviderClass[type]
  }

  /**
   * 创建地形对象的工厂方法
   *
   * @export
   * @param {Object} options 地形参数
   * @param {TerrainType} options.type 地形类型
   * @param {String|Cesium.Resource} options.url 地形服务地址
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] url模版，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'}
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' }
   *
   * @param {Boolean} [options.requestVertexNormals=true] 是否应该从服务器请求额外的光照信息，如果可用，以每个顶点法线的形式。
   * @param {Boolean} [options.requestWaterMask=false] 是否应该向服务器请求每个瓦的水掩膜(如果有的话)。
   * @param {Boolean} [options.requestMetadata=true] 是否应该从服务器请求每个块元数据(如果可用)。
   * @return {Cesium.CesiumTerrainProvider} 地形对象
   */
  function createTerrainProvider(options) {
    options = options || { type: TerrainType.ION };
    options.type = options.type || TerrainType.XYZ;
    options.requestVertexNormals = options.requestVertexNormals ?? true; // 坡度需要为true

    let terrainProvider;
    switch (options.type) {
      case TerrainType.XYZ: // 默认是自定义的
        replaceOnlineUrlDomain(options);
        if (Cesium__namespace.defined(Cesium__namespace.S3MTilesLayer)) {
          terrainProvider = new Cesium__namespace.CesiumTerrainProvider(options); // 超图库不能传Resource参数
        } else {
          terrainProvider = new Cesium__namespace.CesiumTerrainProvider({
            ...options,
            url: getUrlResource(options)
          });
        }
        break
      case TerrainType.NONE:
      case "ellipsoid": // 别名
        terrainProvider = _ellipsoid;
        break
      case TerrainType.ION: // cesium官方在线的
        terrainProvider = new Cesium__namespace.CesiumTerrainProvider({
          url: Cesium__namespace.IonResource.fromAssetId(1),
          requestWaterMask: options.requestWaterMask,
          requestVertexNormals: options.requestVertexNormals
        });
        break
      case TerrainType.GEE: // 谷歌地球企业服务
      case "google": // 别名
        terrainProvider = new Cesium__namespace.GoogleEarthEnterpriseTerrainProvider({
          ...options,
          metadata: new Cesium__namespace.GoogleEarthEnterpriseMetadata({
            ...options,
            url: getUrlResource(options)
          })
        });
        break
      case TerrainType.ARCGIS: // ArcGIS地形服务
        terrainProvider = new Cesium__namespace.ArcGISTiledElevationTerrainProvider({
          ...options,
          url: getUrlResource(options)
        });
        break
      case TerrainType.VR:
        terrainProvider = new Cesium__namespace.VRTheWorldTerrainProvider({
          ...options,
          url: getUrlResource(options)
        });
        break
      default:
        {
          const ThisLayerProvider = getTerrainProviderClass(options.type);
          terrainProvider = new ThisLayerProvider(options);
        }
        break
    }

    return terrainProvider
  }

  /**
   * 获取baseLayerPicker使用的绑定地形列表
   * @param {Object} options 地形参数,同{@link createTerrainProvider}方法参数
   * @export
   * @return {Cesium.ProviderViewModel[]} 地形列表
   */
  function getTerrainProviderViewModels(options) {
    if (options) {
      return [
        new Cesium__namespace.ProviderViewModel({
          name: "无地形",
          iconUrl: Cesium__namespace.buildModuleUrl("Widgets/Images/TerrainProviders/Ellipsoid.png"),
          tooltip: "WGS84标准椭球，即 EPSG:4326",
          category: "",
          creationFunction: function () {
            return getNoTerrainProvider()
          }
        }),
        new Cesium__namespace.ProviderViewModel({
          name: options.name || "有地形",
          iconUrl: Cesium__namespace.buildModuleUrl("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"),
          tooltip: options.tooltip || "提供的高精度的DEM地形服务",
          category: "",
          creationFunction: function () {
            return createTerrainProvider(options)
          }
        })
      ]
    } else {
      return [
        new Cesium__namespace.ProviderViewModel({
          name: "无地形",
          iconUrl: Cesium__namespace.buildModuleUrl("Widgets/Images/TerrainProviders/Ellipsoid.png"),
          tooltip: "WGS84标准椭球，即 EPSG:4326",
          category: "",
          creationFunction: function () {
            return getNoTerrainProvider()
          }
        }),
        new Cesium__namespace.ProviderViewModel({
          name: "Mar3D 中国地形",
          iconUrl: Cesium__namespace.buildModuleUrl("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"),
          tooltip: "Mar3D提供的12.5米精度的中国地形",
          category: "",
          creationFunction: function () {
            return createTerrainProvider({
              url: "//data.mars3d.cn/terrain"
            })
          }
        }),
        new Cesium__namespace.ProviderViewModel({
          name: "Ion 全球地形",
          iconUrl: Cesium__namespace.buildModuleUrl("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"),
          tooltip: "Cesium官方Ion提供的高分辨率全球地形",
          category: "",
          creationFunction: function () {
            return createTerrainProvider({
              type: "ion"
            })
          }
        }),
        new Cesium__namespace.ProviderViewModel({
          name: "ArcGIS 全球地形",
          iconUrl: Cesium__namespace.buildModuleUrl("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"),
          tooltip: "arcgis官方提供的高分辨率全球地形",
          category: "",
          creationFunction: function () {
            return createTerrainProvider({
              type: "arcgis",
              url: "https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer"
            })
          }
        })
      ]
    }
  }

  var LayerUtil = {
    __proto__: null,
    register: register$2,
    getClass: getClass$2,
    create: create$2,
    converOptions: converOptions,
    registerImageryProvider: registerImageryProvider,
    getProviderClass: getProviderClass,
    createImageryProvider: createImageryProvider$k,
    getImageryProviderViewModels: getImageryProviderViewModels,
    getNoTerrainProvider: getNoTerrainProvider,
    registerTerrainProvider: registerTerrainProvider,
    getTerrainProviderClass: getTerrainProviderClass,
    createTerrainProvider: createTerrainProvider,
    getTerrainProviderViewModels: getTerrainProviderViewModels
  };

  /**
   * 控件相关 静态方法
   * @module ControlUtil
   */

  // 控件集合（按类型）
  const ControlClass = {};

  /**
   * 注册控件类
   *
   * @export
   * @param {String} type 控件类型
   * @param {BaseControl} layerClass 控件类
   * @return {void}  无
   */
  function register$1(type, layerClass) {
    if (ControlClass[type]) {
      logError(`register: ${type}类型已存在`, layerClass);
    }
    ControlType[type] = type;
    ControlClass[type] = layerClass;

    layerClass.type = type; // 静态属性
    layerClass.prototype._type = type; // 对象属性
  }

  /**
   * 根据 控件类型 获取 控件类
   * @param {ControlType} type 控件类型
   * @returns {BaseControl|undefined} 控件类
   */
  function getClass$1(type) {
    return ControlClass[type]
  }

  /**
   * 创建控件工厂方法
   *
   * @export
   * @param {ControlType} type 控件类型
   * @param {Object} options 控件参数，具体见各{@link ControlType}对应的控件类的构造方法参数
   * @return {BaseControl} 创建完成的控件对象
   */
  function create$1(type, options) {
    const ThisControl = getClass$1(type);

    if (ThisControl) {
      const layer = new ThisControl(options);
      return layer
    }
  }

  var ControlUtil = {
    __proto__: null,
    register: register$1,
    getClass: getClass$1,
    create: create$1
  };

  /**
   * 特效相关 静态方法
   * @module EffectUtil
   */

  // 特效集合（按类型）
  const EffectClass = {};

  /**
   * 注册特效类
   *
   * @export
   * @param {String} type 特效类型
   * @param {BaseEffect} layerClass 特效类
   * @return {void}  无
   */
  function register(type, layerClass) {
    if (EffectClass[type]) {
      logError(`register: ${type}类型已存在`, layerClass);
    }
    EffectType[type] = type;
    EffectClass[type] = layerClass;

    layerClass.type = type; // 静态属性
    layerClass.prototype._type = type; // 对象属性
  }

  /**
   * 根据 特效类型 获取 特效类
   * @param {EffectType} type 特效类型
   * @returns {BaseEffect|undefined} 特效类
   */
  function getClass(type) {
    return EffectClass[type]
  }

  /**
   * 创建特效工厂方法
   *
   * @export
   * @param {EffectType} type 特效类型
   * @param {Object} options 特效参数，具体见各{@link EffectType}对应的特效类的构造方法参数
   * @return {BaseEffect} 创建完成的特效对象
   */
  function create(type, options) {
    const ThisEffect = getClass(type);

    if (ThisEffect) {
      const layer = new ThisEffect(options);
      return layer
    } else {
      logWarn("配置中的特效未处理", type, options);
    }
  }

  var EffectUtil = {
    __proto__: null,
    register: register,
    getClass: getClass,
    create: create
  };

  /**
   * 转换options参数处理基类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class BaseOptsConver
   */
  class BaseOptsConver {
    constructor(options = {}) {
      this.options = options;
    }

    // 排除的不用处理的属性
    get excludedKeys() {
      return null
    }

    // 必须需要处理的属性
    get includeKeys() {
      return ["color", "outlineColor", "backgroundColor", "strokeColor"]
    }

    //= ===================
    /**
     * 转换为Cesium相关属性值
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @return {Object} Cesium属性值
     * @memberof BaseOptsConver
     */
    toCesiumVal(style, czmVal = {}) {
      this._toCesiumValBefore(style, czmVal);

      for (const key in style) {
        const value = style[key];

        if (this.includeKeys.indexOf(key) === -1) {
          if (!isSimpleType(value)) {
            czmVal[key] = value; // 非简单类型，无需处理 直接赋值。
            continue
          }

          if (this.excludedKeys && this.excludedKeys.indexOf(key) !== -1) {
            continue
          }
        }

        const showval = this._toOneCesiumVal(key, value, style, czmVal);
        if (showval == null) {
          continue
        }
        czmVal[key] = showval;
      }

      this._toCesiumValEnd(style, czmVal);

      return czmVal
    }

    _toCesiumValBefore(style, czmVal) {}
    _toCesiumValEnd(style, czmVal) {}
    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        default:
          czmVal[key] = value;
          break
        // case 'repeat_x': {
        //   let repeatX = style.repeat_x ??1
        //   let repeatY = style.repeat_y?? 1
        //   czmVal.repeat = new Cesium.Cartesian2(repeatX, repeatY)
        //   break
        // }
      }
    }

    //= ===================
    /**
     * 转换为json简单对象，用于导出
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @return {Object} json简单对象
     * @memberof BaseOptsConver
     */
    toJSON(czmVal, style = {}) {
      czmVal = getAttrVal(czmVal);

      if (this._toJSONValBefore) {
        this._toJSONValBefore(style, czmVal);
      }

      for (const key in czmVal) {
        const value = czmVal[key];
        if (isSimpleType(value)) {
          style[key] = value;
        } else {
          this._toOneJson(key, czmVal[key], style);
        }
      }

      if (this._toJSONValEnd) {
        this._toJSONValEnd(style, czmVal);
      }

      return style
    }

    // 将cesium属性转为style ，用于导出json
    _toOneJson(key, value, style) {}

    //= ===================
    /**
     * 根据样式配置获取颜色
     * @param {Object} style  样式配置
     * @return {Cesium.Color} 颜色
     * @memberof BaseOptsConver
     */
    static getColorByStyle(style) {
      if (!this.baseOptsConver) {
        this.baseOptsConver = new BaseOptsConver();
      }
      return this.baseOptsConver.getColorByStyle(style)
    }

    /**
     * 根据样式配置获取颜色
     * @param {Object} style  样式配置
     * @return {Cesium.Color} 颜色
     * @memberof BaseOptsConver
     */
    getColorByStyle(style) {
      return getColorByStyle(style, this.options.color)
    }

    /**
     * 根据样式配置获取outline颜色
     * @param {Object} style  样式配置
     * @return {Cesium.Color} 颜色
     * @memberof BaseOptsConver
     */
    getOutlineColorByStyle(style) {
      let color;
      if (style.outlineColor) {
        if (isString(style.outlineColor)) {
          color = Cesium__namespace.Color.fromCssColorString(style.outlineColor);
        } else {
          color = style.outlineColor;
        }
      } else {
        color = this.options.outlineColor;
      }
      if (!color) {
        return color
      }

      if (Cesium__namespace.defined(style.outlineOpacity)) {
        color = color.withAlpha(Number(style.outlineOpacity));
      } else if (Cesium__namespace.defined(style.opacity)) {
        color = color.withAlpha(Number(style.opacity));
      }

      if (Cesium__namespace.defined(style.globalAlpha) && style.globalAlpha !== 1) {
        color = color.withAlpha(color.alpha * style.globalAlpha); // 动态调整图层或数据的透明度时使用
      }

      return color
    }
  }

  /**
   * 通用材质 转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class BaseMaterialConver
   * @extends {BaseOptsConver}
   */
  class BaseMaterialConver extends BaseOptsConver {
    // 排除的不用处理的属性
    get excludedKeys() {
      const arr = ["label"];
      return arr.concat(this._getExcludedStyle())
    }

    _getExcludedStyle() {
      return []
    }

    /**
     * 转换为Cesium相关属性值
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal) {
      if (!this.baseMaterialConver) {
        this.baseMaterialConver = new BaseMaterialConver();
      }
      return this.baseMaterialConver.toCesiumVal(style, czmVal)
    }

    // 点状数据的通用处理
    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "color":
        case "randomColor":
          czmVal.color = this.getColorByStyle(style);
          break
        case "color2":
        case "bgColor":
        case "outlineColor":
        case "evenColor":
        case "oddColor":
        case "lightColor":
        case "darkColor":
        case "baseWaterColor":
        case "blendColor":
        case "gapColor":
        case "strokeColor":
        case "backgroundColor":
        case "asphaltColor": {
          let color = getCesiumColor(value);
          if (Cesium__namespace.defined(style.opacity) && style.opacity !== 1) {
            color = color.withAlpha(style.opacity);
          }
          if (Cesium__namespace.defined(style.globalAlpha) && style.globalAlpha !== 1) {
            color = color.withAlpha(color.alpha * style.globalAlpha); // 动态调整图层或数据的透明度时使用
          }
          czmVal[key] = color;
          break
        }
        case "repeat_x":
        case "repeat_y": {
          const repeatX = style.repeat_x ?? 1;
          const repeatY = style.repeat_y ?? 1;
          czmVal.repeat = new Cesium__namespace.Cartesian2(repeatX, repeatY);
          break
        }
        case "repeat": {
          if (style.materialType === Stripe || style.materialType === CylinderWave) {
            czmVal[key] = value;
          } else {
            czmVal[key] = new Cesium__namespace.Cartesian2(style.repeat_x || value, style.repeat_y || value);
          }
          break
        }
        case "lineCount":
        case "lineThickness":
        case "lineOffset":
        case "noiseScale": {
          czmVal[key] = new Cesium__namespace.Cartesian2(value, value);
          break
        }
        case "orientation": {
          if (value) {
            czmVal[key] = Cesium__namespace.StripeOrientation.VERTICAL;
          } else {
            czmVal[key] = Cesium__namespace.StripeOrientation.HORIZONTAL;
          }
          break
        }
        default:
          czmVal[key] = value;
          break
      }
    }

    /**
     * 转换Ceium对象为json简单对象，用于导出
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style) {
      if (!this.baseMaterialConver) {
        this.baseMaterialConver = new BaseMaterialConver();
      }
      return this.baseMaterialConver.toJSON(czmVal, style)
    }

    toJSON(czmVal, style = {}) {
      if (czmVal?.options) {
        // 属性时
        const newKey = czmVal.options;
        for (const key in newKey) {
          if (Cesium__namespace.defined(czmVal[key])) {
            newKey[key] = czmVal[key]; // 读取get属性值
          }
        }
        czmVal = newKey;
      }
      return super.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      if (value instanceof Cesium__namespace.Color) {
        style[key] = value.toCssColorString();
        return
      }

      switch (key) {
        case "label":
          break
        case "color":
        case "fillColor":
        case "outlineColor":
        case "evenColor":
        case "oddColor":
        case "baseWaterColor":
        case "blendColor":
        case "gapColor":
        case "strokeColor":
        case "backgroundColor":
        case "asphaltColor":
        case "lightColor": {
          const color = getCesiumColor(value);
          if (color) {
            style[key] = color.toCssColorString();
          }
          break
        }
        case "repeat": {
          if (value instanceof Cesium__namespace.Cartesian2) {
            if (value.x !== value.y) {
              style[key + "_x"] = value.x;
              style[key + "_y"] = value.y;
            } else {
              style[key] = value.x;
            }
          } else {
            style[key] = value;
          }
          break
        }
        case "lineCount":
        case "lineThickness":
        case "lineOffset":
        case "noiseScale": {
          style[key + "_x"] = value.x;
          style[key + "_y"] = value.y;
          break
        }
        default:
          // style[key] = value
          console.log("未处理的属性", key, value);
          break
      }
    }
  }
  registerOptsConver("default", BaseMaterialConver);

  /**
   * 颜色材质 转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class ColorOptsConver
   * @extends {BaseMaterialConver}
   * @private
   */
  class ColorOptsConver extends BaseMaterialConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isProperty] 是否为属性材质（Entity使用）
     * @return {Object} Cesium属性值
     * @memberof ColorOptsConver
     */
    static toCesiumVal(style, czmVal, isProperty) {
      if (style instanceof Cesium__namespace.Color) {
        return style
      }
      if (!this.colorOptsConver) {
        this.colorOptsConver = new ColorOptsConver();
      }
      this.colorOptsConver.isProperty = isProperty;
      return this.colorOptsConver.toCesiumVal(style, czmVal)
    }

    /**
     * 转换为Cesium相关属性值
     *
     * @param {Object} style 样式配置
     * @return {Object} Cesium属性值
     */
    toCesiumVal(style) {
      if (this.isProperty) {
        return this.getColorByStyle(style)
      } else {
        return { color: this.getColorByStyle(style) }
      }
    }

    /**
     * 转换Ceium对象为json简单对象，用于导出
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isProperty] 是否为属性材质（Entity使用）
     * @return {Object} json简单对象
     * @memberof ColorOptsConver
     */
    static toJSON(czmVal, style = {}, isProperty = false) {
      if (!this.colorOptsConver) {
        this.colorOptsConver = new ColorOptsConver();
      }
      this.colorOptsConver.isProperty = isProperty;
      return this.colorOptsConver.toJSON(czmVal, style)
    }

    /**
     * 转换为json简单对象，用于导出
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @return {Object} json简单对象
     */
    toJSON(czmVal, style = {}) {
      if (czmVal?.color) {
        czmVal = czmVal.color;
      }

      let color = getCesiumValue(czmVal, Cesium__namespace.Color);
      if (color.color) {
        color = color.color;
      }
      if (color) {
        if (color instanceof Cesium__namespace.Color) {
          style.color = color.toCssColorString();
        } else if (isString(color)) {
          style.color = color;
        }
      }

      return style
    }
  }
  registerOptsConver(Color$2, ColorOptsConver);
  registerOptsConver(PolylineArrow, ColorOptsConver);

  /**
   * 图片材质 转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class ImageOptsConver
   * @extends {BaseMaterialConver}
   */
  class ImageOptsConver extends BaseMaterialConver {
    // 排除的不用处理的属性
    get excludedKeys() {
      return ["repeat_y"]
    }

    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal) {
      if (!this.imageOptsConver) {
        this.imageOptsConver = new ImageOptsConver();
      }
      return this.imageOptsConver.toCesiumVal(style, czmVal)
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "repeat_x": {
          const repeatX = style.repeat_x ?? 1;
          const repeatY = style.repeat_y ?? 1;
          czmVal.repeat = new Cesium__namespace.Cartesian2(repeatX, repeatY);
          break
        }
        case "repeat": {
          czmVal[key] = new Cesium__namespace.Cartesian2(style.repeat_x || value, style.repeat_y || value);
          break
        }
        case "color":
          // czmVal.color = this.getColorByStyle(style)
          break
        case "opacity":
          if (Cesium__namespace.defined(style.globalAlpha) && style.globalAlpha !== 1) {
            // 动态调整图层或数据的透明度时使用
            czmVal.color = Cesium__namespace.Color.WHITE.withAlpha(style.globalAlpha * (value ?? 1));
          } else if (style.transparent ?? true) {
            czmVal.color = Cesium__namespace.Color.WHITE.withAlpha(value ?? 1.0);
          } else {
            czmVal.color = Cesium__namespace.Color.WHITE;
          }

          break
        default:
          czmVal[key] = value;
          break
      }
    }

    _toCesiumValEnd(style, czmVal) {
      czmVal.transparent = czmVal.transparent ?? true;
    }

    /**
     * 转换Ceium对象为json简单对象，用于导出
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style) {
      if (!this.imageOptsConver) {
        this.imageOptsConver = new ImageOptsConver();
      }
      return this.imageOptsConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      switch (key) {
        case "repeat": {
          style.repeat_x = value.x;
          style.repeat_y = value.y;
          break
        }
        case "color": {
          style.opacity = getCesiumColor(value)?.alpha ?? 1;
          break
        }
        default:
          console.log("未处理的属性", key, value);
          break
      }
    }
  }

  registerOptsConver(Image$1, ImageOptsConver);

  /**
   * 矢量数据style转换处理基类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class BaseStyleConver
   * @extends {BaseOptsConver}
   */
  class BaseStyleConver extends BaseOptsConver {
    // 排除的不用处理的属性
    get excludedKeys() {
      const arr = [
        "label",
        "outlineOpacity",
        "outlineStyle",
        "lineCount",
        "lineThickness",
        "cellAlpha",
        "oddcolor",
        "speed",
        "axisY",
        "image2",
        "color2",
        "scaleByDistance_near",
        "scaleByDistance_nearValue",
        "scaleByDistance_far",
        "scaleByDistance_farValue",
        "distanceDisplayCondition_far",
        "distanceDisplayCondition_near"
      ];
      return arr.concat(this._getExcludedStyle())
    }

    _getExcludedStyle() {
      return []
    }

    _toCesiumValBefore(style, czmVal) {
      if (!style.material && !style.materialType) {
        // 没有类型时，如果有对应的属性值，即视为对应的类型
        if (style.color || style.randomColor) {
          style.materialType = Color$2;
        } else if (style.image) {
          style.materialType = Image$1;
        }
      }

      // if (Cesium.defined(style.globalAlpha) && style.globalAlpha !== 1) {
      //   if (style.color && style.color instanceof Cesium.Color) {
      //     style.color = style.color.toCssColorString()
      //   }
      // }
    }

    // 点状数据的通用处理
    _toOneCesiumVal_Point(key, value, style, czmVal) {
      switch (key) {
        case "clampToGround": // 贴地
          if (value) {
            czmVal.heightReference = Cesium__namespace.HeightReference.CLAMP_TO_GROUND;
          } else {
            czmVal.heightReference = Cesium__namespace.HeightReference.NONE;
          }
          break
        case "visibleDepth":
          if (value) {
            czmVal.disableDepthTestDistance = 0;
          } else {
            // 一直显示，不被地形等遮挡
            czmVal.disableDepthTestDistance = Number.POSITIVE_INFINITY;
          }
          break
        case "hasShadows": // 阴影
          if (value) {
            // 对象投射并接收阴影。
            czmVal.shadows = Cesium__namespace.ShadowMode.ENABLED;
          } else {
            // 该对象不会投射或接收阴影
            czmVal.shadows = Cesium__namespace.ShadowMode.DISABLED;
          }
          break
        case "scaleByDistance": // 是否按视距缩放
          if (value) {
            czmVal.scaleByDistance = new Cesium__namespace.NearFarScalar(
              Number(Cesium__namespace.defaultValue(style.scaleByDistance_near, 1000)),
              Number(Cesium__namespace.defaultValue(style.scaleByDistance_nearValue, 1.0)),
              Number(Cesium__namespace.defaultValue(style.scaleByDistance_far, 1000000)),
              Number(Cesium__namespace.defaultValue(style.scaleByDistance_farValue, 0.1))
            );
          } else {
            czmVal.scaleByDistance = undefined;
          }
          break
        case "distanceDisplayCondition": // 是否按视距显示
          if (value) {
            czmVal.distanceDisplayCondition = new Cesium__namespace.DistanceDisplayCondition(
              Number(Cesium__namespace.defaultValue(style.distanceDisplayCondition_near, 0)),
              Number(Cesium__namespace.defaultValue(style.distanceDisplayCondition_far, 100000))
            );
          } else {
            czmVal.distanceDisplayCondition = undefined;
          }
          break
        default:
          czmVal[key] = value;
          break
      }
    }

    // 面状数据的通用处理
    _toOneCesiumVal_Poly(key, value, style, czmVal) {
      switch (key) {
        case "materialType": {
          if (this.isEntity) {
            czmVal.material = createMaterialProperty(style.materialType, style.materialOptions || style);
          } else {
            czmVal.material = createMaterial(style.materialType, style.materialOptions || style);
          }
          break
        }
        case "color":
        case "randomColor": {
          // color本身也需要处理
          czmVal.color = this.getColorByStyle(style);
          break
        }
        case "outlineColor": {
          czmVal.outlineColor = this.getOutlineColorByStyle(style);
          break
        }
        case "hasShadows": // 阴影
          if (value) {
            // 对象投射并接收阴影。
            czmVal.shadows = Cesium__namespace.ShadowMode.ENABLED;
          } else {
            // 该对象不会投射或接收阴影
            czmVal.shadows = Cesium__namespace.ShadowMode.DISABLED;
          }
          break
        case "distanceDisplayCondition": // 是否按视距显示
          if (value) {
            if (this.isEntity) {
              czmVal.distanceDisplayCondition = new Cesium__namespace.DistanceDisplayCondition(
                Number(Cesium__namespace.defaultValue(style.distanceDisplayCondition_near, 0)),
                Number(Cesium__namespace.defaultValue(style.distanceDisplayCondition_far, 100000))
              );
            } else {
              czmVal.distanceDisplayCondition = new Cesium__namespace.DistanceDisplayConditionGeometryInstanceAttribute(
                Number(Cesium__namespace.defaultValue(style.distanceDisplayCondition_near, 0)),
                Number(Cesium__namespace.defaultValue(style.distanceDisplayCondition_far, 100000))
              );
            }
          } else {
            czmVal.distanceDisplayCondition = undefined;
          }
          break
        default:
          if (czmVal[key] instanceof Cesium__namespace.CallbackProperty) {
            // 回调时不覆盖
            logWarn("回调属性未覆盖更新", key, value);
          } else {
            czmVal[key] = value;
          }
          break
      }
    }

    _toJSONValEnd(style, czmVal) {
      // if (style.materialType === Color && style.materialOptions) {
      //   style.color = style.materialOptions?.color || style.color
      //   delete style.materialOptions
      // }
    }

    _toOneJson_Poly(key, value, style) {
      switch (key) {
        case "label":
        case "outlineStyle":
        case "highlight": {
          // 不用处理的属性
          break
        }
        case "material": {
          toJSON(value, style);
          break
        }
        case "materialOptions": {
          style[key] = toJSONByType(style.materialType, value);
          break
        }
        case "color": {
          const color = getCesiumColor(value);
          if (color) {
            style[key] = color.toCssColorString();
          }
          break
        }
        case "outlineColor": {
          const color = getCesiumColor(value);
          if (color) {
            style[key] = color.toCssColorString();
          }
          break
        }
        case "rotation":
          style.rotationDegree = formatNum$1(Cesium__namespace.Math.toDegrees(value), 2);
          break
        case "stRotation":
          style.stRotationDegree = formatNum$1(Cesium__namespace.Math.toDegrees(value), 2);
          break
        case "shadows": {
          if (value === Cesium__namespace.ShadowMode.ENABLED) {
            style.shadows = true;
          } else {
            style[key] = value;
          }
          break
        }
        case "distanceDisplayCondition": {
          style.distanceDisplayCondition_near = value.near;
          style.distanceDisplayCondition_far = value.far;
          break
        }
        default:
          logWarn("未处理的属性", key, value);
          break
      }
    }

    _toOneJson_Point(key, value, style) {
      switch (key) {
        case "label":
        case "outlineStyle":
        case "highlight": {
          // 不用处理的属性
          break
        }
        case "material": {
          toJSON(value, style);
          break
        }
        case "materialOptions": {
          style[key] = toJSONByType(style.materialType, value);
          break
        }
        case "color":
        case "fillColor":
        case "outlineColor":
        case "backgroundColor":
        case "strokeColor": {
          const color = getCesiumColor(value);
          if (color) {
            style[key] = color.toCssColorString();
          }
          break
        }
        case "heightReference": {
          if (value === Cesium__namespace.HeightReference.CLAMP_TO_GROUND) {
            style.clampToGround = true;
          }
          break
        }
        case "rotation":
          style.rotationDegree = formatNum$1(Cesium__namespace.Math.toDegrees(value), 2);
          break
        case "stRotation":
          style.stRotationDegree = formatNum$1(Cesium__namespace.Math.toDegrees(value), 2);
          break
        case "disableDepthTestDistance": {
          if (value === Number.POSITIVE_INFINITY) {
            style.visibleDepth = false;
          } else {
            style.disableDepthTestDistance = value;
          }
          break
        }
        case "scaleByDistance": {
          style.scaleByDistance = true;
          style.scaleByDistance_near = value.near;
          style.scaleByDistance_nearValue = value.nearValue;
          style.scaleByDistance_far = value.far;
          style.scaleByDistance_farValue = value.farValue;
          break
        }
        case "distanceDisplayCondition": {
          style.distanceDisplayCondition = true;
          style.distanceDisplayCondition_near = value.near;
          style.distanceDisplayCondition_far = value.far;
          break
        }
        default:
          logWarn("未处理的属性", key, value);
          break
      }
    }
  }

  /**
   * Billboard 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class BillboardStyleConver
   * @extends {BaseStyleConver}
   */
  class BillboardStyleConver extends BaseStyleConver {
    _getExcludedStyle() {
      return ["outlineColor", "backgroundColor", "font_style", "font_weight", "font_size", "font_family", "backgroundOpacity", "fill", "outline"]
    }

    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.billboardStyleConver) {
        this.billboardStyleConver = new BillboardStyleConver();
      }
      this.billboardStyleConver.isEntity = isEntity;
      return this.billboardStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {
      czmVal.horizontalOrigin = czmVal.horizontalOrigin ?? Cesium__namespace.HorizontalOrigin.CENTER;
      czmVal.verticalOrigin = czmVal.verticalOrigin ?? Cesium__namespace.HorizontalOrigin.BOTTOM;
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "color": {
          czmVal.color = this.getColorByStyle(style); // 颜色
          break
        }
        case "opacity": // 透明度
          if (Cesium__namespace.defined(style.globalAlpha) && style.globalAlpha !== 1) {
            // 动态调整图层或数据的透明度时使用
            czmVal.color = Cesium__namespace.Color.WHITE.withAlpha(style.globalAlpha * (value ?? 1));
          } else {
            czmVal.color = Cesium__namespace.Color.WHITE.withAlpha(value ?? 1.0);
          }
          break
        case "rotationDegree": // 旋转角度 (度数)
          czmVal.rotation = Cesium__namespace.Math.toRadians(value);
          break
        case "hasPixelOffset": // 是否存在偏移量
          if (!value) {
            czmVal.pixelOffset = new Cesium__namespace.Cartesian2(0, 0);
          }
          break
        case "pixelOffsetX": // 偏移量
        case "pixelOffsetY":
          czmVal.pixelOffset = new Cesium__namespace.Cartesian2(style.pixelOffsetX || 0, style.pixelOffsetY || 0);
          break
        case "pixelOffset": // 偏移量
          if (Cesium__namespace.defined(value[0]) && Cesium__namespace.defined(value[1])) {
            czmVal.pixelOffset = new Cesium__namespace.Cartesian2(value[0], value[1]);
          } else {
            czmVal.pixelOffset = value;
          }
          break
        default:
          this._toOneCesiumVal_Point(key, value, style, czmVal);
          break
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.billboardStyleConver) {
        this.billboardStyleConver = new BillboardStyleConver();
      }
      this.billboardStyleConver.isEntity = isEntity;
      return this.billboardStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      switch (key) {
        case "pixelOffset": {
          style.pixelOffsetX = value.x;
          style.pixelOffsetY = value.y;
          break
        }
        default:
          this._toOneJson_Point(key, value, style);
          break
      }
    }
  }

  /**
   * Cloud 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class CloudStyleConver
   * @extends {BaseStyleConver}
   */
  class CloudStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal) {
      if (!this.cloudStyleConver) {
        this.cloudStyleConver = new CloudStyleConver();
      }
      return this.cloudStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {}
    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "scaleX":
        case "scaleY":
          czmVal.scale = new Cesium__namespace.Cartesian2(style.scaleX || 1, style.scaleY || 1);
          break
        case "maximumSizeX":
        case "maximumSizeY":
        case "maximumSizeZ":
          czmVal.maximumSize = new Cesium__namespace.Cartesian3(style.maximumSizeX || 1, style.maximumSizeY || 1, style.maximumSizeZ || 1);
          break
        default:
          this._toOneCesiumVal_Point(key, value, style, czmVal);
          break
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style) {
      if (!this.cloudStyleConver) {
        this.cloudStyleConver = new CloudStyleConver();
      }
      return this.cloudStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      switch (key) {
        case "scale":
          style.scaleX = value.x;
          style.scaleY = value.y;
          break
        case "maximumSize":
          style.maximumSizeX = value.x;
          style.maximumSizeY = value.y;
          style.maximumSizeZ = value.z;
          break
        default:
          this._toOneJson_Point(key, value, style);
          break
      }
    }
  }

  /**
   * Box矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class BoxStyleConver
   * @extends {BaseStyleConver}
   */
  class BoxStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.boxStyleConver) {
        this.boxStyleConver = new BoxStyleConver();
      }
      this.boxStyleConver.isEntity = isEntity;
      return this.boxStyleConver.toCesiumVal(style, czmVal)
    }

    _getExcludedStyle() {
      return ["opacity", "dimensions_y", "dimensions_z"]
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "outlineColor": {
          czmVal.outlineColor = this.getOutlineColorByStyle(style);
          break
        }
        case "dimensions_x": {
          // 盒子的长宽高
          const dimensions_x = style.dimensions_x ?? 100.0;
          const dimensions_y = style.dimensions_y ?? 100.0;
          const dimensions_z = style.dimensions_z ?? 100.0;
          czmVal.dimensions = new Cesium__namespace.Cartesian3(dimensions_x, dimensions_y, dimensions_z);
          break
        }
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);
          break
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.boxStyleConver) {
        this.boxStyleConver = new BoxStyleConver();
      }
      this.boxStyleConver.isEntity = isEntity;
      return this.boxStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      switch (key) {
        case "dimensions": {
          // 盒子的长宽高
          style.dimensions_x = value.x;
          style.dimensions_y = value.y;
          style.dimensions_z = value.z;
          break
        }
        default:
          this._toOneJson_Poly(key, value, style);
          break
      }
    }
  }

  /**
   * Circle 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class CircleStyleConver
   * @extends {BaseStyleConver}
   */
  class CircleStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.circleStyleConver) {
        this.circleStyleConver = new CircleStyleConver();
      }
      this.circleStyleConver.isEntity = isEntity;
      return this.circleStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {
      super._toCesiumValBefore(style, czmVal);

      // 圆 的特殊处理
      if (style.clampToGround) {
        if (style.hasOwnProperty("height")) {
          delete style.height;
        }
        if (style.hasOwnProperty("extrudedHeight")) {
          delete style.extrudedHeight;
        }
        if (style.hasOwnProperty("diffHeight")) {
          delete style.diffHeight;
        }
      }

      if (Cesium__namespace.defined(style.height)) {
        style.clampToGround = false;
      }
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "rotation": // 旋转角度 (弧度)
          czmVal.rotation = value;
          if (!style.stRotation) {
            czmVal.stRotation = czmVal.rotation;
          }
          break
        case "rotationDegree": // 旋转角度 (度数)
          czmVal.rotation = Cesium__namespace.Math.toRadians(value);
          if (!style.stRotation) {
            czmVal.stRotation = czmVal.rotation;
          }
          break
        case "stRotationDegree": // (度数)
          czmVal.stRotation = Cesium__namespace.Math.toRadians(value);
          break
        case "height":
          czmVal.height = value;
          if (style.diffHeight) {
            czmVal.extrudedHeight = Number(style.diffHeight) + Number(value);
          }
          break
        case "diffHeight":
          if (Cesium__namespace.defined(style.height)) {
            czmVal.extrudedHeight = style.height + value;
          }
          break
        case "radius": // 半径（圆）
          if (this.isEntity) {
            czmVal.semiMinorAxis = Number(value);
            czmVal.semiMajorAxis = Number(value);
          } else {
            czmVal.radius = Number(value);
          }
          break
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);
          break
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.circleStyleConver) {
        this.circleStyleConver = new CircleStyleConver();
      }
      this.circleStyleConver.isEntity = isEntity;
      return this.circleStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      switch (key) {
        case "rotation": {
          style.rotationDegree = formatNum$1(Cesium__namespace.Math.toDegrees(value), 1);
          break
        }
        case "stRotation": {
          style.stRotationDegree = formatNum$1(Cesium__namespace.Math.toDegrees(value), 1);
          break
        }
        default:
          this._toOneJson_Poly(key, value, style);
          break
      }
    }
  }

  /**
   * Corridor 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class CorridorStyleConver
   * @extends {BaseStyleConver}
   */
  class CorridorStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.corridorStyleConver) {
        this.corridorStyleConver = new CorridorStyleConver();
      }
      this.corridorStyleConver.isEntity = isEntity;
      return this.corridorStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {
      super._toCesiumValBefore(style, czmVal);

      // XX的特殊处理
      if (style.clampToGround) {
        if (style.hasOwnProperty("height")) {
          delete style.height;
        }
        if (style.hasOwnProperty("extrudedHeight")) {
          delete style.extrudedHeight;
        }
        if (style.hasOwnProperty("diffHeight")) {
          delete style.diffHeight;
        }
      }
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "outlineColor": {
          czmVal.outlineColor = this.getOutlineColorByStyle(style);
          break
        }
        case "height":
          czmVal.height = value;
          if (style.diffHeight) {
            czmVal.extrudedHeight = Number(style.diffHeight) + Number(value);
          }
          break
        case "diffHeight":
          if (Cesium__namespace.defined(style.height)) {
            czmVal.extrudedHeight = style.height + value;
          }
          break
          default:
            this._toOneCesiumVal_Poly(key, value, style, czmVal);
            break
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.corridorStyleConver) {
        this.corridorStyleConver = new CorridorStyleConver();
      }
      this.corridorStyleConver.isEntity = isEntity;
      return this.corridorStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }
  }

  /**
   * Cylinder 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class CylinderStyleConver
   * @extends {BaseStyleConver}
   */
  class CylinderStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.cylinderStyleConver) {
        this.cylinderStyleConver = new CylinderStyleConver();
      }
      this.cylinderStyleConver.isEntity = isEntity;
      return this.cylinderStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {
      super._toCesiumValBefore(style, czmVal);

      // XX的特殊处理
      if (!style.topRadius) {
        style.topRadius = 0;
      }
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "diffHeight": // 高度
          if (czmVal.length instanceof Cesium__namespace.CallbackProperty) ; else {
            czmVal.length = Number(value);
          }
          break
          default:
            this._toOneCesiumVal_Poly(key, value, style, czmVal);
            break
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.cylinderStyleConver) {
        this.cylinderStyleConver = new CylinderStyleConver();
      }
      this.cylinderStyleConver.isEntity = isEntity;
      return this.cylinderStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }
  }

  /**
   * DivGraphic 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class DivGraphicStyleConver
   * @extends {BaseStyleConver}
   */
  class DivGraphicStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal) {
      if (!this.divGraphicStyleConver) {
        this.divGraphicStyleConver = new DivGraphicStyleConver();
      }
      return this.divGraphicStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {
      // 覆盖父类
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      this._toOneCesiumVal_Point(key, value, style, czmVal);
    }

    /**
     * 转换Ceium对象为json简单对象，用于导出
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style) {
      if (!this.divGraphicStyleConver) {
        this.divGraphicStyleConver = new DivGraphicStyleConver();
      }
      return this.divGraphicStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      this._toOneJson_Point(key, value, style);
    }
  }

  /**
   * Ellipsoid 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class EllipsoidStyleConver
   * @extends {BaseStyleConver}
   */
  class EllipsoidStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.ellipsoidStyleConver) {
        this.ellipsoidStyleConver = new EllipsoidStyleConver();
      }
      this.ellipsoidStyleConver.isEntity = isEntity;
      return this.ellipsoidStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {
      super._toCesiumValBefore(style, czmVal);

      // XX的特殊处理
    }

    _getExcludedStyle() {
      return ["radii_y", "radii_z", "innerRadii_y", "innerRadii_z"]
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "radii":
          czmVal.radii = new Cesium__namespace.Cartesian3(value, value, value);
          break
        case "radii_x": // 球体 长宽高半径
          czmVal.radii = new Cesium__namespace.Cartesian3(style.radii_x ?? 100, style.radii_y ?? 100, style.radii_z ?? 100);
          break
        case "innerRadii":
          czmVal.innerRadii = new Cesium__namespace.Cartesian3(value, value, value);
          break
        case "innerRadii_x": // 球体内圈 长宽高半径
          if (style.innerRadii_x > 0 && style.innerRadii_y > 0 && style.innerRadii_z > 0) {
            czmVal.innerRadii = new Cesium__namespace.Cartesian3(style.innerRadii_x ?? 0, style.innerRadii_y ?? 0, style.innerRadii_z ?? 0);
          } else {
            czmVal.innerRadii = new Cesium__namespace.Cartesian3(0.001, 0.001, 0.001);
          }
          break
        case "minimumClockDegree": // （度数值，0-360度）
        case "maximumClockDegree":
        case "minimumConeDegree":
        case "maximumConeDegree":
          czmVal[key.replace("Degree", "")] = Cesium__namespace.Math.toRadians(value || 0);
          break
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);
          break
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.ellipsoidStyleConver) {
        this.ellipsoidStyleConver = new EllipsoidStyleConver();
      }
      this.ellipsoidStyleConver.isEntity = isEntity;
      return this.ellipsoidStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      switch (key) {
        case "radii": {
          style.radii_x = value.x;
          style.radii_y = value.y;
          style.radii_z = value.z;
          break
        }
        case "innerRadii": {
          style.innerRadii_x = value.x;
          style.innerRadii_y = value.y;
          style.innerRadii_z = value.z;
          break
        }
        case "minimumClock":
        case "maximumClock":
        case "minimumCone":
        case "maximumCone":
          style[key + "Degree"] = formatNum$1(Cesium__namespace.Math.toDegrees(value), 2);
          break
        default:
          this._toOneJson_Poly(key, value, style);
          break
      }
    }
  }

  /**
   *  Label 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   * @export
   * @class LabelStyleConver
   * @extends {BaseStyleConver}
   */
  class LabelStyleConver extends BaseStyleConver {
    // 转换style到Cesium对象需要的格式
    static toCesiumVal(style, czmVal, attr) {
      if (!this.labelStyleConver) {
        this.labelStyleConver = new LabelStyleConver();
      }
      this.labelStyleConver.attr = attr;
      czmVal = this.labelStyleConver.toCesiumVal(style, czmVal);
      return czmVal
    }

    _toCesiumValBefore(style, czmVal) {
      czmVal.horizontalOrigin = czmVal.horizontalOrigin ?? Cesium__namespace.HorizontalOrigin.CENTER;
      czmVal.verticalOrigin = czmVal.verticalOrigin ?? Cesium__namespace.HorizontalOrigin.BOTTOM;
    }

    _toCesiumValEnd(style, czmVal) {
      // 样式（倾斜、加粗等）
      if (!Cesium__namespace.defined(style.font)) {
        const size = style.font_size || 18;
        czmVal.font =
          (style.font_style || "normal") + " small-caps " + (style.font_weight || "normal") + " " + size + "px " + (style.font_family || "楷体");
      }

      if (!Cesium__namespace.defined(style.style) && (style.fill ?? true)) {
        if (style.outline) {
          czmVal.style = Cesium__namespace.LabelStyle.FILL_AND_OUTLINE;
        } else {
          czmVal.style = Cesium__namespace.LabelStyle.FILL;
        }
      }
    }

    _getExcludedStyle() {
      return ["font_style", "font_weight", "font_size", "font_family", "backgroundOpacity", "fill"]
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "text": {
          if (this.attr) {
            value = template(value, this.attr, true);
          }
          czmVal.text = value.replace(/<br \/>/gm, "\n");
          break
        }
        case "color": {
          czmVal.fillColor = this.getColorByStyle(style); // 颜色
          break
        }
        case "outlineColor": {
          czmVal.outlineColor = this.getOutlineColorByStyle(style);
          break
        }
        case "strokeColor":
        case "fillColor": {
          czmVal[key] = getCesiumColor(value);
          break
        }
        case "background": // 是否背景色
          czmVal.background = value; // 文本材质使用
          czmVal.showBackground = value;
          break
        case "backgroundColor": {
          // 背景色
          let color = getCesiumColor(value, Cesium__namespace.Color.BLACK);
          if (Cesium__namespace.defined(style.backgroundOpacity)) {
            color = color.withAlpha(Number(style.backgroundOpacity));
          } else if (Cesium__namespace.defined(style.opacity)) {
            color = color.withAlpha(Number(style.opacity));
          }
          czmVal.backgroundColor = color;
          break
        }
        case "backgroundPadding":
          czmVal.backgroundPadding = new Cesium__namespace.Cartesian2(value * 1.2, value);
          czmVal.padding = value; // getTextImage
          break

        case "hasPixelOffset": // 是否存在偏移量
          if (!value) {
            czmVal.pixelOffset = new Cesium__namespace.Cartesian2(0, 0);
          }
          break
        case "pixelOffsetX": // 偏移量
        case "pixelOffsetY":
          czmVal.pixelOffset = new Cesium__namespace.Cartesian2(style.pixelOffsetX || 0, style.pixelOffsetY || 0);
          break
        case "pixelOffset": // 偏移量
          if (Cesium__namespace.defined(value[0]) && Cesium__namespace.defined(value[1])) {
            czmVal.pixelOffset = new Cesium__namespace.Cartesian2(value[0], value[1]);
          } else {
            czmVal.pixelOffset = value;
          }
          break

        default:
          this._toOneCesiumVal_Point(key, value, style, czmVal);
          break
      }
    }

    // 导出Cesium的样式对象到json可以保存的格式
    /**
     * 转换Ceium对象为json简单对象，用于导出
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style) {
      if (!this.labelStyleConver) {
        this.labelStyleConver = new LabelStyleConver();
      }
      return this.labelStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      switch (key) {
        case "pixelOffset": {
          style.pixelOffsetX = value.x;
          style.pixelOffsetY = value.y;
          break
        }
        case "disableDepthTestDistance": {
          if (value === Number.POSITIVE_INFINITY) {
            style.visibleDepth = false;
          } else {
            style.disableDepthTestDistance = value;
          }
          break
        }

        default:
          this._toOneJson_Point(key, value, style);
          break
      }
    }

    /**
     * 设置Label全局透明度
     *
     * @param {Cesium.Label|Cesium.LabelGraphics} label 文本对象
     * @param {Number} value 透明度
     * @return {void}  无
     */
    static setOpacity(label, value) {
      const fillColor = getCesiumValue(label.fillColor, Cesium__namespace.Color);
      if (fillColor) {
        if (!Cesium__namespace.defined(label._fillColor_alpha_bak)) {
          label._fillColor_alpha_bak = fillColor.alpha ?? 1;
        }
        label.fillColor = fillColor.withAlpha(value * label._fillColor_alpha_bak);
      } else {
        label.fillColor = Cesium__namespace.Color.WHITE.withAlpha(value);
      }

      const outlineColor = getCesiumValue(label.outlineColor, Cesium__namespace.Color);
      if (outlineColor) {
        if (!Cesium__namespace.defined(label._outlineColor_alpha_bak)) {
          label._outlineColor_alpha_bak = outlineColor.alpha ?? 1;
        }
        label.outlineColor = outlineColor.withAlpha(value * label._outlineColor_alpha_bak);
      }

      const backgroundColor = getCesiumValue(label.backgroundColor, Cesium__namespace.Color);
      if (backgroundColor) {
        if (!Cesium__namespace.defined(label._backgroundColor_alpha_bak)) {
          label._backgroundColor_alpha_bak = backgroundColor.alpha ?? 1;
        }
        label.backgroundColor = backgroundColor.withAlpha(value * label._backgroundColor_alpha_bak);
      }
    }
  }

  /**
   * Model 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class ModelStyleConver
   * @extends {BaseStyleConver}
   */
  class ModelStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.modelStyleConver) {
        this.modelStyleConver = new ModelStyleConver();
      }
      this.modelStyleConver.isEntity = isEntity;
      return this.modelStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {
      // 覆盖父类
    }

    _getExcludedStyle() {
      return ["silhouette", "silhouetteColor", "silhouetteAlpha", "silhouetteSize", "fill", "opacity"]
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "url": // 模型uri
        case "modelUrl":
        case "uri":
          value = replaceOnlineUrlDomain({ url: value }).url;

          if (this.isEntity) {
            czmVal.uri = value;
          } else {
            czmVal.url = value;
          }
          break
        case "scale":
          if (!isNaN(value)) {
            czmVal[key] = value;
          }
          break
        default:
          this._toOneCesiumVal_Point(key, value, style, czmVal);
          break
      }
    }

    _toCesiumValEnd(style, czmVal) {
      czmVal.show = Boolean(czmVal.uri || czmVal.url); // 没有路径的隐藏不加载

      // 轮廓
      if (style.silhouette) {
        let silhouetteColor = getCesiumColor(style.silhouetteColor, Cesium__namespace.Color.WHITE);
        if (Cesium__namespace.defined(style.silhouetteAlpha)) {
          silhouetteColor = silhouetteColor.withAlpha(Number(style.silhouetteAlpha));
        }
        if (Cesium__namespace.defined(style.globalAlpha) && style.globalAlpha !== 1) {
          silhouetteColor = silhouetteColor.withAlpha(silhouetteColor.alpha * style.globalAlpha); // 动态调整图层或数据的透明度时使用
        }

        czmVal.silhouetteColor = silhouetteColor;
        czmVal.silhouetteSize = Number(style.silhouetteSize || 1.0);
      } else {
        czmVal.silhouetteSize = 0.0;
      }

      // 透明度、颜色
      if (style.fill) {
        czmVal.color = getColorByStyle(style, Cesium__namespace.Color.WHITE);
      } else if (Cesium__namespace.defined(style.opacity)) {
        czmVal.color = Cesium__namespace.Color.WHITE.withAlpha(style.opacity);
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.modelStyleConver) {
        this.modelStyleConver = new ModelStyleConver();
      }
      this.modelStyleConver.isEntity = isEntity;
      return this.modelStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      switch (key) {
        case "uri": {
          style.url = value;
          break
        }
        default:
          this._toOneJson_Point(key, value, style);
          break
      }
    }

    /**
     * 设置Model全局透明度
     *
     * @param {Cesium.Model|Cesium.ModelGraphics} model 模型对象
     * @param {Number} value 透明度
     * @return {void}  无
     */
    static setOpacity(model, value) {
      const color = getCesiumValue(model.color, Cesium__namespace.Color);
      if (!Cesium__namespace.defined(model._color_alpha_bak)) {
        model._color_alpha_bak = color?.alpha ?? 1;
      }

      if (color) {
        model.color = color.withAlpha(value * model._color_alpha_bak);
      } else {
        model.color = Cesium__namespace.Color.WHITE.withAlpha(value);
      }

      const silhouetteColor = getCesiumValue(model.silhouetteColor, Cesium__namespace.Color);
      if (silhouetteColor) {
        if (!Cesium__namespace.defined(model._silhouetteColor_alpha_bak)) {
          model._silhouetteColor_alpha_bak = silhouetteColor.alpha ?? 1;
        }
        model.silhouetteColor = silhouetteColor.withAlpha(value * model._silhouetteColor_alpha_bak);
      }
    }
  }

  /**
   * Path 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class PathStyleConver
   * @extends {BaseStyleConver}
   */
  class PathStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.pathStyleConver) {
        this.pathStyleConver = new PathStyleConver();
      }
      this.pathStyleConver.isEntity = isEntity;
      return this.pathStyleConver.toCesiumVal(style, czmVal)
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      this._toOneCesiumVal_Poly(key, value, style, czmVal);
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.pathStyleConver) {
        this.pathStyleConver = new PathStyleConver();
      }
      this.pathStyleConver.isEntity = isEntity;
      return this.pathStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }
  }

  /**
   * Plane 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class PlaneStyleConver
   * @extends {BaseStyleConver}
   */
  class PlaneStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.planeStyleConver) {
        this.planeStyleConver = new PlaneStyleConver();
      }
      this.planeStyleConver.isEntity = isEntity;
      return this.planeStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {
      super._toCesiumValBefore(style, czmVal);

      // XX的特殊处理
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "dimensions_x": {
          // 平面的长宽
          const dimensions_x = style.dimensions_x ?? 100.0;
          const dimensions_y = style.dimensions_y ?? 100.0;
          czmVal.dimensions = new Cesium__namespace.Cartesian2(dimensions_x, dimensions_y);
          break
        }
        case "plane_normal": {
          // 平面的方向及距离
          let plane_normal;
          switch (value) {
            case "x":
              plane_normal = Cesium__namespace.Cartesian3.UNIT_X;
              break
            case "y":
              plane_normal = Cesium__namespace.Cartesian3.UNIT_Y;
              break
            case "z":
              plane_normal = Cesium__namespace.Cartesian3.UNIT_Z;
              break
            default:
              plane_normal = value;
              break
          }
          const plane_distance = style.plane_distance ?? 0.0;
          czmVal.plane = new Cesium__namespace.Plane(plane_normal, plane_distance);
          break
        }
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);
          break
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.planeStyleConver) {
        this.planeStyleConver = new PlaneStyleConver();
      }
      this.planeStyleConver.isEntity = isEntity;
      return this.planeStyleConver.toJSON(czmVal, style)
    }

    static toOneJson(key, value, style) {
      if (!this.planeStyleConver) {
        this.planeStyleConver = new PlaneStyleConver();
      }
      return this.planeStyleConver._toOneJson(key, value, style)
    }

    _toOneJson(key, value, style) {
      switch (key) {
        case "dimensions": {
          style.dimensions_x = value.x;
          style.dimensions_y = value.y;
          break
        }
        case "plane_normal": {
          if (value.equals(Cesium__namespace.Cartesian3.UNIT_X)) {
            style.plane_normal = "x";
          } else if (value.equals(Cesium__namespace.Cartesian3.UNIT_Y)) {
            style.plane_normal = "y";
          } else if (value.equals(Cesium__namespace.Cartesian3.UNIT_Z)) {
            style.plane_normal = "z";
          } else {
            logWarn("plane类型未识别", value);
            style.plane_normal = "z";
          }
          break
        }
        case "plane": {
          if (value.normal.equals(Cesium__namespace.Cartesian3.UNIT_X)) {
            style.plane_normal = "x";
          } else if (value.normal.equals(Cesium__namespace.Cartesian3.UNIT_Y)) {
            style.plane_normal = "y";
          } else if (value.normal.equals(Cesium__namespace.Cartesian3.UNIT_Z)) {
            style.plane_normal = "z";
          } else {
            logWarn("plane类型未识别", value);
            style.plane_normal = "z";
          }
          style.plane_distance = value.distance;
          break
        }
        default:
          this._toOneJson_Poly(key, value, style);
          break
      }
    }
  }

  /**
   * Point 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class PointStyleConver
   * @extends {BaseStyleConver}
   */
  class PointStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.pointStyleConver) {
        this.pointStyleConver = new PointStyleConver();
      }
      this.pointStyleConver.isEntity = isEntity;
      return this.pointStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {
      // 覆盖父类
      czmVal.pixelSize = 6; // 默认值
    }

    _toCesiumValEnd(style, czmVal) {
      if (style.outline === false) {
        czmVal.outlineWidth = 0;
      }

    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "color":
        case "randomColor": {
          // 填充颜色
          czmVal.color = this.getColorByStyle(style);
          break
        }
        case "outlineColor": {
          // 边框颜色
          czmVal.outlineColor = this.getOutlineColorByStyle(style);
          break
        }
        default:
          this._toOneCesiumVal_Point(key, value, style, czmVal);
          break
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.pointStyleConver) {
        this.pointStyleConver = new PointStyleConver();
      }
      this.pointStyleConver.isEntity = isEntity;
      return this.pointStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      this._toOneJson_Point(key, value, style);
    }
  }

  /**
   * Polygon 矢量数据style转换处理类
   *
   * @export
   * @class PolygonStyleConver
   * @extends {BaseStyleConver}
   */
  class PolygonStyleConver extends BaseStyleConver {
    /**
     * style样式属性赋值到 entity
     *
     * @param {PolygonEntity.StyleOptions} style 样式
     * @param {Cesium.PolygonGraphics|null} entityGraphic 矢量数据对应的 Cesium内部对象
     * @param {Boolean} isEntity 是否为entity
     * @return {Cesium.PolygonGraphics} 矢量数据所需的Cesium内部对象
     * @function
     */
    static toCesiumVal(style, entityGraphic, isEntity) {
      if (!this.polygonStyleConver) {
        this.polygonStyleConver = new PolygonStyleConver();
      }
      this.polygonStyleConver.isEntity = isEntity;
      return this.polygonStyleConver.toCesiumVal(style, entityGraphic)
    }

    _toCesiumValBefore(style, czmVal) {
      super._toCesiumValBefore(style, czmVal);

      // 面的特殊处理
      if (style.clampToGround) {
        czmVal.arcType = Cesium__namespace.ArcType.GEODESIC;
      } else if (Cesium__namespace.defined(style.height)) {
        style.clampToGround = false;
        czmVal.perPositionHeight = false;
      } else {
        style.clampToGround = false;
        czmVal.perPositionHeight = true;
      }
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "outlineColor": {
          czmVal.outlineColor = this.getOutlineColorByStyle(style);
          break
        }
        case "height": {
          czmVal[key] = value;
          czmVal.perPositionHeight = false;
          break
        }
        case "diffHeight": {
          if (Cesium__namespace.defined(style.height)) {
            czmVal.extrudedHeight = value + style.height;
          }
          break
        }
        case "clampToGround": // 贴地
          czmVal[key] = value;
          czmVal.perPositionHeight = !value && !Cesium__namespace.defined(style.height);
          break
        case "stRotation":
          czmVal.stRotation = value; // CallbackProperty也覆盖
          break
        case "stRotationDegree": // 材质旋转角度(度数)
          czmVal.stRotation = Cesium__namespace.Math.toRadians(value);
          break
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);
          break
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.polygonStyleConver) {
        this.polygonStyleConver = new PolygonStyleConver();
      }
      this.polygonStyleConver.isEntity = isEntity;
      return this.polygonStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      switch (key) {
        case "stRotation": {
          style.stRotationDegree = formatNum$1(Cesium__namespace.Math.toDegrees(value), 1);
          break
        }
        default:
          this._toOneJson_Poly(key, value, style);
          break
      }
    }
  }

  /**
   * Polyline 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class PolylineStyleConver
   * @extends {BaseStyleConver}
   */
  class PolylineStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.polylineStyleConver) {
        this.polylineStyleConver = new PolylineStyleConver();
      }
      this.polylineStyleConver.isEntity = isEntity;
      return this.polylineStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {
      super._toCesiumValBefore(style, czmVal);

      // XX的特殊处理
      if (style.clampToGround) {
        czmVal.arcType = Cesium__namespace.ArcType.GEODESIC;
      }

      if (style.materialType === Color$2 && style.outline && style.outlineColor) {
        style.materialType = PolylineOutline;
      }
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "depthFail":
          if (value) {
            let depthFailColor = getCesiumColor(style.depthFailColor || style.color, Cesium__namespace.Color.YELLOW);
            if (Cesium__namespace.defined(style.depthFailOpacity)) {
              depthFailColor = depthFailColor.withAlpha(Number(style.depthFailOpacity));
            }

            if (this.isEntity) {
              czmVal.depthFailMaterial = depthFailColor;
            } else {
              czmVal.depthFailColor = depthFailColor;
            }
            if (style.opacity === 1.0) {
              style.opacity = 0.98; // 不透明时，竟然不显示depthFailMaterial？！
            }
          } else {
            czmVal.depthFailMaterial = undefined;
          }
          czmVal[key] = value;
          break
        case "closure":
          if (!this.isEntity) {
            czmVal.loop = value; // PolylineSimplePrimitive
          }
          czmVal.closure = value;
          break
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);
          break
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.polylineStyleConver) {
        this.polylineStyleConver = new PolylineStyleConver();
      }
      this.polylineStyleConver.isEntity = isEntity;
      return this.polylineStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      switch (key) {
        case "loop":
          // 在primitive中
          style.closure = value;
          break
        default:
          this._toOneJson_Poly(key, value, style);
          break
      }
    }
  }

  /**
   * PolylineVolume 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class PolylineVolumeStyleConver
   * @extends {BaseStyleConver}
   */
  class PolylineVolumeStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.polylineVolumeStyleConver) {
        this.polylineVolumeStyleConver = new PolylineVolumeStyleConver();
      }
      this.polylineVolumeStyleConver.isEntity = isEntity;
      return this.polylineVolumeStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValEnd(style, czmVal) {
      const shape = style.shape || style.shapePositions;
      style.radius = style.radius || 10;

      switch (shape) {
        case "pipeline":
          czmVal.shape = PolylineVolumeStyleConver.getShapeForPipeline(style); // （厚度固定为半径的1/3）
          break
        case "circle":
          czmVal.shape = PolylineVolumeStyleConver.getShapeForCircle(style);
          break
        case "star":
          czmVal.shape = PolylineVolumeStyleConver.getShapeForStar(style);
          break
        default:
          czmVal.shape = shape;
          break
      }
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      this._toOneCesiumVal_Poly(key, value, style, czmVal);
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.polylineVolumeStyleConver) {
        this.polylineVolumeStyleConver = new PolylineVolumeStyleConver();
      }
      this.polylineVolumeStyleConver.isEntity = isEntity;
      return this.polylineVolumeStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }

    //= ==================================

    // 管道形状【内空管道】 radius整个管道的外半径
    static getShapeForPipeline(style) {
      const radius = style.radius ?? 1; // radius整个管道的外半径
      const hd = style.thicknes ?? radius / 3; // 厚度
      const step = Math.ceil(360 / (style.slices ?? 60)); // 步长
      const startAngle = style.startAngle ?? 0;
      const endAngle = style.endAngle ?? startAngle + 360;

      const pss = [];
      for (let i = startAngle; i <= endAngle; i += step) {
        const radians = Cesium__namespace.Math.toRadians(i);
        pss.push(new Cesium__namespace.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
      }

      for (let i = endAngle; i >= startAngle; i -= step) {
        const radians = Cesium__namespace.Math.toRadians(i);
        pss.push(new Cesium__namespace.Cartesian2((radius - hd) * Math.cos(radians), (radius - hd) * Math.sin(radians)));
      }
      return pss
    }

    // 管道形状【圆柱体】 radius整个管道的外半径
    static getShapeForCircle(style) {
      const radius = style.radius ?? 1; // radius整个管道的外半径
      const step = Math.ceil(360 / (style.slices ?? 60)); // 步长
      const startAngle = style.startAngle ?? 0;
      const endAngle = style.endAngle ?? startAngle + 360;

      const pss = [];
      for (let i = startAngle; i <= endAngle; i += step) {
        const radians = Cesium__namespace.Math.toRadians(i);
        pss.push(new Cesium__namespace.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
      }
      return pss
    }

    // 管道形状【星状】
    static getShapeForStar(style) {
      const radius = style.radius ?? 1; // radius整个管道的外半径
      const hd = radius - style.thicknes ?? radius / 3; // 内部厚度
      const arms = style.slices ?? 6; // 星角的个数（默认6个角）
      const startAngle = Cesium__namespace.Math.toRadians(style.startAngle ?? 0);

      const angle = Math.PI / arms;
      const length = 2 * arms;
      const pss = new Array(length);
      for (let i = 0; i < length; i++) {
        const r = i % 2 === 0 ? radius : hd;
        const thisRadians = startAngle + i * angle;
        pss[i] = new Cesium__namespace.Cartesian2(Math.cos(thisRadians) * r, Math.sin(thisRadians) * r);
      }
      return pss
    }
  }

  /**
   * Rectangle 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class RectangleStyleConver
   * @extends {BaseStyleConver}
   */
  class RectangleStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.rectangleStyleConver) {
        this.rectangleStyleConver = new RectangleStyleConver();
      }
      this.rectangleStyleConver.isEntity = isEntity;
      return this.rectangleStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {
      super._toCesiumValBefore(style, czmVal);

      if (style.clampToGround) {
        // 贴地时，剔除高度相关属性
        if (style.hasOwnProperty("height")) {
          delete style.height;
        }
        if (style.hasOwnProperty("diffHeight")) {
          delete style.diffHeight;
        }
        if (style.hasOwnProperty("extrudedHeight")) {
          delete style.extrudedHeight;
        }
      } else {
        style.clampToGround = false;
        czmVal.height = 0;
      }
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "height":
          czmVal.height = value;
          if (style.diffHeight) {
            czmVal.diffHeight = Number(style.diffHeight) + Number(value);
          }
          break
        case "diffHeight":
          if (Cesium__namespace.defined(style.height)) {
            czmVal.extrudedHeight = style.height + value;
          }
          break

        case "rotation": // 旋转角度 (弧度)
          czmVal.rotation = value;
          if (!style.stRotation) {
            czmVal.stRotation = czmVal.rotation;
          }
          break
        case "rotationDegree": // 旋转角度 (度数)
          czmVal.rotation = Cesium__namespace.Math.toRadians(value);
          if (!style.stRotation) {
            czmVal.stRotation = czmVal.rotation;
          }
          break
        case "stRotation":
          czmVal.stRotation = value; // CallbackProperty也覆盖
          break
        case "stRotationDegree": // (度数)
          czmVal.stRotation = Cesium__namespace.Math.toRadians(value);
          break
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);
          break
      }
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.rectangleStyleConver) {
        this.rectangleStyleConver = new RectangleStyleConver();
      }
      this.rectangleStyleConver.isEntity = isEntity;
      return this.rectangleStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }
  }

  /**
   * RectangularSensor 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class RectangularSensorStyleConver
   * @extends {BaseStyleConver}
   */
  class RectangularSensorStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal) {
      if (!this.rectangularSensorStyleConver) {
        this.rectangularSensorStyleConver = new RectangularSensorStyleConver();
      }
      this.rectangularSensorStyleConver.isEntity = true;
      return this.rectangularSensorStyleConver.toCesiumVal(style, czmVal)
    }

    _toCesiumValBefore(style, czmVal) {
      super._toCesiumValBefore(style, czmVal);

      // XX的特殊处理
    }

    _getExcludedStyle() {
      return ["lineOpacity", "scanPlaneOpacity"]
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      switch (key) {
        case "lineColor": {
          // 边框颜色
          let color = Cesium__namespace.Color.fromCssColorString(value || "#ffffff");
          if (Cesium__namespace.defined(style.lineOpacity)) {
            color = color.withAlpha(Number(style.lineOpacity));
          } else if (Cesium__namespace.defined(style.opacity)) {
            color = color.withAlpha(Number(style.opacity));
          }

          if (Cesium__namespace.defined(style.globalAlpha) && style.globalAlpha !== 1) {
            color = color.withAlpha(color.alpha * style.globalAlpha); // 动态调整图层或数据的透明度时使用
          }

          czmVal.lineColor = color;
          break
        }
        case "scanPlaneColor": {
          // 扫描面颜色
          let color = Cesium__namespace.Color.fromCssColorString(value || "#ffffff");
          if (Cesium__namespace.defined(style.scanPlaneOpacity)) {
            color = color.withAlpha(Number(style.scanPlaneOpacity));
          } else if (Cesium__namespace.defined(style.opacity)) {
            color = color.withAlpha(Number(style.opacity));
          }

          if (Cesium__namespace.defined(style.globalAlpha) && style.globalAlpha !== 1) {
            color = color.withAlpha(color.alpha * style.globalAlpha); // 动态调整图层或数据的透明度时使用
          }

          czmVal.scanPlaneColor = color;
          break
        }
        case "xHalfAngleDegree": // 传感器水平半角(度数)
          czmVal.xHalfAngle = Cesium__namespace.Math.toRadians(value);
          break
        case "yHalfAngleDegree": // 传感器垂直半角(度数)
          czmVal.yHalfAngle = Cesium__namespace.Math.toRadians(value);
          break
        case "depthTest":
          czmVal.showThroughEllipsoid = !value;
          break
        default:
          this._toOneCesiumVal_Poly(key, value, style, czmVal);
          break
      }
    }

    // 导出Cesium的样式对象到json可以保存的格式
    /**
     * 转换Ceium对象为json简单对象，用于导出
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style) {
      if (!this.rectangularSensorStyleConver) {
        this.rectangularSensorStyleConver = new RectangularSensorStyleConver();
      }
      this.rectangularSensorStyleConver.isEntity = true;
      return this.rectangularSensorStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }
  }

  /**
   * Wall 矢量数据style转换处理类
   * @param {Object} [options] 控制参数
   *
   * @export
   * @class WallStyleConver
   * @extends {BaseStyleConver}
   */
  class WallStyleConver extends BaseStyleConver {
    /**
     * 转换style到Cesium对象需要的格式
     *
     * @param {Object} style 样式配置
     * @param {Object} [czmVal={}] Cesium属性值
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} Cesium属性值
     */
    static toCesiumVal(style, czmVal, isEntity) {
      if (!this.wallStyleConver) {
        this.wallStyleConver = new WallStyleConver();
      }
      this.wallStyleConver.isEntity = isEntity;
      return this.wallStyleConver.toCesiumVal(style, czmVal)
    }

    _toOneCesiumVal(key, value, style, czmVal) {
      this._toOneCesiumVal_Poly(key, value, style, czmVal);
    }

    /**
     * 导出Cesium的样式对象到json可以保存的格式
     *
     * @param {Object} czmVal   Cesium属性值
     * @param {Object} [style={}] json简单对象
     * @param {Boolean} [isEntity] 是否为Entity对象
     * @return {Object} json简单对象
     */
    static toJSON(czmVal, style, isEntity) {
      if (!this.wallStyleConver) {
        this.wallStyleConver = new WallStyleConver();
      }
      this.wallStyleConver.isEntity = isEntity;
      return this.wallStyleConver.toJSON(czmVal, style)
    }

    _toOneJson(key, value, style) {
      this._toOneJson_Poly(key, value, style);
    }
  }

  var czm_cellular = "\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 _czm_permute289(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec2 czm_cellular(vec2 P) {\n  #define K 0.142857142857 // 1/7\n  #define Ko 0.428571428571 // 3/7\n  #define jitter 1.0 // Less gives more regular pattern\n  vec2 Pi = mod(floor(P), 289.0);\n  vec2 Pf = fract(P);\n  vec3 oi = vec3(-1.0, 0.0, 1.0);\n  vec3 of = vec3(-0.5, 0.5, 1.5);\n  vec3 px = _czm_permute289(Pi.x + oi);\n  vec3 p = _czm_permute289(px.x + Pi.y + oi); // p11, p12, p13\n  vec3 ox = fract(p * K) - Ko;\n  vec3 oy = mod(floor(p * K), 7.0) * K - Ko;\n  vec3 dx = Pf.x + 0.5 + jitter * ox;\n  vec3 dy = Pf.y - of + jitter * oy;\n  vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n  p = _czm_permute289(px.y + Pi.y + oi); // p21, p22, p23\n  ox = fract(p * K) - Ko;\n  oy = mod(floor(p * K), 7.0) * K - Ko;\n  dx = Pf.x - 0.5 + jitter * ox;\n  dy = Pf.y - of + jitter * oy;\n  vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n  p = _czm_permute289(px.z + Pi.y + oi); // p31, p32, p33\n  ox = fract(p * K) - Ko;\n  oy = mod(floor(p * K), 7.0) * K - Ko;\n  dx = Pf.x - 1.5 + jitter * ox;\n  dy = Pf.y - of + jitter * oy;\n  vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n  vec3 d1a = min(d1, d2);\n  d2 = max(d1, d2); // Swap to keep candidates for F2\n  d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n  d1 = min(d1a, d2); // F1 is now in d1\n  d2 = max(d1a, d2); // Swap to keep candidates for F2\n  d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n  d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n  d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n  d1.y = min(d1.y, d1.z); // nor in  d1.z\n  d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n  return sqrt(d1.xy);\n}\n"; // eslint-disable-line

  var czm_snoise = "/**\n * @license\n * Description : Array and textureless GLSL 2D/3D/4D simplex\n *               noise functions.\n *      Author : Ian McEwan, Ashima Arts.\n *  Maintainer : ijm\n *     Lastmod : 20110822 (ijm)\n *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n *               Distributed under the MIT License. See LICENSE file.\n *               https://github.com/ashima/webgl-noise\n */\n\nvec4 _czm_mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 _czm_mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 _czm_mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat _czm_mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 _czm_permute(vec4 x) {\n  return _czm_mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec3 _czm_permute(vec3 x) {\n  return _czm_mod289(((x * 34.0) + 1.0) * x);\n}\n\nfloat _czm_permute(float x) {\n  return _czm_mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 _czm_taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat _czm_taylorInvSqrt(float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 _czm_grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p, s;\n\n  p.xyz = floor(fract(vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.www;\n\n  return p;\n}\n\n/**\n * DOC_TBA\n *\n * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}\n *\n * @name czm_snoise\n * @glslFunction\n *\n * @see <a href=\"https://github.com/ashima/webgl-noise\">https://github.com/ashima/webgl-noise</a>\n * @see Stefan Gustavson's paper <a href=\"http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\">Simplex noise demystified</a>\n */\nfloat czm_snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n  0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n  -0.577350269189626,  // -1.0 + 2.0 * C.x\n  0.024390243902439); // 1.0 / 41.0\n    // First corner\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n  vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n    // Permutations\n  i = _czm_mod289(i); // Avoid truncation effects in permutation\n  vec3 p = _czm_permute(_czm_permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    // Compute final noise value at P\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat czm_snoise(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n    // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n  i = _czm_mod289(i);\n  vec4 p = _czm_permute(_czm_permute(_czm_permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n    //Normalise gradients\n  vec4 norm = _czm_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n    // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n\nfloat czm_snoise(vec4 v) {\n  const vec4 C = vec4(0.138196601125011,  // (5 - sqrt(5))/20  G4\n  0.276393202250021,  // 2 * G4\n  0.414589803375032,  // 3 * G4\n  -0.447213595499958); // -1 + 4 * G4\n\n    // (sqrt(5) - 1)/4 = F4, used once below\n    #define F4 0.309016994374947451\n\n    // First corner\n  vec4 i = floor(v + dot(v, vec4(F4)));\n  vec4 x0 = v - i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step(x0.yzw, x0.xxx);\n  vec3 isYZ = step(x0.zww, x0.yyz);\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp(i0, 0.0, 1.0);\n  vec4 i2 = clamp(i0 - 1.0, 0.0, 1.0);\n  vec4 i1 = clamp(i0 - 2.0, 0.0, 1.0);\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n  i = _czm_mod289(i);\n  float j0 = _czm_permute(_czm_permute(_czm_permute(_czm_permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = _czm_permute(_czm_permute(_czm_permute(_czm_permute(i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0);\n\n  vec4 p0 = _czm_grad4(j0, ip);\n  vec4 p1 = _czm_grad4(j1.x, ip);\n  vec4 p2 = _czm_grad4(j1.y, ip);\n  vec4 p3 = _czm_grad4(j1.z, ip);\n  vec4 p4 = _czm_grad4(j1.w, ip);\n\n    // Normalise gradients\n  vec4 norm = _czm_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= _czm_taylorInvSqrt(dot(p4, p4));\n\n    // Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * (dot(m0 * m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + dot(m1 * m1, vec2(dot(p3, x3), dot(p4, x4))));\n}\n"; // eslint-disable-line

  var LineFlowMaterial = "uniform float globalAlpha;\nuniform bool axisY;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = repeat * materialInput.st;\n\n  float currTime;\n  if(time < 0.0) {\n    currTime = speed * czm_frameNumber / 1000.0;\n  } else {\n    currTime = time;\n  }\n\n  vec4 colorImage = texture2D(image, vec2(fract((axisY ? st.t : st.s) - currTime), st.t));\n  if(color.a == 0.0) {\n    if(colorImage.rgb == vec3(1.0)) {\n      discard;\n    }\n  }\n\n  if(color.rgb == vec3(1.0)) {\n    material.alpha = colorImage.a * globalAlpha;\n    material.diffuse = colorImage.rgb;\n  } else {\n    material.alpha = colorImage.a * color.a * globalAlpha;\n    material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb);\n  }\n\n  if(hasImage2) {\n    vec4 colorBG = texture2D(image2, materialInput.st);\n    if(colorBG.a > 0.5) {\n      material.diffuse = color2.rgb;\n    }\n  }\n  return material;\n}\n"; // eslint-disable-line

  var LineFlowColorMaterial = "uniform vec4 color;\nuniform float speed;\nuniform float startTime;\nuniform float percent;\nuniform float alpha;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float t = fract(startTime + czm_frameNumber * speed / 1000.0);\n  t *= (1.0 + percent);\n  float alpha1 = smoothstep(t - percent, t, st.s) * step(-t, -st.s);\n  alpha1 += alpha;\n  material.diffuse = color.rgb;\n  material.alpha = alpha1 * globalAlpha;\n  return material;\n}\n"; // eslint-disable-line

  var ODLineMaterial = "uniform vec4 color;\nuniform vec4 bgColor;\nuniform float speed;\nuniform float startTime;\nuniform float bidirectional;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float t = fract(startTime + czm_frameNumber * speed / 1000.0);\n\n  t *= 1.03;\n  float alpha0 = smoothstep(t - 0.03, t, st.s) * step(st.s, t);\n  float mt = 1. - t;\n  float alpha1 = smoothstep(mt + 0.03, mt, st.s) * step(mt, st.s);\n\n  float a0 = step(abs(bidirectional - 0.0) - 0.001, 0.);\n  float a1 = step(abs(bidirectional - 1.0) - 0.001, 0.);\n  float db = step(abs(bidirectional - 2.0) - 0.001, 0.);\n  float alpha = alpha0 * (a0 + db) + alpha1 * (a1 + db);\n  alpha = clamp(alpha, 0., 1.);\n\n  material.diffuse = color.rgb * alpha + bgColor.rgb * (1. - alpha);\n  material.alpha = (color.a * alpha + bgColor.a * (1. - alpha)) * globalAlpha;\n\n    // if (useImageAndRepeat.x != 0.) {\n    //     float repeat = useImageAndRepeat.y;\n    //     vec4 marsImageColor = texture2D(image, fract(vec2(fract((st.s-t)*repeat), st.t)));\n    //     material.diffuse = marsImageColor.rgb;\n    //     material.alpha = marsImageColor.a;\n    // }\n\n  return material;\n}\n"; // eslint-disable-line

  var LineFlickerMaterial = "uniform vec4 color;\nuniform float speed;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  float time = fract(czm_frameNumber * speed / 1000.0);\n  vec2 st = materialInput.st;\n  float scalar = smoothstep(0.0, 1.0, time);\n  material.diffuse = color.rgb * scalar;\n  material.alpha = color.a * scalar * globalAlpha;\n  return material;\n}\n"; // eslint-disable-line

  var LineTrailMaterial = "uniform vec4 bgColor;\nuniform vec4 color;\nuniform float speed;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float time = fract(czm_frameNumber * speed / 1000.0);\n\n  vec3 fragColor = color.rgb;\n  if(st.t > 0.45 && st.t < 0.55) {\n    fragColor = vec3(1.0);\n  }\n  material.alpha = color.a * 1.5 * smoothstep(.0, 1., fract(st.s - time));\n  material.diffuse = max(fragColor.rgb * material.alpha, fragColor.rgb);\n\n  if(material.alpha < bgColor.a) {\n    material.alpha = bgColor.a;\n    material.diffuse = bgColor.rgb;\n  }\n  material.alpha = material.alpha * globalAlpha;\n\n  return material;\n}\n"; // eslint-disable-line

  var LineBloomMaterial = "uniform vec4 color;\nuniform float speed;\nuniform float glow;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  vec2 st = materialInput.st;\n  float t = fract(speed * czm_frameNumber / 1000.0);\n  t *= 1.03;\n\n  float alpha = smoothstep(t - 0.03, t, st.s) * step(-t, -st.s);\n  alpha += 0.1;\n\n  vec4 fragColor;\n  fragColor.rgb = (color.rgb) / 0.5;\n  fragColor = czm_gammaCorrect(fragColor);\n  material.diffuse = fragColor.rgb;\n  material.alpha = alpha * globalAlpha;\n  material.emission = fragColor.rgb * glow;\n  return material;\n}\n"; // eslint-disable-line

  var DigitalFlowMaterial = "uniform float globalAlpha;\n\nfloat plot(float st, float pct) {\n  return smoothstep(pct, pct, st) - smoothstep(pct, pct + 0.5, st);\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float time2 = czm_frameNumber / speed;\n  vec4 colorImage = texture2D(image, vec2(fract(st.s), fract(float(st.t * segment) - time2)));\n  float percent = distance(st.y, .5) / 0.9;\n  float distance = length(vec2(st.x, st.y));\n  float pf = plot(distance, fract(czm_frameNumber / 200.0) * 10.);\n  vec4 gradient = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(pf, pf, pf, 1.0), 0.8);\n  float alpha = (colorImage.a * (1.0 - percent));\n  vec3 diffuse = max(color.rgb * alpha * glow, color.rgb);\n\n  if(flowGlow == 1.0) {\n    vec4 rgba = mix(vec4(diffuse, alpha), gradient, pf);\n    material.diffuse = rgba.rgb;\n    material.alpha = rgba.a * globalAlpha;\n  } else {\n    material.diffuse = diffuse;\n    material.alpha = alpha * globalAlpha;\n  }\n  return material;\n}\n"; // eslint-disable-line

  var WallScrollMaterial = "uniform sampler2D image;\nuniform float speed;\nuniform vec4 color;\nuniform float count;\nuniform bool axisY;\nuniform bool reverse;\nuniform bool bloom;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float time = fract(czm_frameNumber * speed / 1000.0);\n\n  vec4 colorImage;\n  if(axisY) {\n    if(reverse)\n      colorImage = texture2D(image, vec2(fract(float(count) * st.s - time)));\n    else\n      colorImage = texture2D(image, vec2(fract(float(count) * st.s + time)));\n  } else {\n    if(reverse)\n      colorImage = texture2D(image, vec2(fract(float(count) * st.t - time)));\n    else\n      colorImage = texture2D(image, vec2(fract(float(count) * st.t + time)));\n  }\n\n  float perDis = 1.0 / count / 3.0;\n  material.alpha = colorImage.a * smoothstep(.2, 1., distance(st.t * perDis, 1. + perDis)) * globalAlpha;\n\n  if(bloom) {\n    //泛光\n    vec4 fragColor;\n    fragColor.rgb = (colorImage.rgb + color.rgb) / 1.0;\n    fragColor = czm_gammaCorrect(fragColor);\n\n    material.diffuse = colorImage.rgb;\n    material.emission = fragColor.rgb;\n  } else {\n    material.diffuse = max(color.rgb * material.alpha * 1.5, color.rgb);\n    material.emission = max(color.rgb * material.alpha * 1.5, color.rgb);\n  }\n  return material;\n}\n"; // eslint-disable-line

  var ScanLineMaterial = "uniform vec4 color;\nuniform float globalAlpha;\n\nfloat circle(vec2 uv, float r, float blur) {\n  float d = length(uv) * 2.0;\n  float c = smoothstep(r + blur, r, d);\n  return c;\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st - .5;\n  material.diffuse = color.rgb;\n  material.emission = vec3(0);\n\n  float t = fract(czm_frameNumber * speed / 1000.0);\n  float s = 0.3;\n  float radius1 = smoothstep(.0, s, t) * 0.9;\n  float alpha1 = circle(st, radius1, 0.01) * circle(st, radius1, -0.01);\n  float alpha2 = circle(st, radius1, 0.01 - radius1) * circle(st, radius1, 0.01);\n  float radius2 = 0.5 + smoothstep(s, 1.0, t) * 0.5;\n  float alpha3 = circle(st, radius1, radius2 + 0.01 - radius1) * circle(st, radius1, -0.01);\n\n  material.alpha = smoothstep(1.0, s, t) * (alpha1 + alpha2 * 0.1 + alpha3 * 0.1);\n  material.alpha *= color.a * globalAlpha;\n\n  return material;\n}\n"; // eslint-disable-line

  var CircleScanMaterial = "uniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  vec4 imgC = texture2D(image, st);\n  if(imgC.a > .0) {\n    material.diffuse = color.rgb;\n  }\n  material.alpha = imgC.a * color.a * globalAlpha;\n  return material;\n}\n"; // eslint-disable-line

  var CircleWaveMaterial = "uniform float globalAlpha;\nuniform vec4 color;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  material.diffuse = 1.5 * color.rgb;\n\n  vec2 st = materialInput.st;\n  float dis = distance(st, vec2(0.5, 0.5));\n  float currTime;\n  if(time < 0.0) {\n    currTime = speed * czm_frameNumber / 1000.0;\n  } else {\n    currTime = time;\n  }\n\n  float per = fract(currTime);\n  if(count == 1.0) {\n    if(dis > per * 0.5) {\n      discard;\n    } else {\n      material.alpha = color.a * dis / per / 2.0 * globalAlpha;\n    }\n  } else {\n    vec3 str = materialInput.str;\n    if(abs(str.z) > 0.001) {\n      discard;\n    }\n    if(dis > 0.5) {\n      discard;\n    } else {\n      float perDis = 0.5 / count;\n      float disNum;\n      float bl = 0.0;\n      for(int i = 0; i <= 999; i++) {\n        if(float(i) <= count) {\n          disNum = perDis * float(i) - dis + per / count;\n          if(disNum > 0.0) {\n            if(disNum < perDis) {\n              bl = 1.0 - disNum / perDis;\n            } else if(disNum - perDis < perDis) {\n              bl = 1.0 - abs(1.0 - disNum / perDis);\n            }\n            material.alpha = pow(bl, (1.0 + 10.0 * (1.0 - gradient))) * color.a * globalAlpha;\n          }\n        }\n      }\n    }\n  }\n  return material;\n}\n"; // eslint-disable-line

  var RadarLineMaterial = "uniform vec4 color;\nuniform float speed;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st * 2.0 - 1.0;\n  float t = czm_frameNumber * speed / 1000.0;\n  vec3 col = vec3(0.0);\n  vec2 p = vec2(sin(t), cos(t));\n  float d = length(st - dot(p, st) * p);\n  if(dot(st, p) < 0.) {\n    d = length(st);\n  }\n\n  col = .006 / d * color.rgb;\n\n  if(distance(st, vec2(0)) > 0.99) {\n    col = color.rgb;\n  }\n\n  material.alpha = pow(length(col), 2.0) * globalAlpha;\n  material.diffuse = col * 3.0;\n  return material;\n}\n"; // eslint-disable-line

  var RadarWaveMaterial = "uniform vec4 color;\nuniform float speed;\nuniform float globalAlpha;\n\n#define PI 3.14159265359\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  vec2 pos = st - vec2(0.5);\n  float time = czm_frameNumber * speed / 1000.0;\n  float r = length(pos);\n  float t = atan(pos.y, pos.x) - time * 2.5;\n  float a = (atan(sin(t), cos(t)) + PI) / (2.0 * PI);\n  float ta = 0.5;\n  float v = smoothstep(ta - 0.05, ta + 0.05, a) * smoothstep(ta + 0.05, ta - 0.05, a);\n  vec3 flagColor = color.rgb * v;\n  float blink = pow(sin(time * 1.5) * 0.5 + 0.5, 0.8);\n  flagColor = color.rgb * pow(a, 8.0 * (.2 + blink)) * (sin(r * 500.0) * .5 + .5);\n  flagColor = flagColor * pow(r, 0.4);\n  material.alpha = length(flagColor) * 1.3 * globalAlpha;\n  material.diffuse = flagColor * 3.0;\n  return material;\n}\n"; // eslint-disable-line

  var RectSlideMaterial = "uniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  vec4 colorImage = texture2D(image, vec2(fract(st.s + czm_frameNumber * speed / 1000.0), fract(st.t)));\n\n  material.alpha = colorImage.a * color.a * globalAlpha;\n  if(pure) {\n    material.diffuse = diffusePower * color.rgb;\n  } else {\n    material.diffuse = colorImage.rgb;\n  }\n  return material;\n}\n"; // eslint-disable-line

  var EllipsoidElectricMaterial = "precision highp float;\nprecision highp int;\n\n#define pi 3.1415926535\n#define PI2RAD 0.01745329252\n#define TWO_PI (2. * PI)\n\nuniform vec4 marscolor;\nuniform float speed;\nuniform float globalAlpha;\n\nfloat time;\nfloat rands(float p) {\n  return fract(sin(p) * 10000.0);\n}\nfloat noise(vec2 p) {\n  float t = time / 20000.0;\n  if(t > 1.0)\n    t -= floor(t);\n  return rands(p.x * 14. + p.y * sin(t) * 0.5);\n}\nvec2 sw(vec2 p) {\n  return vec2(floor(p.x), floor(p.y));\n}\nvec2 se(vec2 p) {\n  return vec2(ceil(p.x), floor(p.y));\n}\nvec2 nw(vec2 p) {\n  return vec2(floor(p.x), ceil(p.y));\n}\nvec2 ne(vec2 p) {\n  return vec2(ceil(p.x), ceil(p.y));\n}\nfloat smoothNoise(vec2 p) {\n  vec2 inter = smoothstep(0.0, 1.0, fract(p));\n  float s = mix(noise(sw(p)), noise(se(p)), inter.x);\n  float n = mix(noise(nw(p)), noise(ne(p)), inter.x);\n  return mix(s, n, inter.y);\n}\nfloat fbm(vec2 p) {\n  float z = 2.0;\n  float rz = 0.0;\n  vec2 bp = p;\n  for(float i = 1.0; i < 6.0; i++) {\n    rz += abs((smoothNoise(p) - 0.5) * 2.0) / z;\n    z *= 2.0;\n    p *= 2.0;\n  }\n  return rz;\n}\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 vUv = materialInput.st;\n  time = czm_frameNumber * speed / 100.0;\n\n  vec2 uv = vUv;\n  vec2 uv2 = vUv;\n  // if (uv.y < 0.5) {\n  //     discard;\n  // }\n  uv *= 4.;\n  float rz = fbm(uv);\n  uv /= exp(mod(time * 2.0, pi));\n  rz *= pow(15., 1.0);\n  vec4 marscolor = mix(vec4(color.rgb, 1.0) / rz, vec4(color.rgb, 0.1), 0.5);\n  if(uv2.x < 0.05) {\n    marscolor = mix(vec4(color.rgb, 0.1), marscolor, uv2.x / 0.05);\n  }\n  if(uv2.x > 0.95) {\n    marscolor = mix(marscolor, vec4(color.rgb, 0.1), (uv2.x - 0.95) / 0.05);\n  }\n\n  material.alpha = marscolor.a * 2.0 * globalAlpha;\n  material.diffuse = max(marscolor.rgb + marscolor.rgb * material.alpha, marscolor.rgb);\n\n  return material;\n}\n"; // eslint-disable-line

  var EllipsoidWaveMaterial = "uniform vec4 color;\nuniform float speed;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float time = fract(czm_frameNumber * speed / 1000.0);\n  float alpha = abs(smoothstep(0.5, 1., fract(-st.t - time)));\n  alpha += .1;\n  material.alpha = alpha * globalAlpha;\n  material.diffuse = color.rgb;\n  return material;\n}\n"; // eslint-disable-line

  var PolyGradientMaterial = "uniform vec4 color;\nuniform float diffusePower;\nuniform float alphaPower;\nuniform float globalAlpha;\nuniform vec2 center;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float alpha = distance(st, center);\n  material.alpha = color.a * alpha * alphaPower * globalAlpha;\n  material.diffuse = color.rgb * diffusePower;\n  return material;\n}\n"; // eslint-disable-line

  var AsphaltMaterial = "uniform vec4 color;\nuniform float size;\nuniform float frequency;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n  //Main cellular pattern\n  vec4 color = color;\n  vec2 st = materialInput.st;\n  vec2 F = czm_cellular(st / size);\n  color.rgb -= (F.x / F.y) * 0.1;\n\n  //Extra bumps for frequency\n  float noise = czm_snoise(st / size);\n  noise = pow(noise, 5.0) * frequency;\n  color.rgb += noise;\n\n  material.diffuse = color.rgb;\n  material.alpha = color.a * globalAlpha;\n\n  return material;\n}\n"; // eslint-disable-line

  var BlobMaterial = "uniform vec4 evenColor;\nuniform vec4 oddColor;\nuniform float frequency;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n  vec2 F = czm_cellular(materialInput.st * frequency);\n  float t = 1.0 - F.x * F.x;\n\n  vec4 color = mix(evenColor, oddColor, t);\n  material.diffuse = color.rgb;\n  material.alpha = color.a * globalAlpha;\n\n  return material;\n}\n"; // eslint-disable-line

  var FacetMaterial = "uniform vec4 evenColor;\nuniform vec4 oddColor;\nuniform float frequency;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights\n  vec2 F = czm_cellular(materialInput.st * frequency);\n  float t = 0.1 + (F.y - F.x);\n\n  vec4 color = mix(evenColor, oddColor, t);\n  material.diffuse = color.rgb;\n  material.alpha = color.a * globalAlpha;\n\n  return material;\n}\n"; // eslint-disable-line

  var PolyGrassMaterial = "uniform vec4 evenColor;\nuniform vec4 oddColor;\nuniform float frequency;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  vec2 st = materialInput.st;\n  float noise1 = (czm_snoise(st * frequency * 1.0)) * 1.0;\n  float noise2 = (czm_snoise(st * frequency * 2.0)) * 0.5;\n  float noise3 = (czm_snoise(st * frequency * 4.0)) * 0.25;\n  float noise = sin(noise1 + noise2 + noise3) * 0.1;\n\n  vec4 color = mix(evenColor, oddColor, noise);\n\n  //Make thatch patterns\n  float verticalNoise = czm_snoise(vec2(st.x * 100.0, st.y * 20.0)) * 0.02;\n  float horizontalNoise = czm_snoise(vec2(st.x * 20.0, st.y * 100.0)) * 0.02;\n  float stripeNoise = min(verticalNoise, horizontalNoise);\n\n  color.rgb += stripeNoise;\n\n  material.diffuse = color.rgb;\n  material.alpha = color.a * globalAlpha;\n\n  return material;\n}\n"; // eslint-disable-line

  var PolyWoodMaterial = "uniform vec4 evenColor;\nuniform vec4 oddColor;\nuniform float frequency;\nuniform vec2 noiseScale;\nuniform float grainFrequency;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  //Based on wood shader from OpenGL Shading Language (3rd edition) pg. 455\n  vec2 st = materialInput.st;\n\n  vec2 noisevec;\n  noisevec.x = czm_snoise(st * noiseScale.x);\n  noisevec.y = czm_snoise(st * noiseScale.y);\n\n  vec2 location = st + noisevec;\n  float dist = sqrt(location.x * location.x + location.y * location.y);\n  dist *= frequency;\n\n  float r = fract(dist + noisevec[0] + noisevec[1]) * 2.0;\n  if(r > 1.0)\n    r = 2.0 - r;\n\n  vec4 color = mix(evenColor, oddColor, r);\n\n  //streaks\n  r = abs(czm_snoise(vec2(st.x * grainFrequency, st.y * grainFrequency * 0.02))) * 0.2;\n  color.rgb += evenColor.rgb * r;\n\n  material.diffuse = color.rgb;\n  material.alpha = color.a * globalAlpha;\n\n  return material;\n}\n"; // eslint-disable-line

  var ImageMaterial = "uniform sampler2D image;\nuniform float opacity;\nuniform vec4 color;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  vec4 colorImage = texture2D(image, st);\n  if(colorImage.rgb == vec3(1.0)) {\n    discard;\n  }\n  material.alpha = colorImage.a * opacity * color.a * globalAlpha;\n  material.diffuse = colorImage.rgb * color.rgb;\n  return material;\n}\n"; // eslint-disable-line

  var WaterLightMaterial = "uniform float globalAlpha;\n\nfloat time = 0.0;\nmat2 m2 = mat2(0.80, 0.60, -0.60, 0.80);\n\nmat2 mars3d_makem(in float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat noise(in vec2 x) {\n  return texture2D(specularMap, x * .01).x;\n}\n\nfloat mars3d_fbm(in vec2 p) {\n  float z = 2.;\n  float rz = 0.;\n  for(float i = 1.; i < 7.; i++) {\n    rz += abs((noise(p) - 0.5) * 2.) / z;\n    z = z * 2.;\n    p = p * 2.;\n    p *= m2;\n  }\n  return rz;\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 vUv = materialInput.st;\n  time = czm_frameNumber / 200.0;\n  vec2 p = 2. * vUv.xy - vec2(1., 1.);\n  vec2 bp = p;\n\n  #ifndef CENTERED\n  p += 5.;\n  p *= 30.;\n  #endif\n  float rb = mars3d_fbm(p * .5 + time * .17) * .1;\n  rb = sqrt(rb);\n  #ifndef CENTERED\n  p *= mars3d_makem(rb * .2 + atan(p.y, p.x) * 1.);\n  #else\n  p *= mars3d_makem(rb * .2 + atan(p.y, p.x) * 2.);\n  #endif\n\n    //coloring\n  float rz = mars3d_fbm(p * .9 - time * .7);\n  rz *= dot(bp * 5., bp) + .5;\n  rz *= sin(p.x * .5 + time * 4.) * 1.5;\n  vec3 col = vec3(.04, 0.07, 0.45) / (.1 - rz);\n  vec4 fragColor = vec4(sqrt(abs(col)), 1.0);\n  material.alpha = fragColor.a * alpha * globalAlpha;\n  material.diffuse = fragColor.rgb * .5;\n\n    // cesium\n  float frequency = 2000.0;\n  float amplitude = 10.0;\n  float fadeFactor = 1.0;\n  vec4 mapColor = texture2D(normalMap, materialInput.st);\n  float specularMapValue = texture2D(normalMap, materialInput.st).r;\n  specularMapValue = 1.0;\n\n  float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\n  vec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\n  vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\n  normalTangentSpace.xy /= fade;\n  normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\n  normalTangentSpace = normalize(normalTangentSpace);\n\n  float mars3dPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 0.1)), 0.0, 1.0);\n  material.diffuse += (0.1 * mars3dPerturbationRatio);\n  material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\n  material.specular = 0.5;\n  material.shininess = 10.0;\n\n  return material;\n}\n"; // eslint-disable-line

  var NeonLightMaterial = "uniform float globalAlpha;\n\nfloat marsstepping(float t) {\n  if(t < 0.)\n    return -1. + pow(1. + t, 2.);\n  else\n    return 1. - pow(1. - t, 2.);\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 vUv = materialInput.st;\n  vec2 uv = 2. * vUv.xy - vec2(1., 1.);\n  ;\n  uv *= 2.0;\n  vec4 fragColor = vec4(0.);\n  uv = normalize(uv) * length(uv);\n\n  float time = czm_frameNumber / speed;\n  for(int i = 0; i < 12; i++) {\n    float t = time + float(i) * 3.141592 / 12. * (5. + 1. * marsstepping(sin(time * 3.)));\n    vec2 p = vec2(cos(t), sin(t));\n    p *= cos(time + float(i) * 3.141592 * cos(time / 8.));\n    vec3 col = cos(vec3(0, 1, -1) * 3.141592 * 2. / 3. + 3.141925 * (time / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    fragColor += vec4(0.05 / length(uv - p * 0.9) * col, 1.0);\n  }\n  fragColor.xyz = pow(fragColor.xyz, vec3(3.));\n  fragColor.w = 1.0;\n\n  vec4 baseColor = vec4(fragColor.rgb + color.rgb * 2.0, fragColor.r * 0.2);\n  material.alpha = baseColor.a * globalAlpha;\n  material.diffuse = baseColor.rgb;\n\n  return material;\n}\n"; // eslint-disable-line

  /// //////////////////////////////////////////////////////////////////////
  Cesium__namespace.ShaderSource._czmBuiltinsAndUniforms.czm_cellular = czm_cellular;
  Cesium__namespace.ShaderSource._czmBuiltinsAndUniforms.czm_snoise = czm_snoise;

  register$3(LineFlow, {
    fabric: {
      uniforms: {
        image: Cesium__namespace.Material.DefaultImageId,
        color: new Cesium__namespace.Color(1, 0, 0, 1.0),
        repeat: new Cesium__namespace.Cartesian2(1.0, 1.0),
        axisY: false,
        speed: 10.0,
        time: -1.0,
        hasImage2: false,
        image2: Cesium__namespace.Material.DefaultImageId,
        color2: new Cesium__namespace.Color(1, 1, 1),
        globalAlpha: 1.0
      },
      source: LineFlowMaterial
    },
    translucent: true
  });

  register$3(LineFlowColor, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(1.0, 0.0, 0.0, 0.7),
        startTime: 0,
        speed: 2,
        percent: 0.04,
        alpha: 0.1,
        globalAlpha: 1.0
      },
      source: LineFlowColorMaterial
    },
    translucent: true
  });

  register$3(ODLine, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(1.0, 1.0, 0.0, 0.7),
        startTime: 0,
        speed: 20,
        bgColor: new Cesium__namespace.Color(1.0, 1.0, 0.0, 0.1),
        bidirectional: 0, // 运行形式：0 正向运动 1 反向运动 2 双向运动
        globalAlpha: 1.0
      },
      source: ODLineMaterial
    },
    translucent: true
  });

  register$3(LineFlicker, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(1.0, 0.0, 0.0, 0.7),
        speed: 10,
        globalAlpha: 1.0
      },
      source: LineFlickerMaterial
    },
    translucent: true
  });

  register$3(LineTrail, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(1.0, 0.0, 0.0, 0.7),
        bgColor: new Cesium__namespace.Color(0.0, 0.0, 0.0, 0.0),
        speed: 5.0,
        globalAlpha: 1.0
      },
      source: LineTrailMaterial
    },
    translucent: true
  });

  register$3(LineBloom, {
    fabric: {
      uniforms: {
        color: Cesium__namespace.Color.ORANGE,
        glow: 1.0,
        speed: 5.0,
        globalAlpha: 1.0
      },
      source: LineBloomMaterial
    },
    translucent: true
  });


  register$3(DigitalFlow, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(0.0, 0.0, 0.0, 0.8),
        image: Cesium__namespace.Material.DefaultImageId,
        speed: 10.0,
        glow: 10.0,
        flowGlow: 1.0,
        segment: 3.0,
        globalAlpha: 1.0
      },
      source: DigitalFlowMaterial
    },
    translucent: true
  });


  register$3(WallScroll, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(1.0, 0.0, 0.0, 0.7),
        image: Cesium__namespace.Material.DefaultImageId,
        count: 1,
        speed: 5.0,
        reverse: false,
        axisY: false,
        bloom: false,
        globalAlpha: 1.0
      },
      source: WallScrollMaterial
    },
    translucent: true
  });

  register$3(ScanLine, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(1.0, 1.0, 0.0, 1.0),
        speed: 10,
        globalAlpha: 1.0
      },
      source: ScanLineMaterial
    },
    translucent: true
  });

  register$3(CircleScan, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(1.0, 0.0, 0.0, 1.0),
        image: Cesium__namespace.Material.DefaultImageId,
        globalAlpha: 1.0
      },
      source: CircleScanMaterial
    },
    translucent: true
  });

  register$3(CircleWave, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(1.0, 1.0, 0.0, 1.0),
        speed: 10.0,
        time: -1.0,
        count: 1.0,
        gradient: 0.1,
        globalAlpha: 1.0
      },
      source: CircleWaveMaterial
    },
    translucent: true
  });

  register$3(RadarLine, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(0.0, 1.0, 1.0, 0.7),
        speed: 5.0,
        globalAlpha: 1.0
      },
      source: RadarLineMaterial
    },
    translucent: true
  });

  register$3(RadarWave, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(0.0, 1.0, 1.0, 0.7),
        speed: 5.0,
        globalAlpha: 1.0
      },
      source: RadarWaveMaterial
    },
    translucent: true
  });



  register$3(RectSlide, {
    fabric: {
      uniforms: {
        image: Cesium__namespace.Material.DefaultImageId,
        color: Cesium__namespace.Color.WHITE,
        speed: 10.0,
        pure: false,
        diffusePower: 1.3, // 不公开
        globalAlpha: 1.0
      },
      source: RectSlideMaterial
    },
    translucent: true
  });

  register$3(EllipsoidElectric, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(0.0, 1.0, 1.0, 0.7),
        speed: 5.0,
        globalAlpha: 1.0
      },
      source: EllipsoidElectricMaterial
    },
    translucent: true
  });

  register$3(EllipsoidWave, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(0.0, 1.0, 1.0, 0.7),
        speed: 5.0,
        globalAlpha: 1.0
      },
      source: EllipsoidWaveMaterial
    },
    translucent: true
  });

  register$3(PolyGradient, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(1.0, 1.0, 0.0, 0.5),
        diffusePower: 1.6,
        alphaPower: 1.5,
        center: new Cesium__namespace.Cartesian2(0.5, 0.5),
        globalAlpha: 1.0
      },
      source: PolyGradientMaterial
    },
    translucent: true
  });

  register$3(PolyAsphalt, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(0.15, 0.15, 0.15, 1.0),
        size: 0.02,
        frequency: 0.2,
        globalAlpha: 1.0
      },
      source: AsphaltMaterial
    },
    translucent: function (material) {
      return material.uniforms.color.alpha < 1.0
    }
  });

  register$3(PolyBlob, {
    fabric: {
      uniforms: {
        evenColor: new Cesium__namespace.Color(1.0, 1.0, 1.0, 0.5),
        oddColor: new Cesium__namespace.Color(0.0, 0.0, 1.0, 0.5),
        frequency: 10.0,
        globalAlpha: 1.0
      },
      source: BlobMaterial
    },
    translucent: function (material) {
      const uniforms = material.uniforms;
      return uniforms.evenColor.alpha < 1.0 || uniforms.oddColor.alpha < 0.0
    }
  });

  register$3(PolyFacet, {
    fabric: {
      uniforms: {
        evenColor: new Cesium__namespace.Color(0.25, 0.25, 0.25, 0.75),
        oddColor: new Cesium__namespace.Color(0.75, 0.75, 0.75, 0.75),
        frequency: 10.0,
        globalAlpha: 1.0
      },
      source: FacetMaterial
    },
    translucent: function (material) {
      const uniforms = material.uniforms;
      return uniforms.evenColor.alpha < 1.0 || uniforms.oddColor.alpha < 0.0
    }
  });

  register$3(PolyGrass, {
    fabric: {
      uniforms: {
        evenColor: new Cesium__namespace.Color(0.25, 0.4, 0.1, 1.0),
        oddColor: new Cesium__namespace.Color(0.1, 0.1, 0.1, 1.0),
        frequency: 1.5,
        globalAlpha: 1.0
      },
      source: PolyGrassMaterial
    },
    translucent: function (material) {
      const uniforms = material.uniforms;
      return uniforms.evenColor.alpha < 1.0 || uniforms.oddColor.alpha < 1.0
    }
  });

  register$3(PolyWood, {
    fabric: {
      uniforms: {
        evenColor: new Cesium__namespace.Color(0.6, 0.3, 0.1, 1.0),
        oddColor: new Cesium__namespace.Color(0.4, 0.2, 0.07, 1.0),
        frequency: 3.0,
        noiseScale: new Cesium__namespace.Cartesian2(0.7, 0.5),
        grainFrequency: 27.0,
        globalAlpha: 1.0
      },
      source: PolyWoodMaterial
    },
    translucent: function (material) {
      const uniforms = material.uniforms;
      return uniforms.evenColor.alpha < 1.0 || uniforms.oddColor.alpha < 1.0
    }
  });

  register$3(Image2, {
    fabric: {
      uniforms: {
        image: Cesium__namespace.Material.DefaultImageId,
        color: Cesium__namespace.Color.WHITE,
        opacity: 1.0,
        globalAlpha: 1.0
      },
      source: ImageMaterial
    },
    translucent: true
  });

  register$3(WaterLight, {
    fabric: {
      uniforms: {
        alpha: 0.3,
        specularMap: Cesium__namespace.Material.DefaultImageId,
        normalMap: Cesium__namespace.buildModuleUrl("Assets/Textures/waterNormals.jpg"),
        globalAlpha: 1.0
      },
      source: WaterLightMaterial
    },
    translucent: true
  });

  register$3(NeonLight, {
    fabric: {
      uniforms: {
        color: Cesium__namespace.Color.WHITE,
        speed: 1.0,
        globalAlpha: 1.0
      },
      source: NeonLightMaterial
    },
    translucent: true
  });

  registerPropertyClass(Color$2, Cesium__namespace.ColorMaterialProperty);
  registerPropertyClass(Image$1, Cesium__namespace.ImageMaterialProperty);

  registerPropertyClass(PolylineArrow, Cesium__namespace.PolylineArrowMaterialProperty);
  registerPropertyClass(PolylineOutline, Cesium__namespace.PolylineOutlineMaterialProperty);
  registerPropertyClass(PolylineDash, Cesium__namespace.PolylineDashMaterialProperty);
  registerPropertyClass(PolylineGlow, Cesium__namespace.PolylineGlowMaterialProperty);

  registerPropertyClass(Grid, Cesium__namespace.GridMaterialProperty);
  registerPropertyClass(Checkerboard, Cesium__namespace.CheckerboardMaterialProperty);
  registerPropertyClass(Stripe, Cesium__namespace.StripeMaterialProperty);

  /**
   * 文字贴图 primitive材质
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.text] 文本内容
   *
   * @param {String} [options.font_family = "楷体"] 字体 ,可选项：微软雅黑,宋体,楷体,隶书,黑体,
   * @param {Number} [options.font_size = 30] 字体大小
   * @param {String} [options.font_weight = "normal"] 是否加粗 ,可选项：bold (解释：是),normal (解释：否),
   * @param {String} [options.font_style = "normal"] 是否斜体 ,可选项：italic (解释：是),normal (解释：否),
   * @param {string} [options.font='30px normal normal 楷体'] 上叙4个属性的一次性指定CSS字体的属性。
   *
   * @param {Boolean} [options.fill = true] 是否填充
   * @param {String} [options.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0)] 文本颜色
   *
   * @param {Boolean} [options.stroke=false] 是否描边文本。
   * @param {Cesium.Color} [options.strokeColor=new Cesium.Color(1.0, 1.0, 1.0, 0.8)] 描边的颜色。
   * @param {Number} [options.strokeWidth=2] 描边的宽度。
   *
   * @param {Boolean} [options.background=false] 是否背景色。
   * @param {Cesium.Color} [options.backgroundColor=new Cesium.Color(1.0, 1.0, 1.0, 0.1)] 画布的背景色。
   *
   * @param {Number} [options.outlineWidth] 边框的宽度。
   * @param {Cesium.Color} [options.outlineColor=color] 矩形边框的颜色。
   *
   * @param {Number} [options.padding=10] 要在文本周围添加的填充的像素大小。
   * @param {String} [options.textBaseline='top'] 文本的基线。
   *
   * @export
   * @class TextMaterial
   * @extends {Cesium.Material}
   * @example
  var primitive = new mars3d.graphic.WallPrimitive({
    positions: [
      [121.479343, 29.791419, 25],
      [121.479197, 29.791474, 25],
    ],
    style: {
      diffHeight: 5,
      material: new mars3d.material.TextMaterial({
        text: "火星科技",
        color: "#3388cc",
        outlineWidth: 4,
      }),
    },
  })
  graphicLayer.addGraphic(primitive)
   */
  class TextMaterial extends Cesium__namespace.Material {
    constructor(options = {}) {
      super(conventOptions$1(options));
    }
  }

  function conventOptions$1(options) {
    const _text = options.text;

    options.font_size = options.font_size || 70;
    const _textStyles = LabelStyleConver.toCesiumVal(options, {
      fill: true,
      fillColor: new Cesium__namespace.Color(1.0, 1.0, 0.0, 1.0),
      textBaseline: "middle",
      padding: 10
    });

    const canvas = getTextImage(_text, _textStyles);
    let image;
    if (canvas) {
      image = canvas.toDataURL("image/png");
    }
    return {
      fabric: {
        uniforms: {
          image: image,
          opacity: 1.0,
          color: Cesium__namespace.Color.WHITE,
          globalAlpha: 1.0
        },
        source: ImageMaterial
      },
      translucent: true
    }
  }

  registerClass(Text, TextMaterial);

  var CylinderWaveMaterialGlsl = "uniform vec4 color;\nuniform float repeat;\nuniform float offset;\nuniform float thickness;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  float sp = 1.0 / repeat;\n  vec2 st = materialInput.st;\n  float dis = distance(st, vec2(0.5));\n  float m = mod(dis + offset, sp);\n  float a = step(sp * (1.0 - thickness), m);\n  material.diffuse = color.rgb;\n  material.alpha = a * color.a * globalAlpha;\n  return material;\n}\n"; // eslint-disable-line

  /**
   * 圆锥 波纹扩散效果 材质
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|Cesium.Color} [options.color= new Cesium.Color(2, 1, 0.0, 0.8)] 颜色
   * @param {Number} [options.repeat=30] 圈数量
   * @param {Number} [options.thickness=0.3] 圈的宽度比例
   * @param {Number} [options.speed=10] 速度，值越大越快
   *
   *
   * @export
   * @class CylinderWaveMaterial
   * @extends {Cesium.Material}
   * @example
  var primitive = new mars3d.graphic.CylinderPrimitive({
    position: [116.328775, 30.954602, 5000],
    style: {
      topRadius: 0.0,
      bottomRadius: 1500.0,
      length: 10000.0,
      material: new mars3d.material.CylinderWaveMaterial({
        color: 'rgba(255,0,0,0.7)',
        repeat: 30.0,
      }),
      faceForward: false,
      closed: true,
    },
  })
  graphicLayer.addGraphic(primitive)
   */
  class CylinderWaveMaterial extends Cesium__namespace.Material {
    constructor(options = {}) {
      super(conventOptions(options));

      // 每秒刷新次数，因为requestAnimationFrame固定每秒60次的渲染，所以如果不想这么快，就把该数值调小一些
      this._frameTime = 1000 / (options.frameRate || 60);
      this._speed = options.speed ?? 10;

      // 动态修改雷达材质中的offset变量，从而实现动态效果。
      const that = this;
      let then = Date.now()
      ;(function frame() {
        that.animateFrame = window.requestAnimationFrame(frame);
        const now = Date.now();
        const delta = now - then;
        if (delta > that._frameTime) {
          then = now - (delta % that._frameTime);
          that.updateOffset(); // 按帧率执行
        }
      })();
    }

    // 动态修改雷达材质中的offset变量，从而实现动态效果。
    updateOffset() {
      let offset = this.uniforms.offset;
      offset -= 0.0001 * this._speed;
      if (offset > 1.0) {
        offset = 0.0;
      }
      this.uniforms.offset = offset;
    }

    destroy(noDel) {
      window.cancelAnimationFrame(this.animateFrame);
      delete this.animateFrame;

      return super.destroy(noDel)
    }
  }

  function conventOptions(options) {
    return {
      fabric: {
        uniforms: {
          color: getCesiumColor(options.color, new Cesium__namespace.Color(2, 1, 0.0, 0.8)),
          repeat: options.repeat ?? 30.0,
          thickness: options.thickness ?? 0.3,
          offset: options.offset ?? 0.0,
          globalAlpha: 1.0
        },
        source: CylinderWaveMaterialGlsl
      },
      translucent: function (material) {
        return material.uniforms.color.alpha < 1.0
      }
    }
  }
  registerClass(CylinderWave, CylinderWaveMaterial);

  /**
   * 材质属性(Entity使用) 基础类
   *
   * @param {Object} options 参数对象
   *
   * @export
   * @class BaseMaterialProperty
   */
  class BaseMaterialProperty {
    constructor(options = {}) {
      this.options = options;
      this._definitionChanged = new Cesium__namespace.Event();
    }

    get isConstant() {
      return true
    }

    get definitionChanged() {
      return this._definitionChanged
    }

    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return null
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result = {}) {
      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return this === other
    }
  }

  /**
   * 圆形扫描效果 材质属性
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} options.image 背景图片URL
   * @param {String|Cesium.Color} [options.color= new Cesium.Color(1, 0, 0, 0.5))] 颜色
   *
   * @export
   * @class CircleScanMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class CircleScanMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 背景图片URL
       * @type {String}
       */
      this.image = options.image ?? options.url;

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = options.color;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return CircleScan
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = getCesiumColor(this.color, new Cesium__namespace.Color(1, 0, 0, 0.5), time);
      result.image = this.image;
      result.globalAlpha = this.globalAlpha;
      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other || (other instanceof CircleScanMaterialProperty && Cesium__namespace.Property.equals(this.color, other.color) && this.image === other.image)
      )
    }
  }

  registerPropertyClass(CircleScan, CircleScanMaterialProperty);

  /**
   *
   * 圆形扩散波纹效果 材质属性
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|Cesium.Color} [options.color= Cesium.Color.YELLOW] 颜色
   * @param {Number} [options.speed=10] 速度
   * @param {Number} [options.duration] 播放总时长，单位：秒 （会覆盖speed参数）
   * @param {Number} [options.count=1] 圆圈个数
   * @param {Number} [options.gradient=0.1] 透明度的幂方（0-1）,0表示无虚化效果，1表示虚化成均匀渐变
   *
   * @export
   * @class CircleWaveMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class CircleWaveMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = options.color;

      /**
       * 速度
       * @type { Number}
       */
      this.speed = options.speed ?? 10;

      /**
       * 播放总时长，单位：秒 （会覆盖speed参数）
       * @type { Number}
       */
      this.duration = options.duration;

      /**
       * 圆圈个数
       * @type { Number}
       */
      this.count = options.count ?? 1;

      /**
       * 透明度的幂方（0-1）,0表示无虚化效果，1表示虚化成均匀渐变
       * @type {Number}
       */
      this.gradient = options.gradient ?? 0.1;


      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度

      // 属性容错
      if (this.count <= 0) {
        this.count = 1;
      }
      if (this.gradient < 0) {
        this.gradient = 0;
      }
      if (this.gradient > 1) {
        this.gradient = 1;
      }
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return CircleWave
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = getCesiumColor(this.color, Cesium__namespace.Color.YELLOW, time);
      result.count = this.count;
      result.gradient = this.gradient;
      result.speed = this.speed;
      result.globalAlpha = this.globalAlpha;

      if (this.duration) {
        if (this._time === undefined) {
          this._time = new Date().getTime();
        }
        result.time = (new Date().getTime() - this._time) / (this.duration * 1000);
      } else {
        result.time = -1.0;
      }
      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof CircleWaveMaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          this.count === other.count &&
          this.speed === other.speed &&
          this.gradient === other.gradient)
      )
    }
  }

  registerPropertyClass(CircleWave, CircleWaveMaterialProperty);

  // 绑定到Cesium中
  register$3(CylinderWave, {
    fabric: {
      uniforms: {
        color: new Cesium__namespace.Color(2, 1, 0.0, 0.8),
        repeat: 30,
        thickness: 0.3,
        offset: 0.0,
        globalAlpha: 1.0
      },
      source: CylinderWaveMaterialGlsl
    },
    translucent: true
  });

  /**
   *
   *  圆锥 波纹扩散效果 材质属性
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|Cesium.Color} [options.color= new Cesium.Color(2, 1, 0.0, 0.8)] 颜色
   * @param {Number} [options.repeat=30] 圈数量
   * @param {Number} [options.thickness=0.3] 圈的宽度比例
   * @param {Number} [options.speed=10] 速度，值越大越快
   *
   * @export
   * @class CylinderWaveMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class CylinderWaveMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = options.color;

      /**
       * 圈数量
       * @type { Number}
       */
      this.repeat = options.repeat ?? 30;

      /**
       *  圈的宽度比例
       * @type { Number}
       */
      this.thickness = options.thickness ?? 0.3;

      /**
       * 速度，值越大越快
       * @type { Number}
       */
      this.speed = options.speed ?? 10;


      this.offset = 0;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return CylinderWave
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }

      this.offset -= 0.0001 * this.speed;
      if (this.offset > 1.0) {
        this.offset = 0.0;
      }

      result.color = getCesiumColor(this.color, new Cesium__namespace.Color(2, 1, 0.0, 0.8), time);
      result.repeat = this.repeat;
      result.offset = this.offset;
      result.thickness = this.thickness;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof CylinderWaveMaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          this.repeat === other.repeat &&
          this.thickness === other.thickness)
      )
    }
  }

  registerPropertyClass(CylinderWave, CylinderWaveMaterialProperty);

  /**
   *
   * 线状: 数字流动线 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.color=Cesium.Color.ORANGE] 颜色
   * @param {Number} [options.speed=5.0] 速度，值越大越快
   * @param {Number} [options.glow=1.0] 高亮强度
   * @param {Number} [options.flowGlow=1.0] 流动高亮强度
   * @param {Number} [options.segment=3.0] 分段数
   *
   * @export
   * @class DigitalFlowMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class DigitalFlowMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type {Cesium.Color}
       */
      this.color = getCesiumColor(options.color, new Cesium__namespace.Color(0, 0, 0, 0));

      /**
       * 速度，值越大越快
       * @type {Number}
       */
      this.speed = options.speed ?? 5.0;

      /**
       * 高亮强度
       * @type {Number}
       */
      this.glow = options.glow ?? 1.0;

      /**
       * 流动高亮强度
       * @type {Number}
       */
      this.flowGlow = options.flowGlow ?? 1.0;

      /**
       * 分段数
       * @type {Number}
       */
      this.segment = options.segment ?? 3.0;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return DigitalFlow
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = this.color;
      result.speed = this.speed;
      result.glow = this.glow;
      result.flowGlow = this.flowGlow;
      result.segment = this.segment;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof DigitalFlowMaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          this.glow === other.glow &&
          this.speed === other.speed)
      )
    }
  }

  registerPropertyClass(DigitalFlow, DigitalFlowMaterialProperty);

  /**
   *
   * 球体: 电弧球体效果  材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
   * @param {Number} [options.speed=5.0] 速度，值越大越快
   *
   * @export
   * @class EllipsoidElectricMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class EllipsoidElectricMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, new Cesium__namespace.Color(0, 0, 0, 0));

      /**
       *  速度，值越大越快
       * @type { Number}
       */
      this.speed = options.speed ?? 5.0;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return EllipsoidElectric
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = this.color;
      result.speed = this.speed;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof EllipsoidElectricMaterialProperty && Cesium__namespace.Property.equals(this.color, other.color) && this.speed === other.speed)
      )
    }
  }

  registerPropertyClass(EllipsoidElectric, EllipsoidElectricMaterialProperty);

  /**
   *
   * 球体: 波纹球体效果  材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
   * @param {Number} [options.speed=5.0] 速度，值越大越快
   *
   * @export
   * @class EllipsoidWaveMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class EllipsoidWaveMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, new Cesium__namespace.Color(0, 0, 0, 0));
      /**
       * 速度
       * @type {Number}
       */
      this.speed = options.speed ?? 5.0;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return EllipsoidWave
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = this.color;
      result.speed = this.speed;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof EllipsoidWaveMaterialProperty && Cesium__namespace.Property.equals(this.color, other.color) && this.speed === other.speed)
      )
    }
  }

  registerPropertyClass(EllipsoidWave, EllipsoidWaveMaterialProperty);

  /**
   * 通用：图片 材质2  材质属性,  没有加载完成前的白色闪烁，但也不支持纯白色的图片
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} options.image 背景图片URL
   * @param {Number} [options.opacity= 1] 透明度
   * @param {String|Cesium.Color} [options.color= Cesium.Color.WHITE] 颜色
   *
   * @export
   * @class Image2MaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class Image2MaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 背景图片URL
       * @type {String}
       */
      this.image = options.image; // 背景图片

      /**
       * 透明度，0-1
       * @type {Number}
       */
      this.opacity = options.opacity ?? 1.0;

      /**
       * 颜色
       * @type {Cesium.Color}
       */
      this.color = options.color ?? Cesium__namespace.Color.WHITE;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return Image2
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.image = this.image;
      result.color = this.color;
      result.opacity = this.opacity;
      result.globalAlpha = this.globalAlpha;
      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof Image2MaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          this.opacity === other.opacity &&
          this.image === other.image)
      )
    }
  }

  registerPropertyClass(Image2, Image2MaterialProperty);

  /**
   *
   * 线状: 泛光线 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.color=Cesium.Color.ORANGE] 颜色
   * @param {Number} [options.glow=1.0] 泛光强度
   * @param {Number} [options.speed=5.0] 速度，值越大越快
   *
   * @export
   * @class LineBloomMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class LineBloomMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, new Cesium__namespace.Color(0, 0, 0, 0));
      /**
       * 速度，值越大越快
       * @type {Number}
       */
      this.speed = options.speed ?? 5.0;
      /**
       * 泛光强度
       * @type {Number}
       */
      this.glow = options.glow ?? 1.0;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return LineBloom
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = this.color;
      result.speed = this.speed;
      result.glow = this.glow;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof LineBloomMaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          this.glow === other.glow &&
          this.speed === other.speed)
      )
    }
  }


  registerPropertyClass(LineBloom, LineBloomMaterialProperty);

  /**
   *
   * 线状: 闪烁线 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
   * @param {Number} [options.speed=2] 速度，值越大越快
   *
   * @export
   * @class LineFlickerMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class LineFlickerMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 背景图片颜色
       * @type { Cesium.Color}
       */
      this.color = options.color;
      /**
       * 速度，值越大越快
       * @type {Number}
       */
      this.speed = options.speed ?? 2;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return LineFlicker
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = getCesiumColor(this.color, new Cesium__namespace.Color(0, 0, 0, 0), time);
      result.speed = this.speed;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof LineFlickerMaterialProperty && Cesium__namespace.Property.equals(this.color, other.color) && this.speed === other.speed)
      )
    }
  }


  registerPropertyClass(LineFlicker, LineFlickerMaterialProperty);

  /**
   *
   * 线状 流动效果 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
   * @param {Number} [options.speed=2] 速度，值越大越快
   * @param {Number} [options.percent=0.04] 比例
   * @param {Number} [options.alpha=0.1] 透明程度 0.0-1.0
   * @param {Number} [options.startTime=0] 开始的时间系数
   *
   * @export
   * @class LineFlowColorMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class LineFlowColorMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = options.color;
      /**
       * 速度，值越大越快
       * @type {Number}
       */
      this.speed = options.speed ?? 2;
      /**
       * 比例
       * @type {Number}
       */
      this.percent = options.percent ?? 0.04;
      /**
       * 透明程度 0.0-1.0
       * @type {Number}
       */
      this.alpha = options.alpha ?? 0.1;
      /**
       * 开始的时间系数
       * @type {Number}
       */
      this.startTime = options.startTime ?? 0;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return LineFlowColor
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = getCesiumColor(this.color, new Cesium__namespace.Color(1, 0, 0, 1.0), time);
      result.speed = this.speed;
      result.percent = this.percent;
      result.alpha = this.alpha;
      result.startTime = this.startTime;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof LineFlowColorMaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          this.speed === other.speed &&
          this.percent === other.percent &&
          this.startTime === other.startTime &&
          this.alpha === other.alpha)
      )
    }
  }

  registerPropertyClass(LineFlowColor, LineFlowColorMaterialProperty);

  /**
   *
   * 线状 流动效果 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String}  options.image 背景图片URL
   * @param {String|Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 背景图片颜色
   * @param {Cesium.Cartesian2} [options.repeat=new Cesium.Cartesian2(1.0, 1.0)] 横纵方向重复次数
   * @param {Boolean} [options.axisY=false] 是否Y轴朝上
   * @param {Number} [options.speed=10] 速度
   * @param {Number} [options.duration] 播放总时长，单位：秒 （会覆盖speed参数）
   * @param {Boolean} [options.hasImage2=false] 是否有2张图片的混合模式
   * @param {String} [options.image2] 第2张背景图片URL地址
   * @param {String|Cesium.Color} [options.color2=new Cesium.Color(1, 1, 1)] 第2张背景图片颜色
   *
   * @export
   * @class LineFlowMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class LineFlowMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 背景图片URL
       * @type {String}
       */
      this.image = options.image ?? options.url;

      /**
       * 背景图片颜色
       * @type { Cesium.Color}
       */
      this.color = options.color ?? new Cesium__namespace.Color(0, 0, 0, 0);
      /**
       * 是否Y轴朝上
       * @type {Boolean}
       */
      this.axisY = options.axisY ?? false;
      /**
       * 速度
       * @type {Number}
       */
      this.speed = options.speed ?? 10;
      /**
       * 播放总时长，单位：秒 （会覆盖speed参数）
       * @type {Number}
       */
      this.duration = options.duration;
      /**
       * 横纵方向重复次数
       * @type {Cesium.Cartesian2}
       */
      this.repeat = options.repeat ?? new Cesium__namespace.Cartesian2(1.0, 1.0);
      /**
       * 第2张背景图片
       * @type {String}
       */
      this.image2 = options.image2 ?? options.bgUrl;
      /**
       * 第2张背景图片颜色
       * @type {Cesium.Color}
       */
      this.color2 = options.color2 ?? options.bgColor ?? new Cesium__namespace.Color(1, 1, 1);
      /**
       * 是否有2张图片的混合模式
       * @type {Boolean}
       */
      this.hasImage2 = Cesium__namespace.defined(this.image2);

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return LineFlow
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.image = this.image;
      result.color = getCesiumColor(this.color, new Cesium__namespace.Color(0, 0, 0, 0), time);
      result.repeat = getCesiumValue(this.repeat, Cesium__namespace.Cartesian2, time);
      result.axisY = this.axisY;
      result.speed = getCesiumValue(this.speed, Number, time);

      if (this.duration) {
        if (this._time === undefined) {
          this._time = new Date().getTime();
        }
        result.time = (new Date().getTime() - this._time) / (this.duration * 1000);
      } else {
        result.time = -1.0;
      }

      result.hasImage2 = this.hasImage2;
      result.image2 = this.image2;
      result.color2 = getCesiumColor(this.color2, new Cesium__namespace.Color(1, 1, 1), time);
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof LineFlowMaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          Cesium__namespace.Property.equals(this.repeat, other.repeat) &&
          this.image === other.image &&
          this.axisY === other.axisY &&
          this.speed === other.speed &&
          this.hasImage2 === other.hasImage2 &&
          this.image2 === other.image2 &&
          Cesium__namespace.Property.equals(this.color2, other.color2))
      )
    }
  }


  registerPropertyClass(LineFlow, LineFlowMaterialProperty);

  /**
   *
   * 线状: 轨迹线 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
   * @param {String|Cesium.Color} [options.bgColor] 背景颜色
   * @param {Number} [options.speed=5.0] 速度，值越大越快
   *
   * @export
   * @class LineTrailMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class LineTrailMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, new Cesium__namespace.Color(0, 0, 0, 0));
      /**
       * 背景颜色
       * @type { Cesium.Color}
       */
      this.bgColor = getCesiumColor(options.bgColor, this.color.withAlpha(0.1));
      /**
       * 速度，值越大越快
       * @type {Number}
       */
      this.speed = options.speed ?? 2;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return LineTrail
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = this.color;
      result.bgColor = this.bgColor;
      result.speed = this.speed;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof LineTrailMaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          Cesium__namespace.Property.equals(this.bgColor, other.bgColor) &&
          this.speed === other.speed)
      )
    }
  }

  registerPropertyClass(LineTrail, LineTrailMaterialProperty);

  /**
   * 面状: 霓虹灯材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|Cesium.Color} [options.color="#9b08fd"] 颜色
   * @param {Number} [options.speed=2] 速度，值越大越快
   *
   * @export
   * @class NeonLightMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class NeonLightMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, Cesium__namespace.Color.fromCssColorString("#9b08fd"));
      /**
       * 速度
       * @type {Number}
       */
      this.speed = options.speed ?? 2;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return NeonLight
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = this.color;
      result.speed = this.speed;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof NeonLightMaterialProperty && Cesium__namespace.Property.equals(this.color, other.color) && this.speed === other.speed)
      )
    }
  }


  registerPropertyClass(NeonLight, NeonLightMaterialProperty);

  /**
   * 线状 OD线效果 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|Cesium.Color} [options.color=随机色] 运动对象的颜色
   * @param {String|Cesium.Color} [options.bgColor] 线的背景颜色
   * @param {Number} [options.speed=20 + 10 * Math.random()] 速度
   * @param {Number} [options.startTime=Math.random] 开始的时间系数
   * @param {Number} [options.bidirectional=0]  运行形式：0 正向运动 1 反向运动 2 双向运动
   *
   * @export
   * @class ODLineMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class ODLineMaterialProperty extends BaseMaterialProperty {
    constructor(options = {}) {
      super(options);

      /**
       * 运动对象的颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, new Cesium__namespace.Color(Math.random() * 0.5 + 0.5, Math.random() * 0.8 + 0.2, 0.0, 1.0));

      /**
       * 线的背景颜色
       * @type { Cesium.Color}
       */
      this.bgColor = getCesiumColor(options.bgColor, this.color.withAlpha(0.1));

      /**
       * 速度
       * @type {Number}
       */
      this.speed = options.speed ?? 20 + 10 * Math.random();
      /**
       * 开始的时间系数
       * @type {Number}
       */
      this.startTime = options.startTime ?? Math.random();
      /**
       * 运行形式：0 正向运动 1 反向运动 2 双向运动
       * @type {Number}
       */
      this.bidirectional = options.bidirectional ?? 0;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return ODLine
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!result) {
        result = {};
      }
      result.color = this.color;
      result.speed = this.speed;
      result.startTime = this.startTime;
      result.bgColor = this.bgColor;
      result.bidirectional = this.bidirectional;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof ODLineMaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          Cesium__namespace.Property.equals(this.bgColor, other.bgColor) &&
          this.speed === other.speed &&
          this.startTime === other.startTime &&
          this.bidirectional === other.bidirectional)
      )
    }
  }

  registerPropertyClass(ODLine, ODLineMaterialProperty);

  /**
   *
   * 面状： 柏油路面效果 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.color=Cesium.Color.ORANGE] 颜色
   * @param {Number} [options.size=0.02] 块大小
   * @param {Number} [options.frequency=0.2] 粗糙度
   *
   * @export
   * @class PolyAsphaltMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class PolyAsphaltMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, new Cesium__namespace.Color(0, 0, 0, 0));

      /**
       * 块大小
       * @type {Number}
       */
      this.size = options.size ?? 0.02;
      /**
       * 粗糙度
       * @type {Number}
       */
      this.frequency = options.frequency ?? 0.2;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return PolyAsphalt
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = this.color;
      result.size = this.size;
      result.frequency = this.frequency;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof PolyAsphaltMaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          this.frequency === other.frequency &&
          this.size === other.size)
      )
    }
  }

  registerPropertyClass(PolyAsphalt, PolyAsphaltMaterialProperty);

  /**
   *
   * 面状：混合 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.evenColor=new Cesium.Color(1.0, 1.0, 1.0, 0.5)] 浅色的颜色
   * @param {Cesium.Color} [options.oddColor= new Cesium.Color(0.0, 0.0, 1.0, 0.5)] 深色的颜色
   * @param {Number} [options.frequency=10.0] 频率
   *
   * @export
   * @class PolyBlobMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class PolyBlobMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 浅色的颜色
       * @type { Cesium.Color}
       */
      this.evenColor = getCesiumColor(options.evenColor, new Cesium__namespace.Color(1.0, 1.0, 1.0, 0.5));

      /**
       * 深色的颜色
       * @type { Cesium.Color}
       */
      this.oddColor = getCesiumColor(options.evenColor, new Cesium__namespace.Color(0.0, 0.0, 1.0, 0.5));

      /**
       * 频率
       * @type {Number}
       */
      this.frequency = options.frequency ?? 10.0;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return PolyBlob
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }

      result.evenColor = this.evenColor;
      result.evenColor = this.oddColor;
      result.frequency = this.frequency;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof PolyBlobMaterialProperty &&
          Cesium__namespace.Property.equals(this.evenColor, other.evenColor) &&
          Cesium__namespace.Property.equals(this.oddColor, other.oddColor) &&
          this.frequency === other.frequency)
      )
    }
  }

  registerPropertyClass(PolyBlob, PolyBlobMaterialProperty);

  /**
   *
   * 面状：碎石面 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.evenColor=new Cesium.Color(1.0, 1.0, 1.0, 0.5)] 浅色的颜色
   * @param {Cesium.Color} [options.oddColor= new Cesium.Color(0.0, 0.0, 1.0, 0.5)] 深色的颜色
   * @param {Number} [options.frequency=10.0] 频率
   *
   * @export
   * @class PolyFacetMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class PolyFacetMaterialProperty extends PolyBlobMaterialProperty {
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return PolyFacet
    }
  }

  registerPropertyClass(PolyFacet, PolyFacetMaterialProperty);

  /**
   *
   * 面状： 渐变面 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|Cesium.Color} [options.color=new Cesium.Color(1.0, 1.0, 0.0, 0.5)] 颜色
   * @param {Number} [options.alphaPower=1.5] 透明度系数
   * @param {Number} [options.diffusePower=1.6] 漫射系数
   * @param {Cesium.Cartesian2} [options.center=new Cesium.Cartesian2(0.5, 0.5)] 渐变位置，默认在中心
   *
   * @export
   * @class PolyGradientMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class PolyGradientMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, new Cesium__namespace.Color(1.0, 1.0, 0.0, 0.5));

      /**
       * 漫射系数
       * @type {Number}
       */
      this.diffusePower = options.diffusePower ?? 1.6;

      /**
       * 透明度系数
       * @type {Number}
       */
      this.alphaPower = options.alphaPower ?? 1.5;

      /**
       * 渐变位置，默认在中心
       * @type {Cesium.Cartesian2}
       */
      this.center = options.center ?? new Cesium__namespace.Cartesian2(0.5, 0.5);

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return PolyGradient
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = this.color;
      result.diffusePower = this.diffusePower;
      result.alphaPower = this.alphaPower;
      result.center = this.center;

      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof PolyGradientMaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          this.diffusePower === other.diffusePower)
      )
    }
  }


  registerPropertyClass(PolyGradient, PolyGradientMaterialProperty);

  /**
   *
   * 面状：草地面 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.evenColor=new Cesium.Color(1.0, 1.0, 1.0, 0.5)] 浅色的颜色
   * @param {Cesium.Color} [options.oddColor= new Cesium.Color(0.0, 0.0, 1.0, 0.5)] 深色的颜色
   * @param {Number} [options.frequency=10.0] 频率
   *
   * @export
   * @class PolyGrassMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class PolyGrassMaterialProperty extends PolyBlobMaterialProperty {
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return PolyGrass
    }
  }

  registerPropertyClass(PolyGrass, PolyGrassMaterialProperty);

  /**
   *
   * 面状：混合 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.evenColor=new Cesium.Color(1.0, 1.0, 1.0, 0.5)] 浅色的颜色
   * @param {Cesium.Color} [options.oddColor= new Cesium.Color(0.0, 0.0, 1.0, 0.5)] 深色的颜色
   * @param {Number} [options.frequency=3.0] 环频率
   * @param {Cesium.Cartesian2} [options.noiseScale= new Cesium.Cartesian2(0.7, 0.5)] 噪波比例
   * @param {Number} [options.grainFrequency=27.0] 颗粒的频率
   *
   * @export
   * @class PolyWoodMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class PolyWoodMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);
      /**
       * 浅色的颜色
       * @type { Cesium.Color}
       */
      this.evenColor = getCesiumColor(options.evenColor, new Cesium__namespace.Color(1.0, 1.0, 1.0, 0.5));
      /**
       * 深色的颜色
       * @type { Cesium.Color}
       */
      this.oddColor = getCesiumColor(options.evenColor, new Cesium__namespace.Color(0.0, 0.0, 1.0, 0.5));
      /**
       * 环频率
       * @type {Number}
       */
      this.frequency = options.frequency ?? 10.0;
      /**
       * 噪波比例
       * @type {Cesium.Cartesian2}
       */
      this.noiseScale = options.noiseScale ?? new Cesium__namespace.Cartesian2(0.7, 0.5);
      /**
       * 颗粒的频率
       * @type {Number}
       */
      this.grainFrequency = options.grainFrequency ?? 27.0;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return PolyWood
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }

      result.evenColor = this.evenColor;
      result.evenColor = this.oddColor;
      result.frequency = this.frequency;
      result.noiseScale = this.noiseScale;
      result.grainFrequency = this.grainFrequency;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof PolyWoodMaterialProperty &&
          Cesium__namespace.Property.equals(this.evenColor, other.evenColor) &&
          Cesium__namespace.Property.equals(this.oddColor, other.oddColor) &&
          this.frequency === other.frequency)
      )
    }
  }

  registerPropertyClass(PolyWood, PolyWoodMaterialProperty);

  /**
   *
   * 圆形: 雷达线(圆+旋转半径线) 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
   * @param {Number} [options.speed=5.0] 速度，值越大越快
   *
   * @export
   * @class RadarLineMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class RadarLineMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, new Cesium__namespace.Color(0, 0, 0, 0));
      /**
       * 速度
       * @type {Number}
       */
      this.speed = options.speed ?? 5.0;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return RadarLine
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = this.color;
      result.speed = this.speed;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof RadarLineMaterialProperty && Cesium__namespace.Property.equals(this.color, other.color) && this.speed === other.speed)
      )
    }
  }

  registerPropertyClass(RadarLine, RadarLineMaterialProperty);

  /**
   *
   * 圆形: 雷达线(圆+旋转半径线) 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 颜色
   * @param {Number} [options.speed=5.0] 速度，值越大越快
   *
   * @export
   * @class RadarWaveMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class RadarWaveMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, new Cesium__namespace.Color(0, 0, 0, 0));
      /**
       * 速度
       * @type {Number}
       */
      this.speed = options.speed ?? 5.0;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return RadarWave
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = this.color;
      result.speed = this.speed;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof RadarWaveMaterialProperty && Cesium__namespace.Property.equals(this.color, other.color) && this.speed === other.speed)
      )
    }
  }


  registerPropertyClass(RadarWave, RadarWaveMaterialProperty);

  /**
   *
   * 矩形面： 轮播图  材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String}  options.image  图片URL
   * @param {Cesium.Color} [options.color=Cesium.Color.WHITE] 颜色和透明度
   * @param {Number} [options.speed=1] 速度，值越大越快
   * @param {Boolean} [options.pure=false] 是否纯色
   *
   * @export
   * @class RectSlideMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class RectSlideMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 背景图片URL
       * @type {String}
       */
      this.image = options.image;

      /**
       * 背景图片颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, new Cesium__namespace.Color(1, 1, 1, 0.9));
      /**
       * 速度，值越大越快
       * @type {Number}
       */
      this.speed = options.speed ?? 1; // 速度
      /**
       * 是否纯色
       * @type {Boolean}
       */
      this.pure = !!options.pure;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return RectSlide
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.image = this.image;
      result.color = this.color;
      result.speed = this.speed;
      result.pure = this.pure;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof RectSlideMaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          this.image === other.image &&
          this.pure === other.pure &&
          this.speed === other.speed)
      )
    }
  }


  registerPropertyClass(RectSlide, RectSlideMaterialProperty);

  /**
   * 面状: 用于面状对象的 扫描线放大效果 材质属性
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|Cesium.Color} [options.color=Cesium.Color.YELLOW]  颜色
   * @param {Number} [options.speed=10] 速度
   *
   * @export
   * @class ScanLineMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class ScanLineMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, Cesium__namespace.Color.YELLOW);
      /**
       * 速度
       * @type {Number}
       */
      this.speed = options.speed ?? 10;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return ScanLine
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.color = this.color;
      result.speed = this.speed;
      result.globalAlpha = this.globalAlpha;
      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof ScanLineMaterialProperty && Cesium__namespace.Property.equals(this.color, other.color) && this.speed === other.speed)
      )
    }
  }

  registerPropertyClass(ScanLine, ScanLineMaterialProperty);

  /**
   * 文字贴图 entity材质
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.text] 文本内容
   * @param {String} [options.font_family = "楷体"] 字体 ,可选项：微软雅黑,宋体,楷体,隶书,黑体,
   * @param {Number} [options.font_size = 30] 字体大小
   * @param {String} [options.font_weight = "normal"] 是否加粗 ,可选项：bold (解释：是),normal (解释：否),
   * @param {String} [options.font_style = "normal"] 是否斜体 ,可选项：italic (解释：是),normal (解释：否),
   * @param {string} [options.font='30px normal normal 楷体'] 上叙4个属性的一次性指定CSS字体的属性。
   *
   * @param {Boolean} [options.fill = true] 是否填充
   * @param {String} [options.color = "#ffff00"] 文本颜色
   *
   * @param {Boolean} [options.stroke=false] 是否描边文本。
   * @param {Cesium.Color} [options.strokeColor=new Cesium.Color(1.0, 1.0, 1.0, 0.8)] 描边的颜色。
   * @param {Number} [options.strokeWidth=2] 描边的宽度。
   *
   * @param {Boolean} [options.background=false] 是否背景色。
   * @param {Cesium.Color} [options.backgroundColor=new Cesium.Color(1.0, 1.0, 1.0, 0.1)] 画布的背景色。
   *
   * @param {Number} [options.outlineWidth] 边框的宽度。
   * @param {Cesium.Color} [options.outlineColor=color] 矩形边框的颜色。
   *
   * @param {Number} [options.padding=10] 要在文本周围添加的填充的像素大小。
   * @param {String} [options.textBaseline='top'] 文本的基线。
   *
   * @param {Function} [options.onCustomCanvas] 支持对生成后的Canvas做自定义处理。
   * @export
   * @class TextMaterialProperty
   * @extends {Image2MaterialProperty}
   */
  class TextMaterialProperty extends Image2MaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      options.font_size = options.font_size ?? 70;
      super(options);

      /**
       * 是否透明
       * @type {boolean}
       */
      this.transparent = options.transparent ?? true;

      this._textStyles = LabelStyleConver.toCesiumVal(options, {
        fill: true,
        fillColor: new Cesium__namespace.Color(1.0, 1.0, 0.0, 1.0),
        textBaseline: "middle",
        padding: 10
      });

      this._updateImage();
    }

    //= ========= 对外属性 ==========
    /**
     * 文本内容
     * @type {String}
     */
    get text() {
      return this.options.text
    }

    set text(val) {
      this.options.text = val;
      this._updateImage();
    }

    /**
     * 文本样式
     *
     * @type {Object}
     */
    get textStyles() {
      return this._textStyles
    }

    set textStyles(val) {
      this._textStyles = LabelStyleConver.toCesiumVal(val, this._textStyles);
      this._updateImage();
    }

    _updateImage() {
      this._canvas = getTextImage(this.options.text, this._textStyles);
      if (this._canvas) {
        this.image = this._canvas;

        const onCustomCanvas = this.options?.onCustomCanvas;
        if (onCustomCanvas) {
          onCustomCanvas(this._canvas, this).then((canvas) => {
            this.image = copyCanvas(canvas);
          });
        }
      }
    }
  }

  registerPropertyClass(Text, TextMaterialProperty);

  /**
   *
   * 墙体:  走马灯围墙 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String}  options.image 背景图片URL
   * @param {String|Cesium.Color} [options.color=new Cesium.Color(1, 0, 0, 1.0)] 背景图片颜色
   * @param {Number} [options.count=1] 数量
   * @param {Number} [options.reverse=false] 方向，false是往下，true是往上
   * @param {Number} [options.speed=5.0] 速度，值越大越快
   * @param {Boolean} [options.bloom=false] 是否泛光
   * @param {Boolean} [options.axisY=false] 是否Y轴朝上
   *
   * @export
   * @class WallScrollMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class WallScrollMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 背景图片URL
       * @type {String}
       */
      this.image = options.image;

      /**
       * 背景图片颜色
       * @type { Cesium.Color}
       */
      this.color = getCesiumColor(options.color, new Cesium__namespace.Color(0, 0, 0, 0));

      /**
       * 速度
       * @type { Number}
       */
      this.speed = options.speed ?? 10;

      /**
       * 数量
       * @type { Number}
       */
      this.count = options.count ?? 1;

      /**
       * 方向，false是往下，true是往上
       * @type { Boolean}
       */
      this.reverse = options.reverse ?? false;

      /**
       * 是否Y轴朝上
       * @type { Boolean}
       */
      this.axisY = options.axisY ?? false;

      /**
       * 是否泛光
       * @type { Boolean}
       */
      this.bloom = options.bloom ?? false;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return WallScroll
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.image = this.image;
      result.color = this.color;
      result.speed = this.speed;
      result.count = this.count;
      result.reverse = this.reverse;
      result.axisY = this.axisY;
      result.bloom = this.bloom;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof WallScrollMaterialProperty &&
          Cesium__namespace.Property.equals(this.color, other.color) &&
          this.image === other.image &&
          this.count === other.count &&
          this.reverse === other.reverse &&
          this.bloom === other.bloom &&
          this.speed === other.speed)
      )
    }
  }


  registerPropertyClass(WallScroll, WallScrollMaterialProperty);

  /**
   *
   * 线状 流动效果 材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String}  options.specularMap 图片路径，镜面反射纹理材质图片
   * @param {String}  [options.normalMap=Cesium.Material.DefaultImageId] 图片路径，水正常扰动的法线图材质图片
   * @param {Number} [options.alpha=0.2] 透明度
   *
   * @export
   * @class WaterLightMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class WaterLightMaterialProperty extends BaseMaterialProperty {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);
      /**
       * 图片路径，镜面反射纹理材质图片
       * @type { String}
       */
      this.specularMap = options.specularMap;
      /**
       * 图片路径，水正常扰动的法线图材质图片
       * @type { String}
       */
      this.normalMap = options.normalMap || Cesium__namespace.Material.DefaultImageId;
      /**
       * 透明度
       * @type {Number}
       */
      this.alpha = options.alpha ?? 0.2;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    //= ========= 方法 ==========
    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return WaterLight
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!Cesium__namespace.defined(result)) {
        result = {};
      }
      result.specularMap = this.specularMap;
      result.normalMap = this.normalMap;
      result.alpha = this.alpha;
      result.globalAlpha = this.globalAlpha;

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof WaterLightMaterialProperty &&
          this.specularMap === other.specularMap &&
          this.normalMap === other.normalMap &&
          this.alpha === other.alpha)
      )
    }
  }

  registerPropertyClass(WaterLight, WaterLightMaterialProperty);

  /**
   * 水面效果材质
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|Cesium.Color}  [options.baseWaterColor=new Cesium.Color(0.2, 0.3, 0.6, 1.0)] 基础颜色
   * @param {String|Cesium.Color}  [options.blendColor=new Cesium.Color(0.0, 1.0, 0.699, 1.0)] 从水中混合到非水域时使用的rgba颜色
   * @param {String}  [options.specularMap] 单一通道纹理用来指示水域的面积
   * @param {String}  [options.normalMap] 水正常扰动的法线图
   * @param {Number}  [options.frequency=100] 控制波数的数字
   * @param {Number}  [options.animationSpeed=0.01] 控制水的动画速度的数字
   * @param {Number}  [options.amplitude=10] 控制水波振幅的数字
   * @param {Number}  [options.specularIntensity=0.5] 控制镜面反射强度的数字
   * @param {Number}  [options.fadeFactor=1.0] 衰减因子
   *
   * @export
   * @class WaterMaterialProperty
   * @extends {BaseMaterialProperty}
   */
  class WaterMaterialProperty extends BaseMaterialProperty {
    constructor(options = {}) {
      super(options);
      /**
       * 基础颜色
       * @type { Cesium.Color}
       */
      this.baseWaterColor = getCesiumColor(options.baseWaterColor, new Cesium__namespace.Color(0.2, 0.3, 0.6, 1.0));
      /**
       * 从水中混合到非水域时使用的rgba颜色
       * @type { Cesium.Color}
       */
      this.blendColor = getCesiumColor(options.blendColor, new Cesium__namespace.Color(0.0, 1.0, 0.699, 1.0));
      /**
       * 单一通道纹理用来指示水域的面积
       * @type {String}
       */
      this.specularMap = options.specularMap || Cesium__namespace.Material.DefaultImageId;
      /**
       * 水正常扰动的法线图
       * @type {String}
       */
      this.normalMap = options.normalMap || Cesium__namespace.Material.DefaultImageId;
      /**
       * 控制波数的数字
       * @type {Number}
       */
      this.frequency = options.frequency ?? 1000;
      /**
       * 控制水的动画速度的数字
       * @type {Number}
       */
      this.animationSpeed = options.animationSpeed ?? 0.01;
      /**
       * 控制水波振幅的数字
       * @type {Number}
       */
      this.amplitude = options.amplitude ?? 10.0;
      /**
       * 控制镜面反射强度的数字
       * @type {Number}
       */
      this.specularIntensity = options.specularIntensity ?? 0.5;
      /**
       * 衰减因子
       * @type {Number}
       */
      this.fadeFactor = options.fadeFactor ?? 1.0;

      this.globalAlpha = options.globalAlpha ?? 1; // 用于全局调整透明度
    }

    /**
     * 获取 材质名称
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @returns {String} 材质名称
     */
    getType(time) {
      return Water$1
    }

    /**
     * 获取所提供时间的属性值。
     *
     * @param {Cesium.JulianDate} [time] 检索值的时间。
     * @param {Object} [result] 用于存储值的对象，如果省略，则创建并返回一个新的实例。
     * @returns {Object} 修改的result参数或一个新的实例(如果没有提供result参数)。
     */
    getValue(time, result) {
      if (!result) {
        result = {};
      }
      result.baseWaterColor = this.baseWaterColor;
      result.blendColor = this.blendColor;
      result.specularMap = this.specularMap;
      result.normalMap = this.normalMap;
      result.frequency = this.frequency;
      result.animationSpeed = this.animationSpeed;
      result.amplitude = this.amplitude;
      result.specularIntensity = this.specularIntensity;
      result.fadeFactor = this.fadeFactor;

      if (this.globalAlpha !== 1) {
        result.baseWaterColor.alpha *= this.globalAlpha;
        result.blendColor.alpha *= this.globalAlpha;
      }

      return result
    }

    /**
     * 将此属性与提供的属性进行比较并返回, 如果两者相等返回true，否则为false
     * @param { Cesium.Property} [other] 比较的对象
     * @returns {Boolean}  两者是同一个对象
     */
    equals(other) {
      return (
        this === other ||
        (other instanceof WaterMaterialProperty &&
          this.baseWaterColor.equals(other.baseWaterColor) &&
          this.blendColor.equals(other.blendColor) &&
          this.specularMap === other.specularMap &&
          this.normalMap === other.normalMap &&
          this.frequency === other.frequency &&
          this.animationSpeed === other.animationSpeed &&
          this.amplitude === other.amplitude &&
          this.specularIntensity === other.specularIntensity &&
          this.fadeFactor === other.fadeFactor)
      )
    }
  }

  registerPropertyClass(Water$1, WaterMaterialProperty);

  var index$7 = {
    __proto__: null,
    TextMaterial: TextMaterial,
    CylinderWaveMaterial: CylinderWaveMaterial,
    BaseMaterialProperty: BaseMaterialProperty,
    CircleScanMaterialProperty: CircleScanMaterialProperty,
    CircleWaveMaterialProperty: CircleWaveMaterialProperty,
    CylinderWaveMaterialProperty: CylinderWaveMaterialProperty,
    DigitalFlowMaterialProperty: DigitalFlowMaterialProperty,
    EllipsoidElectricMaterialProperty: EllipsoidElectricMaterialProperty,
    EllipsoidWaveMaterialProperty: EllipsoidWaveMaterialProperty,
    Image2MaterialProperty: Image2MaterialProperty,
    LineBloomMaterialProperty: LineBloomMaterialProperty,
    LineFlickerMaterialProperty: LineFlickerMaterialProperty,
    LineFlowColorMaterialProperty: LineFlowColorMaterialProperty,
    LineFlowMaterialProperty: LineFlowMaterialProperty,
    LineTrailMaterialProperty: LineTrailMaterialProperty,
    NeonLightMaterialProperty: NeonLightMaterialProperty,
    ODLineMaterialProperty: ODLineMaterialProperty,
    PolyAsphaltMaterialProperty: PolyAsphaltMaterialProperty,
    PolyBlobMaterialProperty: PolyBlobMaterialProperty,
    PolyFacetMaterialProperty: PolyFacetMaterialProperty,
    PolyGradientMaterialProperty: PolyGradientMaterialProperty,
    PolyGrassMaterialProperty: PolyGrassMaterialProperty,
    PolyWoodMaterialProperty: PolyWoodMaterialProperty,
    RadarLineMaterialProperty: RadarLineMaterialProperty,
    RadarWaveMaterialProperty: RadarWaveMaterialProperty,
    RectSlideMaterialProperty: RectSlideMaterialProperty,
    ScanLineMaterialProperty: ScanLineMaterialProperty,
    TextMaterialProperty: TextMaterialProperty,
    WallScrollMaterialProperty: WallScrollMaterialProperty,
    WaterLightMaterialProperty: WaterLightMaterialProperty,
    WaterMaterialProperty: WaterMaterialProperty
  };

  /**
   * @typedef {Object} BaseGraphic.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} add 本身被添加
   * @property {String} remove 本身被移除
   *
   * @property {String} show 显示了对象本身
   * @property {String} hide 隐藏了对象本身
   *
   * @property {String} updatePosition 更新了坐标位置
   * @property {String} updateStyle 更新了style对象
   * @property {String} updateAttr 更新了attr对象
   *
   * @property {String} click 左键单击 鼠标事件 【仅支持交互的相关对象内存在】
   * @property {String} rightClick 右键单击 鼠标事件
   * @property {String} mouseOver 鼠标移入 鼠标事件
   * @property {String} mouseOut 鼠标移出 鼠标事件
   * @property {String} popupOpen popup弹窗打开后
   * @property {String} popupClose popup弹窗关闭
   * @property {String} tooltipOpen tooltip弹窗打开后
   * @property {String} tooltipClose tooltip弹窗关闭
   * @property {String} contextMenuOpen 右键菜单 打开后
   * @property {String} contextMenuClose 右键菜单 关闭
   * @property {String} contextMenuClick 右键菜单 单击某一项后
   * @property {String} highlightOpen highlight高亮后
   * @property {String} highlightClose highlight关闭后
   *
   * @property {String} postRender 每帧渲染  【仅DIV或Popup相关对象内存在】
   *
   * @property {String} drawStart 开始绘制 标绘事件 【仅支持标绘的相关对象内存在】
   * @property {String} drawMouseMove 正在移动鼠标中，绘制过程中鼠标移动了点 标绘事件
   * @property {String} drawAddPoint 绘制过程中增加了点 标绘事件
   * @property {String} drawRemovePoint 绘制过程中删除了最后一个点 标绘事件
   * @property {String} drawCreated 创建完成 标绘事件
   *
   * @property {String} editStart 开始编辑 标绘事件 【仅支持编辑的相关对象内存在】
   * @property {String} editMouseDown 移动鼠标按下左键（LEFT_DOWN）标绘事件
   * @property {String} editMouseMove 正在移动鼠标中，正在编辑拖拽修改点中（MOUSE_MOVE） 标绘事件
   * @property {String} editMovePoint 编辑修改了点（LEFT_UP）标绘事件
   * @property {String} editRemovePoint 编辑删除了点 标绘事件
   * @property {String} editStyle 图上编辑修改了相关style属性 标绘事件
   * @property {String} editStop 停止编辑 标绘事件
   *
   * @property {String} load gltf模型加载完成后【仅gltf模型相关对象存在】
   * @property {String} stop 模型addDynamicPosition添加的动态点，到时时间停止后触发【仅addDynamicPosition动态点时存在】
   *
   * @example
   * //绑定监听事件
   * graphic.on(mars3d.EventType.click, function (event) {
   *   console.log('单击了矢量数据对象', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 矢量数据 基础类
   *
   * @param {Object} options 参数对象，包括以下：
   *
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 【点状】矢量数据时的坐标位置，具体看子类实现
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 【线面状（多点）】矢量数据时的坐标位置，具体看子类实现
   * @param {Object} options.style 矢量数据的 样式信息，具体见各类数据的说明
   * @param {Object} [options.attr] 矢量数据的 属性信息，可以任意附加属性。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class BaseGraphic
   * @extends {BaseClass}
   *
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BaseGraphic extends BaseClass {
    constructor(options = {}) {
      options.style = options.style || {}; // 样式
      options.attr = options.attr || {}; // 属性
      super(options);

      this.options = options;

      this._id = options.id ?? createGuid();
      this._name = options.attr.name || options.name || "";
      this._show = options.show ?? true;
      this._private = options.private;

      if (options.popup) {
        this.bindPopup(options.popup, options.popupOptions);
      }
      if (options.tooltip) {
        this.bindTooltip(options.tooltip, options.tooltipOptions);
      }
      if (options.contextmenuItems) {
        this.bindContextMenu(options.contextmenuItems, options.contextmenuItemsOptions);
      }

      this._state = State.INITIALIZED;
    }

    /**
     *  矢量数据类型
     *
     * @type {String}
     * @readonly
     */
    get type() {
      return this._type
    }

    /**
     * 对象的id标识
     * @type {String|Number}
     * @readonly
     */
    get id() {
      return this._id
    }

    set id(id) {
      this._id = id;
    }

    // 兼容v3.4之前历史版本
    get uuid() {
      return this._id
    }

    /**
     * 当前对象的状态
     *
     * @type {State}
     * @readonly
     */
    get state() {
      return this._state
    }

    /**
     * 是否已添加到图层
     *
     * @type {Boolean}
     * @readonly
     */
    get isAdded() {
      return this._state === State.ADDED
    }

    /**
     * 是否已经销毁了
     *
     * @type {Boolean}
     * @readonly
     */
    get isDestroy() {
      return this._state === State.DESTROY
    }

    /**
     * 是否Mars3D内部的私有对象，如标绘拖拽点等
     * @type {Boolean}
     * @readonly
     */
    get isPrivate() {
      if (this._private) {
        return true
      }
      return false
    }

    /**
     * 矢量数据对应的 Cesium内部对象 (不同子类中实现)
     * @type {Cesium.Entity|Cesium.Primitive|Cesium.GroundPrimitive|Cesium.ClassificationPrimitive|*}
     * @readonly
     */
    get czmObject() {
      return null
    }

    /**
     * 矢量数据对应的 附加的Cesium内部对象，比如文本等
     * @private
     */
    get czmObjectEx() {
      return null
    }

    /**
     * 显示隐藏状态
     *
     * @type {Boolean}
     */
    get show() {
      return this._show
    }

    set show(show) {
      if (this._show === show) {
        return
      }
      this._show = show;

      if (this.czmObject) {
        this.czmObject.show = this._show;
      }
      if (this.czmObjectEx) {
        this.czmObjectEx.forEach(function (item) {
          item.show = show;
        });
      }
      this._showHook && this._showHook(show);

      if (show) {
        this.fire(EventType.show);
      } else {
        this.fire(EventType.hide);
      }
    }

    /**
     * 名称
     * @type {String}
     */
    get name() {
      return this._name
    }

    set name(name) {
      this._name = name;
    }

    /**
     * 属性信息
     * @type {Object}
     */
    get attr() {
      return this.options.attr
    }

    set attr(attr) {
      this.options.attr = attr;
      this.fire(EventType.updateAttr, { attr: attr }, true);
    }

    /**
     * 样式信息
     * @type {Object}
     */
    get style() {
      return this.options.style
    }

    set style(style) {
      this.setStyle(style);
    }

    /**
     * 是否允许鼠标穿透拾取
     * @type {Boolean|Function}
     */
    get allowDrillPick() {
      return this.options.allowDrillPick
    }

    set allowDrillPick(value) {
      this.options.allowDrillPick = value;
    }

    /**
     * 是否可以编辑
     * @type {Boolean}
     */
    get hasEdit() {
      return this._hasEdit && Boolean(this.EditClass || this._getDrawEntityClass)
    }

    set hasEdit(val) {
      this._hasEdit = val;
    }

    /**
     * 中心点坐标（笛卡尔坐标）
     * @type {Cesium.Cartesian3|Cesium.SampledPositionProperty}
     * @readonly
     */
    get center() {
      return null
    }

    /**
     * 中心点坐标
     * @type {LngLatPoint}
     * @readonly
     */
    get centerPoint() {
      return LngLatPoint.fromCartesian(this.center)
    }

    /**
     * 是否可以调整透明度
     * @type {Boolean}
     * @readonly
     */
    get hasOpacity() {
      return true
    }

    //= ============方法==================

    /**
     * 添加到图层上，同  layer.addGraphic
     *
     * @param {GraphicLayer} layer 图层对象
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    addTo(layer) {
      if (layer && layer.addGraphic) {
        layer.addGraphic(this);
      }
      return this
    }

    /**
     * 从图层上移除，同 layer.removeGraphic
     *
     * @param {Boolean} [hasDestroy] 是否调用destroy释放
     * @return {void}  无
     */
    remove(hasDestroy) {
      if (this._layer) {
        this._layer.removeGraphic(this, hasDestroy);
      }
    }

    /**
     * 绑定Cesium内部对象进行相关管理。
     *
     * @param {*} item Cesium对象
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    bindPickId(item) {
      item._mars3d_layerId = this._layer?.id;
      item._mars3d_graphicId = this.id;
      return this
    }

    /**
     * 添加到图层上的钩子方法
     *
     * @param {GraphicLayer} layer 图层对象
     * @return {void}  无
     * @private
     */
    _onAdd(layer) {
      if (this._state === State.ADDED) {
        return
      }
      this._layer = layer;
      this._map = layer._map;
      if (!this._map) {
        logWarn("BaseGraphic:为了避免异常问题，请将图层添加到Map上再进行添加矢量数据的操作！");
      }

      if (this.options.eventParent) {
        this.addEventParent(this.options.eventParent);
      } else if (this.options?.eventParent === false) ; else {
        this.addEventParent(layer);
      }

      if (!this.czmObject) {
        this._mountedHook && this._mountedHook();
      }
      this._addedHook && this._addedHook(this.style);

      // 图层上绑定的优先
      if (!this._layer._highlightOptions) {
        if (this.style.highlight) {
          this.bindHighlight(this.style.highlight);
        } else if (this.options.highlight) {
          this.bindHighlight(this.options.highlight); // PolygonCombine等对象
        }
      }

      // 将矢量数据关联的mars3d图层和graphic记录下
      if (this.czmObject) {
        this.bindPickId(this.czmObject);
      }

      if (this.czmObjectEx) {
        this.czmObjectEx.forEach((item) => {
          this.bindPickId(item);
        });
      }
      this._state = State.ADDED;
      this.fire(EventType.add);

      if (!this.isPrivate) {
        this._layer.fire(EventType.addGraphic, { graphic: this }, true);
      }
    }

    /**
     * 从图层上移除的钩子方法
     *
     * @return {void}  无
     * @private
     */
    _onRemove() {
      if (this._state !== State.ADDED) {
        return
      }

      if (!this._layer || !this.options) {
        return
      }

      this._closeAllControl();

      this.unbindHighlight();

      if (this.update) {
        this.unbindUpdateEvent();
      }

      this._removedHook && this._removedHook();
      if (!this.options) {
        return
      }

      this._state = State.REMOVED;

      this.fire(EventType.remove);
      if (!this.isPrivate) {
        this._layer.fire(EventType.removeGraphic, { graphic: this }, true);
      }

      if (this.options?.eventParent) {
        this.removeEventParent(this.options.eventParent);
      } else if (this.options?.eventParent === false) ; else {
        this.removeEventParent(this._layer);
      }

      this._layer = null;
      this._map = null;
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @abstract
     */
    _mountedHook() {}

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @abstract
     */
    _addedHook(style) {}

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @abstract
     */
    _removedHook() {}

    /**
     * 启用或禁用所有内部控件（含tooltip、popup、contextmenu）
     * @param {Boolean} value 是否启用
     * @return {void}  无
     */
    enableControl(value) {
      this._map.mouseEvent.enabledMoveTarget = value;
      if (this._map.popup) {
        this._map.popup.enabled = value;
      }
      if (this._map.tooltip) {
        this._map.tooltip.enabled = value;
      }
      if (this._map.contextmenu) {
        this._map.contextmenu.enabled = value;
      }
    }

    /**
     * 重新赋值参数，同构造方法参数一致。
     * @param {Object} options 参数,与类的构造方法参数相同
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    setOptions(options) {
      if (!options || Object.keys(options).length === 0) {
        return this
      }

      for (const key in options) {
        switch (key) {
          case "name":
            this.name = options.name;
            break
          case "show":
            this.show = options.show;
            break
          case "attr": {
            this.options.attr = merge(this.options.attr, options.attr);
            this.fire(EventType.updateAttr, { attr: options.attr }, true);
            break
          }
          case "style": {
            this.options.style = merge(this.options.style, options.style);
            this._updateStyleBaseHook(options.style);

            this.fire(EventType.updateStyle, { style: options.style }, true);
            break
          }
          case "position": {
            this.position = options.position;
            break
          }
          case "positions": {
            this.positions = options.positions;
            break
          }
          default: {
            this.options[key] = merge(this.options[key], options[key]);
            break
          }
        }
      }

      this._setOptionsHook && this._setOptionsHook(this.options, options);

      return this
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 本次更新的部分样式信息,内部会合并属性
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    setStyle(newStyle) {
      if (newStyle.material) {
        delete this.options.style.material;
      }
      if (newStyle.materialType && this.options.style.materialOptions) {
        delete this.options.style.materialOptions;
      }

      this.options.style = merge(this.options.style, newStyle);
      this._updateStyleBaseHook(newStyle);

      this.fire(EventType.updateStyle, { style: newStyle }, true);
      return this
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 本次更新的部分样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleBaseHook(newStyle) {}

    /**
     * 设置透明度, 不是所有类型均支持，主要看数据类型和材质类型决定。
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      // 不能随时刷新，需要隔一段时间刷新，避免卡顿
      clearTimeout(this._canrefresh);
      this._canrefresh = setTimeout(() => {
        if (this.isAdded) {
          this.setStyle({ globalAlpha: value });
        }
      }, 500);
    }

    /**
     * 将矢量数据导出为GeoJSON格式规范对象。
     * @param {Object} [options] 参数对象:
     * @param {Boolean} [options.noAlt] 不导出高度值
     * @return {Object} GeoJSON格式规范对象
     */
    toGeoJSON(options) {
      const geojson = {
        type: "Feature",
        properties: {
          ...this.attr,
          id: this.id,
          name: this.name,
          type: this.type,
          style: this._style2JsonBase(this.style, true)
        }
      };

      if (this._getGeoJsonGeometry) {
        geojson.geometry = this._getGeoJsonGeometry(options);
      } else if (this.position) {
        geojson.geometry = { type: "Point", coordinates: this.getCoordinate(options?.noAlt) };
      } else if (this.positions) {
        geojson.geometry = { type: "LineString", coordinates: this.getCoordinates(options?.noAlt) };
      }

      if (Cesium__namespace.defined(this.options.styleType)) {
        geojson.properties.styleType = this.options.styleType;
      }
      if (this._toJSON_Ex) {
        this._toJSON_Ex(geojson.properties);
      }

      return geojson
    }

    /**
     * 将矢量数据的坐标、样式及属性等信息导出为对象，可以用于存储。
     * @return {Object} 导出的坐标、样式及属性等信息
     */
    toJSON() {
      const json = {
        ...getAttrVal(this.options, { onlySimpleType: true }),
        id: this.id,
        name: this.name,
        type: this.type,
        attr: this.attr,
        style: this._style2JsonBase(this.style, false)
      };

      if (this._getJsonPositions) {
        this._getJsonPositions(json);
      } else if (this.coordinate) {
        json.position = this.coordinate;
      } else if (this.coordinates) {
        json.positions = this.coordinates;
      } else {
        logError("toJSON:缺少坐标信息", this);
      }

      if (Cesium__namespace.defined(this.options.styleType) && this.options.styleType !== this.type) {
        json.styleType = this.options.styleType;
      }

      if (this._toJSON_Ex) {
        this._toJSON_Ex(json);
      }

      return json
    }

    // style样式转object，子类可以重写
    _style2JsonBase(style, isGeoJSON) {
      let styleJson;
      if (this._style2Json) {
        styleJson = this._style2Json(style);
        if (style.highlight) {
          styleJson.highlight = this._style2Json(style.highlight);
        }
      } else {
        styleJson = getAttrVal(style, { onlySimpleType: true });
      }

      if (style.label) {
        styleJson.label = LabelStyleConver.toJSON(style.label);
      }
      if (style.outlineStyle) {
        styleJson.outlineStyle = PolylineStyleConver.toJSON(style.outlineStyle);
      }

      return styleJson
    }

    // 绑定对定时刷新的绑定[需要做定时任务的子类中使用]
    bindUpdateEvent() {
      if (!this.update || !this._map) {
        return
      }
      this.unbindUpdateEvent();

      this._map.on(EventType.preRender, this._map_preRenderHandler, this);
      this._map_preRenderHandler(this._map.scene);
    }

    unbindUpdateEvent() {
      if (this._map) {
        this._map.off(EventType.preRender, this._map_preRenderHandler, this);
      }
    }

    _map_preRenderHandler(scene) {
      if (this.options.frameRate && this._last_preUpdateTime) {
        const delta = scene._frameState.frameNumber - this._last_preUpdateTime;
        // 为了效率考虑，每frameRate帧才去update一次
        if (delta < this.options.frameRate) {
          return
        }
      }
      this._last_preUpdateTime = scene._frameState.frameNumber;

      this.update(scene._frameState);
    }

    /**
     * 获取数据的矩形边界
     * @param {Boolean} [options] 控制参数
     * @param {Boolean} [options.isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */
    getRectangle(options) {
      const positions = this.positionsShow || this.positions;
      if (positions && positions.length > 0) {
        return getRectangle(positions, options?.isFormat)
      }

      if (this.position) {
        return getRectangle([this.position], options?.isFormat)
      }
    }

    fire(type, data = {}, propagate) {
      data.graphic = this;

      return super.fire(type, data, propagate)
    }

    /**
     * 飞行定位至 数据所在的视角
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.radius] 点状数据时，相机距离目标点的距离（单位：米）
     * @param {Number} [options.scale=1.2] 线面数据时，缩放比例，可以控制视角比矩形略大一些，这样效果更友好。
     *
     * @param {Number} [options.minHeight] 定位时相机的最小高度值，用于控制避免异常数据
     * @param {Number} [options.maxHeight] 定位时相机的最大高度值，用于控制避免异常数据
     * @param {Number} [options.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} [options.pitch] 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} [options.roll] 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Cesium.Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     */
    flyTo(options = {}) {
      if (!this._map) {
        return Promise.resolve(false)
      }

      let positions;
      if (this.positionsShow) {
        positions = this.positionsShow;
      } else if (this.positions) {
        positions = this.positions;
      } else if (this.position) {
        positions = [this.position];
      }

      options.clampToGround = this.style.clampToGround;
      return this._map.flyToPositions(positions, options)
    }

    // 获取增加的高度
    getAddHeight(index = 0) {
      let addHeight = this.style.addHeight;
      if (Cesium__namespace.defined(addHeight)) {
        if (isString(addHeight)) {
          addHeight = Number(template(addHeight, this.attr, true));
          if (isNaN(addHeight)) {
            addHeight = 0;
          }
        } else if (Array.isArray(addHeight)) {
          addHeight = addHeight[index] || 0;
        }
        return addHeight
      }
      return 0
    }

    //= ============= Highlight ======================
    /**
     * 绑定鼠标移入或单击后的 对象高亮
     * @param {Object} options 高亮的样式，具体见各{@link GraphicType}矢量数据的style参数。
     * @param {String} [options.type] 事件类型，默认为鼠标移入高亮，也可以指定'click'单击高亮.
     * @return {void}  无
     */
    bindHighlight(options) {
      this.unbindHighlight();

      this._highlightOptions = options;

      if (this._highlightOptions.type === EventType.click) {
        this.on(EventType.click, this._highlight_mouseEventHandler, this);
      } else {
        this.on(EventType.mouseOver, this._highlight_mouseEventHandler, this);
        this.on(EventType.mouseOut, this._highlight_mouseOutHandler, this);
      }
    }

    /**
     * 解绑鼠标移入或单击后的高亮处理
     * @return {void}  无
     */
    unbindHighlight() {
      if (this._highlightOptions) {
        if (this._highlightOptions.type === EventType.click) {
          this.off(EventType.click, this._highlight_mouseEventHandler, this);
        } else {
          this.off(EventType.mouseOver, this._highlight_mouseEventHandler, this);
          this.off(EventType.mouseOut, this._highlight_mouseOutHandler, this);
        }
        this._map.closeHighlight();
        this._highlightOptions = null;
      }
    }

    // 移入
    _highlight_mouseEventHandler(event) {
      if (!this._map) {
        return
      }
      const graphic = event?.graphic;
      if (graphic) {
        this._map.openHighlight(graphic, this._highlightOptions, event);
      } else {
        this._map.closeHighlight();
      }
    }

    // 移出
    _highlight_mouseOutHandler(event) {
      this._map.closeHighlight();
    }

    //= ============= popup ======================
    _closeAllControl() {
      this.closePopup();
      this.closeTooltip();
      this.closeSmallTooltip();
      this.closeContextMenu();
    }

    _getPopupPosition() {
      return this.position || this.center
    }

    /**
     * 是否存在Popup绑定
     * @param {Boolean} [hasLayer=true] 是否判断图层上的Popup
     * @return {Boolean} 是否存在Popup绑定
     */
    hasPopup(hasLayer) {
      return Boolean(this.getPopupConfig(hasLayer))
    }

    // 获取popup配置
    getPopupConfig(hasLayer = true) {
      if (this._popupConfig) {
        return { ...this._popupConfig }
      }
      if (hasLayer && this._layer?._popupConfig) {
        return { ...this._layer._popupConfig }
      }
      return null
    }

    /**
     * 绑定鼠标单击对象后的弹窗。
     *
     * @param {String|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Popup.StyleOptions} [options] 控制参数
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    bindPopup(content, options = {}) {
      this._popupConfig = {
        content: content,
        options: options || this.options.popupOptions,
        graphic: this,
        layer: this._layer
      };
      this._onEventHook && this._onEventHook("popup");
      return this
    }

    /**
     * 解除绑定的鼠标单击对象后的弹窗。
     *
     * @param {Boolean} [bubbling=false] 单击事件中是否继续冒泡往上级查找
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    unbindPopup(bubbling) {
      if (bubbling) {
        this._popupConfig = false;
      } else {
        this._popupConfig = null;
      }
      this._onEventHook && this._onEventHook("popup");
      return this
    }

    /**
     * 打开绑定的弹窗
     *
     * @param {LngLatPoint|Cesium.Cartesian3|Number[]} [position=this.center] 矢量对象 或 显示的位置
     * @param {Object} [event] 用于抛出事件时的相关额外属性
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    openPopup(position, event) {
      const conifg = this.getPopupConfig();
      if (conifg && this._map) {
        if (event) {
          conifg.event = event;
        }
        conifg.graphic = this;
        conifg.layer = this._layer;
        this._map.popup.open(position || this._getPopupPosition(), conifg);
      }
      return this
    }

    /**
     * 关闭弹窗
     *
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    closePopup() {
      if (this._map) {
        this._map.popup.close(this);
      }
      return this
    }

    //= ============= tooltip ======================
    /**
     * 是否绑定了tooltip
     * @param {Boolean} [hasLayer=true] 是否判断图层上的tooltip
     * @return {Boolean} 是否绑定
     */
    hasTooltip(hasLayer) {
      return Boolean(this.getTooltipConfig(hasLayer))
    }

    // 获取Tooltip配置
    getTooltipConfig(hasLayer = true) {
      if (this._tooltipConfig) {
        return { ...this._tooltipConfig }
      }
      if (hasLayer && this._layer?._tooltipConfig) {
        return { ...this._layer._tooltipConfig }
      }
      return null
    }

    /**
     * 绑定鼠标移入的弹窗
     *
     * @param {String|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Tooltip.StyleOptions} [options] 控制参数
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    bindTooltip(content, options) {
      this._tooltipConfig = {
        content: content,
        options: options || this.options.tooltipOptions
      };
      this._onEventHook && this._onEventHook("tooltip");
      return this
    }

    /**
     * 解除绑定的鼠标移入对象后的弹窗。
     *
     * @param {Boolean} [bubbling=false] 单击事件中是否继续冒泡查找
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     *
     */
    unbindTooltip(bubbling) {
      if (bubbling) {
        this._tooltipConfig = false;
      } else {
        this._tooltipConfig = null;
      }
      this._onEventHook && this._onEventHook("tooltip");
      return this
    }

    /**
     * 打开绑定的tooltip弹窗
     * @param {LngLatPoint|Cesium.Cartesian3|Number[]} [position=this.center] 显示的位置,默认为矢量对象所在点或中心点位置
     * @param {Object} [event] 用于抛出事件时的相关额外属性
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    openTooltip(position, event) {
      const conifg = this.getTooltipConfig();
      if (conifg && this._map) {
        conifg.graphic = this;
        conifg.layer = this._layer;
        if (event) {
          conifg.event = event;
        }
        this._map.tooltip.open(position || this._getPopupPosition(), conifg);
      }
      return this
    }

    /**
     *  关闭弹窗
     *
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     *
     */
    closeTooltip() {
      if (this._map) {
        this._map.tooltip.close(this);
      }
      return this
    }

    //= ============= contextMenu ======================

    /**
     * 是否有绑定的右键菜单
     * @param {Boolean} [hasLayer=true] 是否判断图层上的右键菜单
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    hasContextMenu(hasLayer) {
      return Boolean(this.getContextMenu(hasLayer))
    }

    /**
     * 获取绑定的右键菜单数组
     * @param {Boolean} [hasLayer=true] 是获取图层上的右键菜单
     * @return {Object[]} 右键菜单数组
     */
    getContextMenu(hasLayer = true) {
      if (this._contextmenuConfig) {
        return this._contextmenuConfig
      }
      if (hasLayer && this._layer?._contextmenuConfig) {
        return this._layer._contextmenuConfig
      }
      return null
    }

    /**
     * 绑定右键菜单
     *
     * @param {Object[]} content 右键菜单配置数组，数组中每一项包括：
     * @param {String} [content.text] 菜单文字
        * @param {String} [content.icon] 图标,可以是：图片url路径、base64字符串、svg字符串、字体图标class名
     * @param {Function|Boolean} [content.show] 菜单项是否显示的回调方法
     * @param {Function} [content.callback] 菜单项单击后的回调方法
     * @param {Object[]} [content.children] 当有二级子菜单时，配置数组。
     *
     * @param {Object} [options={}] 控制参数
     * @param {Number} [options.offsetX] 用于非规则对象时，横向偏移的px像素值
     * @param {Number} [options.offsetY] 用于非规则对象时，垂直方向偏移的px像素值
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     *
     * @example
     *
        graphic.bindContextMenu([
          {
            text: '删除对象',
            icon: 'fa fa-trash-o',
            callback: function (e) {
              let graphic = e.graphic
              if (graphic) {
                graphic.remove()
              }
            },
          },
        ])
     */
    bindContextMenu(content, options) {
      this._contextmenuConfig = {
        content: content,
        options: options || this.options.contextmenuOptions,
        graphic: this,
        layer: this._layer
      };

      this._onEventHook && this._onEventHook("contextMenu");
      return this
    }

    /**
     * 解除绑定的右键菜单
     *
     * @param {Boolean} [bubbling=false] 单击事件中是否继续冒泡查找
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    unbindContextMenu(bubbling) {
      if (bubbling) {
        this._contextmenuConfig = false;
      } else {
        this._contextmenuConfig = null;
      }
      this._onEventHook && this._onEventHook("contextMenu");
      return this
    }

    /**
     * 打开右键菜单
     * @param {Cesium.Cartesian3} [position=this.center] 矢量对象 或 显示的位置
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    openContextMenu(position) {
      const conifg = this.getContextMenu();
      if (conifg && this._map) {
        conifg.graphic = this;
        conifg.layer = this._layer;
        this._map.contextmenu.open(position || this._getPopupPosition(), conifg);
      }
      return this
    }

    /**
     *  关闭右键菜单
     *
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    closeContextMenu() {
      if (this.hasContextMenu() && this._map) {
        this._map.contextmenu.close(this);
      }
      return this
    }

    //= ============= Small tooltip ======================

    /**
     * 显示小提示窗，一般用于鼠标操作的提示。
     *
     * @param {Cesium.Cartesian2|Cesium.Cartesian3} position 显示的屏幕坐标位置 或 笛卡尔坐标位置
     * @param {*} message 显示的内容
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     *
     */
    openSmallTooltip(position, message) {
      if (this._map) {
        this._map.openSmallTooltip(position, message);
      }
      return this
    }

    /**
     * 关闭小提示窗
     *
     * @return {BaseGraphic|*} 当前对象本身，可以链式调用
     */
    closeSmallTooltip() {
      if (this._map) {
        this._map.closeSmallTooltip();
      }
      return this
    }

    // 销毁
    destroy(noDel) {
      if (this._state === State.DESTROY || this._noDestroy) {
        return
      }

      if (this._state !== State.REMOVED) {
        this.clear && this.clear();
        this.remove();
      }
      super.destroy(noDel);

      this._state = State.DESTROY;
    }
  }

  /**
   * 定时闪烁高亮Entity（点、线、面）
   *
   * @export
   * @class FlickerEntity
   */
  class FlickerEntity {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      this.color = Cesium__namespace.Color.YELLOW.withAlpha(0);
    }

    //= ========= 方法 ==========
    /**
     * 高亮闪烁 Enity实体对象
     * @param {Cesium.Entity|Cesium.Entity[]} entitys entity对象或对象数组
     * @param {*} [opts={}] 控制参数
     * @param {Number} [opts.time] 闪烁的时长(秒)，未设置时不自动停止。
     * @param {Cesium.Color} [opts.color=Cesium.Color.YELLOW] 高亮的颜色
     * @param {Number} [opts.maxAlpha=0.3] 闪烁的最大透明度，从 0 到 maxAlpha 渐变
     * @param {Function} [opts.onEnd] 播放完成后的回调方法
     * @return {FlickerEntity} 高亮闪烁控制 对象
     */
    startFlicker(entitys, opts = {}) {
      const that = this;
      this.stopFlicker();

      this.entitys = entitys;
      this.maxAlpha = opts.maxAlpha ?? 0.3;
      this.time = opts.time; // 播放时长，默认一直不停止
      this.color = opts.color ?? Cesium__namespace.Color.YELLOW;
      this.color = this.color.withAlpha(this.maxAlpha);
      this.onEnd = opts.onEnd;

      this._startTime();

      loopArrayForFun(entitys, function (entity) {
        if (entity.polygon) {
          entity.polygon.material_bak = entity.polygon.material;
          entity.polygon.material = new Cesium__namespace.ColorMaterialProperty(
            new Cesium__namespace.CallbackProperty((time) => {
              return that.color
            }, false)
          );
        }
        if (entity.polyline) {
          entity.polyline.material_bak = entity.polyline.material;
          entity.polyline.material = new Cesium__namespace.ColorMaterialProperty(
            new Cesium__namespace.CallbackProperty((time) => {
              return that.color
            }, false)
          );
        }
        if (entity.ellipse) {
          entity.ellipse.material_bak = entity.ellipse.material;
          entity.ellipse.material = new Cesium__namespace.ColorMaterialProperty(
            new Cesium__namespace.CallbackProperty((time) => {
              return that.color
            }, false)
          );
        }
        if (entity.rectangle) {
          entity.rectangle.material_bak = entity.rectangle.material;
          entity.rectangle.material = new Cesium__namespace.ColorMaterialProperty(
            new Cesium__namespace.CallbackProperty((time) => {
              return that.color
            }, false)
          );
        }
        if (entity.wall) {
          entity.wall.material_bak = entity.wall.material;
          entity.wall.material = new Cesium__namespace.ColorMaterialProperty(
            new Cesium__namespace.CallbackProperty((time) => {
              return that.color
            }, false)
          );
        }

        if (entity.point) {
          entity.point.color_bak = entity.point.color;
          entity.point.color = that.color;
        }
        if (entity.billboard) {
          entity.billboard.color_bak = entity.billboard.color;
          entity.billboard.color = that.color;
        }
        if (entity.model) {
          entity.model.color_bak = entity.model.color;
          entity.model.color = that.color;
        }
        if (entity.label) {
          entity.label.fillColor_bak = entity.label.fillColor;
          entity.label.fillColor = that.color;
        }
      });
      return this
    }

    /**
     * 停止高亮闪烁
     * @return {FlickerEntity} 高亮闪烁控制 对象
     */
    stopFlicker() {
      this._stopTime();

      if (this.entitys) {
        loopArrayForFun(this.entitys, function (entity) {
          if (entity.polygon) {
            if (entity.polygon.material_bak) {
              entity.polygon.material = entity.polygon.material_bak;
            }
          }
          if (entity.polyline) {
            if (entity.polyline.material_bak) {
              entity.polyline.material = entity.polyline.material_bak;
            }
          }
          if (entity.ellipse) {
            if (entity.ellipse.material_bak) {
              entity.ellipse.material = entity.ellipse.material_bak;
            }
          }
          if (entity.rectangle) {
            if (entity.rectangle.material_bak) {
              entity.rectangle.material = entity.rectangle.material_bak;
            }
          }
          if (entity.wall) {
            if (entity.wall.material_bak) {
              entity.wall.material = entity.wall.material_bak;
            }
          }

          if (entity.point) {
            if (entity.point.color_bak) {
              entity.point.color = entity.point.color_bak;
            }
          }
          if (entity.billboard) {
            if (entity.billboard.color_bak) {
              entity.billboard.color = entity.billboard.color_bak;
            } else {
              entity.billboard.color = undefined;
            }
          }
          if (entity.model) {
            if (entity.model.color_bak) {
              entity.model.color = entity.model.color_bak;
            } else {
              entity.model.color = undefined;
            }
          }
          if (entity.label) {
            if (entity.label.fillColor_bak) {
              entity.label.fillColor = entity.label.fillColor_bak;
            }
          }
        });
        if (this.onEnd) {
          this.onEnd(this.entitys);
        }
        delete this.entitys;
      }
      return this
    }

    _updateClr() {
      const that = this;
      if (this.entitys) {
        loopArrayForFun(this.entitys, function (entity) {
          if (entity.point) {
            entity.point.color = that.color;
          }
          if (entity.billboard) {
            entity.billboard.color = that.color;
          }
          if (entity.model) {
            entity.model.color = that.color;
          }
          if (entity.label) {
            entity.label.fillColor = that.color;
          }
        });
      }
    }

    _startTime() {
      const time = 30;
      const setp = this.maxAlpha / time;

      let alpha = 0;
      this.interVal = setInterval(() => {
        alpha += setp;
        if (alpha > this.maxAlpha) {
          alpha = 0;
        }
        this.color = this.color.withAlpha(alpha);
        this._updateClr();
      }, time);

      if (this.time) {
        this.timeEndVal = setTimeout(() => {
          this.stopFlicker();
        }, this.time * 1000);
      }
    }

    _stopTime() {
      if (this.interVal) {
        clearInterval(this.interVal);
        this.interVal = null;
      }
      if (this.timeEndVal) {
        clearTimeout(this.timeEndVal);
        this.timeEndVal = null;
      }
    }
  }

  // 循环执行数组或对象
  // 调用示例 loopArrayForFun(ArrOrObj, function (entity) {
  //    drawControl.deleteEntity(entity);
  // });
  function loopArrayForFun(ArrOrObj, callback) {
    if (ArrOrObj == null) {
      return
    }
    if (Array.isArray(ArrOrObj)) {
      const arr = [];
      for (let i = 0, len = ArrOrObj.length; i < len; i++) {
        arr.push(callback(ArrOrObj[i]));
      }
      return arr
    } else {
      return callback(ArrOrObj)
    }
  }

  /**
   * Entity实体 矢量对象 基类
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 【点状】矢量数据时的坐标位置，具体看子类实现
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 【线面状（多点）】矢量数据时的坐标位置，具体看子类实现
   * @param {Object} options.style 矢量数据的 样式信息，具体见各类数据的说明
   * @param {Object} [options.attr] 矢量数据的 属性信息，可以任意附加属性
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class BaseEntity
   * @extends {BaseGraphic}
   *
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BaseEntity extends BaseGraphic {
    /**
     * 加载Entity数据的内部Cesium容器
     * @type {Cesium.CustomDataSource}
     * @readonly
     */
    get dataSource() {
      return this._layer?.dataSource
    }

    // 内部用
    get czmObject() {
      return this._entity
    }

    // 内部用，文本等附加对象
    get czmObjectEx() {
      let arr = [];
      if (this._primitive_label) {
        arr.push(this._primitive_label);
      }
      if (this._entity_outlines) {
        arr = arr.concat(this._entity_outlines);
      }
      return arr
    }

    /**
     *
     * 矢量数据对应的 Cesium内部对象
     * @type {Cesium.Entity}
     * @readonly
     */
    get entity() {
      return this._entity
    }

    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {*}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.point
    }

    /**
     *
     * 附加的label文本对象
     * @type {Cesium.Label |Cesium.LabelGraphics}
     * @readonly
     */
    get label() {
      // 线面数据时
      if (this._primitive_label) {
        return this._primitive_label
      }
      // 点状数据时
      if (this._entity?.label) {
        return this._entity.label
      }
      // 尚未添加entity、primitive时
      if (this.style?.label) {
        return this.style?.label
      }
      return {}
    }

    /**
     * 是否正在编辑状态
     * @type {Boolean}
     * @readonly
     */
    get isEditing() {
      return this._enabledEdit
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {}

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      this.dataSource.entities.add(this.czmObject);
      this.czmObjectEx.forEach((item) => {
        if (item instanceof Cesium__namespace.Entity) {
          this.dataSource.entities.add(item);
        }
      });
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.stopDraw();
      this.stopEditing();

      if (this.czmObject) {
        this.dataSource.entities.remove(this.czmObject);
      }
      if (this.czmObjectEx) {
        this.czmObjectEx.forEach((item) => {
          if (item instanceof Cesium__namespace.Entity) {
            this.dataSource.entities.remove(item);
          }
        });
      }

      if (this._primitive_label) {
        this._layer.labelCollection.remove(this._primitive_label);
        delete this._primitive_label;
      }
    }

    _initFromEntity(entity) {
      if (entity.entityCollection) {
        // 从原有的集合中删除
        entity.entityCollection.remove(entity);
      }
      entity._id = this.id;

      return entity
    }

    // 如果在编辑中，更新编辑的拖拽点。
    _updateEditDraggers() {
      if (this.editing?.enabled) {
        this.editing.updateDraggers();
      }
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 本次更新的部分样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleBaseHook(newStyle) {
      if (!this.czmObject || !newStyle) {
        return
      }

      this._updateStyleHook(this.style, newStyle);
      this._updateLabelStyleHook(this.style, newStyle);
      if (this._getOutlinePositions) {
        this._updateOutlineStyle(this._getOutlinePositions(), this.style);
      }

      if (this._updateExOpacity && Cesium__namespace.defined(newStyle.globalAlpha)) {
        this._updateExOpacity(newStyle.globalAlpha);
      }

      if (this._isCallbackPositions) {
        this._updateDistanceDisplayConditionByEdit();
      }

      if (this.editing?.enabled) {
        this.editing._updateStyleHook(newStyle);
      }
      return this
    }

    // distanceDisplayCondition属性的特殊处理
    _updateDistanceDisplayConditionByEdit() {
      let radius;
      const center = this.center;
      if (center) {
        radius = Cesium__namespace.Cartesian3.distance(center, new Cesium__namespace.Cartesian3());
      } else {
        radius = (Cesium__namespace.Ellipsoid.WGS84.minimumRadius + Cesium__namespace.Ellipsoid.WGS84.maximumRadius) / 2;
      }

      if (this._isCallbackPositions) {
        this.updateDistanceDisplayCondition(radius);
      } else {
        this.updateDistanceDisplayCondition();
      }

      if (this._entity_outlines) {
        for (let i = 0, len = this._entity_outlines.length; i < len; i++) {
          const polyline = this._entity_outlines[i].polyline;
          if (this.style.distanceDisplayCondition) {
            if (polyline.positions instanceof Cesium__namespace.CallbackProperty && this.style.clampToGround) {
              this.updateOutlinesDistanceDisplayCondition(polyline, radius);
            } else {
              this.updateOutlinesDistanceDisplayCondition(polyline);
            }
          } else {
            polyline.distanceDisplayCondition = undefined;
          }
        }
      }
    }

    updateDistanceDisplayCondition(addFar = 0) {
      if (this.style.distanceDisplayCondition) {
        this.entityGraphic.distanceDisplayCondition = new Cesium__namespace.DistanceDisplayCondition(
          Number((this.style.distanceDisplayCondition_near ?? 0) + addFar),
          Number((this.style.distanceDisplayCondition_far ?? 100000) + addFar)
        );
      } else {
        this.entityGraphic.distanceDisplayCondition = undefined;
      }
    }

    updateOutlinesDistanceDisplayCondition(polyline, addFar = 0) {
      polyline.distanceDisplayCondition = new Cesium__namespace.DistanceDisplayCondition(
        Number((this.style.distanceDisplayCondition_near ?? 0) + addFar),
        Number((this.style.distanceDisplayCondition_far ?? 100000) + addFar)
      );
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {}

    /**
     * 高亮对象。
     * @param {Object} [highlightStyle] 高亮的样式，具体见各{@link GraphicType}矢量数据的style参数。
     * @param {Boolean} [closeLast=true] 是否清除地图上上一次的高亮对象
     * @return {void}  无
     */
    openHighlight(highlightStyle, closeLast = true) {
      if (closeLast) {
        this._map.closeHighlight();
        this._map.last_highlighGraphic = this;
      }

      const style = highlightStyle || this._highlightOptions || this._layer?._highlightOptions;
      if (style) {
        const styleAll = merge({}, this.style, style);
        this._updateStyleHook(styleAll, style);
        this._updateLabelStyleHook(styleAll, style);
        this.fire(EventType.highlightOpen, {}, true);
      }
    }

    /**
     * 清除已选中的高亮，原有style的配置项需要与highlightStyle配置有一一对应关系，否则无法清除
     * @return {void}  无
     */
    closeHighlight() {
      if (this._state !== State.ADDED || this._map?.last_highlighGraphic !== this) {
        return
      }

      this._updateStyleHook(this.style, this.style);
      this._updateLabelStyleHook(this.style, this.style);

      this._map._clearLastHighlight();

      this.fire(EventType.highlightClose, {}, true);
    }

    // 创建Entity，并附加Graphic的一些属性
    _createEntity(addattr) {
      // 可以在添加前做特殊处理的。
      if (this.options.onBeforeCreate) {
        addattr = this.options.onBeforeCreate(addattr) || addattr;
      }
      if (this._onBeforeCreate) {
        addattr = this._onBeforeCreate(addattr) || addattr;
      }

      const defAttr = {
        id: this.id,
        name: this.name || this.id,
        properties: this.attr,
        show: this.show,
        parent: this.options.parent
      };
      if (this.options.availability) {
        defAttr.availability = this.options.availability;
      }
      if (this.options.description) {
        defAttr.description = this.options.description;
      }
      if (this.options.viewFrom) {
        defAttr.viewFrom = this.options.viewFrom;
      }
      if (this.options.parent) {
        defAttr.parent = this.options.parent;
      }

      const entity = new Cesium__namespace.Entity({
        ...defAttr,
        ...addattr
      });
      return entity
    }

    _updateLabelStyleHook(style, newStyle) {
      // 同时加文字
      if (newStyle?.label) {
        if (Cesium__namespace.defined(style.clampToGround) && !Cesium__namespace.defined(style.label.clampToGround)) {
          newStyle.label.clampToGround = style.clampToGround;
        }

        if (this._entity.label) {
          LabelStyleConver.toCesiumVal(style.label, this._entity.label, this.attr);
          if (Cesium__namespace.defined(newStyle?.label?.height) || Cesium__namespace.defined(newStyle?.label?.addHeight) || Cesium__namespace.defined(newStyle?.label?.setHeight)) {
            this._updateLabelPosition();
          }
        } else if (this._primitive_label) {
          LabelStyleConver.toCesiumVal(style.label, this._primitive_label, this.attr);
          if (Cesium__namespace.defined(newStyle?.label?.height) || Cesium__namespace.defined(newStyle?.label?.addHeight) || Cesium__namespace.defined(newStyle?.label?.setHeight)) {
            this._updateLabelPosition();
          }
        } else {
          this._addLabel();
        }
      } else if (Cesium__namespace.defined(newStyle?.globalAlpha)) {
        this._updateLabelOpacity(newStyle.globalAlpha);
      }
    }

    /**
     * 添加文本的统一方法 (不含Point、Billboard对象)
     * @return {Cesium.Label} 文本矢量对象
     * @private
     */
    _addLabel() {
      const style = this.style.label;

      if (!style || !style.text) {
        return
      }

      if (Cesium__namespace.defined(this.style.clampToGround) && !Cesium__namespace.defined(style.clampToGround) && !Cesium__namespace.defined(style.height)) {
        style.clampToGround = this.style.clampToGround;
      }
      const labelattr = LabelStyleConver.toCesiumVal(this.style.label, {}, this.attr);
      labelattr.show = this.show;
      labelattr.position = this._getLablePosition();

      if (this._primitive_label) {
        this._layer.labelCollection.remove(this._primitive_label);
      }
      this._primitive_label = this._layer.labelCollection.add(labelattr);
      this.bindPickId(this._primitive_label);
      return this._primitive_label
    }

    // 更新文本的位置
    _updateLabelPosition() {
      if (this._primitive_label) {
        this._primitive_label.position = this._getLablePosition();
      }
    }

    _updateLabelOpacity(value) {
      if (this._entity?.label) {
        LabelStyleConver.setOpacity(this._entity.label, value);
      }

      if (this._primitive_label && this._primitive_label.show) {
        LabelStyleConver.setOpacity(this._primitive_label, value);
      }
    }

    // 根据配置获取文本的坐标位置
    _getLablePosition() {
      const style = this.style.label;

      let position;
      if (style.position) {
        if (style.position === "center") {
          position = this.centerOfMass;
        } else {
          if (isString(style.position)) {
            const cfgPt = template(style.position, this.attr, true);
            if (cfgPt) {
              position = LngLatPoint.parse(cfgPt).toCartesian();
            }
          } else {
            position = LngLatPoint.parse(style.position).toCartesian();
          }
        }
      }

      if (!position) {
        position = this.center;
      }

      if (!position) {
        return new Cesium__namespace.Cartesian3()
      }

      if (Cesium__namespace.defined(style.height) || Cesium__namespace.defined(this.style.height)) {
        const height = style.height ?? this.style.height;
        position = setPositionsHeight(position, height);
      }
      // 存在垂直高度
      if (Cesium__namespace.defined(this.style.diffHeight)) {
        position = addPositionsHeight(position, this.style.diffHeight);
      }

      let setHeight = style.setHeight;
      if (Cesium__namespace.defined(setHeight)) {
        if (isString(setHeight)) {
          setHeight = Number(template(setHeight, this.attr, true));
          if (isNaN(setHeight)) {
            setHeight = 0;
          }
        }
        position = setPositionsHeight(position, setHeight);
      }
      let addHeight = style.addHeight;
      if (Cesium__namespace.defined(addHeight)) {
        if (isString(addHeight)) {
          addHeight = Number(template(addHeight, this.attr, true));
          if (isNaN(addHeight)) {
            addHeight = 0;
          }
        }
        position = addPositionsHeight(position, addHeight);
      }
      return position
    }

    // 图上量算等功能使用的，用于创建一个label
    _createLabel(style = {}, position) {
      const labelattr = LabelStyleConver.toCesiumVal({
        color: "#ffffff",
        font_size: 20,
        outline: true,
        outlineColor: "#000000",
        outlineWidth: 3,
        background: true,
        backgroundColor: "#000000",
        backgroundOpacity: 0.5,
        scaleByDistance: true,
        scaleByDistance_far: 800000,
        scaleByDistance_farValue: 0.5,
        scaleByDistance_near: 1000,
        scaleByDistance_nearValue: 1,
        pixelOffsetY: -15,
        horizontalOrigin: Cesium__namespace.HorizontalOrigin.LEFT,
        verticalOrigin: Cesium__namespace.VerticalOrigin.BOTTOM,
        visibleDepth: false, // 一直显示，不被地形等遮挡
        ...style
      });
      if (position) {
        labelattr.position = position;
      }

      const primitive_label = this._layer.labelCollection.add(labelattr);
      this.bindPickId(primitive_label);

      primitive_label._noMousePick = true;
      primitive_label.hasEdit = false;

      return primitive_label
    }

    // 图上量算等功能使用的，用于移除一个label
    _removeLabel(primitive_label) {
      this._layer.labelCollection.remove(primitive_label);
    }

    _getOutlineStyle(style, exStyle) {
      const cloneStyle = { ...style };
      delete cloneStyle.material;
      delete cloneStyle.materialType;
      delete cloneStyle.materialOptions;
      delete cloneStyle.outline; // 避免传递给线
      delete cloneStyle.outlineColor;
      delete cloneStyle.outlineOpacity;
      delete cloneStyle.outlineWidth;
      delete cloneStyle.outlineStyle;

      return {
        ...cloneStyle,
        show: style.outline ?? false,
        color: style.outlineColor ?? Cesium__namespace.Color.WHITE,
        opacity: style.outlineOpacity,
        width: style.outlineWidth ?? 1,
        arcType: style.arcType ?? style.clampToGround ? Cesium__namespace.ArcType.GEODESIC : Cesium__namespace.ArcType.NONE,
        ...(style.outlineStyle || {}),
        ...(exStyle || {})
      }
    }

    _updateOutlineStyle(arrline, style, exStyle) {
      const outlineStyle = this._getOutlineStyle(style, exStyle);
      // logInfo("outlineStyle", outlineStyle);

      // 加上线宽
      if (
        outlineStyle.show &&
        (this.style.diffHeight ?? 0) === 0 &&
        (outlineStyle.width > 1 || style.clampToGround || this._entity_outlines?.length > 0)
      ) {
        this.entityGraphic.outline = false;

        // _outlineEx是数组，支持挖洞多边形的多个边线。
        if (this._entity_outlines) {
          for (let i = 0, len = this._entity_outlines.length; i < len; i++) {
            const polyline = this._entity_outlines[i].polyline;
            if (arrline && arrline[i]) {
              let positions = arrline[i];
              if (positions instanceof Cesium__namespace.CallbackProperty) {
                polyline.positions = positions;
              } else if (Array.isArray(positions) && positions.length > 0) {
                // 按style修改高度
                if (Cesium__namespace.defined(outlineStyle.height)) {
                  positions = setPositionsHeight(positions, outlineStyle.height);
                }
                if (Cesium__namespace.defined(outlineStyle.setHeight)) {
                  positions = setPositionsHeight(positions, outlineStyle.setHeight);
                }
                if (Cesium__namespace.defined(outlineStyle.addHeight)) {
                  positions = addPositionsHeight(positions, outlineStyle.addHeight);
                }

                polyline.positions = positions.concat(positions[0]);
              }
            }
            PolylineStyleConver.toCesiumVal(outlineStyle, polyline, true);
          }
        } else {
          if (arrline) {
            this._entity_outlines = [];
            for (let i = 0, len = arrline.length; i < len; i++) {
              let positions = arrline[i];
              const polyline = PolylineStyleConver.toCesiumVal(outlineStyle, {}, true);
              if (positions instanceof Cesium__namespace.CallbackProperty) {
                polyline.positions = positions;
              } else if (Array.isArray(positions) && positions.length > 0) {
                // 按style修改高度
                if (Cesium__namespace.defined(outlineStyle.height)) {
                  positions = setPositionsHeight(positions, outlineStyle.height);
                }
                if (Cesium__namespace.defined(outlineStyle.setHeight)) {
                  positions = setPositionsHeight(positions, outlineStyle.setHeight);
                }
                if (Cesium__namespace.defined(outlineStyle.addHeight)) {
                  positions = addPositionsHeight(positions, outlineStyle.addHeight);
                }
                polyline.positions = positions.concat(positions[0]);
              }
              const lineEx = this._createEntity({
                id: this.id + "-outline" + i,
                polyline: polyline
              });
              this.bindPickId(lineEx);
              this._entity_outlines.push(lineEx);
              if (this._state === State.ADDED) {
                this.dataSource.entities.add(lineEx);
              }
            }
          }
        }
        return true
      } else {
        if (this._entity_outlines) {
          for (let i = 0, len = this._entity_outlines.length; i < len; i++) {
            const polyline = this._entity_outlines[i].polyline;
            polyline.show = false;
          }
        }
        // 本身的outline处理
        this.entityGraphic.outline = outlineStyle.show;
        this.entityGraphic.outlineWidth = outlineStyle.width;
        if (outlineStyle.show) {
          this.entityGraphic.outlineColor = getCesiumColor(outlineStyle.color, Cesium__namespace.Color.WHITE);
        }
        return false
      }
    }

    _updateOutlineOpacity(value) {
      if (this._entity_outlines && this._entity_outlines.length > 0) {
        for (let i = 0, len = this._entity_outlines.length; i < len; i++) {
          const polyline = this._entity_outlines[i].polyline;
          // 已有globalAlpha处理的材质时
          if (Cesium__namespace.defined(polyline?.material?.globalAlpha)) {
            polyline.material.globalAlpha = value;
          } else {
            this._updateOutlineStyle(null, this.style);
          }
        }
      }
      if (this.entityGraphic?.outline && this.entityGraphic.outline.getValue()) {
        const color = getCesiumColor(this.entityGraphic.outlineColor, Cesium__namespace.Color.WHITE);
        if (!Cesium__namespace.defined(this.entityGraphic._outlineColor_alpha)) {
          this.entityGraphic._outlineColor_alpha = color.alpha;
        }
        this.entityGraphic.outlineColor = color.withAlpha(this.entityGraphic._outlineColor_alpha * value);
      }
    }

    _updateOutlineToCallback() {
      if (this._entity_outlines) {
        for (let i = 0, len = this._entity_outlines.length; i < len; i++) {
          const entity = this._entity_outlines[i];
          if (entity.polyline.positions instanceof Cesium__namespace.CallbackProperty) {
            continue
          }

          entity.polyline.positions = new Cesium__namespace.CallbackProperty((time) => {
            return this.outlinePositions
          }, false);
        }
      }
    }

    // 坐标CallbackProperty属性改为实际值
    _cancelOutlinePositionsCallback() {
      if (this._entity_outlines) {
        for (let i = 0, len = this._entity_outlines.length; i < len; i++) {
          const entity = this._entity_outlines[i];
          if (!(entity.polyline.positions instanceof Cesium__namespace.CallbackProperty)) {
            continue
          }
          entity.polyline.positions = this.outlinePositions;
        }
      }
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this.style.globalAlpha = value;

      const result = this._updateEntityOpacity(this.entityGraphic, value);
      if (result) {
        this._updateLabelOpacity(value);
        this._updateOutlineOpacity(value);
        this._updateExOpacity && this._updateExOpacity(value);
        return
      }
      super.setOpacity(value);
    }

    _updateEntityOpacity(entityGraphic, value) {
      const material = entityGraphic?.material;
      if (!material) {
        return false
      }

      // 已有globalAlpha处理的材质时
      if (Cesium__namespace.defined(material?.globalAlpha)) {
        material.globalAlpha = value;
        return true
      }

      // 纯色时
      if (material._mars_type === "Color" || material._mars_type === "Image") {
        const color = getCesiumColor(material.color, Cesium__namespace.Color.WHITE);
        if (!Cesium__namespace.defined(material._color_alpha)) {
          material._color_alpha = color.alpha;
        }
        material.color = color.withAlpha(material._color_alpha * value);
        return true
      }
      return false
    }

    /**
     *
     * 高亮闪烁 Enity实体对象
     * @export
     * @param {Object} options 参数
     * @param {Number} [options.time] 闪烁的时长(秒)，未设置时不自动停止。
     * @param {Cesium.Color} [options.color=Cesium.Color.YELLOW] 高亮的颜色
     * @param {Number} [options.maxAlpha=0.3] 闪烁的最大透明度，从 0 到 maxAlpha 渐变
     * @param {Function} [options.onEnd] 播放完成后的回调方法
     * @return {FlickerEntity} 高亮闪烁控制 对象
     */
    startFlicker(options) {
      if (!this.flickerEntity) {
        this.flickerEntity = new FlickerEntity();
      }
      const arr = this.czmObjectEx.concat(this.czmObject);
      this.flickerEntity.startFlicker(arr, options);
      return this.flickerEntity
    }

    /**
     * 停止高亮闪烁
     * @return {void}  无
     */
    stopFlicker() {
      if (this.flickerEntity) {
        return this.flickerEntity.stopFlicker()
      } else {
        return null
      }
    }

    //= =================Draw绘制相关=================
    /**
     * 开始绘制矢量数据，绘制的数据会加载在layer图层。
     *
     * @param {GraphicLayer} layer 图层
     * @return {void}  无
     */
    startDraw(layer) {
      if (this._enabledDraw) {
        return this
      }
      this._enabledDraw = true;

      if (layer) {
        this.addTo(layer);
      }
      if (!this._map) {
        throw new Error("绘制时_map不能为空,请将对象添加到图层，并且图层已添加到Map")
      }

      this._map.mouseEvent.noPickEntity = this._entity;
      this._map._setEditCursor(true);
      this.enableControl(false);

      this._setPositionsToCallback();
      this._startDrawHook();

      this.fire(
        EventType.drawStart,
        {
          drawtype: this.type,
          graphic: this
        },
        true
      );
    }

    /**
     * 停止绘制
     * @return {void}  无
     */
    stopDraw() {
      if (!this._enabledDraw) {
        return this
      }

      this._stopDrawHook();
      this._updateLabelPosition();

      this._map._setEditCursor(false);
      this.enableControl(true);
      this._map.closeSmallTooltip();
      this._map.mouseEvent.noPickEntity = null;

      this._enabledDraw = false;

      if (!this._position_draw && (!this._positions_draw || this._positions_draw?.length === 0)) {
        this.remove(true);
        return undefined
      }

      if (this._positions_draw && this._positions_draw.length < this._minPointNum) {
        this.remove(true);
        return undefined
      }

      if (this._layer.options.isRestorePositions) {
        this._cancelPositionsCallback(); // 坐标CallbackProperty属性改为实际值,提高效率
      }

      this.fire(EventType.drawCreated, { drawtype: this.type, positions: this._positions_draw }, true);

      if (this.options?.success) {
        this.options.success(this);
      }
      if (this.options?._promise?.resolve) {
        this.options._promise.resolve(this);
      }
    }

    _setPositionsToCallback() {}

    _cancelPositionsCallback() {}

    _startDrawHook() {}

    _stopDrawHook() {}

    _showDrawMouseMoveSmallTooltip(event) {
      const position = event.endPosition;
      if (this._positions_draw.length <= 1) {
        this._map.openSmallTooltip(position, this._map.getLangText("_单击开始绘制"));
      } else if (this._positions_draw.length < this._minPointNum) {
        // 点数不满足最少数量
        this._map.openSmallTooltip(position, this._map.getLangText("_单击增加点"));
      } else if (this._positions_draw.length >= this._maxPointNum) {
        // 点数满足最大数量
        this._map.openSmallTooltip(position, this._map.getLangText("_单击完成绘制"));
      } else {
        let tooltip;
        if (isPCBroswer()) {
          tooltip =
            this._map.getLangText("_单击增加点") + ", " + this._map.getLangText("_右击删除点") + "<br/>" + this._map.getLangText("_双击完成绘制");
        } else {
          tooltip = this._map.getLangText("_单击增加点");
        }
        this._map.openSmallTooltip(position, tooltip);
      }
    }

    // 鼠标移动
    _onMouseMoveHandler(event) {
      this._showDrawMouseMoveSmallTooltip(event);

      const point = event.cartesian;
      if (point) {
        if (this.lastPointTemporary) {
          this._positions_draw.pop();
        }
        this.lastPointTemporary = true;

        this._positions_draw.push(point);
        this.updateAttrForDrawing(false);

        this.fire(EventType.drawMouseMove, { ...event, drawtype: this.type, positions: this._positions_draw }, true);
      }
    }

    _onClickHandler(event) {
      // 下面代码是 避免双击带来的2次click事件
      const times = new Date().getTime() - (this._last_clickTime || 0);
      if (this._last_clickTime && times < 200) {
        // console.log('屏蔽了单击时间很近的点')
        return
      }
      this._last_clickTime = new Date().getTime();

      if (
        this._last_clickPositionX &&
        Math.abs(this._last_clickPositionX - event.windowPosition.x) < 10 &&
        Math.abs(this._last_clickPositionY - event.windowPosition.y) < 10
      ) {
        // console.log('屏蔽了单击像素很近的点')
        return
      }
      this._last_clickPositionX = event.windowPosition.x;
      this._last_clickPositionY = event.windowPosition.y;
      // 上面代码是 避免双击带来的2个重复点

      let point = event.cartesian;

      if (!point && this.lastPointTemporary) {
        // 如果未拾取到点，并且存在MOUSE_MOVE时，取最后一个move的点
        point = this._positions_draw[this._positions_draw.length - 1];
      }

      if (point) {
        if (this.lastPointTemporary) {
          this._positions_draw.pop();
        }
        this.lastPointTemporary = false;

        this.removeNearPoint(); // 消除双击带来的多余经纬度

        // 在绘制点基础自动增加高度
        if (this.options?.addHeight) {
          point = addPositionsHeight(point, this.options.addHeight);
        }

        this._positions_draw.push(point);
        this.updateAttrForDrawing(false);

        this.fire(EventType.drawAddPoint, { ...event, drawtype: this.type, positions: this._positions_draw }, true);

        if (this._positions_draw.length >= this._maxPointNum) {
          // 点数满足最大数量，自动结束
          this.stopDraw();
        }
      }
    }

    _onRightClickHandler(event) {
      // 右击删除上一个点
      this._positions_draw.pop(); // 删除最后标的一个点

      const point = event.cartesian;
      if (point) {
        if (this.lastPointTemporary) {
          this._positions_draw.pop();
        }
        this.lastPointTemporary = true;

        this.fire(EventType.drawRemovePoint, { ...event, drawtype: this.type, positions: this._positions_draw }, true);

        this._positions_draw.push(point);
        this.updateAttrForDrawing(false);
      }
    }

    _onDbClickHandler(event) {
      // 双击结束标绘
      this.removeNearPoint(); // 消除双击带来的多余经纬度
      this.endDraw();
    }

    /**
     * 移除绘制的坐标中的重复点，比如快速单击或双击产生的冗余坐标。
     * @return {void}  无
     */
    removeNearPoint() {
      if (this._positions_draw.length < 3) {
        return
      }
      // 消除双击带来的多余经纬度
      for (let i = this._positions_draw.length - 1; i > 0; i--) {
        const mpt1 = this._positions_draw[i];
        const mpt2 = this._positions_draw[i - 1];

        const distance = Cesium__namespace.Cartesian3.distance(mpt1, mpt2);
        if (distance < 0.01) {
          this._positions_draw.splice(i, 1);
        } else {
          break
        }
      }
    }

    /**
     * 完成绘制和编辑，如有未完成的绘制会自动完成。
     * 在移动端需要调用此方法来类似PC端双击结束。
     * @return {boolean}  是否正常结束了矢量对象绘制
     */
    endDraw() {
      if (!this._enabledDraw) {
        return false
      }
      // 点数不够
      if (this._positions_draw.length < this._minPointNum) {
        return false
      }

      this.updateAttrForDrawing(false);
      this.stopDraw();

      return true
    }

    updateAttrForDrawing(isEditing) {}

    //= =================Draw编辑相关=================
    /**
     * 开始编辑对象
     * @return {void}  无
     */
    startEditing() {
      if (this._enabledEdit) {
        return this
      }
      this._enabledEdit = true;

      if (!this._map) {
        throw new Error("编辑时_map不能为空,请将对象添加到图层，并且图层已添加到Map")
      }

      this._map.mouseEvent.noPickEntity = this._entity;
      this._map.mouseEvent.enabledMoveTarget = false;

      if (!this.editing) {
        this.editing = new this.EditClass(this);
      }

      if (this.editing.activate) {
        this.editing.activate();
      }

      if (this._isCallbackPositions) {
        this._updateDistanceDisplayConditionByEdit();
      }
    }

    /**
     * 停止编辑，释放正在编辑的对象。
     * @return {void}  无
     */
    stopEditing() {
      if (!this._enabledEdit || !this.isAdded) {
        return this
      }

      if (this.editing?.disable) {
        this.editing.disable();
      }

      if (!this.options) {
        return
      }

      if (this.style.distanceDisplayCondition) {
        this._updateDistanceDisplayConditionByEdit();
      }

      if (this._stopEditingHook) {
        this._stopEditingHook();
      }

      if (this._map) {
        this._map.closeSmallTooltip();
        this._map.mouseEvent.noPickEntity = null;
        this._map.mouseEvent.enabledMoveTarget = true;
      }
      this._enabledEdit = false;
    }
  }

  /**
   * Primitive图元 矢量对象 基类
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 【点状】矢量数据时的坐标位置，具体看子类实现
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 【线面状（多点）】矢量数据时的坐标位置，具体看子类实现
   * @param {Object} options.style 矢量数据的 样式信息，具体见各类数据的说明
   * @param {Object} [options.attr] 矢量数据的 属性信息，可以任意附加属性。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class BasePrimitive
   * @extends {BaseGraphic}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BasePrimitive extends BaseGraphic {
    // 内部用
    get czmObject() {
      return this._primitive
    }

    // 内部用，文本等附加对象
    get czmObjectEx() {
      const arr = [];
      if (this._primitive_label) {
        arr.push(this._primitive_label);
      }
      if (this._primitive_outline) {
        arr.push(this._primitive_outline);
      }
      return arr
    }

    /**
     * 当加载primitive数据的内部Cesium容器
     * @type {Cesium.PrimitiveCollection|Cesium.LabelCollection|Cesium.BillboardCollection|Cesium.PointPrimitiveCollection|Cesium.CloudCollection}
     */
    get primitiveCollection() {
      return this._layer?.primitiveCollection
    }

    /**
     *
     * 矢量数据对应的 Cesium内部对象
     * @type {Cesium.Primitive|Cesium.GroundPrimitive|Cesium.ClassificationPrimitive|*}
     * @readonly
     */
    get primitive() {
      return this._primitive
    }

    /**
     * 返回实例可修改的属性。{@link Cesium.GeometryInstance}
     *
     * @type {Object}
     * @readonly
     * @memberof BasePrimitive
     * @exception {DeveloperError} 在调用getGeometryInstanceAttributes之前必须调用update。
     *
     * @example
     * var attributes = primitiveGraphic.geometryInstanceAttributes;
     * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
     * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
     */
    get geometryInstanceAttributes() {
      if (this._primitive?.getGeometryInstanceAttributes) {
        return this._primitive.getGeometryInstanceAttributes(this.id)
      } else if (this._primitive_outline?.getGeometryInstanceAttributes) {
        return this._primitive_outline.getGeometryInstanceAttributes(this.id)
      }
      return null
    }

    /**
     * 对应材质的uniforms（当赋有材质时）,
     * 一个对象，它的属性被用来设置片段着色器shader。
     * <p>
     * 对象属性值可以是常量或函数。这个函数将在每一帧后处理阶段执行之前被调用。
     * </p>
     * <p>
     *  常量值也可以是图像的URI、数据URI，或者可以用作纹理的HTML元素，如HTMLImageElement或HTMLCanvasElement。
     * </p>
     * @type {Object|undefined}
     * @readonly
     */
    get uniforms() {
      return this.primitive?.appearance?.material?.uniforms
    }

    /**
     *
     * 附加的label文本对象
     * @type {Cesium.Label|*}
     * @readonly
     */
    get label() {
      if (this._primitive_label) {
        return this._primitive_label
      } else {
        return this.style.label // 尚未添加primitive时
      }
    }

    /**
     * 是否正在编辑状态，不是所有子类均支持编辑
     * @type {Boolean}
     * @readonly
     */
    get isEditing() {
      return this._enabledEdit
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show) {
        return
      }

      if (!style.material && !style.materialType) {
        // 没有类型时，如果有对应的属性值，即视为对应的类型
        if (style.color || style.randomColor) {
          style.materialType = Color$2;
        } else if (style.image) {
          style.materialType = Image$1;
        }
      }

      const addattr = this._conversionStyle(style);
      addattr._isColorMaterial = true; // 是否纯色材质
      const materialType = style.materialType || addattr?.materialType || addattr?.material?.type;
      if (Cesium__namespace.defined(materialType) && materialType !== Color$2) {
        addattr._isColorMaterial = false;
      }

      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
      }
      if (style.fill ?? true) {
        this._primitive = this._createPrimitive(addattr);
      }

      // 添加边线
      if (style.outline) {
        if (this._primitive_outline) {
          this.primitiveCollection.remove(this._primitive_outline);
        }

        const outlineStyle = this._getOutlineStyle(style);
        if ((outlineStyle.width > 1 && (this.style.diffHeight ?? 0) === 0) || outlineStyle.clampToGround) {
          this._primitive_outline = this._createPolylineOutline(outlineStyle);
        } else {
          addattr.outlineStyle = outlineStyle;
          this._primitive_outline = this._createPrimitive(addattr, true);
        }
      }

      // 同时加文字
      if (style.label) {
        this._addLabel();
      }
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (!this._noDestroy) {
        this.stopDraw();
        this.stopEditing();
      }

      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
        delete this._primitive;
      }
      if (this._primitive_outline) {
        this.primitiveCollection.remove(this._primitive_outline);
      }
      if (this._primitive_label) {
        this._layer.labelCollection.remove(this._primitive_label);
      }
    }

    _showHook(val) {
      if (val) {
        this._addedHook(this.style);

        if (this.czmObject) {
          this.bindPickId(this.czmObject);
        }
        if (this.czmObjectEx) {
          this.czmObjectEx.forEach((item) => {
            this.bindPickId(item);
          });
        }
      } else {
        this._noDestroy = true;
        this._removedHook();
        this._noDestroy = false;
      }
    }

    // 子类需要继承实现
    _conversionStyle(style) {
      return style
    }

    // 创建主体primitive
    _createPrimitive(addattr, outline) {
      if ((!addattr.vertexFormat && addattr._isColorMaterial) || outline) {
        addattr.vertexFormat = this.defaultVertexFormat || Cesium__namespace.PerInstanceColorAppearance.VERTEX_FORMAT;
      }

      const primitiveOpts = {
        ...this.options,
        geometryInstances: this._createGeometryInstance(addattr, outline),
        show: this.show,
        shadows: addattr.shadows // Primitive支持
      };
      delete primitiveOpts.style;
      delete primitiveOpts.attr;

      // attributes
      primitiveOpts.geometryInstances.attributes = primitiveOpts.geometryInstances.attributes || {};
      primitiveOpts.geometryInstances.attributes.show = new Cesium__namespace.ShowGeometryInstanceAttribute(this.show);
      if (addattr.distanceDisplayCondition) {
        primitiveOpts.geometryInstances.attributes.distanceDisplayCondition = addattr.distanceDisplayCondition;
      }

      if (!primitiveOpts.appearance) {
        primitiveOpts.appearance = this._createAppearance(addattr, primitiveOpts, outline);
      }
      if (addattr.depthFail && !primitiveOpts.depthFailAppearance) {
        primitiveOpts.depthFailAppearance = this._createAppearance(addattr, primitiveOpts, outline);
      }

      let primitive;
      if (this.style.clampToGround) {
        primitiveOpts.classificationType = addattr.classificationType;
        if (this.type === "polylineP" || this.type === "polylineCombine") {
          primitive = this.primitiveCollection.add(new Cesium__namespace.GroundPolylinePrimitive(primitiveOpts));
        } else {
          primitive = this.primitiveCollection.add(new Cesium__namespace.GroundPrimitive(primitiveOpts));
        }
      } else if (addattr.classification) {
        primitiveOpts.classificationType = addattr.classificationType || Cesium__namespace.ClassificationType.CESIUM_3D_TILE;
        primitive = this.primitiveCollection.add(new Cesium__namespace.ClassificationPrimitive(primitiveOpts));
      } else {
        primitive = this.primitiveCollection.add(new Cesium__namespace.Primitive(primitiveOpts));
      }
      this.bindPickId(primitive);
      return primitive
    }

    // 纯色时的颜色值
    _getColorByColorMaterial(addattr, defaultVal = Cesium__namespace.Color.WHITE.withAlpha(0.5)) {
      return addattr.material?.uniforms?.color || addattr.material?.options?.color || addattr.color || defaultVal
    }

    _createAppearance(addattr, primitiveOpts, outline) {
      if (addattr.material && !addattr._isColorMaterial && !outline) {
        // 存在材质时

        return new Cesium__namespace.MaterialAppearance({ ...addattr })
      } else {
        // 纯色时
        if (primitiveOpts.geometryInstances instanceof Cesium__namespace.GeometryInstance) {
          let color;
          if (outline && addattr.outlineStyle) {
            color = getColorByStyle(addattr.outlineStyle, Cesium__namespace.Color.WHITE);
          } else {
            color = this._getColorByColorMaterial(addattr);
          }

          addattr.translucent = color.alpha !== 1;

          primitiveOpts.geometryInstances.attributes = primitiveOpts.geometryInstances.attributes || {};
          primitiveOpts.geometryInstances.attributes.color = Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color);
          if (addattr.depthFail) {
            primitiveOpts.geometryInstances.attributes.depthFailColor = Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(addattr.depthFailColor || color);
          }
        }

        // 合并渲染等对象，内部计算得到translucent
        if (Cesium__namespace.defined(this.translucent)) {
          addattr.translucent = this.translucent;
        }
        return new Cesium__namespace.PerInstanceColorAppearance({ ...addattr })
      }
    }

    // 子类需要继承实现
    _createGeometryInstance(addattr, outline) {
      return this.options.geometryInstances
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 本次更新的部分样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleBaseHook(newStyle) {
      if (!newStyle) {
        return
      }

      if (this.czmObject) {
        this._updateLabelStyleHook(this.style, newStyle);
        if (this._updateExOpacity && Cesium__namespace.defined(newStyle.globalAlpha)) {
          this._updateExOpacity(newStyle.globalAlpha);
        }
        this._updateStyleHook(this.style, newStyle);
      }

      if (this._editing_entity) {
        this._editing_entity.setStyle(newStyle);
      }
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      if (style.materialType === Color$2 && (Cesium__namespace.defined(newStyle.color) || Cesium__namespace.defined(newStyle.opacity))) {
        const color = getColorByStyle(style);
        if (color) {
          const result = this._updatePrimitiveForColorMaterial(this._primitive, color, style);
          if (result) {
            if (this._primitive_outline && Cesium__namespace.defined(newStyle.outline)) {
              const outlineStyle = this._getOutlineStyle(style);
              const result = this._updatePrimitiveForColorMaterial(this._primitive_outline, getCesiumColor(outlineStyle.color), style);
              if (result) {
                return
              }
            } else {
              return
            }
          }
        }
      }

      this.redraw(style);
    }

    _updatePrimitiveForColorMaterial(primitive, newColor, style) {
      if (!primitive) {
        return false
      }

      //
      const uniforms = primitive?.appearance?.material?.uniforms;
      if (Cesium__namespace.defined(uniforms?.color) && primitive.appearance.material.type === Color$2) {
        primitive.appearance.translucent = newColor.alpha !== 1;
        uniforms.color = newColor;
        return true
      }

      // 纯色时
      if (primitive?.getGeometryInstanceAttributes) {
        const attributes = primitive.getGeometryInstanceAttributes(this.id);
        if (attributes?.color) {
          attributes.color = Cesium__namespace.ColorGeometryInstanceAttribute.toValue(newColor);
          if (attributes.depthFailColor && (style.depthFailColor || style.depthFail)) {
            attributes.depthFailColor = Cesium__namespace.ColorGeometryInstanceAttribute.toValue(getCesiumColor(style.depthFailColor, newColor));
          }
          return true
        }
      }

      return false
    }

    /**
     * 设置透明度, 不是所有类型均支持调整透明度，主要看数据类型和材质类型决定。
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this.style.globalAlpha = value;

      const result = this._updatePrimitiveOpacity(this._primitive, value);
      if (result) {
        this._updatePrimitiveOpacity(this._primitive_outline, value);
        this._updateLabelOpacity(value);
        this._updateExOpacity && this._updateExOpacity(value);
        return
      }

      super.setOpacity(value);
    }

    _updatePrimitiveOpacity(primitive, value) {
      if (!primitive) {
        return false
      }

      try {
        // 已有globalAlpha处理的材质时
        const uniforms = primitive?.appearance?.material?.uniforms;
        if (uniforms) {
          if (Cesium__namespace.defined(uniforms.globalAlpha)) {
            primitive.appearance.translucent = value !== 1;
            uniforms.globalAlpha = value;
            return true
          }

          // 纯色时,uniforms方式
          if ((primitive.appearance.material.type === Color$2 || primitive.appearance.material.type === Image$1) && Cesium__namespace.defined(uniforms.color)) {
            if (!Cesium__namespace.defined(primitive._uniforms_color_alpha)) {
              primitive._uniforms_color_alpha = uniforms.color.alpha;
            }
            uniforms.color.alpha = primitive._uniforms_color_alpha * value;
            primitive.appearance.translucent = uniforms.color.alpha !== 1;
            return true
          }

          //
          if (primitive.appearance.material.type === Water$1) {
            if (!Cesium__namespace.defined(primitive._uniforms_baseWaterColor_alpha)) {
              primitive._uniforms_baseWaterColor_alpha = uniforms.baseWaterColor.alpha;
              primitive._uniforms_blendColor_alpha = uniforms.blendColor.alpha;
            }
            if (this.globalAlpha !== 1) {
              uniforms.baseWaterColor.alpha = primitive._uniforms_baseWaterColor_alpha * value;
              uniforms.blendColor.alpha = primitive._uniforms_blendColor_alpha * value;
            }
            return true
          }
        }

        // 纯色时,attributes方式
        if (primitive?.getGeometryInstanceAttributes) {
          const attributes = primitive.getGeometryInstanceAttributes(this.id);
          if (attributes?.color) {
            if (!Cesium__namespace.defined(primitive._attributes_color_alpha)) {
              primitive._attributes_color_alpha = attributes.color[3] / 255;
            }
            const alpha = primitive._attributes_color_alpha * value;
            attributes.color = new Uint8Array([attributes.color[0], attributes.color[1], attributes.color[2], Cesium__namespace.Color.floatToByte(alpha)]);
            primitive.appearance.translucent = alpha !== 1;

            if (attributes.depthFailColor) {
              if (!Cesium__namespace.defined(primitive._attributes_depthFailColor_alpha)) {
                primitive._attributes_depthFailColor_alpha = attributes.depthFailColor[3] / 255;
              }
              attributes.depthFailColor = new Uint8Array([
                attributes.depthFailColor[0],
                attributes.depthFailColor[1],
                attributes.depthFailColor[2],
                Cesium__namespace.Color.floatToByte(primitive._attributes_depthFailColor_alpha * value)
              ]);
            }
            return true
          }
        }
      } catch (error) {
        //
      }

      return false
    }

    _updateLabelOpacity(value) {
      if (this._primitive_label && this._primitive_label.show) {
        LabelStyleConver.setOpacity(this._primitive_label, value);
      }
    }

    /**
     * 重新渲染
     * @param {Object} [style] 新的样式信息
     * @returns {BasePrimitive} 当前对象本身
     * @memberof BasePrimitive
     */
    redraw(style) {
      if (this.isAdded && this.show) {
        this._noDestroy = true;
        this._removedHook();
        this._noDestroy = false;

        this._addedHook(style || this.style);

        if (this.czmObject) {
          this.bindPickId(this.czmObject);
        }
        if (this.czmObjectEx) {
          this.czmObjectEx.forEach((item) => {
            this.bindPickId(item);
          });
        }
      }
      return this
    }

    _updatePositionsHook() {
      this.redraw();
    }

    _updateLabelStyleHook(style, newStyle) {
      // 同时加文字
      if (newStyle?.label) {
        if (this._primitive_label) {
          LabelStyleConver.toCesiumVal(style.label, this._primitive_label, this.attr);
          if (Cesium__namespace.defined(newStyle?.label?.height) || Cesium__namespace.defined(newStyle?.label?.addHeight) || Cesium__namespace.defined(newStyle?.label?.setHeight)) {
            this._updateLabelPosition();
          }
        } else {
          this._addLabel();
        }
      } else if (Cesium__namespace.defined(newStyle?.globalAlpha)) {
        this._updateLabelOpacity(newStyle.globalAlpha);
      }
    }

    // 添加线面的文本的统一方法
    _addLabel() {
      const style = this.style.label;

      if (!style || !style.text) {
        return
      }

      if (Cesium__namespace.defined(this.style.clampToGround) && !Cesium__namespace.defined(style.clampToGround) && !Cesium__namespace.defined(style.height)) {
        style.clampToGround = this.style.clampToGround;
      }
      const labelattr = LabelStyleConver.toCesiumVal(style, {}, this.attr);
      labelattr.show = this.show;
      labelattr.position = this._getLablePosition();

      if (this._primitive_label) {
        this._layer.labelCollection.remove(this._primitive_label);
      }
      this._primitive_label = this._layer.labelCollection.add(labelattr);
      this.bindPickId(this._primitive_label);
      return this._primitive_label
    }

    _updateLabelPosition() {
      if (this._primitive_label && !this._primitive_label.isDestroyed()) {
        this._primitive_label.position = this._getLablePosition();
      }
    }

    // 根据配置获取文本的坐标位置
    _getLablePosition() {
      const style = this.style.label;

      let position;
      if (style.position) {
        if (style.position === "center") {
          position = this.centerOfMass;
        } else {
          if (isString(style.position)) {
            const cfgPt = template(style.position, this.attr, true);
            if (cfgPt) {
              position = LngLatPoint.parse(cfgPt).toCartesian();
            }
          } else {
            position = LngLatPoint.parse(style.position).toCartesian();
          }
        }
      }

      if (!position) {
        position = this.center;
      }

      if (!position) {
        return new Cesium__namespace.Cartesian3()
      }

      if (Cesium__namespace.defined(style.height) || Cesium__namespace.defined(this.style.height)) {
        const height = style.height ?? this.style.height;
        position = setPositionsHeight(position, height);
      }
      // 存在垂直高度
      if (Cesium__namespace.defined(this.style.diffHeight)) {
        position = addPositionsHeight(position, this.style.diffHeight);
      }

      let setHeight = style.setHeight;
      if (Cesium__namespace.defined(setHeight)) {
        if (isString(setHeight)) {
          setHeight = Number(template(setHeight, this.attr, true));
          if (isNaN(setHeight)) {
            setHeight = 0;
          }
        }
        position = setPositionsHeight(position, setHeight);
      }
      let addHeight = style.addHeight;
      if (Cesium__namespace.defined(addHeight)) {
        if (isString(addHeight)) {
          addHeight = Number(template(addHeight, this.attr, true));
          if (isNaN(addHeight)) {
            addHeight = 0;
          }
        }
        position = addPositionsHeight(position, addHeight);
      }
      return position
    }

    _getOutlineStyle(style, exStyle) {
      const cloneStyle = { ...style };
      delete cloneStyle.material;
      delete cloneStyle.materialType;
      delete cloneStyle.materialOptions;
      delete cloneStyle.outline; // 避免传递给线
      delete cloneStyle.outlineColor;
      delete cloneStyle.outlineOpacity;
      delete cloneStyle.outlineWidth;
      delete cloneStyle.outlineStyle;

      return {
        ...cloneStyle,
        show: style.outline ?? false,
        color: style.outlineColor ?? Cesium__namespace.Color.WHITE,
        opacity: style.outlineOpacity,
        width: style.outlineWidth ?? 1,
        arcType: style.arcType ?? style.clampToGround ? Cesium__namespace.ArcType.GEODESIC : Cesium__namespace.ArcType.NONE,
        ...(style.outlineStyle || {}),
        ...(exStyle || {})
      }
    }

    // 边线坐标数组，支持多个线 [线坐标集合]
    _getPolylineOutlinePositions() {
      return [this.positions]
    }

    // 创建Polyline的outline对象
    _createPolylineOutline(outlineStyle) {
      const polyline = PolylineStyleConver.toCesiumVal(outlineStyle);
      const GeometryClass = polyline.clampToGround ? Cesium__namespace.GroundPolylineGeometry : Cesium__namespace.PolylineGeometry;

      const arrInstance = [];
      const arrline = this._getPolylineOutlinePositions();
      for (let i = 0, len = arrline.length; i < len; i++) {
        // 坐标
        let positions = arrline[i];
        if (!positions || positions.length === 0) {
          continue
        }

        // 按style修改高度
        if (Cesium__namespace.defined(outlineStyle.height)) {
          positions = setPositionsHeight(positions, outlineStyle.height);
        }
        if (Cesium__namespace.defined(outlineStyle.setHeight)) {
          positions = setPositionsHeight(positions, outlineStyle.setHeight);
        }
        if (Cesium__namespace.defined(outlineStyle.addHeight)) {
          positions = addPositionsHeight(positions, outlineStyle.addHeight);
        }

        if (positions.length > 0) {
          positions = positions.concat(positions[0]);
        }

        // 属性
        const addattr = { ...polyline };
        addattr.positions = positions;

        if (!addattr.material || addattr.material.type === "Color") {
          addattr.vertexFormat = Cesium__namespace.PolylineColorAppearance.VERTEX_FORMAT;
        }
        const color = this._getColorByColorMaterial(addattr);
        const instance = new Cesium__namespace.GeometryInstance({
          id: this.id,
          geometry: new GeometryClass(addattr),
          attributes: {
            color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
            distanceDisplayCondition: polyline.distanceDisplayCondition,
            show: new Cesium__namespace.ShowGeometryInstanceAttribute(this.show)
          }
        });

        arrInstance.push(instance);
      }

      if (arrInstance.length === 0) {
        return
      }

      const primitiveOpts = {
        ...this.options,
        geometryInstances: arrInstance,
        show: this.show,
        shadows: polyline.shadows // Primitive支持
      };
      delete primitiveOpts.style;
      delete primitiveOpts.attr;

      // 存在材质时
      if (polyline.material && !polyline.classification) {
        primitiveOpts.appearance = new Cesium__namespace.PolylineMaterialAppearance({
          ...polyline
        });
      } else {
        primitiveOpts.appearance = new Cesium__namespace.PolylineColorAppearance({
          ...polyline
        });
      }

      let primitive;
      if (this.style.clampToGround) {
        primitiveOpts.classificationType = polyline.classificationType;
        primitive = this.primitiveCollection.add(new Cesium__namespace.GroundPolylinePrimitive(primitiveOpts));
      } else {
        primitive = this.primitiveCollection.add(new Cesium__namespace.Primitive(primitiveOpts));
      }
      this.bindPickId(primitive);
      return primitive
    }

    /**
     * 高亮对象。
     * @param {Object} [highlightStyle] 高亮的样式，具体见各{@link GraphicType}矢量数据的style参数。
     * @param {Boolean} [closeLast=true] 是否清除地图上上一次的高亮对象
     * @return {void}  无
     */
    openHighlight(highlightStyle, closeLast = true) {
      if (closeLast) {
        this._map.closeHighlight();
        this._map.last_highlighGraphic = this;
      }
      const style = highlightStyle || this._highlightOptions || this._layer?._highlightOptions;
      if (style) {
        const styleAll = merge({}, this.style, style);
        this._updateStyleHook(styleAll, style);
        this._updateLabelStyleHook(styleAll, style);
        this.fire(EventType.highlightOpen, {}, true);
      }
    }

    /**
     * 清除已选中的高亮，原有style的配置项需要与highlightStyle配置有一一对应关系，否则无法清除
     * @return {void}  无
     */
    closeHighlight() {
      if (this._state !== State.ADDED || this._map?.last_highlighGraphic !== this) {
        return
      }

      this._updateStyleHook(this.style, this.style);
      this._updateLabelStyleHook(this.style, this.style);

      this._map._clearLastHighlight();

      this.fire(EventType.highlightClose, {}, true);
    }

    // 部分自定义DrawCommand对象时使用,根据样式替换FS
    _replaceFragmentShaderSourceByStyle(shaderSource) {
      if (this.style.flat) {
        shaderSource = "#define FLAT\n" + shaderSource;
      }
      if (this.style.faceForward) {
        shaderSource = "#define FACE_FORWARD\n" + shaderSource;
      }
      return shaderSource
    }

    //= =================Draw绘制相关=================
    /**
     * 开始绘制矢量数据，绘制的数据会加载在layer图层。
     *
     * @param {GraphicLayer} layer 图层
     * @return {void}  无
     */
    startDraw(layer) {
      if (!this._getDrawEntityClass) {
        logInfo("对象不支持标绘", this);
        return
      }

      if (this._enabledDraw) {
        return this
      }
      this._enabledDraw = true;

      this.show = false;
      if (layer) {
        this.addTo(layer);
      }
      if (!this._map) {
        throw new Error("绘制时_map不能为空,请将对象添加到图层，并且图层已添加到Map")
      }

      // 构造绘制使用的Entity对象
      this._editing_entity = this._getDrawEntityClass(
        {
          minPointNum: this.options.minPointNum,
          maxPointNum: this.options.maxPointNum,
          style: this._getDrawEntityStyle(), // 样式
          private: true
        },
        true
      );
      this._editing_entity.parent = this;
      this._editing_entity.once(EventType.drawCreated, (event) => {
        this.stopDraw();
      });
      this._editing_entity.on([EventType.drawAddPoint, EventType.drawMouseMove, EventType.drawRemovePoint], (event) => {
        event.graphic = this;
        event.drawtype = this.type;
        this.fire(event.type, event, true);
      });
      this._editing_entity.startDraw(this._map.graphicLayer);

      this.fire(EventType.drawStart, { drawtype: this.type }, true);
    }

    /**
     * 停止绘制
     * @return {void}  无
     */
    stopDraw() {
      if (!this._enabledDraw || !this._editing_entity) {
        return this
      }
      this._enabledDraw = false;

      if (!this._editing_entity.stopDraw()) {
        this.remove(true);
        return
      }

      // 获取坐标 + 销毁Entity对象
      this._updateDrawEntityToThis();

      this.fire(EventType.drawCreated, { drawtype: this.type, positions: this.positions }, true);

      // 回调事件
      if (this.options?.success) {
        this.options.success(this);
      }
      if (this.options?._promise?.resolve) {
        this.options._promise.resolve(this);
      }
    }

    /**
     * 完成绘制和编辑，如有未完成的绘制会自动完成。
     * 在移动端需要调用此方法来类似PC端双击结束。
     * @return {boolean}  是否正常结束了矢量对象绘制
     */
    endDraw() {
      if (!this._enabledDraw || !this._editing_entity) {
        return false
      }
      // 点数不够
      if (!this._editing_entity.endDraw()) {
        return false
      }
      return true
    }

    _getDrawEntityStyle() {
      const style = this._style2JsonBase(this.style, false);
      delete style.highlight;
      return style
    }

    // 通用点状编辑类
    _getDrawPointEntityClass(options, isDraw) {
      options.drawShow = !isDraw;
      options.style = getEditPointStyle();
      return create$4("point", options)
    }

    _updateDrawEntityToThis() {
      // 获取坐标 + 销毁Entity对象
      const entityJson = this._editing_entity.toJSON();
      this._editing_entity.remove(true);
      delete this._editing_entity;

      if (entityJson.style && this.type.startsWith(entityJson.type)) {
        this.options.style = merge(this.options.style, entityJson.style);
        this._updateStyleBaseHook(this.options.style);
      } else if (this._updateStyleByEdit) {
        this._updateStyleByEdit(entityJson.style, entityJson);
      }

      if (entityJson.position) {
        this.position = entityJson.position;
      } else if (entityJson.positions) {
        this.positions = entityJson.positions;
      }
      this.show = true;
    }

    /**
     * 开始编辑对象
     * @return {void}  无
     */
    startEditing() {
      if (this._enabledEdit) {
        return this
      }
      this._enabledEdit = true;

      if (!this._map) {
        throw new Error("编辑时_map不能为空,请将对象添加到图层，并且图层已添加到Map")
      }

      // 构造绘制使用的Entity对象
      this._editing_entity = this._getDrawEntityClass(
        {
          hasMoveEdit: this.options.hasMoveEdit,
          hasHeightEdit: this.options.hasHeightEdit,
          style: this._getDrawEntityStyle(),
          position: this.position, // 点数据时
          positions: this.positions, // 线面数据时
          private: true
        },
        false
      );
      if (this._startEditingHook) {
        this._startEditingHook(this._editing_entity);
      }
      this._editing_entity.parent = this;

      // 记录是否同类型
      const hasSameType = this.type.startsWith(this._editing_entity.type);

      this._editing_entity.once(EventType.editStop, (event) => {
        this.stopEditing();
      });
      this._editing_entity.on(EventType.editStyle, (event) => {
        const entityJson = this._editing_entity.toJSON();
        if (entityJson.style && hasSameType) {
          this.options.style = merge(this.options.style, entityJson.style);
        } else if (this._updateStyleByEdit) {
          this._updateStyleByEdit(entityJson.style, entityJson);
        }
      });
      this._editing_entity.on([EventType.editAddPoint, EventType.editMovePoint, EventType.editRemovePoint], (event) => {
        if (this._editing_entity._position_draw) {
          if (hasSameType) {
            this._point = LngLatPoint.parse(this._editing_entity._position_draw);
            this._position = this._editing_entity._position_draw;
          } else {
            this.position = this._editing_entity._position_draw;
          }
        } else if (this._editing_entity._positions_draw) {
          if (hasSameType) {
            this._points = LngLatArray.toPoints(this._editing_entity._positions_draw);
            this._positions = this._editing_entity._positions_draw;
          } else {
            this.positions = this._editing_entity._positions_draw;
          }
        }
      });

      this._map.graphicLayer.addGraphic(this._editing_entity);

      this._editing_entity.startEditing();
      if (hasSameType) {
        this.show = false; // 同类型的entity，隐藏primitive
      } else {
        if (this._editing_entity.type !== "point") {
          this._editing_entity.entityGraphic.show = false;
        }
      }
    }

    /**
     * 停止编辑，释放正在编辑的对象。
     * @return {void}  无
     */
    stopEditing() {
      if (!this._enabledEdit || !this._editing_entity) {
        return this
      }
      this._enabledEdit = false;

      this._updateDrawEntityToThis();
    }
  }

  /**
   *
   * 单个坐标的点状 Primitive图元 矢量对象 基类
   *
   * @param {Object} options 参数对象，包括以下：

   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
   * @param {Object} options.style 矢量数据的 样式信息，具体见各类数据的说明
   * @param {Object} [options.attr] 矢量数据的 属性信息，可以任意附加属性。
   *
   * @param {Number} [options.frameRate = 20] 当postion为CallbackProperty时，多少帧获取一次数据。用于控制效率，如果卡顿就把该数值调大一些。
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {Number} [options.maxCacheCount=50] 当使用addDynamicPosition设置为动画轨迹位置时，保留的坐标点数量
   * @param {Cesium.ExtrapolationType} [options.forwardExtrapolationType= Cesium.ExtrapolationType.HOLD]  当使用addDynamicPosition设置为动画轨迹位置时，在任何可用坐标之后一次请求值时要执行的推断类型，默认为最后一个坐标位置。
   * @param {Cesium.ExtrapolationType} [options.backwardExtrapolationType= Cesium.ExtrapolationType.HOLD] 当使用addDynamicPosition设置为动画轨迹位置时， 在任何可用坐标之前一次请求值时要执行的推断类型，默认为第一个坐标位置。
   * @param {Boolean} [options.clampToTileset] 当使用addDynamicPosition设置为动画轨迹位置时，是否进行贴模型。
   * @param {Number} [options.frameRateHeight=30] 当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，多少帧计算一次贴模型高度
   * @param {Object[]} [options.objectsToExclude]  当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class BasePointPrimitive
   * @extends {BasePrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BasePointPrimitive extends BasePrimitive {
    constructor(options = {}) {
      super(options);

      this._hasEdit = this.options.hasEdit ?? true; // 是否允许编辑

      // 坐标位置
      if (options.positions) {
        this.positions = options.positions;
      }
      if (options.position) {
        this.position = options.position;
      }
    }

    //= ============坐标相关==================
    /**
     * 位置坐标 （笛卡尔坐标）, 赋值时可以传入LatLngPoint对象
     * @type {Cesium.Cartesian3|LngLatPoint}
     */
    get position() {
      return this._position ?? this.property
    }

    set position(value) {
      if (this._forPositionProperty(value)) {
        return // 对动态属性坐标的支持
      }

      this._point = LngLatPoint.parse(value);

      // 按配置调整高度值
      if (this._point) {
        let setHeight = this.style.setHeight;
        if (Cesium__namespace.defined(setHeight)) {
          if (isString(setHeight)) {
            setHeight = Number(template(setHeight, this.attr, true));
            if (isNaN(setHeight)) {
              setHeight = 0;
            }
          }
          this._point.alt = setHeight;
        }
        const addHeight = this.getAddHeight();
        if (addHeight !== 0) {
          this._point.alt = this._point.alt + addHeight;
        }
      }

      this._position = this._point?.toCartesian();

      if (this.czmObject) {
        this._updatePositionsHook();
      }

      if (this._primitive_label) {
        this._updateLabelPosition();
      }
      this.fire(EventType.updatePosition, { position: this._position });
    }

    /**
     * 同 positions只是为了兼容entity的同名属性
     * @type {Cesium.Cartesian3[]}
     * @readonly
     */
    get positionsShow() {
      return this.positions
    }

    /**
     * 当前实时位置坐标（笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get positionShow() {
      return this._position
    }

    /**
     * 位置坐标
     * @type {LngLatPoint}
     * @readonly
     */
    get point() {
      return this._point
    }

    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @type {Array}
     * @readonly
     */
    get coordinate() {
      return this.getCoordinate()
    }

    /**
     * 中心点坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get center() {
      return this.position
    }

    /**
     * 中心点坐标
     * @type {LngLatPoint}
     * @readonly
     */
    get centerPoint() {
      return this.point
    }

    /**
     * 坐标对应的高度值（单位：米）
     * @type {Number}
     */
    get height() {
      return this.point?.alt
    }

    set height(val) {
      this.point.alt = val;
      this.position = this.point;
    }

    // 兼容线面的属性，方便标绘统一控制。 start
    get positions() {
      if (this.position) {
        return [this.position]
      } else {
        return null
      }
    }

    set positions(value) {
      if (value && value.length > 0) {
        this.position = value[0];
      }
    }

    get points() {
      return [this.point]
    }

    get coordinates() {
      return [this.coordinate]
    }
    // 兼容线面的属性，方便标绘统一控制。 end

    /**
     * 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵。
     * <br/>提示：父类属性，非所有子类都具备
     * @type {Cesium.Matrix4}
     * @readonly
     */
    get modelMatrix() {
      if (this.options.modelMatrix) {
        return this.options.modelMatrix
      } else {
        return this._getModelMatrix(this.position, this._orientation)
      }
    }

    /**
     * 四周方向角，0-360度角度值
     * <br/>提示：父类属性，非所有子类都具备
     * @type {Number}
     */
    get heading() {
      if (Cesium__namespace.defined(this._heading_reality)) {
        return Cesium__namespace.Math.toDegrees(this._heading_reality)
      }
      return this.style.heading ?? 0
    }

    set heading(val) {
      this.style.heading = val;
      this.updateModelMatrix();
    }

    /**
     * 俯仰角，上下摇摆的角度，0-360度角度值
     * <br/>提示：父类属性，非所有子类都具备
     * @type {Number}
     */
    get pitch() {
      if (Cesium__namespace.defined(this._pitch_reality)) {
        return Cesium__namespace.Math.toDegrees(this._pitch_reality)
      }
      return this.style.pitch ?? 0
    }

    set pitch(val) {
      this.style.pitch = val;
      this.updateModelMatrix();
    }

    /**
     * 滚转角，左右摆动的角度，0-360度角度值
     * <br/>提示：父类属性，非所有子类都具备
     * @type {Number}
     */
    get roll() {
      if (Cesium__namespace.defined(this._roll_reality)) {
        return Cesium__namespace.Math.toDegrees(this._roll_reality)
      }
      return this.style.roll ?? 0
    }

    set roll(val) {
      this.style.roll = val;
      this.updateModelMatrix();
    }

    /**
     * 贴模型分析时，排除的不进行贴模型计算的模型对象，默认是当前本身，可以是： primitives, entities 等
     * @type {Object[]|undefined}
     */
    get objectsToExclude() {
      if (this.options.objectsToExclude) {
        return this.options.objectsToExclude
      }
      if (this._primitive instanceof Cesium__namespace.Model) {
        return [this._primitive]
      }
      return undefined
    }

    set objectsToExclude(value) {
      this.options.objectsToExclude = value;
    }

    /**
     * 用于 map.trackedEntity 追踪的
     * @type {Cesium.Entity|*}
     * @readonly
     */
    get trackedEntity() {
      if (!this._trackedEntity) {
        this._trackedEntity = this._layer.dataSource.entities.add({
          position:
            this.property ||
            new Cesium__namespace.CallbackProperty((time) => {
              return this._position
            }, false),
          point: {
            pixelSize: 2,
            color: Cesium__namespace.Color.WHITE.withAlpha(0.01)
          }
        });
      }
      return this._trackedEntity
    }

    _addedHook(style) {
      if (!this.show || !this.position) {
        return
      }

      this._forPositionProperty(this.options.position); // 对动态属性坐标的支持
      super._addedHook(style);
    }

    _removedHook(style) {
      if (this._trackedEntity) {
        if (this._map.trackedEntity === this._trackedEntity) {
          this._map.trackedEntity = undefined;
        }
        this._layer.dataSource.entities.remove(this._trackedEntity);
        delete this._trackedEntity;
      }

      super._removedHook(style);
    }

    updateModelMatrix() {
      if (this._primitive) {
        this._primitive.modelMatrix = this.modelMatrix;
      }
    }

    _getModelMatrix(position, orientation) {
      if (!position) {
        return Cesium__namespace.Matrix4.IDENTITY
      }
      let heading = Cesium__namespace.Math.toRadians(this.style.heading || 0);
      let pitch = Cesium__namespace.Math.toRadians(this.style.pitch || 0);
      let roll = Cesium__namespace.Math.toRadians(this.style.roll || 0);

      if (orientation && !this.options.fixedHeading) {
        if (orientation.getValue) {
          orientation = orientation.getValue(this._map?.clock?.currentTime);
        }
        if (orientation) {
          const hpr = getHeadingPitchRollByOrientation(position, orientation);
          if (!this.style.noPitchRoll) {
            pitch = hpr.pitch;
            roll = hpr.roll;
          }
          heading += hpr.heading;
        }
      }

      this._heading_reality = heading;
      this._pitch_reality = pitch;
      this._roll_reality = roll;

      const modelMatrix = Cesium__namespace.Transforms.headingPitchRollToFixedFrame(
        position,
        new Cesium__namespace.HeadingPitchRoll(heading, pitch, roll),
        Cesium__namespace.Ellipsoid.WGS84,
        this.options.fixedFrameTransform
      );

      if (Cesium__namespace.defined(this.scaleX) && Cesium__namespace.defined(this.scaleY) && Cesium__namespace.defined(this.scaleZ)) {
        Cesium__namespace.Matrix4.multiplyByScale(modelMatrix, new Cesium__namespace.Cartesian3(this.scaleX, this.scaleY, this.scaleZ), modelMatrix);
      } else if (Cesium__namespace.defined(this.style.scale)) {
        Cesium__namespace.Matrix4.multiplyByScale(modelMatrix, new Cesium__namespace.Cartesian3(this.style.scale, this.style.scale, this.style.scale), modelMatrix);
      }

      return modelMatrix
    }

    _getGeoJsonGeometry(options) {
      return { type: "Point", coordinates: this.getCoordinate(options?.noAlt) }
    }

    // 以下为对动态属性的坐标的支持
    _forPositionProperty(pt) {
      if (pt instanceof Cesium__namespace.CallbackProperty || pt instanceof Cesium__namespace.SampledPositionProperty) {
        this.options.frameRate = this.options.frameRate ?? 20;
        this._orientation = this.options.orientation || new Cesium__namespace.VelocityOrientationProperty(pt);

        /**
         * 动态位置坐标
         * @type {Cesium.SampledPositionProperty|Cesium.CallbackProperty}
         */
        this.property = pt;

        this.bindUpdateEvent();
        return true
      } else {
        return false
      }
    }

    // 内部自动刷新的方法体
    update(frameState) {
      if (!this.show) {
        return
      }

      // 自动定时更新坐标
      if (this.property) {
        this._position = this.property.getValue(frameState.time);

        if (this.czmObject) {
          this._updatePositionsHook();
        }

        if (this._primitive_label) {
          this._updateLabelPosition();
        }
      }
    }

    _getPopupPosition() {
      return this.property || this.position || this.center
    }

    /**
     * 设置并添加动画轨迹位置，按“指定时间”运动到达“指定位置”。
     *
     * @param {LngLatPoint|Cesium.Cartesian3|Number[]} point 指定位置坐标
     * @param {Cesium.JulianDate|Date|String|Number} [currTime=Cesium.JulianDate.now()] 指定时间, 默认为当前时间5秒后。当为String时，可以传入'2021-01-01 12:13:00'; 当为Number时，可以传入当前时间延迟的秒数。
     * @return {BasePointPrimitive} 当前对象本身，可以链式调用
     */
    addDynamicPosition(point, currTime) {
      if (!this._sampledPositionProperty) {
        this._initSampledPositionProperty();
      }

      this._removeDynamicPosition();

      if (!currTime) {
        currTime = this._map?.clock?.currentTime || Cesium__namespace.JulianDate.now();
      } else if (isNumber(currTime)) {
        const now = this._map?.clock?.currentTime || Cesium__namespace.JulianDate.now();
        currTime = Cesium__namespace.JulianDate.addSeconds(now, currTime, new Cesium__namespace.JulianDate());
      } else if (isString(currTime)) {
        if (currTime.indexOf("Z") === -1) {
          currTime = Cesium__namespace.JulianDate.fromDate(new Date(currTime));
        } else {
          currTime = Cesium__namespace.JulianDate.fromIso8601(currTime);
        }
      } else if (currTime instanceof Date) {
        currTime = Cesium__namespace.JulianDate.fromDate(currTime);
      }

      const pt = LngLatPoint.parse(point).toCartesian();
      this._sampledPositionProperty.addSample(currTime, pt);

      return this
    }

    _initSampledPositionProperty() {
      this._clampToTilesetFrame = -1;

      this._frameRateHeight = this.options.frameRateHeight ?? 30;
      this._maxCacheCount = this.options.maxCacheCount ?? 50; // 保留的坐标点数量

      let property;
      if (this._sampledPositionProperty) {
        property = this._sampledPositionProperty;
      } else {
        property = new Cesium__namespace.SampledPositionProperty();
        property.forwardExtrapolationType = this.options.forwardExtrapolationType ?? Cesium__namespace.ExtrapolationType.NONE;
        property.backwardExtrapolationType = this.options.backwardExtrapolationType ?? Cesium__namespace.ExtrapolationType.NONE;
        this._sampledPositionProperty = property;
      }

      // const result = new Cesium.Cartesian3()
      this.property = new Cesium__namespace.CallbackProperty((time) => {
        if (!this._map) {
          return undefined
        }
        let position = property.getValue(time);

        if (position && this.options.clampToTileset) {
          // 贴模型
          this._clampToTilesetFrame++;
          if (!this._clampToTilesetHeight || this._clampToTilesetFrame % this._frameRateHeight === 0) {
            this._clampToTilesetHeight = getHeight(this._map.scene, position, {
              objectsToExclude: this.objectsToExclude
            });
          }
          if (this._clampToTilesetHeight) {
            const car = Cesium__namespace.Cartographic.fromCartesian(position);
            position = Cesium__namespace.Cartesian3.fromRadians(car.longitude, car.latitude, this._clampToTilesetHeight + this.getAddHeight());
          }
        }
        return position
      }, false);

      this._orientation = this.options.orientation || new Cesium__namespace.VelocityOrientationProperty(property);

      this.bindUpdateEvent();
    }

    _removeDynamicPosition() {
      if (this._maxCacheCount < 1) {
        return
      }

      const times = this._sampledPositionProperty?._property?._times;
      if (!times || times.length === 0) {
        return
      }

      const removeCount = times.length - this._maxCacheCount - 1;

      if (removeCount > 0) {
        this._sampledPositionProperty.removeSamples(
          new Cesium__namespace.TimeInterval({
            start: times[0],
            stop: times[removeCount]
          })
        );
      }
    }

    /**
     * 异步计算更新坐标高度进行贴地(或贴模型)，内部自动调用{@link PointUtil#getSurfaceHeight}方法处理。
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @return {Promise<Object>} 异步计算完成的Promise
     */
    autoSurfaceHeight(options = {}) {
      return getSurfaceHeight(this._map.scene, this.position, options).then((result) => {
        if (result.position) {
          this.position = result.position;
        }
      })
    }

    // 兼容旧版本命名，同updateSurfaceHeight
    clampToGround(options) {
      return this.autoSurfaceHeight(options)
    }

    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @param {Boolean} noAlt true时不导出高度值
     * @return {Array} 位置坐标(数组对象)
     */
    getCoordinate(noAlt) {
      if (this.point) {
        return this.point.toArray(noAlt)
      } else {
        return []
      }
    }
  }
  // 对类是否为点状数据的判断,GraphicUtil内用到
  BasePointPrimitive.isPoint = true;

  /**
   * 像素点 支持的样式信息
   *
   * @typedef {Object} PointPrimitive.StyleOptions
   *
   * @property {Number} [pixelSize = 10] 像素大小
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   * @property {Number} [outlineWidth = 2] 边框宽度
   *
   * @property {Boolean|Cesium.NearFarScalar} [scaleByDistance = false] 是否按视距缩放 或 指定用于基于距离缩放点。
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [visibleDepth = true] 是否被遮挡
   * @property {number} [disableDepthTestDistance] 指定从相机到禁用深度测试的距离。
   * @property {Cesium.NearFarScalar} [translucencyByDistance] 用于基于与相机的距离设置半透明度。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示
   * @see Cesium.PointPrimitive
   */

  /**
   * 像素点 Primitive矢量数据
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {PointPrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Number} [options.frameRate = 1] 当postion为CallbackProperty时，多少帧获取一次数据。用于控制效率，如果卡顿就把该数值调大一些。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class PointPrimitive
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PointPrimitive extends BasePointPrimitive {
    /**
     * 当加载primitive数据的内部Cesium容器
     * @type {Cesium.PointPrimitiveCollection}
     * @readonly
     */
    get primitiveCollection() {
      return this._layer?.pointCollection
    }

    _showHook(val) {
      // 覆盖父类
      if (val && !this._primitive) {
        super._showHook(val);
      }
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show) {
        return
      }

      this._forPositionProperty(this.options.position); // 对动态属性坐标的支持

      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
      }

      const addattr = PointStyleConver.toCesiumVal(this.style, {
        show: this.show,
        position: this.position
      });
      this._primitive = this.primitiveCollection.add(addattr);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      PointStyleConver.toCesiumVal(style, this.primitive);
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PointStyleConver.toJSON(czmStyle, styleJson)
    }

    _updatePositionsHook() {
      this._primitive.position = this.position;
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return create$4("point", options)
    }
  }

  // 注册下
  register$4("pointP", PointPrimitive);

  /**
   *
   * 多个坐标的线面状 Primitive图元 矢量对象 基类
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标位置
   * @param {Object} options.style 矢量数据的 样式信息，具体见各类数据的说明
   * @param {Object} [options.attr] 矢量数据的 属性信息，可以任意附加属性。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class BasePolyPrimitive
   * @extends {BasePrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BasePolyPrimitive extends BasePrimitive {
    constructor(options = {}) {
      super(options);

      this._hasEdit = this.options.hasEdit ?? true; // 是否允许编辑

      // 坐标位置
      if (options.positions) {
        if (this.style.buffer > 0) {
          this.positions = bufferPoints(options.positions);
        } else {
          this.positions = options.positions;
        }
      }
    }

    //= ============坐标相关==================

    /**
     * 中心点坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get center() {
      if (this.style.closure) {
        return this.centerOfMass
      } else {
        return this.centerOfLine
      }
    }

    /**
     * 围合面的内部中心点坐标
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get centerOfMass() {
      return centerOfMass(this.positions)
    }

    /**
     * 边线的中心点坐标
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get centerOfLine() {
      const pots = this.positions;
      if (!pots || pots.length === 0) {
        return null
      } else if (pots.length === 1) {
        return pots[0]
      }

      if (pots.length < 10) {
        return sliceByMaxDistance(pots, this.distance / 2, { point: true })
      } else {
        return pots[Math.floor(pots.length / 2)]
      }
    }

    /**
     * 距离（单位：米）
     * @type {Number}
     * @readonly
     */
    get distance() {
      return getDistance(this.positions)
    }

    /**
     * 面积（单位：平方米）
     * @type {Number}
     * @readonly
     */
    get area() {
      return getSurfaceArea(this.positions)
    }

    /**
     * 位置坐标数组 （笛卡尔坐标）, 赋值时可以传入LatLngPoint数组对象
     * @type {Cesium.Cartesian3[]}
     */
    get positions() {
      return this._positions
    }

    set positions(value) {
      if (!value) {
        return
      }

      const _points = [];
      const _positions = [];
      value.forEach((item, index) => {
        const _point = LngLatPoint.parse(item);
        if (!_point || !_point.valid()) {
          return
        }
        // 按配置调整高度值
        let setHeight = this.style.setHeight;
        if (Cesium__namespace.defined(setHeight)) {
          if (isString(setHeight)) {
            setHeight = Number(template(setHeight, this.attr, true));
            if (isNaN(setHeight)) {
              setHeight = 0;
            }
          } else if (Array.isArray(setHeight)) {
            setHeight = setHeight[index] || 0;
          }
          _point.alt = setHeight;
        }
        const addHeight = this.getAddHeight(index);
        if (addHeight !== 0) {
          _point.alt = _point.alt + addHeight;
        }

        _points.push(_point);
        _positions.push(_point.toCartesian());
      });
      this._points = _points;
      this._positions = _positions;

      if (this._primitive) {
        this._updatePositionsHook();
      }

      if (this._primitive_label) {
        this._updateLabelPosition();
      }

      this.fire(EventType.updatePosition, { positions: this._positions });
    }

    /**
     * 同 positions 只是为了兼容entity的同名属性
     * @type {Cesium.Cartesian3[]}
     * @readonly
     */
    get positionsShow() {
      return this.positions
    }

    /**
     * 位置坐标数组
     * @type {LngLatPoint[]|Cesium.Cartesian3[]|Array}
     * @readonly
     */
    get points() {
      if (!this._points) {
        this._points = LngLatArray.toPoints(this._positions);
      }
      return this._points
    }

    /**
     * 位置坐标(数组对象)，示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
     * @type {Array[]}
     * @readonly
     */
    get coordinates() {
      return this.getCoordinates()
    }

    /**
     * 坐标数据对应的矩形边界
     * @type {Cesium.Rectangle}
     * @readonly
     */
    get rectangle() {
      return Cesium__namespace.Rectangle.fromCartesianArray(this.positions)
    }

    _getGeoJsonGeometry(options) {
      return { type: "LineString", coordinates: this.getCoordinates(options?.noAlt) }
    }

    /**
     * 位置坐标(数组对象)，示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
     * @param {Boolean} noAlt true时不导出高度值
     * @return {Array[]} 位置坐标(数组对象)
     */
    getCoordinates(noAlt) {
      const coords = [];
      this.points.forEach((item) => {
        coords.push(item.toArray(noAlt));
      });
      return coords
    }

    /**
     * 判断点是否在当前对象的坐标点围成的多边形内
     *
     * @param {Cesium.Cartesian3|LngLatPoint} position 需要判断的点
     * @return {Boolean} 是否在多边形内
     */
    isInPoly(position) {
      const point = LngLatPoint.parse(position);

      // 面的时候，为了提高效率，先判断是否在外接矩形内
      const isInArea = Cesium__namespace.Rectangle.contains(Cesium__namespace.Rectangle.fromCartesianArray(this.positions), point.toCartographic());
      if (!isInArea) {
        return false
      }
      return isInPoly(point, this.coordinates)
    }

    /**
     * 异步计算更新坐标高度进行贴地(或贴模型)，内部自动调用{@link PolyUtil#computeSurfacePoints}方法处理。
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @param {Number} [options.offset=0]  可以按需增加偏移高度（单位：米），便于可视
     * @return {Promise<*>} 异步计算完成的Promise
     */
    autoSurfaceHeight(options = {}) {
      // 求对比的贴地地面高度
      return computeSurfacePoints({
        ...options,
        map: this._map,
        positions: this.positions // 需要计算的源路线坐标数组
      }).then((result) => {
        if (!result.noHeight) {
          this.positions = result.positions;
        }
        return result
      })
    }

    // 兼容旧版本命名，同updateSurfaceHeight
    clampToGround(options) {
      return this.autoSurfaceHeight(options)
    }
  }

  /**
   * 线 Primitive图元 支持的样式信息
   *
   * @typedef {Object} PolylinePrimitive.StyleOptions
   *
   * @property {Number} [width = 4] 线宽
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {Boolean} [randomColor = false] 是否随机颜色
   *
   * @property {Cesium.Color[]} [colors] 定义每顶点或每段颜色 的数组。
   * @property {Boolean} [colorsPerVertex = false] 用于确定颜色在线条的每一段上是平坦的还是在顶点上插值的。
   * @property {Boolean} [closure = false] 是否闭合
   *
   * @property {Boolean} [depthFail] 是否显示遮挡
   * @property {String} [depthFailColor] 遮挡处颜色
   * @property {Number} [depthFailOpacity] 遮挡处透明度
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Cesium.ArcType} [arcType=Cesium.ArcType.GEODESIC]  折线段必须遵循的线的类型。
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 如果arcType不是arcType.none，则指定每个纬度和经度之间的角距离的数字属性。
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
   *
   * @property {Number|Number[]} [setHeight] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
   * @property {Number|Number[]} [addHeight] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
   *
   * @property {PolylinePrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelPrimitive.StyleOptions|Object} [label] 支持附带文字的显示 ，额外支持：<br />
  //  * @property {String|LngLatPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
  //  * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
   *
   */

  /**
   * 线 Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标位置
   * @param {PolylinePrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePolyPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PolylinePrimitive extends BasePolyPrimitive {
    _conversionStyle(style) {
      return PolylineStyleConver.toCesiumVal(style)
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PolylineStyleConver.toJSON(czmStyle, styleJson)
    }

    // 子类需要继承实现
    _createGeometryInstance(addattr, outline) {
      addattr.positions = this.positions || [];

      if (addattr.closure && addattr.positions?.length > 0) {
        addattr.positions = addattr.positions.concat(addattr.positions[0]);
      }

      const GeometryClass = addattr.clampToGround ? Cesium__namespace.GroundPolylineGeometry : Cesium__namespace.PolylineGeometry;

      return new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new GeometryClass(addattr),
        attributes: this.options.attributes
      })
    }

    _createAppearance(addattr, primitiveOpts) {
      if (addattr._isColorMaterial) {
        // 纯色时
        primitiveOpts.geometryInstances.geometry.vertexFormat = Cesium__namespace.PolylineColorAppearance.VERTEX_FORMAT;

        const color = this._getColorByColorMaterial(addattr);

        primitiveOpts.geometryInstances.attributes = primitiveOpts.geometryInstances.attributes || {};
        primitiveOpts.geometryInstances.attributes.color = Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color);
        if (addattr.depthFail) {
          primitiveOpts.geometryInstances.attributes.depthFailColor = Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(addattr.depthFailColor || color);
        }

        return new Cesium__namespace.PolylineColorAppearance({
          ...addattr
        })
      } else {
        // 存在材质时
        return new Cesium__namespace.PolylineMaterialAppearance({
          ...addattr
        })
      }
    }

    // 获取对应标绘时的Entity对象
   _getDrawEntityClass(options, isDraw) {
      return create$4("polyline", options)
    }
  }
  // 注册下
  register$4("polylineP", PolylinePrimitive);

  /**
   * 图层对象 的基类
   *
   * @param {Object} [options] 参数对象，包括以下：
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   *
   * @export
   * @class BaseLayer
   * @extends {BaseClass}
   */
  class BaseLayer extends BaseClass {
    constructor(options = {}) {
      super(options);
      this.options = options;

      options.id = options.id ?? createGuid();
      options.pid = options.pid ?? -1;

      this._show = options.show ?? true;
      this._private = options.private;

      this._opacity = options.opacity ?? 1;
      if (Cesium__namespace.defined(options.alpha)) {
        this._opacity = options.alpha;
      }

      if (this.options.proxy) {
        if (isString(this.options.proxy)) {
          this._proxy = new Cesium__namespace.DefaultProxy(this.options.proxy);
        } else {
          this._proxy = this.options.proxy;
        }
      }

      replaceOnlineUrlDomain(this.options);

      this._bindControl();

      this._readyPromise = Cesium__namespace.defer ? Cesium__namespace.defer() : Cesium__namespace.when.defer();
      this._state = State.INITIALIZED;
    }

    //= ========= 对外属性 ==========

    /**
     * 对象的id标识
     * @type {String|Number}
     */
    get id() {
      return this.options.id
    }

    set id(id) {
      this.options.id = id;
    }

    // 兼容v3.4之前历史版本
    get uuid() {
      return this.options.id
    }

    /**
     * 名称 标识
     *
     * @type {String}
     */
    get name() {
      return this.options.name
    }

    set name(name) {
      this.options.name = name;
    }

    /**
     * 对象的pid标识
     *
     * @type {String|Number}
     */
    get pid() {
      return this.options.pid
    }

    set pid(pid) {
      this.options.pid = pid;
    }

    /**
     * 图层类型
     *
     * @type {String}
     * @readonly
     */
    get type() {
      return this._type
    }

    /**
     * 当前对象的状态
     *
     * @type {State}
     * @readonly
     *
     */
    get state() {
      return this._state
    }

    /**
     * 是否已添加到地图
     *
     * @type {Boolean}
     * @readonly
     */
    get isAdded() {
      return this._state === State.ADDED
    }

    /**
     * 是否已经销毁了
     *
     * @type {Boolean}
     * @readonly
     */
    get isDestroy() {
      return this._state === State.DESTROY
    }

    /**
     * 是否Mars3D内部的私有对象，如标绘拖拽点等
     * @type {Boolean}
     * @readonly
     */
    get isPrivate() {
      if (this._private) {
        return true
      }
      return false
    }

    /**
     * 获取图层完成解析加载完成的Promise承诺, 等价于load事件(区别在于load事件必须在load完成前绑定才能监听)。
     * @type {Promise<BaseLayer|Object>}
     * @readonly
     * @example
    tiles3dLayer.readyPromise.then(function(layer) {
      console.log("load完成", layer)
    })
     */
    get readyPromise() {
      return this._readyPromise.promise
    }

    get layer() {
      return null
    }

    /**
     * 显示隐藏状态
     *
     * @type {Boolean}
     */
    get show() {
      return this._show
    }

    set show(show) {
      if (this._show === show || this.isDestroy) {
        return
      }
      this.options.show = show;
      this._show = show;

      if (this.layer) {
        if (Array.isArray(this.layer)) {
          this.layer.forEach(function (item) {
            item.show = show;
          });
        } else {
          this.layer.show = show;
        }
      }

      if (this.isAdded) {
        this._showHook && this._showHook(show);

        if (show) {
          this.fire(EventType.show);
        } else {
          this.fire(EventType.hide);
        }
      }
    }

    /**
     * 是否可以调整透明度
     * @type {Boolean}
     * @readonly
     */
    get hasOpacity() {
      if (this.options.hasOpacity === false) {
        return false
      }
      return !!this.setOpacity
    }

    /**
     * 透明度，取值范围：0.0-1.0
     * @type {Number}
     *
     */
    get opacity() {
      return this._opacity
    }

    set opacity(value) {
      this._opacity = value;
      this.setOpacity && this.setOpacity(value);
    }

    /**
     * 添加到地图上，同 map.addThing
     *
     * @param {Map} map 地图对象
     * @return {BaseLayer} 当前对象本身，可以链式调用
     *
     */
    addTo(map) {
      if (map && map.addLayer) {
        map.addLayer(this);
      }
      return this
    }

    /**
     * 从地图上移除，同map.removeThing
     *
     * @param {Boolean} [destroy] 是否调用destroy释放
     * @return {void}  无
     */
    remove(destroy) {
      if (this._map) {
        this._map.removeLayer(this, destroy);
      }
    }

    /**
     * 添加到地图上的钩子方法
     *
     * @param {Map} map 地图对象
     * @return {void}  无
     * @private
     */
    _onAdd(map) {
      if (this._state === State.ADDED) {
        return
      }
      this._map = map;

      if (this.options.eventParent) {
        this.addEventParent(this.options.eventParent);
      } else if (this.options?.eventParent === false) ; else {
        this.addEventParent(map);
      }

      if (this._mountedHook) {
        if (!this._createOK) {
          this._mountedHook();
          this._createOK = true;
        }
      }
      this._addedHook && this._addedHook();

      if (this.options.flyTo) {
        this.flyToByAnimationEnd({ duration: 0 });
      }
      this._state = State.ADDED;

      this.fire(EventType.add);
      this.fire(EventType.addLayer, {}, true);
    }

    /**
     * 从地图上移除的钩子方法
     *
     * @return {void}  无
     * @private
     */
    _onRemove() {
      if (this._state !== State.ADDED) {
        return
      }

      if (!this._map) {
        return
      }

      this._removedHook && this._removedHook();

      this._state = State.REMOVED;

      this.fire(EventType.remove);
      this.fire(EventType.removeLayer, {}, true);

      if (this.options?.eventParent) {
        this.removeEventParent(this.options.eventParent);
      } else if (this.options?.eventParent === false) ; else {
        this.removeEventParent(this._map);
      }

      this._map = null;
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     *
     * @abstract
     * @return {void}  无
     */
    _mountedHook() {}

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */
    _addedHook() {}

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */
    _removedHook() {}

    fire(type, data = {}, propagate) {
      if (!data.layer) {
        data.layer = this;
      }
      return super.fire(type, data, propagate)
    }

    // /**
    //  * 入场动画后再执行flyTo，直接调用flyTo可能造成入场动画失败。
    //  * @return {BaseLayer} 当前对象本身，可以链式调用
    //  */
    flyToByAnimationEnd(options) {
      if (!this._map || !this.show) {
        return this
      }

      if (this._map.isFlyAnimation()) {
        this._map.openFlyAnimationEndFun = () => {
          this.flyTo(options || this.options.flyToOptions);
        };
      } else {
        this.flyTo(options || this.options.flyToOptions);
      }
      return this
    }

    /**
     * 飞行定位至图层数据所在的视角
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.radius] 点状数据时，相机距离目标点的距离（单位：米）
     * @param {Number} [options.scale=1.2] 线面数据时，缩放比例，可以控制视角比矩形略大一些，这样效果更友好。
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Cesium.Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     */
    flyTo(options) {
      if (!this._map) {
        return Promise.resolve(false)
      }
      this._map.cancelFlyTo();

      if (this.options.center) {
        return this._map.setCameraView(this.options.center, options)
      }

      const rect = this.options.extent || this._extent || (this.getRectangle && this.getRectangle());
      if (rect) {
        return this._map.flyToExtent(rect, options)
      }

      return Promise.resolve(false)
    }

    /**
     * 更新图层参数
     *
     * @param {Object} options 与类的构造方法参数相同
     * @return {BaseLayer} 当前对象本身，可以链式调用
     *
     */
    setOptions(options) {
      if (!options || Object.keys(options).length === 0) {
        return this
      }
      this.options = merge(this.options, options);

      if (Cesium__namespace.defined(options.opacity)) {
        this.opacity = options.opacity;
      }
      if (Cesium__namespace.defined(options.name)) {
        this.name = options.name;
      }
      if (Cesium__namespace.defined(options.show)) {
        this.show = options.show;
      }

      this._bindControl();

      this._setOptionsHook && this._setOptionsHook(this.options, options);
      return this
    }

    /**
     * 将图层转为Json简单对象，用于存储后再传参加载
     * @return {Object} Json简单对象
     */
    toJSON() {
      const options = clone(this.options, ["parent", "eventParent"]);
      options.id = this.id;
      options.type = this.type;
      options.show = this.show;
      this._toJsonEx(options);

      return options
    }

    // 转为json的额外需要处理的对象
    _toJsonEx(newData) {}

    //= ============= popup/tooltip/contextmenuItems ======================

    // 绑定内置的控件
    _bindControl() {
      if (Cesium__namespace.defined(this.options.contextmenuItems)) {
        this._contextmenuConfig = {
          content: this.options.contextmenuItems,
          options: this.options.contextmenuOptions,
          layer: this
        };
      }
      if (Cesium__namespace.defined(this.options.popup)) {
        const options = this.options.popupOptions || {};
        this._popupConfig = {
          options: options,
          content: bindLayerPopup(this.options.popup, (template, event) => {
            const attr = {
              layer_name: this.options.name,
              ...this._getAttrForPopup(event)
            };
            let title = this.name;
            if (options.noTitle) {
              title = null;
            } else if (options.title) {
              title = options.title;
            } else if (options.titleField) {
              title = attr[options.titleField];
            }
            return getTemplateHtml({ title: title, template: template, attr: attr })
          }),
          layer: this
        };
      }
      if (Cesium__namespace.defined(this.options.tooltip)) {
        const options = this.options.tooltipOptions || {};
        this._tooltipConfig = {
          options: options,
          content: bindLayerPopup(this.options.tooltip, (template, event) => {
            const attr = {
              layer_name: this.options.name,
              ...this._getAttrForPopup(event)
            };
            let title = this.name;
            if (options.noTitle) {
              title = null;
            } else if (options.title) {
              title = options.title;
            } else if (options.titleField) {
              title = attr[options.titleField];
            }
            return getTemplateHtml({ title: title, template: template, attr: attr })
          }),
          layer: this
        };
      }
    }

    _getAttrForPopup(event) {
      if (event?.attr) {
        return event.attr
      }
      if (event?.graphic?.attr) {
        return event.graphic.attr
      }
      if (!event.czmObject) {
        return {}
      }

      let attr = event.czmObject._attr || event.czmObject.properties || event.czmObject.attribute;
      if (attr && attr.type && attr.attr) {
        attr = attr.attr; // 兼容历史数据,V2内部标绘生产的geojson
      }
      return attr ?? {}
    }

    // 子类按需筛选向上抛出事件
    _filterPropagateEvent(target, e) {
      if (e.type === "load") {
        return false
      }
      return true
    }

    // 销毁释放对象
    destroy(noDel) {
      if (this._state === State.DESTROY) {
        return
      }

      if (this._state !== State.REMOVED) {
        this.clear && this.clear();
        this.remove();
      }
      super.destroy(noDel);

      this._state = State.DESTROY;
    }
  }

  // 对图层的popup tooltip处理（图层一般因为有属性读取及格式化处理）
  function bindLayerPopup(content, getHtmlFun) {
    if (typeof content === "function") {
      // 自定义的回调方法
      return function (event) {
        return content(event)
      }
    } else {
      // 内置的格式化方法，一般使用getPopup
      return function (event) {
        return getHtmlFun(content, event)
      }
    }
  }

  /**
   * @typedef {Object} BaseGraphicLayer.EventType
   * 图层类支持的{@link EventType}事件类型
   *
   * @property {String} add 添加对象
   * @property {String} remove 移除对象
   * @property {String} show 显示了对象
   * @property {String} hide 隐藏了对象
   *
   * @property {String} click 左键单击 鼠标事件
   * @property {String} rightClick 右键单击 鼠标事件
   * @property {String} mouseOver 鼠标移入 鼠标事件
   * @property {String} mouseOut 鼠标移出 鼠标事件
   *
   * @property {String} popupOpen popup弹窗打开后
   * @property {String} popupClose popup弹窗关闭
   * @property {String} tooltipOpen tooltip弹窗打开后
   * @property {String} tooltipClose tooltip弹窗关闭
   *
   * @example
   * //绑定监听事件
   * layer.on(mars3d.EventType.click, function (event) {
   *   console.log('单击了矢量数据对象', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 矢量数据图层 Base基类
   *
   * @param {Object} [options] 参数对象，包括以下：
   *
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑定，参数与popup属性完全相同。
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数,还包括：
   * @param {String} [options.tooltipOptions.title] 固定的标题名称
   * @param {String} [options.tooltipOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.tooltipOptions.noTitle] 不显示标题
   * @param {Object} [options.contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class BaseGraphicLayer
   * @extends {BaseLayer}
   * @see [支持的事件类型]{@link BaseGraphicLayer.EventType}
   */
  class BaseGraphicLayer extends BaseLayer {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      if (options.url && options.templateValues) {
        options.url = template(options.url, options.templateValues);
      }
      super(options);
    }

    _showHook(show) {
      if (!show) {
        this._closeAllControl();
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      if (this.options.highlight) {
        this.bindHighlight(this.options.highlight);
      } else if (this.options.symbol?.styleOptions?.highlight) {
        this.bindHighlight(this.options.symbol.styleOptions.highlight);
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._closeAllControl();
      this.unbindHighlight();
    }

    _setOptionsHook(options) {
      if (this._highlightOptions) {
        this.unbindHighlight();
        if (this.options.highlight) {
          this.bindHighlight(this.options.highlight);
        } else if (this.options.symbol?.styleOptions?.highlight) {
          this.bindHighlight(this.options.symbol.styleOptions.highlight);
        }
      }
    }

    // 关闭所有内部控件
    _closeAllControl() {
      this.closePopup();
      this.closeTooltip();
      this.closeSmallTooltip();
      this.closeContextMenu();
    }

    //= ============= Highlight ======================
    /**
     * 绑定鼠标移入或单击后的 对象高亮
     * @param {Object} [options] 参数：
     * @param {String} [options.type='mouseOver'] 事件类型，默认为鼠标移入高亮，也可以指定'click'单击高亮。
     * @param {String} [options.多个参数] 高亮的样式，具体见各{@link GraphicType}矢量数据的style参数。
     * @return {void}  无
     */
    bindHighlight(options) {
      this.unbindHighlight();

      this._highlightOptions = options;

      if (this._highlightOptions.type === EventType.click) {
        this.on(EventType.click, this._highlight_mouseEventHandler, this);
      } else {
        this.on(EventType.mouseOver, this._highlight_mouseEventHandler, this);
        this.on(EventType.mouseOut, this._highlight_mouseOutHandler, this);
      }
    }

    /**
     * 解绑鼠标移入或单击后的高亮处理
     * @return {void}  无
     */
    unbindHighlight() {
      if (this._highlightOptions) {
        if (this._highlightOptions.type === EventType.click) {
          this.off(EventType.click, this._highlight_mouseEventHandler, this);
          // this._map.off(EventType.clickMap, this._highlight_mouseOutHandler, this);
        } else {
          this.off(EventType.mouseOver, this._highlight_mouseEventHandler, this);
          this.off(EventType.mouseOut, this._highlight_mouseOutHandler, this);
        }
        this._map.closeHighlight();
        this._highlightOptions = null;
      }
    }

    // 移入
    _highlight_mouseEventHandler(event) {
      if (!this._map) {
        return
      }
      const graphic = event?.graphic;
      if (graphic) {
        this._map.openHighlight(graphic, this._highlightOptions, event);
      } else {
        this._map.closeHighlight();
      }
    }

    // 移出
    _highlight_mouseOutHandler(event) {
      this._map.closeHighlight();
    }

    //= ============= popup ======================

    /**
     *  是否存在Popup绑定，判断图层及内部所有矢量数据
     *
     * @return {Boolean} 是否存在Popup绑定
     */
    hasPopup() {
      if (this._popupConfig) {
        return true
      }
      if (this._graphicList) {
        const graphics = this._graphicList.values;
        for (let i = 0, len = graphics.length; i < len; i++) {
          const graphic = graphics[i];
          if (graphic._popupConfig) {
            return true
          }
        }
      }
      return false
    }

    /**
     * 绑定鼠标单击对象后的弹窗。
     *
     * @param {String|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Popup.StyleOptions} [options] 控制参数
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     *
     */
    bindPopup(content, options) {
      this._popupConfig = {
        content: content,
        options: options || this.options.popupOptions,
        layer: this
      };
      return this
    }

    /**
     * 解除绑定的鼠标单击对象后的弹窗。
     *
     * @param {Boolean} [bubbling=false] 单击事件中是否继续冒泡查找
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    unbindPopup(bubbling) {
      this.closePopup();
      if (bubbling) {
        this._popupConfig = false;
      } else {
        this._popupConfig = null;
      }
      return this
    }

    /**
     * 打开绑定的弹窗
     *
     * @param {BaseGraphic|LngLatPoint|Cesium.Cartesian3} position 矢量对象 或 显示的位置
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    openPopup(position) {
      if (position.openPopup) {
        position.openPopup(); // 是graphic
      } else if (this._popupConfig && position && this._map) {
        this._popupConfig.graphic = null;
        this._map.popup.open(position, this._popupConfig);
      }
      return this
    }

    /**
     * 关闭弹窗
     *
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    closePopup() {
      if (this._map && this.hasPopup()) {
        this._map.popup.close(null, this);
      }
      return this
    }

    //= ============= _tooltipConfig ======================
    /**
     * 是否绑定了tooltip
     *
     * @return {Boolean} 是否绑定
     */
    hasTooltip() {
      if (this._tooltipConfig) {
        return true
      }
      if (this._graphicList) {
        const graphics = this._graphicList.values;
        for (let i = 0, len = graphics.length; i < len; i++) {
          const graphic = graphics[i];
          if (graphic._tooltipConfig) {
            return true
          }
        }
      }
      return false
    }

    /**
     * 绑定鼠标移入的弹窗
     *
     * @param {String|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Tooltip.StyleOptions} [options] 控制参数
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    bindTooltip(content, options) {
      this._tooltipConfig = {
        content: content,
        options: options || this.options.tooltipOptions,
        layer: this
      };
      return this
    }

    /**
     * 解除绑定的鼠标移入对象后的弹窗。
     *
     * @param {Boolean} [bubbling=false] 单击事件中是否继续冒泡查找
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     *
     */
    unbindTooltip(bubbling) {
      if (bubbling) {
        this._tooltipConfig = false;
      } else {
        this._tooltipConfig = null;
      }
      this.closeTooltip();
      return this
    }

    /**
     * 打开绑定的tooltip弹窗
     *
     * @param {BaseGraphic|LngLatPoint|Cesium.Cartesian3} position graphic矢量对象 或 显示的位置
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     *
     */
    openTooltip(position) {
      if (position.openTooltip) {
        position.openTooltip(); // 是graphic
      } else if (this._tooltipConfig && position && this._map) {
        this._tooltipConfig.graphic = null;
        this._map.tooltip.open(position, this._tooltipConfig);
      }
      return this
    }

    /**
     *  关闭弹窗
     *
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     *
     */
    closeTooltip() {
      if (this._map && this.hasTooltip()) {
        this._map.tooltip.close(null, this);
      }
      return this
    }

    //= ============= contextMenu ======================

    /**
     * 是否有绑定的右键菜单
     *
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    hasContextMenu() {
      if (this._contextmenuConfig) {
        return true
      }
      if (this._graphicList) {
        const graphics = this._graphicList.values;
        for (let i = 0, len = graphics.length; i < len; i++) {
          const graphic = graphics[i];
          if (graphic._contextmenuConfig) {
            return true
          }
        }
      }
      return false
    }

    /**
     * 获取绑定的右键菜单数组
     *
     * @return {Object[]} 右键菜单数组
     */
    getContextMenu() {
      return this._contextmenuConfig
    }

    /**
     * 绑定右键菜单
     *
     * @param {Object[]} content 右键菜单配置数组，数组中每一项包括：
     * @param {String} [content.text] 菜单文字
        * @param {String} [content.icon] 图标,可以是：图片url路径、base64字符串、svg字符串、字体图标class名
     * @param {Function|Boolean} [content.show] 菜单项是否显示的回调方法
     * @param {Function} [content.callback] 菜单项单击后的回调方法
     * @param {Object[]} [content.children] 当有二级子菜单时，配置数组。
     *
     * @param {Object} [options={}] 控制参数
     * @param {Number} [options.offsetX] 用于非规则对象时，横向偏移的px像素值
     * @param {Number} [options.offsetY] 用于非规则对象时，垂直方向偏移的px像素值
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     *
     * @example
     * //在layer上绑定右键菜单
        graphicLayer.bindContextMenu([
          {
            text: '删除对象',
            icon: 'fa fa-trash-o',
            callback: function (e) {
              let graphic = e.graphic
              if (graphic) {
                graphicLayer.removeGraphic(graphic)
              }
            },
          },
          {
            text: '计算长度',
            icon: 'fa fa-medium',
            show: function (e) {
              let graphic = e.graphic
              return graphic.type === 'polyline'
            },
            callback: function (e) {
              let graphic = e.graphic
              let strDis = mars3d.MeasureUtil.formatDistance(graphic.distance)
              alert('该对象的长度为:' + strDis)
            },
          },
        ])

     */
    bindContextMenu(content, options) {
      this._contextmenuConfig = {
        content: content,
        options: options || this.options.contextmenuOptions,
        layer: this
      };
      return this
    }

    /**
     * 解除绑定的右键菜单
     *
     * @param {Boolean} [bubbling=false] 单击事件中是否继续冒泡查找
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    unbindContextMenu(bubbling) {
      if (bubbling) {
        this._contextmenuConfig = false;
      } else {
        this._contextmenuConfig = null;
      }
      this.closeContextMenu();
      return this
    }

    /**
     * 打开右键菜单
     *
     * @param {BaseGraphic|Cesium.Cartesian3} position 矢量对象 或 显示的位置
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     *
     */
    openContextMenu(position) {
      if (position.openContextMenu) {
        position.openContextMenu(); // 是graphic
      } else if (this._contextmenuConfig && position && this._map) {
        this._contextmenuConfig.graphic = null;
        this._map.contextmenu.open(position, this._contextmenuConfig);
      }
      return this
    }

    /**
     *  关闭右键菜单
     *
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     *
     */
    closeContextMenu() {
      if (this._map && this.hasContextMenu()) {
        this._map.contextmenu.close(null, this);
      }
      return this
    }

    //= ============= Small _tooltipConfig ======================

    /**
     * 显示小提示窗，一般用于鼠标操作的提示。
     *
     * @param {Cesium.Cartesian2|Cesium.Cartesian3} position 显示的屏幕坐标位置 或 笛卡尔坐标位置
     * @param {*} message 显示的内容
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     *
     */
    openSmallTooltip(position, message) {
      if (this._map) {
        this._map.openSmallTooltip(position, message);
      }
      return this
    }

    /**
     * 关闭小提示窗
     *
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    closeSmallTooltip() {
      if (this._map) {
        this._map.closeSmallTooltip();
      }
      return this
    }
  }

  /**
   * 自定义集合存储管理类
   * @export
   * @class MarsArray
   */
  class MarsArray {
    constructor() {
      this._array = [];
      this._hash = {};
    }

    /**
     * 获取总数量
     * @type {Number}
     * @readonly
     */
    get length() {
      return this._array.length
    }

    /**
     * 获取集合中的数组列表
     * @type {Array}
     * @readonly
     */
    get values() {
      return this._array
    }

    /**
     * 确定提供的键是否在数组中
     *
     * @param {String|Number} key 主键
     * @returns {Boolean} 是否在数组中
     */
    contains(key) {
      if (!key) {
        return false
      }
      return Cesium__namespace.defined(this._hash[key])
    }

    /**
     * 将提供的键与提供的值关联起来。如果密钥已经存在, 存在时，它将被新值覆盖。
     * @param {String|Number} key 主键
     * @param {*} value 与提供的键相关联的值
     * @returns {void}
     */
    set(key, value) {
      const oldValue = this._hash[key];
      if (value !== oldValue) {
        this.remove(key);
        this._hash[key] = value;
        this._array.push(value);
      }
    }

    /**
     * 检索与提供的键关联的值
     * @param {String|Number} key 主键
     * @returns {*} 关联的值，如果键在集合中不存在，则为未定义。
     */
    get(key) {
      if (key) {
        return this._hash[key]
      } else {
        return undefined
      }
    }

    /**
     * 根据指定属性获取对象
     * @param {String|Number} attrValue 属性值
     * @param {String} [attrName='id'] 属性键
     * @param {String} [exObj='options'] 查找的二级对象属性键
     * @returns {*} 关联的值，如果键在集合中不存在，则为未定义。
     */
    getByAttr(attrValue, attrName = "id", exObj = "options") {
      if (attrName === "id" && this._hash[attrValue]) {
        return this._hash[attrValue]
      }

      for (let index = 0, len = this._array.length; index < len; index++) {
        const item = this._array[index];
        // eslint-disable-next-line eqeqeq
        if (item[attrName] == attrValue || (item[exObj] && item[exObj][attrName] == attrValue)) {
          return item
        }
      }
      return undefined
    }

    /**
     * 根据指定属性获取符合条件对象数组
     * @param {String|Number} attrValue 属性值
     * @param {String} [attrName='id'] 属性键
     * @param {String} [exObj='options'] 查找的二级对象属性键
     * @return {Array} 数组
     */
    getListByAttr(attrValue, attrName = "id", exObj = "options") {
      const arr = [];
      for (let index = 0, len = this._array.length; index < len; index++) {
        const item = this._array[index];
        // eslint-disable-next-line eqeqeq
        if (item[attrName] == attrValue || (item[exObj] && item[exObj][attrName] == attrValue)) {
          arr.push(item);
        }
      }
      return arr
    }

    /**
     * 从集合中移除键值对
     * @param {String|Number} key 主键
     * @returns {Boolean}  是否移除
     */
    remove(key) {
      const value = this._hash[key];
      const hasValue = Cesium__namespace.defined(value);
      if (hasValue) {
        const array = this._array;
        array.splice(array.indexOf(value), 1);
        delete this._hash[key];
      }
      return hasValue
    }

    /**
     * 遍历每一个对象并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} [context] 侦听器的上下文(this关键字将指向的对象)。
     * @return {void}
     */
    forEach(method, context) {
      for (let index = this._array.length - 1; index >= 0; index--) {
        const item = this._array[index];
        method.call(context || this, item, index);
      }
    }

    /**
     * 清空集合
     * @returns {void}
     */
    removeAll() {
      const array = this._array;
      if (array.length > 0) {
        this._hash = {};
        array.length = 0;
      }
    }

    /**
     * 销毁对象
     * @returns {void}
     */
    destroy() {
      if (this._array.length > 0 && this._array[0].destroy) {
        for (let index = 0, len = this._array.length; index < len; index++) {
          const item = this._array[index];
          if (item?.destroy) {
            item.destroy();
          }
        }
      }

      this.removeAll();

      for (const i in this) {
        delete this[i];
      }
    }
  }

  /**
   * @typedef {Object} GraphicLayer.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} addGraphic 添加了矢量对象
   * @property {String} removeGraphic 移除了矢量对象
   *
   * @property {String} addLayer 图层本身被添加
   * @property {String} removeLayer  图层本身被移除
   * @property {String} show  图层本身显示了
   * @property {String} hide 图层本身隐藏了
   *
   * @property {String} click 左键单击 鼠标事件
   * @property {String} rightClick 右键单击 鼠标事件
   * @property {String} mouseOver 鼠标移入 鼠标事件
   * @property {String} mouseOut 鼠标移出 鼠标事件
   *
   * @property {String} popupOpen popup弹窗打开后
   * @property {String} popupClose popup弹窗关闭
   * @property {String} tooltipOpen tooltip弹窗打开后
   * @property {String} tooltipClose tooltip弹窗关闭
   * @property {String} contextMenuOpen 右键菜单 打开后
   * @property {String} contextMenuClose 右键菜单 关闭
   * @property {String} contextMenuClick 右键菜单 单击某一项后
   *
   * @property {String} drawStart 开始绘制 标绘事件
   * @property {String} drawMouseMove 正在移动鼠标中，绘制过程中鼠标移动了点 标绘事件
   * @property {String} drawAddPoint 绘制过程中增加了点 标绘事件
   * @property {String} drawRemovePoint 绘制过程中删除了最后一个点 标绘事件
   * @property {String} drawCreated 创建完成 标绘事件
   * @property {String} editStart 开始编辑 标绘事件
   * @property {String} editMouseDown 移动鼠标按下左键（LEFT_DOWN）标绘事件
   * @property {String} editMouseMove 正在移动鼠标中，正在编辑拖拽修改点中（MOUSE_MOVE） 标绘事件
   * @property {String} editMovePoint 编辑修改了点（LEFT_UP）标绘事件
   * @property {String} editAddPoint 编辑新增了点 标绘事件
   * @property {String} editRemovePoint 编辑删除了点 标绘事件
   * @property {String} editStyle 图上编辑修改了相关style属性 标绘事件
   * @property {String} editStop 停止编辑 标绘事件
   *
   *
   * @example
   * //绑定监听事件
   * layer.on(mars3d.EventType.load, function (event) {
   *   console.log('矢量数据对象加载完成', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 矢量数据图层
   *
   * @param {Object} [options] 参数对象，包括以下：
   *
   * @param {Object|Object[]} [options.data] 需要自动加载的数据，内部自动生成Graphic对象。{@link GraphicUtil#.create}
   * @param {Boolean} [options.hasEdit=false] 是否自动激活编辑（true时，单击后自动激活编辑）
   * @param {Boolean} [options.isAutoEditing=true] 完成标绘时是否自动启动编辑(需要hasEdit:true时)
   * @param {Boolean} [options.isContinued=false] 是否连续标绘,联系标绘状态下无法编辑已有对象。
   * @param {Boolean} [options.isRestorePositions=false] 在标绘和编辑结束时，是否将坐标还原为普通值，true: 停止编辑时会有闪烁，但效率要好些。
   *
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效，且只有贴地对象有效)。
   * @param {Object|Function} [options.symbol] 矢量数据的style样式,为Function时是完全自定义的回调处理 symbol(attr, style, feature)
   * @param {GraphicType|String} [options.symbol.type] 标识数据类型，默认是根据数据生成 point、polyline、polygon
   * @param {Object} options.symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各{@link GraphicType}矢量数据的style参数。
   * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
   * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
   * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   *
   * @param {Object} [options.clustering] 设置聚合相关参数（仅对Entity点数据有效）：
   * @param {Boolean} [options.clustering.enabled=false] 是否开启聚合
   * @param {Number} [options.clustering.pixelRange=20] 多少像素矩形范围内聚合
   * @param {Boolean} [options.clustering.clampToGround=true] 是否贴地
   * @param {BillboardEntity.StyleOptions} [options.clustering.style] 聚合点的样式参数
   * @param {Number} [options.clustering.radius=26] 内置样式时，圆形图标的半径大小（单位：像素）
   * @param {String} [options.clustering.fontColor='#ffffff'] 内置样式时，数字的颜色
   * @param {String} [options.clustering.color='rgba(181, 226, 140, 0.6)'] 内置样式时，圆形图标的背景颜色
   * @param {Number} [options.clustering.opacity=0.5] 内置样式时，圆形图标的透明度
   * @param {Number} [options.clustering.borderWidth=5] 圆形图标的边框宽度（单位：像素），0不显示
   * @param {String} [options.clustering.borderColor='rgba(110, 204, 57, 0.5)'] 内置样式时，圆形图标的边框颜色
   * @param {Number} [options.clustering.borderOpacity=0.6] 内置样式时，圆形图标边框的透明度
   * @param {Function} [options.clustering.getImage] 自定义聚合的图标样式，例如：getImage:function(count) { return image}
   *
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑定，参数与popup属性完全相同。
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数,还包括：
   * @param {String} [options.tooltipOptions.title] 固定的标题名称
   * @param {String} [options.tooltipOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.tooltipOptions.noTitle] 不显示标题
   * @param {Object} [options.contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0至360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, -90至90
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, -90至90
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   *
   * @export
   * @class GraphicLayer
   * @extends {BaseGraphicLayer}
   * @see [支持的事件类型]{@link GraphicLayer.EventType}
   */
  class GraphicLayer extends BaseGraphicLayer {
    constructor(options = {}) {
      super(options);
      this._setOptionsHook(options, options);

      this._graphicList = new MarsArray();
    }

    _setOptionsHook(options, newOptions) {
      this.hasEdit = options.hasEdit ?? false;

      /**
       * 完成标绘时是否自动启动编辑(需要hasEdit:true时)
       * @type {Boolean}
       */
      this.isAutoEditing = options.isAutoEditing ?? true;

      /**
       * 是否连续标绘
       * @type {Boolean}
       */
      this.isContinued = options.isContinued ?? false;
    }

    // 默认
    get layer() {
      const arr = [];
      if (this._dataSource) {
        arr.push(this._dataSource);
      }
      if (this._primitiveCollection) {
        arr.push(this._primitiveCollection);
      }
      if (this._labelCollection) {
        arr.push(this._labelCollection);
      }
      if (this._billboardCollection) {
        arr.push(this._billboardCollection);
      }
      if (this._cloudCollection) {
        arr.push(this._cloudCollection);
      }
      if (this._pointCollection) {
        arr.push(this._pointCollection);
      }
      if (this._polylineCollection) {
        arr.push(this._polylineCollection);
      }
      return arr
    }

    /**
     * 是否聚合(点数据时)
     * @type {Boolean}
     */
    get clustering() {
      return this.dataSource?.clustering?.enabled
    }

    set clustering(val) {
      if (this.dataSource?.clustering) {
        this.dataSource.clustering.enabled = val;
      }
    }

    /**
     * 当加载Entity类型数据的内部Cesium容器 {@link BaseEntity}
     * @type {Cesium.CustomDataSource}
     * @readonly
     */
    get dataSource() {
      if (!this._dataSource) {
        this._dataSource = new Cesium__namespace.CustomDataSource(this.id);
        this._dataSource.show = this.show;
        if (this._state === State.ADDED) {
          this._map.dataSources.add(this._dataSource);
          if (Cesium__namespace.defined(this.options.zIndex)) {
            this.zIndex = this.options.zIndex;
          }
        }
      }
      return this._dataSource
    }

    /**
     * 当加载普通 primitive类型数据的内部Cesium容器 {@link BasePrimitive}
     * @type {Cesium.PrimitiveCollection}
     */
    get primitiveCollection() {
      if (!this._primitiveCollection) {
        this._primitiveCollection = new Cesium__namespace.PrimitiveCollection(this.options);
        this._primitiveCollection.show = this.show;
        if (this._state === State.ADDED) {
          this._map.scene.primitives.add(this._primitiveCollection);
          if (Cesium__namespace.defined(this.options.zIndex)) {
            this.zIndex = this.options.zIndex;
          }
        }
      }
      return this._primitiveCollection
    }

    /**
     * 当加载 文字primitive 数据的内部Cesium容器 {@link LabelPrimitive}
     * @type {Cesium.LabelCollection}
     * @readonly
     * @ignore
     */
    get labelCollection() {
      if (!this._labelCollection) {
        this._labelCollection = new Cesium__namespace.LabelCollection({ ...this.options, scene: this._map.scene });
        this._labelCollection.show = this.show;
        if (this._state === State.ADDED) {
          this._map.scene.primitives.add(this._labelCollection);
        }
      }
      return this._labelCollection
    }

    /**
     * 当加载 点primitive 数据的内部Cesium容器 {@link PointPrimitive}
     * @type {Cesium.PointPrimitiveCollection}
     * @readonly
     * @ignore
     */
    get pointCollection() {
      if (!this._pointCollection) {
        this._pointCollection = new Cesium__namespace.PointPrimitiveCollection(this.options);
        this._pointCollection.show = this.show;
        if (this._state === State.ADDED) {
          this._map.scene.primitives.add(this._pointCollection);
        }
      }
      return this._pointCollection
    }

    /**
     * 当加载 图标点primitive 数据的内部Cesium容器 {@link BillboardPrimitive}
     * @type {Cesium.BillboardCollection}
     * @readonly
     * @ignore
     */
    get billboardCollection() {
      if (!this._billboardCollection) {
        this._billboardCollection = new Cesium__namespace.BillboardCollection({ ...this.options, scene: this._map.scene });
        this._billboardCollection.show = this.show;
        if (this._state === State.ADDED) {
          this._map.scene.primitives.add(this._billboardCollection);
        }
      }
      return this._billboardCollection
    }

    /**
     * 当加载 积云primitive 数据的内部Cesium容器 {@link CloudPrimitive}
     * @type {Cesium.CloudCollection}
     * @readonly
     * @ignore
     */
    get cloudCollection() {
      if (!this._cloudCollection) {
        this._cloudCollection = new Cesium__namespace.CloudCollection(this.options.cloud);
        this._cloudCollection.show = this.show;
        if (this._state === State.ADDED) {
          this._map.scene.primitives.add(this._cloudCollection);
        }
      }
      return this._cloudCollection
    }

    /**
     * 当加载 简单线primitive 数据的内部Cesium容器 {@link PolylinePrimitive}
     * @type {Cesium.PolylineCollection}
     * @readonly
     * @ignore
     */
    get polylineCollection() {
      if (!this._polylineCollection) {
        this._polylineCollection = new Cesium__namespace.PolylineCollection(this.options);
        this._polylineCollection.show = this.show;
        if (this._state === State.ADDED) {
          this._map.scene.primitives.add(this._polylineCollection);
        }
      }
      return this._polylineCollection
    }

    /**
     * 当加载 DivGraphic 数据的内部DOM容器 {@link DivGraphic}
     *
     * @type {HTMLDivElement}
     * @readonly
     */
    get container() {
      if (!this._container) {
        this._container = create$3("div", "mars3d-divlayer");
        if (this.show) {
          this._container.style.display = "block";
        } else {
          this._container.style.display = "none";
        }

        if (this._state === State.ADDED) {
          this._map.container.appendChild(this._container);
        }
      }
      return this._container
    }

    /**
     * 当加载 DivGraphic 数据的DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
     * @type {Boolean}
     */
    get pointerEvents() {
      return this._pointerEvents
    }

    set pointerEvents(value) {
      this._pointerEvents = value;
      if (value) {
        this.container.style["pointer-events"] = "all";
      } else {
        /* 加上这个css后鼠标可以穿透，但是无法触发单击等鼠标事件 */
        this.container.style["pointer-events"] = "none";
      }
    }

    /**
     * 是否可以调整图层顺序（在同类型图层间）
     *
     * @type {Boolean}
     * @readonly
     */
    get hasZIndex() {
      return true
    }

    /**
     * 图层顺序，数字大的在上面。<br/>
     * 只对 同类型(Entity/Primitive) + 贴地(clampToGround: true) 矢量对象间有效
     *
     * @type {Number}
     */
    get zIndex() {
      return this.options.zIndex
    }

    set zIndex(zIndex) {
      this.options.zIndex = zIndex;

      if (zIndex == null) {
        return
      }

      // 调整primitives顺序
      if (this._primitiveCollection && this._map.scene.primitives.contains(this._primitiveCollection)) {
        this._primitiveCollection.zIndex = zIndex;

        // 先移动到最顶层
        this._map.scene.primitives.raiseToTop(this._primitiveCollection);

        const layers = this._map.scene.primitives;
        for (let i = layers.length - 1; i >= 0; i--) {
          const layer = layers.get(i);
          if (layer === this._primitiveCollection) {
            continue
          }
          if (Cesium__namespace.defined(layer.zIndex) && zIndex < layer.zIndex) {
            this._map.scene.primitives.lower(this._primitiveCollection); // 下移一个位置
          }
        }
      }

      // 调整dataSources顺序
      if (this._dataSource && this._map.dataSources.contains(this._dataSource)) {
        this._dataSource.zIndex = zIndex;

        // 先移动到最顶层
        this._map.dataSources.raiseToTop(this._dataSource);

        const layers = this._map.dataSources;
        for (let i = layers.length - 1; i >= 0; i--) {
          const layer = layers.get(i);
          if (layer === this._dataSource) {
            continue
          }
          if (Cesium__namespace.defined(layer.zIndex) && zIndex < layer.zIndex) {
            this._map.dataSources.lower(this._dataSource); // 下移一个位置
          }
        }
      }
    }

    /**
     * 图层内的Graphic矢量数据个数
     *
     * @type {Number}
     * @readonly
     */
    get length() {
      return this._graphicList.length
    }

    /**
     * 图层内的Graphic集合对象
     *
     * @type {BaseGraphic[]|Array}
     * @readonly
     */
    get graphics() {
      return this.getGraphics()
    }

    /**
     * 是否自动激活编辑（true时，单击后自动激活编辑）
     *
     * @type {Boolean}
     */
    get hasEdit() {
      return this._hasEdit
    }

    set hasEdit(val) {
      if (val) {
        this.activateEdit();
      } else {
        this.disableEdit();
      }
    }

    /**
     * 是否正在编辑状态
     * @type {Boolean}
     * @readonly
     */
    get isEditing() {
      return this._graphic_editing != null
    }

    /**
     * 是否允许鼠标穿透拾取
     * @type {Boolean|Function}
     */
    get allowDrillPick() {
      return this.options.allowDrillPick
    }

    set allowDrillPick(value) {
      this.options.allowDrillPick = value;
    }

    /**
     * 添加到地图上的钩子方法
     *
     * @param {Map} map 地图对象
     * @return {void}  无
     * @private
     */
    _onAdd(map) {
      if (this._state === State.ADDED) {
        return
      }
      this._state = State.ADDED;
      this._map = map;

      if (this.options.eventParent) {
        this.addEventParent(this.options.eventParent);
      } else if (this.options?.eventParent === false) ; else {
        this.addEventParent(map);
      }

      if (this._dataSource) {
        this._map.dataSources.add(this._dataSource);
      }
      if (this._primitiveCollection) {
        this._map.scene.primitives.add(this._primitiveCollection);
      }
      if (this._labelCollection) {
        this._map.scene.primitives.add(this._labelCollection);
      }
      if (this._billboardCollection) {
        this._map.scene.primitives.add(this._billboardCollection);
      }
      if (this._cloudCollection) {
        this._map.scene.primitives.add(this._cloudCollection);
      }
      if (this._pointCollection) {
        this._map.scene.primitives.add(this._pointCollection);
      }
      if (this._polylineCollection) {
        this._map.scene.primitives.add(this._polylineCollection);
      }
      if (this._container) {
        this._map.container.appendChild(this._container);
      }

      if (this._mountedHook) {
        if (!this._createOK) {
          this._createOK = true;
          this._mountedHook();
        }
      }
      this._addedHook && this._addedHook();

      this._graphicList.forEach((graphic) => {
        graphic?._onAdd && graphic._onAdd(this);
      }, this);

      if (Cesium__namespace.defined(this.options.zIndex)) {
        this.zIndex = this.options.zIndex;
      }

      this.fire(EventType.addLayer, { layer: this }, true);
    }

    /**
     * 从地图上移除的钩子方法
     *
     * @return {void}  无
     * @private
     */
    _onRemove() {
      if (this._state !== State.ADDED) {
        return
      }
      if (!this._map) {
        return
      }

      this._graphicList.forEach((graphic) => {
        graphic?._onRemove && graphic._onRemove();
      }, this);

      if (this._dataSource) {
        this._map.dataSources.remove(this._dataSource);
      }
      if (this._primitiveCollection) {
        this._map.scene.primitives.remove(this._primitiveCollection);
      }
      if (this._labelCollection) {
        this._map.scene.primitives.remove(this._labelCollection);
      }
      if (this._billboardCollection) {
        this._map.scene.primitives.remove(this._billboardCollection);
      }
      if (this._cloudCollection) {
        this._map.scene.primitives.remove(this._cloudCollection);
      }
      if (this._pointCollection) {
        this._map.scene.primitives.remove(this._pointCollection);
      }
      if (this._polylineCollection) {
        this._map.scene.primitives.remove(this._polylineCollection);
      }
      if (this._container && this._container.parentNode) {
        this._map.container.removeChild(this._container);
      }

      // 自动释放时
      if (this._map.scene.primitives.destroyPrimitives) {
        this._primitiveCollection = null;
        this._labelCollection = null;
        this._billboardCollection = null;
        this._cloudCollection = null;
        this._pointCollection = null;
        this._polylineCollection = null;
      }

      this._removedHook && this._removedHook();
      this._state = State.REMOVED;

      this.fire(EventType.remove);
      this.fire(EventType.removeLayer, { layer: this }, true);

      if (this.options?.eventParent) {
        this.removeEventParent(this.options.eventParent);
      } else if (this.options?.eventParent === false) ; else {
        this.removeEventParent(this._map);
      }

      this._map = null;
    }

    _showHook(show) {
      super._showHook(show);

      if (show) {
        if (this._container) {
          this._container.style.display = "block";

          this._graphicList.forEach((graphic) => {
            graphic.updateDivPosition && graphic.updateDivPosition();
          }, this);
        }
      } else {
        if (this._container) {
          this._container.style.display = "none";
        }
        this.stopDraw();
      }
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      super._mountedHook();

      this.on(
        EventType.drawCreated,
        (e) => {
          this.stopDraw();
          if (this.isContinued) {
            // 连续标绘时
            this.startDraw(clone(e.graphic.options));
          } else if (this.hasEdit && this.isAutoEditing) {
            // 创建完成后激活编辑
            this.startEditing(e.graphic);
          }
        },
        this
      );
      this.on(
        EventType.load,
        (e) => {
          if (this.hasEdit && this.isAutoEditing && this._graphic_editing === e.graphic) {
            this.startEditing(e.graphic); // 模型加载完成后更新编辑
          }
        },
        this
      );
      this.on(
        EventType.removeGraphic,
        (e) => {
          if (this._graphic_drawing === e.graphic) {
            this._graphic_drawing = null;
          }
          if (this._graphic_editing === e.graphic) {
            this._graphic_editing = null;
          }
        },
        this
      );
      this.on(
        EventType.editStart,
        (e) => {
          this._graphic_editing = e.graphic;
        },
        this
      );
      this.on(
        EventType.editStop,
        (e) => {
          this._graphic_editing = null;
        },
        this
      );

      if (this.options.clustering) {
        this._bindClustering(this.options.clustering);
      }

      if (this.options.data && this.type === "graphic") {
        this.addGraphic(this.options.data);
        this._readyPromise.resolve(this);
      }
      if (this.options.geojson) {
        this.loadGeoJSON(this.options.geojson);
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      super._addedHook();

      if (this._hasEdit) {
        this._bindEditEvent();
      }

      if (this.options.flyTo) {
        this.flyToByAnimationEnd();
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */
    _removedHook() {
      super._removedHook();

      if (this._hasEdit) {
        this.stopDraw();
        this._unbindEditEvent();
      }
    }

    /**
     * 获取图层内所有数据的 矩形边界值
     * @param {Boolean} [isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */
    getRectangle(isFormat) {
      let rectangleAll;
      this._graphicList.forEach((graphic) => {
        if (!graphic.getRectangle) {
          return
        }

        const rectangle = graphic.getRectangle();
        if (!Cesium__namespace.defined(rectangle)) {
          return
        }

        if (rectangleAll) {
          rectangleAll = Cesium__namespace.Rectangle.union(rectangle, rectangleAll);
        } else {
          rectangleAll = rectangle;
        }
      }, this);

      if (isFormat) {
        return formatRectangle(rectangleAll)
      } else {
        return rectangleAll
      }
    }

    /**
     * 将图层数据导出为GeoJSON格式规范对象。
     * @param {Object} [options] 参数对象:
     * @param {Boolean} [options.noAlt] 不导出高度值
     * @param {Boolean} [options.stopEdit = false] 是否停止绘制或编辑
     * @return {Object} GeoJSON格式规范对象
     */
    toGeoJSON(options) {
      if (options?.stopEdit) {
        this.stopEditing();
      }

      let features = [];
      this._graphicList.forEach((graphic) => {
        if (graphic.isPrivate) {
          return
        }

        const geojson = graphic.toGeoJSON(options);
        if (!geojson) {
          return
        }
        if (Array.isArray(geojson)) {
          features = features.concat(geojson);
        } else {
          features.push(geojson);
        }
      }, this);

      return {
        type: "FeatureCollection",
        layer: { id: this.id, name: this.name },
        features: features
      }
    }

    // 转为json的额外需要处理的对象
    _toJsonEx(newData) {
      this.stopEditing();

      let arr = [];
      this._graphicList.forEach((graphic) => {
        if (graphic.isPrivate || !graphic.state) {
          return
        }

        const geojson = graphic.toJSON();
        if (!geojson) {
          return
        }
        if (Array.isArray(geojson)) {
          arr = arr.concat(geojson);
        } else {
          arr.push(geojson);
        }
      }, this);
      newData.data = arr;
    }

    /**
     * 加载转换GeoJSON格式规范数据为Graphic后加载到图层中。
     *
     * @param {String|Object} geojson GeoJSON格式规范数据
     * @param {Object} [options] 加载控制参数,包含：
     * @param {Boolean} [options.clear=false] 是否清除图层已有数据
     * @param {Boolean} [options.flyTo=false] 是否加载完成后进行飞行到数据区域
     * @param {GraphicType|String} [options.type] 转为指定的类型
     * @param {Object} [options.style] 可以设置指定style样式,每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
     * @param {String} [options.crs]  原始数据的坐标系，如'EPSG:3857' （可以从 {@link http://epsg.io }查询）
     * @param {Function} [options.onEachFeature] 创建每个Graphic前的回调
     * @return {BaseGraphic[]} 转换后的Graphic对象数组
     *
     */
    loadGeoJSON(geojson, options = {}) {
      try {
        if (isString(geojson)) {
          geojson = JSON.parse(geojson);
        }
      } catch (e) {
        logError("loadGeoJSON:请确认json文件格式正确!", e);
        return
      }

      const dstCoordType = this._map.chinaCRS; // map地图的坐标系
      const srcCoordType = this.options.chinaCRS; // layer图层的坐标系（默认与地图一致）
      const TransFun = getTransFun(srcCoordType, dstCoordType);

      const arr = geoJsonToGraphics(geojson, {
        ...options,
        symbol: this.options.symbol,
        crs: this.options.crs,
        onPointTrans: TransFun
      });
      return this._addGraphicByArrOptions(arr, options)
    }

    _addGraphicByArrOptions(arr, options = {}) {
      if (options.clear) {
        this.clear();
      }

      let arrthis = [];
      if (arr.length === 0) {
        return arrthis
      }

      const type = arr[0].type;
      const defaultOptions = this.options.graphicOptions || {};
      if (isCombineType(type)) {
        const graphicOptions = {
          ...defaultOptions,
          type: type,
          instances: arr
        };
        if (options.onEachFeature) {
          options.onEachFeature(graphicOptions);
        }
        const graphic = this._addGraphic(graphicOptions);
        arrthis.push(graphic);
      } else {
        for (let i = 0, len = arr.length; i < len; i++) {
          const graphicOptions = {
            ...defaultOptions,
            ...arr[i]
          };
          if (options.onEachFeature) {
            options.onEachFeature(graphicOptions);
          }

          if (this.options.onCreateGraphic) {
            const graphic = this.options.onCreateGraphic(graphicOptions);
            if (graphic) {
              this.addGraphic(graphic);
              if (Array.isArray(graphic)) {
                arrthis = arrthis.concat(graphic);
              } else {
                arrthis.push(graphic);
              }
            }
          } else {
            const graphic = this._addGraphic(graphicOptions);
            arrthis.push(graphic);
          }
        }
      }

      if (options.flyTo && this.show) {
        this._map.flyToGraphic(arrthis);
      }

      return arrthis
    }

    // 聚合处理
    _bindClustering(options = {}) {
      const clustering = this.dataSource?.clustering;
      if (!clustering) {
        return
      }

      clustering.enabled = options.enabled ?? false;
      clustering.pixelRange = options.pixelRange ?? 20; // 多少像素矩形范围内聚合

      // 一些属性
      let heightReference;
      if (options.clampToGround) {
        heightReference = Cesium__namespace.HeightReference.CLAMP_TO_GROUND;
      } else {
        heightReference = Cesium__namespace.HeightReference.NONE;
      }

      let timeTik = setInterval(function () {
        if (clustering._cluster) {
          clustering._cluster();
        }
      }, 800);
      clustering.clusterEvent.addEventListener((clusteredEntities, cluster) => {
        if (timeTik) {
          clearInterval(timeTik);
          timeTik = null;
        }

        cluster.label._mars3d_layerId = this.id;
        cluster.label.show = false;
        cluster.point._mars3d_layerId = this.id;

        cluster.billboard._mars3d_layerId = this.id;
        cluster.billboard.show = true;
        cluster.billboard.id = cluster.label.id;
        cluster.billboard.verticalOrigin = Cesium__namespace.VerticalOrigin.BOTTOM;
        cluster.billboard.heightReference = heightReference; // 贴地
        cluster.billboard.scale = 0.5; // 必须，解决数字文本锯齿

        if (options.style) {
          BillboardStyleConver.toCesiumVal(options.style, cluster.billboard);

          if (options.style.setHeight) {
            cluster.billboard.position = setPositionsHeight(cluster.billboard.position, options.style.setHeight);
          }
          if (options.style.addHeight) {
            cluster.billboard.position = addPositionsHeight(cluster.billboard.position, options.style.addHeight);
          }
        }
        if (options.getImage) {
          cluster.billboard.image = options.getImage(clusteredEntities.length, options);
        } else {
          cluster.billboard.image = getCircleImage(clusteredEntities.length, options);
        }
      });
    }

    /**
     * 设置透明度 , 非全部矢量数据都支持，具体需要对应Graphic支持才有效
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this._opacity = value;

      this._graphicList.forEach((graphic) => {
        if (graphic.setOpacity) {
          graphic.setOpacity(value);
        }
      }, this);
    }

    //= =================以下是对graphic矢量数据的管理=========================

    /**
     * 添加Graphic矢量数据
     *
     * @param {BaseGraphic|BaseGraphic[]|*} graphic 矢量数据
     * @return {BaseGraphic|BaseGraphic[]} 添加后的Graphic对象
     */
    addGraphic(graphic) {
      if (!this._createOK && this._mountedHook) {
        this._createOK = true;
        this._mountedHook();
      }

      if (Array.isArray(graphic)) {
        if (graphic.length === 0) {
          return
        }
        const type = graphic[0].type;
        if (isCombineType(type) && !graphic[0].instances) {
          const graphicOptions = {
            type: type,
            instances: graphic
          };
          return this._addGraphic(graphicOptions)
        } else {
          const arrNew = [];
          for (let index = 0, len = graphic.length; index < len; index++) {
            const result = this._addGraphic(graphic[index]);
            if (result) {
              arrNew.push(result);
            }
          }
          return arrNew
        }
      } else {
        return this._addGraphic(graphic)
      }
    }

    // 内部添加Grphic
    _addGraphic(graphic) {
      if (this._graphicList.get(graphic?.id)) {
        graphic.id = createGuid();
        logWarn("addGraphic:数据id存在冲突，已重新赋值id", graphic);
      }

      if (!graphic._onAdd && graphic.type) {
        graphic = create$4(graphic.type, graphic);
      }

      if (graphic) {
        graphic._onAdd(this);
        this._graphicList.set(graphic.id, graphic);
      }
      return graphic
    }

    /**
     * 移除Graphic矢量数据
     *
     * @param {BaseGraphic|*} graphic 矢量数据
     * @param {Boolean} [hasDestroy=false] 是否释放矢量对象
     * @return {GraphicLayer} 当前对象本身，可以链式调用
     */
    removeGraphic(graphic, hasDestroy) {
      this._removeGraphic(graphic, hasDestroy);
      return this
    }

    // 内部移除Grphic
    _removeGraphic(graphic, hasDestroy, hasClear) {
      if (!graphic || !graphic._onRemove) {
        return this
      }

      if (!hasClear) {
        this._graphicList.remove(graphic.id);
      }

      graphic._onRemove();
      if (hasDestroy) {
        graphic.destroy();
      }
    }

    /**
     * 根据id或uuid取矢量数据对象
     *
     * @param {String|Number} id  矢量数据id或uuid
     * @return {BaseGraphic|*} 矢量数据对象
     */
    getGraphicById(id) {
      return this._graphicList.get(id)
    }

    /**
     * 根据 指定属性 获取 单个矢量数据对象（多个匹配时取首个）
     * @param {String|Number} attrValue 属性值
     * @param {String} [attrName='id'] 属性键
     * @return {BaseGraphic|*} 矢量数据对象
     */
    getGraphicByAttr(attrValue, attrName) {
      return this._graphicList.getByAttr(attrValue, attrName, "attr")
    }

    /**
     * 根据 指定属性 获取  矢量数据对象 数组
     * @param {String|Number} attrValue 属性值
     * @param {String} [attrName='id'] 属性键
     * @return {BaseGraphic[]} 矢量数据对象
     */
    getGraphicsByAttr(attrValue, attrName) {
      return this._graphicList.getListByAttr(attrValue, attrName, "attr")
    }

    /**
     * 根据 指定style样式 获取  矢量数据对象 数组
     *
     * @param {String} styleName style内的字段名称
     * @param {String|Number|Boolean|*} styleVal 属性值
     * @return {BaseGraphic[]} 矢量数据对象
     */
    getGraphicsByStyle(styleName, styleVal) {
      const result = [];
      this._graphicList.forEach((graphic) => {
        if (graphic.style[styleName] === styleVal) {
          result.push(graphic);
        }
      }, this);
      return result
    }

    /**
     * 遍历所有矢量数据并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} [context] 侦听器的上下文(this关键字将指向的对象)。
     * @return {GraphicLayer} 当前对象本身,可以链式调用
     */
    eachGraphic(method, context) {
      this._graphicList.forEach(method, context || this);
      return this
    }

    /**
     * 获取图层内 所有矢量数据
     * @param {boolean} [hasPrivate=false] 是否取私有的graphic
     * @return {BaseGraphic[]|Array} 矢量数据数组
     */
    getGraphics(hasPrivate = false) {
      if (hasPrivate) {
        return this._graphicList.values
      } else {
        const arrNew = [];
        this._graphicList.forEach((graphic) => {
          if (!graphic.isPrivate) {
            arrNew.push(graphic);
          }
        }, this);
        return arrNew
      }
    }

    /**
     * 清除图层内所有矢量数据
     *
     * @param {Boolean} [hasDestroy=false] 是否释放矢量对象
     * @return {void}  无
     */
    clear(hasDestroy) {
      this.stopDraw();

      if (this._graphicList) {
        this._graphicList.forEach((graphic) => {
          this._removeGraphic(graphic, hasDestroy, true);
        }, this);
        this._graphicList.removeAll();
      }

      if (this._dataSource) {
        this._dataSource.entities.removeAll();
      }
      if (this._primitiveCollection) {
        this._primitiveCollection.removeAll();
      }
      if (this._labelCollection) {
        this._labelCollection.removeAll();
      }
      if (this._billboardCollection) {
        this._billboardCollection.removeAll();
      }
      if (this._cloudCollection) {
        this._cloudCollection.removeAll();
      }
      if (this._pointCollection) {
        this._pointCollection.removeAll();
      }
      if (this._polylineCollection) {
        this._polylineCollection.removeAll();
      }
      this._closeAllControl();
    }

    /**
     * 异步计算更新坐标进行贴地(或贴模型)
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @param {Function} options.endItem  每计算完成1个graphic高度后 的回调方法
     * @param {Function} options.end  异步计算高度完成所有graphic后 的回调方法
     * @return {Promise<BaseGraphic|*>} 绘制创建完成的Promise
     */
    autoSurfaceHeight(options = {}) {
      return new Promise((resolve, reject) => {
        const graphics = this.getGraphics();

        let index = -1;
        const count = graphics.length;
        function getLineFD() {
          index++;
          if (index >= count) {
            if (options.end) {
              options.end({ index, count, graphics });
            }
            resolve(graphics);
            return
          }

          const graphic = graphics[index];
          if (graphic.autoSurfaceHeight) {
            graphic.autoSurfaceHeight(options).then(() => {
              if (options.endItem) {
                options.endItem({ graphic, index, count });
              }
              getLineFD();
            });
          } else {
            if (options.endItem) {
              options.endItem({ graphic, index, count });
            }
            getLineFD();
          }
        }
        getLineFD();
      })
    }

    // 兼容旧版本命名，同updateSurfaceHeight
    clampToGround(options) {
      return this.autoSurfaceHeight(options)
    }

    //= =================绘制及编辑=======================
    /**
     * 开始绘制矢量数据，绘制的数据会加载在当前图层。
     *
     * @param {Object|*} options 绘制参数，包含：
     * @param {GraphicType|String} options.type 类型
     * @param {Object} [options.style] 矢量数据样式，具体参考支持 {@link GraphicType}查询对应type的类
     * @param {Object} [options.attr] 矢量数据的 属性信息，可以任意附加属性。
     * @param {Function} [options.success] 绘制创建完成的回调方法，同drawCreated事件，例如： success: function (graphic){  }
     * //以下为Entity支持的构造参数
     * @param {String} [options.name] 矢量数据名称
     * @param {Number} [options.maxPointNum] 线面数据时限定的最大坐标个数
     * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
     * @param {Number} [options.addHeight] 在绘制时，在绘制点的基础上增加的高度值
     * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
     * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
     * @return {Promise<BaseGraphic|*>} 绘制创建完成的Promise,等价于success参数
     *
     * @example
      //写法一，使用Promise
      graphicLayer.startDraw({
        type: "point",
        style: { pixelSize: 12, color: "#3388ff" },
      })
      .then(function (graphic) {
        console.log("绘制矢量对象完成", graphic);
      });

      //写法二，使用success回调方法参数
      graphicLayer.startDraw({
        type: "point",
        style: { pixelSize: 12, color: "#3388ff" },
        success: function (graphic){
          console.log("绘制矢量对象完成", graphic);
        }
      })

      //写法三，在图层全局监听完成事件
      graphicLayer.on(mars3d.EventType.drawCreated, function (e) {
        console.log("绘制矢量对象完成", e);
      });
      graphicLayer.startDraw({
        type: "point",
        style: { pixelSize: 12, color: "#3388ff" }
      })
     *
     */
    startDraw(options) {
      return new Promise((resolve, reject) => {
        this.stopDraw();

        if (!this._map) {
          throw new Error("startDraw:需要 map.addLayer(当前图层) 后，才行使用本方法")
        }
        options._promise = { resolve, reject };

        const graphic = fromDraw(this, options);
        if (graphic != null) {
          this._graphic_drawing = graphic;
        }
      })
    }

    /**
     * 完成绘制和编辑，如有未完成的绘制会自动完成。
     * 在移动端需要调用此方法来类似PC端双击结束。
     * @return {boolean}  是否正常结束了矢量对象绘制
     */
    endDraw() {
      this.stopEditing();
      if (this._graphic_drawing) {
        const result = this._graphic_drawing.endDraw(); // 说明有未完成编辑的对象
        if (result) {
          this._graphic_drawing = null;
        }
        return result
      }
      return false
    }

    /**
     * 停止绘制，如有未完成的绘制会自动删除
     * @return {boolean}  是否清除了未完成的对象
     */
    stopDraw() {
      this.stopEditing();
      if (this._graphic_drawing) {
        this._graphic_drawing.stopDraw();
        this._graphic_drawing = null;
        return true
      } else {
        return false
      }
    }

    /**
     * 清除正在绘制
     * @return {boolean}  是否清除了对象
     */
    clearDrawing() {
      if (this._graphic_drawing) {
        this._graphic_drawing.remove(true);
        this._graphic_drawing = null;
        return true
      } else {
        return false
      }
    }

    /**
     * 激活编辑，绑定相关处理，同 hasEdit=true
     * @return {GraphicLayer} 当前对象本身,可以链式调用
     */
    activateEdit() {
      if (this._hasEdit) {
        return
      }
      this._hasEdit = true;

      if (this._map) {
        this._bindEditEvent();
      }
      return this
    }

    /**
     * 释放编辑，解除绑定相关事件，同 hasEdit=false
     * @return {GraphicLayer} 当前对象本身,可以链式调用
     */
    disableEdit() {
      if (!this._hasEdit) {
        return
      }
      this._hasEdit = false;

      this._unbindEditEvent();
      this.stopEditing();
      return this
    }

    _bindEditEvent() {
      this._map.on(EventType.click, this._onClickHandler, this);
      this._map.on(EventType.mouseMoveTarget, this._onMouseMoveHandler, this);
    }

    _unbindEditEvent() {
      this._map.off(EventType.click, this._onClickHandler, this);
      this._map.off(EventType.mouseMoveTarget, this._onMouseMoveHandler, this);
    }

    _onMouseMoveHandler(event) {
      // 无法编辑时，跳出
      if (!this._hasEdit) {
        return
      }
      // 正在拖拽其他的entity时，跳出
      if (!this._map.scene.screenSpaceCameraController.enableInputs) {
        return
      }

      let graphic = event.graphic;
      if (!graphic) {
        const result = this._map.mouseEvent.getPickTarget(event.endPosition, event);
        graphic = result?.graphic;
      }

      if (graphic == null || graphic._layer !== this) {
        this._map.closeSmallTooltip();
        return
      }

      // 正在绘制本身时\是拖拽点时\不允许编辑，跳出
      if (graphic._enabledDraw || graphic.isPrivate || !graphic.hasEdit) {
        return
      }
      // 右键菜单打开了，跳出
      if (this._map.contextmenu.show && this._map.contextmenu.target === graphic) {
        return
      }

      let tooltip;
      if (isPCBroswer()) {
        tooltip = this._map.getLangText("_单击后激活编辑") + "<br/>" + this._map.getLangText("_右击菜单删除");
      } else {
        tooltip = this._map.getLangText("_单击后激活编辑");
      }
      this._map.openSmallTooltip(event.windowPosition, tooltip);
    }

    _onClickHandler(event) {
      if (this._graphic_drawing) {
        return
      }

      const graphic = event.graphic;
      if (graphic && (graphic.isPrivate || !graphic.hasEdit)) {
        return
      }

      if (this.hasEdit && graphic && event.layer === this) {
        this.startEditing(graphic, event);
      } else {
        this.stopEditing();
      }
    }

    /**
     * 激活编辑指定的矢量数据
     *
     * @param {BaseGraphic|*} graphic 需要激活编辑的矢量数据
     * @param {Object} [event] 内部使用，传递事件
     * @return {GraphicLayer} 当前对象本身,可以链式调用
     */
    startEditing(graphic, event) {
      if (!graphic || !graphic.startEditing || !graphic.isAdded || !graphic.hasEdit) {
        return
      }
      if (this._graphic_editing === graphic || graphic._enabledDraw) {
        return
      }

      this.stopEditing();

      graphic.startEditing();

      if (event && graphic._draw_tooltip) {
        this._map.openSmallTooltip(event.position, graphic._draw_tooltip);
      }

      this._graphic_editing = graphic;
      return this
    }

    /**
     * 停止编辑，释放正在编辑的对象。
     * @return {GraphicLayer} 当前对象本身,可以链式调用
     */
    stopEditing() {
      if (this._graphic_editing) {
        this._graphic_editing.stopEditing();
        this._graphic_editing = null;
      }
      return this
    }
  }

  // 注册下
  register$2("graphic", GraphicLayer);

  /**
   * @typedef {Object} MatrixMove.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} start 开始拖动编辑
   * @property {String} change 编辑了坐标
   * @property {String} stop 停止了编辑
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.change, function (event) {
   *   console.log('发送了变化', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 坐标点按XYZ轴平移图上编辑处理类
   * @param {Object} [options] 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} [options.position] 坐标位置
   * @param {Function} [options.onChange] 编辑移动了坐标后的回调方法
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @param {String|Number} [options.pid = -1] 量算对应的图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 量算对应的图层名称
   *
   * @export
   * @class MatrixMove
   * @extends {BaseThing}
   * @see [支持的事件类型]{@link MatrixMove.EventType}
   */
  class MatrixMove extends BaseThing {
    constructor(options = {}) {
      super(options);

      this.translation = new Cesium__namespace.Cartesian3(0, 0, 0); // 模型平移量（向量表示）
      this.rotateMatrix = new Cesium__namespace.Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1); // 模型旋转量(旋转矩阵表示)

      if (options.position) {
        this.position = options.position; // 坐标轴的中心点
      }
    }

    //= ========= 对外属性 ==========
    /**
     * 位置坐标 （笛卡尔坐标）, 赋值时可以传入LatLngPoint对象
     * @type {Cesium.Cartesian3}
     */
    get position() {
      return this._position
    }

    set position(value) {
      this._position = LngLatPoint.toCartesian(value);

      this._initByPosition();
      this._updatePositionHook(true);
    }

    /**
     * 是否正在拖动编辑
     * @type {boolean}
     * @readonly
     */
    get isMoveing() {
      if (!this._map) {
        return false
      }
      return this._map.scene.screenSpaceCameraController.enableRotate
    }

    //= ========= 方法 ==========

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._graphicLayer = new GraphicLayer({
        private: true
      });
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.addLayer(this._graphicLayer);

      this._updatePositionHook(true);
      this._createGraphics();

      this._bindEvent();
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this._graphic_move_x) {
        delete this._graphic_move_x;
      }
      if (this._graphic_move_y) {
        delete this._graphic_move_y;
      }
      if (this._graphic_move_z) {
        delete this._graphic_move_z;
      }
      if (this._graphic_dragger_ing) {
        delete this._graphic_dragger_ing;
      }

      this._graphicLayer.clear();
      this._map.removeLayer(this._graphicLayer);

      this._unbindEvent();
    }

    _createGraphics() {
      this._graphicLayer.clear();

      // x轴移动
      this._graphic_move_x = new PolylinePrimitive({
        positions: this._positions_line_x,
        style: {
          width: 15,
          arcType: Cesium__namespace.ArcType.NONE,
          materialType: PolylineArrow,
          color: Cesium__namespace.Color.RED,
          depthFail: true
        },
        attr: {
          move: true,
          type: Cesium__namespace.Axis.X
        },
        asynchronous: false
      });
      this._graphicLayer.addGraphic(this._graphic_move_x);

      // y轴移动
      this._graphic_move_y = new PolylinePrimitive({
        positions: this._positions_line_y,
        style: {
          width: 15,
          arcType: Cesium__namespace.ArcType.NONE,
          materialType: PolylineArrow,
          color: Cesium__namespace.Color.GREEN,
          depthFail: true
        },
        attr: {
          move: true,
          type: Cesium__namespace.Axis.Y
        },
        asynchronous: false
      });
      this._graphicLayer.addGraphic(this._graphic_move_y);

      // z轴移动
      this._graphic_move_z = new PolylinePrimitive({
        positions: this._positions_line_z,
        style: {
          width: 15,
          arcType: Cesium__namespace.ArcType.NONE,
          materialType: PolylineArrow,
          color: Cesium__namespace.Color.BLUE,
          depthFail: true
        },
        attr: {
          move: true,
          type: Cesium__namespace.Axis.Z
        },
        asynchronous: false
      });
      this._graphicLayer.addGraphic(this._graphic_move_z);

      // 移动中指示提示
      this._graphic_dragger_ing = new PolylinePrimitive({
        positions: [],
        style: {
          width: 3,
          arcType: Cesium__namespace.ArcType.NONE,
          materialType: PolylineDash,
          color: Cesium__namespace.Color.YELLOW,
          depthFail: true
        },
        asynchronous: false,
        show: false
      });
      this._graphicLayer.addGraphic(this._graphic_dragger_ing);
    }

    _initByPosition() {
      this.modelToWorld = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(this.position); // 模型坐标系转世界坐标系
      this.worldToModel = Cesium__namespace.Matrix4.inverse(this.modelToWorld, new Cesium__namespace.Matrix4()); // 世界坐标系转模型坐标系

      this.matrix = this.modelToWorld.clone();
      this.inverseMatrix = Cesium__namespace.Matrix4.inverse(this.matrix, new Cesium__namespace.Matrix4()); // 坐标轴变换矩阵的逆矩阵，将世界坐标转换为坐标轴所在局部坐标

      this.normalX = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, Cesium__namespace.Cartesian3.UNIT_X, new Cesium__namespace.Cartesian3()); // 坐标轴的X单位向量
      this.normalY = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, Cesium__namespace.Cartesian3.UNIT_Y, new Cesium__namespace.Cartesian3()); // 坐标轴的Y单位向量
      this.normalZ = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, Cesium__namespace.Cartesian3.UNIT_Z, new Cesium__namespace.Cartesian3()); // 坐标轴的Z单位向量

      this._positions_line_x = [];
      this._positions_line_y = [];
      this._positions_line_z = [];
    }

    _updatePositionHook(updateRadius) {
      if (!this._map) {
        return
      }

      const center = this.position.clone();

      if (updateRadius) {
        const primitiveInCamera = new Cesium__namespace.Matrix4.multiplyByPoint(this._map.camera.viewMatrix, center, new Cesium__namespace.Cartesian3());
        const width = -primitiveInCamera.z * Math.tan(this._map.camera.frustum.fov / 2) * 2;
        const factor = width / this._map.canvas.width;
        this.radius = 200 * factor; // 坐标轴的半径,计算为像素，当相机位置改变时动态更新
      }

      // 平移轴
      this._positions_line_x = [center, Cesium__namespace.Matrix4.multiplyByPoint(this.matrix, new Cesium__namespace.Cartesian3(this.radius, 0, 0), new Cesium__namespace.Cartesian3())];
      this._positions_line_y = [center, Cesium__namespace.Matrix4.multiplyByPoint(this.matrix, new Cesium__namespace.Cartesian3(0, this.radius, 0), new Cesium__namespace.Cartesian3())];
      this._positions_line_z = [center, Cesium__namespace.Matrix4.multiplyByPoint(this.matrix, new Cesium__namespace.Cartesian3(0, 0, this.radius), new Cesium__namespace.Cartesian3())];

      if (this._graphic_move_x) {
        this._graphic_move_x.positions = this._positions_line_x;
      }
      if (this._graphic_move_y) {
        this._graphic_move_y.positions = this._positions_line_y;
      }
      if (this._graphic_move_z) {
        this._graphic_move_z.positions = this._positions_line_z;
      }
    }

    // 绑定事件
    _bindEvent() {
      this._graphicLayer.on(EventType.leftDown, this._onMap_leftDown, this);
      this._map.on(EventType.leftUp, this._onMap_leftUp, this);

      this._map.on(EventType.middleClick, this._onMap_middleClick, this);
      this._map.on(EventType.wheel, this._onMap_wheel, this);
    }

    _unbindEvent() {
      this._graphicLayer.off(EventType.leftDown, this._onMap_leftDown, this);
      this._map.off(EventType.leftUp, this._onMap_leftUp, this);
      this._map.off(EventType.mouseMove, this._onMap_mouseMove, this);

      this._map.off(EventType.middleClick, this._onMap_middleClick, this);
      this._map.off(EventType.wheel, this._onMap_wheel, this);
    }

    _onMap_leftDown(event) {
      this._graphic = undefined;
      if (event.layer !== this._graphicLayer) {
        return
      }

      const graphic = event.graphic;
      if (!graphic || !(graphic.attr.move || graphic.attr.rotate)) {
        return
      }
      this._graphic = graphic;

      // 高亮
      if (!graphic.style.color_bak) {
        graphic.style.color_bak = graphic.style.color;
      }
      graphic.setStyle({ color: Cesium__namespace.Color.YELLOW });

      this._graphic_dragger_ing.positions = [this.position, this.position];
      this._graphic_dragger_ing.show = true;

      const editType = this._graphic.attr.type;
      this.fire(EventType.start, { ...event, editType: editType, graphic: graphic });

      if (this._map.scene.screenSpaceCameraController.enableInputs) {
        this._map.scene.screenSpaceCameraController.enableInputs = false;
        this._hasChangeEnableInputs = true;
      }

      // 绑定鼠标移动事件
      this._map.on(EventType.mouseMove, this._onMap_mouseMove, this);
    }

    // 平移 的拖动计算
    _onMap_mouseMove(event) {
      if (!this._graphic) {
        return
      }

      const startPosition = event.startPosition;
      const endPosition = event.endPosition;

      let chooseNormal;
      const editType = this._graphic.attr.type;
      if (editType === Cesium__namespace.Axis.X) {
        chooseNormal = this.normalX;
      }
      if (editType === Cesium__namespace.Axis.Y) {
        chooseNormal = this.normalY;
      }
      if (editType === Cesium__namespace.Axis.Z) {
        chooseNormal = this.normalZ;
      }

      // 平移
      const vector2d = new Cesium__namespace.Cartesian3(endPosition.x - startPosition.x, -(endPosition.y - startPosition.y), 0); // 平面向量
      const vector3d = new Cesium__namespace.Matrix4.multiplyByPointAsVector(this._map.camera.inverseViewMatrix, vector2d, new Cesium__namespace.Cartesian3()); // 世界坐标的三维向量

      // 计算一个比例因子，通过fov与z值计算该距离下的平行裁截面的面的宽度，与屏幕宽度做个比例
      const primitiveInCamera = new Cesium__namespace.Matrix4.multiplyByPoint(this._map.camera.viewMatrix, this.position, new Cesium__namespace.Cartesian3());
      const width = -primitiveInCamera.z * Math.tan(this._map.camera.frustum.fov / 2) * 2;
      const factor = width / this._map.canvas.width;
      const distance = Cesium__namespace.Cartesian3.dot(vector3d, chooseNormal) * factor; // 得到实际世界距离

      // 需要计算平移后的点，并且找到相对地表同高度的点
      // 平移前的点（经纬度）
      const currentPosition = Cesium__namespace.Cartographic.fromCartesian(this.position);
      // 平移后的点
      let newPosition = new Cesium__namespace.Cartesian3(
        this.position.x + chooseNormal.x * distance,
        this.position.y + chooseNormal.y * distance,
        this.position.z + chooseNormal.z * distance
      );
      if (editType !== Cesium__namespace.Axis.Z) {
        newPosition = Cesium__namespace.Cartographic.fromCartesian(newPosition);
        newPosition.height = currentPosition.height;
        if (editType === Cesium__namespace.Axis.X) {
          newPosition.latitude = currentPosition.latitude;
        } else {
          newPosition.longitude = currentPosition.longitude;
        }
        newPosition = Cesium__namespace.Cartesian3.fromRadians(newPosition.longitude, newPosition.latitude, newPosition.height);
      }

      // 更新平移量
      const newPositionInModel = Cesium__namespace.Matrix4.multiplyByPoint(this.inverseMatrix, newPosition, new Cesium__namespace.Cartesian3()); // 坐标轴坐标系的坐标
      Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, newPositionInModel, newPositionInModel); // 世界坐标系下的平移量
      Cesium__namespace.Matrix4.multiplyByVector(
        this.worldToModel,
        new Cesium__namespace.Cartesian4(newPositionInModel.x, newPositionInModel.y, newPositionInModel.z, 0),
        newPositionInModel
      );
      Cesium__namespace.Cartesian3.add(this.translation, newPositionInModel, this.translation);

      this.position = newPosition; // 更新坐标轴中心点
      this.matrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(this.position); // 更新坐标轴转换矩阵
      Cesium__namespace.Matrix4.inverse(this.matrix, this.inverseMatrix);

      const currentNormalX = this.normalX;
      const currentNormalY = this.normalY;
      const currentNormalZ = this.normalZ;
      this.normalX = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, Cesium__namespace.Cartesian3.UNIT_X, new Cesium__namespace.Cartesian3()); // 坐标轴的X单位向量
      this.normalY = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, Cesium__namespace.Cartesian3.UNIT_Y, new Cesium__namespace.Cartesian3()); // 坐标轴的Y单位向量
      this.normalZ = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, Cesium__namespace.Cartesian3.UNIT_Z, new Cesium__namespace.Cartesian3()); // 坐标轴的Z单位向量

      // 更新旋转矩阵
      if (editType === Cesium__namespace.Axis.X) {
        // 移动x轴时以y轴夹角确定绕z轴旋转角度，以z轴夹角确定绕y轴旋转角度
        let angleY = Cesium__namespace.Cartesian3.angleBetween(currentNormalY, this.normalY);
        let angleZ = Cesium__namespace.Cartesian3.angleBetween(currentNormalZ, this.normalZ);
        if (distance < 0) {
          angleZ = -angleZ;
          angleY = -angleY;
        }
        const rotateZ = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.worldToModel, currentNormalZ, new Cesium__namespace.Cartesian3());
        let inverseMatrix = Cesium__namespace.Matrix3.inverse(this.rotateMatrix, new Cesium__namespace.Matrix3()); // 旋转矩阵的逆矩阵，等于反向转
        let inModelAxis = Cesium__namespace.Matrix3.multiplyByVector(inverseMatrix, rotateZ, new Cesium__namespace.Cartesian3()); // 将选中的轴转到模型坐标下
        let rotate = this._axisRotation(inModelAxis, angleY); // 计算任意轴的旋转矩阵
        Cesium__namespace.Matrix3.multiply(this.rotateMatrix, rotate, this.rotateMatrix); // 更新旋转矩阵

        const rotateY = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.worldToModel, currentNormalY, new Cesium__namespace.Cartesian3());
        inverseMatrix = Cesium__namespace.Matrix3.inverse(this.rotateMatrix, new Cesium__namespace.Matrix3()); // 旋转矩阵的逆矩阵，等于反向转
        inModelAxis = Cesium__namespace.Matrix3.multiplyByVector(inverseMatrix, rotateY, new Cesium__namespace.Cartesian3()); // 将选中的轴转到模型坐标下
        rotate = this._axisRotation(inModelAxis, angleZ); // 计算任意轴的旋转矩阵
        Cesium__namespace.Matrix3.multiply(this.rotateMatrix, rotate, this.rotateMatrix); // 更新旋转矩阵
      }
      if (editType === Cesium__namespace.Axis.Y) {
        // 移动y轴时以z轴夹角确定绕x轴旋转角度(绕z轴不会变)
        let angleZ = Cesium__namespace.Cartesian3.angleBetween(currentNormalZ, this.normalZ);
        if (distance > 0) {
          angleZ = -angleZ;
        }
        const rotateX = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.worldToModel, currentNormalX, new Cesium__namespace.Cartesian3());
        const inverseMatrix = Cesium__namespace.Matrix3.inverse(this.rotateMatrix, new Cesium__namespace.Matrix3()); // 旋转矩阵的逆矩阵，等于反向转
        const inModelAxis = Cesium__namespace.Matrix3.multiplyByVector(inverseMatrix, rotateX, new Cesium__namespace.Cartesian3()); // 将选中的轴转到模型坐标下
        const rotate = this._axisRotation(inModelAxis, angleZ); // 计算任意轴的旋转矩阵
        Cesium__namespace.Matrix3.multiply(this.rotateMatrix, rotate, this.rotateMatrix); // 更新旋转矩阵
      }

      // 提示移动距离
      this._graphic_dragger_ing.positions = [this._graphic_dragger_ing.positions[0], newPosition];

      // const transform = Cesium.Matrix4.fromRotationTranslation(this.rotateMatrix, this.translation, new Cesium.Matrix4()) // 模型变换矩阵
      // const matrix = Cesium.Matrix4.multiply(this.modelToWorld, transform, new Cesium.Matrix4())

      this._updatePositionHook();

      const result = {
        ...event,
        editType: editType,
        position: newPosition
      };
      this.onChange(result);
    }

    _onMap_leftUp(event) {
      if (!this._graphic) {
        return
      }

      this._graphic.setStyle({ color: this._graphic.style.color_bak });
      this._graphic = null;

      this._graphic_dragger_ing.positions = [];
      this._graphic_dragger_ing.show = false;

      if (this._hasChangeEnableInputs) {
        this._map.scene.screenSpaceCameraController.enableInputs = true;
        delete this._hasChangeEnableInputs;
      }
      this._map.off(EventType.mouseMove, this._onMap_mouseMove, this);

      this.fire(EventType.stop, event);
    }

    _axisRotation(axis, angle, target) {
      let x = axis.x;
      let y = axis.y;
      let z = axis.z;
      const l = Math.sqrt(x * x + y * y + z * z);
      x = x / l;
      y = y / l;
      z = z / l;
      const xx = x * x;
      const yy = y * y;
      const zz = z * z;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const oneMCos = 1 - cos;

      target = target || new Cesium__namespace.Matrix3();

      target[Cesium__namespace.Matrix3.COLUMN0ROW0] = xx + (1 - xx) * cos;
      target[Cesium__namespace.Matrix3.COLUMN0ROW1] = x * y * oneMCos + z * sin;
      target[Cesium__namespace.Matrix3.COLUMN0ROW2] = x * z * oneMCos - y * sin;

      target[Cesium__namespace.Matrix3.COLUMN1ROW0] = x * y * oneMCos - z * sin;
      target[Cesium__namespace.Matrix3.COLUMN1ROW1] = yy + (1 - yy) * cos;
      target[Cesium__namespace.Matrix3.COLUMN1ROW2] = y * z * oneMCos + x * sin;

      target[Cesium__namespace.Matrix3.COLUMN2ROW0] = x * z * oneMCos + y * sin;
      target[Cesium__namespace.Matrix3.COLUMN2ROW1] = y * z * oneMCos - x * sin;
      target[Cesium__namespace.Matrix3.COLUMN2ROW2] = zz + (1 - zz) * cos;

      return target
    }

    _onMap_wheel() {
      this._updatePositionHook(true);
    }

    _onMap_middleClick(event) {
      const pickPosition = this._map.scene.pickPosition(event.position);
      if (pickPosition) {
        this.position = pickPosition; // 更新坐标轴中心点
        this.matrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(this.position); // 更新坐标轴转换矩阵
        Cesium__namespace.Matrix4.inverse(this.matrix, this.inverseMatrix);

        this._updatePositionHook();
      }
    }

    onChange(reuslt) {
      if (this.options.onChange) {
        this.options.onChange(reuslt);
      }
      this.fire(EventType.change, reuslt, true);
    }
  }

  /**
   * 按XYZ轴旋转方向图上编辑处理类
   * @param {Object} [options] 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} [options.position] 坐标位置
   * @param {Number} [options.heading = 0] 方向角 （度数值，0-360度）
   * @param {Number} [options.pitch = 0] 俯仰角（度数值，0-360度）
   * @param {Number} [options.roll = 0] 翻滚角（度数值，0-360度）
   * @param {Function} [options.onChange] 旋转了方向后的回调方法
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @param {String|Number} [options.pid = -1] 量算对应的图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 量算对应的图层名称
   *
   * @export
   * @class MatrixRotate
   * @extends {MatrixMove}
   * @see [支持的事件类型]{@link MatrixMove.EventType}
   */
  class MatrixRotate extends MatrixMove {
    /**
     * 四周方向角，0-360度角度值
     * @type {Number}
     */
    get heading() {
      return this.options.heading ?? 0
    }

    set heading(val) {
      this.options.heading = val;
    }

    /**
     * 俯仰角，上下摇摆的角度，0-360度角度值
     * @type {Number}
     */
    get pitch() {
      return this.options.pitch ?? 0
    }

    set pitch(val) {
      this.options.pitch = val;
    }

    /**
     * 滚转角，左右摆动的角度，0-360度角度值
     * @type {Number}
     */
    get roll() {
      return this.options.roll ?? 0
    }

    set roll(val) {
      this.options.roll = val;
    }

    //= ========= 方法 ==========

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      delete this._graphic_rotate_z;
      delete this._graphic_rotate_x;
      delete this._graphic_rotate_y;

      super._removedHook();
    }

    _createGraphics() {
      this._graphicLayer.clear();

      // 旋转
      this._graphic_rotate_x = new PolylinePrimitive({
        positions: this._positions_circle_x,
        style: {
          width: 8,
          color: Cesium__namespace.Color.RED,
          depthFail: true,
          depthFailColor: Cesium__namespace.Color.RED.withAlpha(0.5)
        },
        attr: {
          rotate: true,
          type: Cesium__namespace.Axis.X
        },
        asynchronous: false
      });
      this._graphicLayer.addGraphic(this._graphic_rotate_x);

      this._graphic_rotate_y = new PolylinePrimitive({
        positions: this._positions_circle_y,
        style: {
          width: 8,
          color: Cesium__namespace.Color.GREEN,
          depthFail: true,
          depthFailColor: Cesium__namespace.Color.GREEN.withAlpha(0.5)
        },
        attr: {
          rotate: true,
          type: Cesium__namespace.Axis.Y
        },
        asynchronous: false
      });
      this._graphicLayer.addGraphic(this._graphic_rotate_y);

      this._graphic_rotate_z = new PolylinePrimitive({
        positions: this._positions_circle_z,
        style: {
          width: 8,
          color: Cesium__namespace.Color.BLUE,
          depthFail: true,
          depthFailColor: Cesium__namespace.Color.BLUE.withAlpha(0.5)
        },
        attr: {
          rotate: true,
          type: Cesium__namespace.Axis.Z
        },
        asynchronous: false
      });
      this._graphicLayer.addGraphic(this._graphic_rotate_z);

      // 移动中指示提示
      this._graphic_dragger_ing = new PolylinePrimitive({
        positions: [],
        style: {
          width: 3,
          arcType: Cesium__namespace.ArcType.NONE,
          materialType: PolylineDash,
          color: Cesium__namespace.Color.YELLOW,
          depthFail: true
        },
        asynchronous: false,
        show: false
      });
      this._graphicLayer.addGraphic(this._graphic_dragger_ing);
    }

    _initByPosition() {
      // const heading = Cesium.Math.toRadians(this.heading)
      // const pitch = Cesium.Math.toRadians(this.pitch)
      // const roll = Cesium.Math.toRadians(this.roll)
      // this.modelToWorld = Cesium.Transforms.headingPitchRollToFixedFrame(this.position, new Cesium.HeadingPitchRoll(heading, pitch, roll)) // 坐标轴的变换矩阵，将坐标轴所在局部坐标转换为世界坐标

      this.modelToWorld = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(this.position); // 模型坐标系转世界坐标系
      this.worldToModel = Cesium__namespace.Matrix4.inverse(this.modelToWorld, new Cesium__namespace.Matrix4()); // 世界坐标系转模型坐标系

      this.matrix = this.modelToWorld.clone();
      this.inverseMatrix = Cesium__namespace.Matrix4.inverse(this.matrix, new Cesium__namespace.Matrix4()); // 坐标轴变换矩阵的逆矩阵，将世界坐标转换为坐标轴所在局部坐标

      this.normalX = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, Cesium__namespace.Cartesian3.UNIT_X, new Cesium__namespace.Cartesian3()); // 坐标轴的X单位向量
      this.normalY = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, Cesium__namespace.Cartesian3.UNIT_Y, new Cesium__namespace.Cartesian3()); // 坐标轴的Y单位向量
      this.normalZ = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, Cesium__namespace.Cartesian3.UNIT_Z, new Cesium__namespace.Cartesian3()); // 坐标轴的Z单位向量

      this._positions_circle_z = [];
      this._positions_circle_x = [];
      this._positions_circle_y = [];
    }

    _updatePositionHook(updateRadius) {
      if (!this._map) {
        return
      }

      const center = this.position.clone();

      if (updateRadius) {
        const primitiveInCamera = new Cesium__namespace.Matrix4.multiplyByPoint(this._map.camera.viewMatrix, center, new Cesium__namespace.Cartesian3());
        const width = -primitiveInCamera.z * Math.tan(this._map.camera.frustum.fov / 2) * 2;
        const factor = width / this._map.canvas.width;
        this.radius = 200 * factor; // 坐标轴的半径,计算为像素，当相机位置改变时动态更新
      }

      // 旋转轴
      this._positions_circle_z = [];
      this._positions_circle_x = [];
      this._positions_circle_y = [];
      for (let i = 0; i <= 360; i++) {
        const x = this.radius * Math.cos((i / 180) * Math.PI);
        const y = this.radius * Math.sin((i / 180) * Math.PI);

        const positionxoy = new Cesium__namespace.Cartesian3();
        Cesium__namespace.Cartesian3.add(center, Cesium__namespace.Cartesian3.multiplyByScalar(this.normalX, x, new Cesium__namespace.Cartesian3()), positionxoy);
        Cesium__namespace.Cartesian3.add(positionxoy, Cesium__namespace.Cartesian3.multiplyByScalar(this.normalY, y, new Cesium__namespace.Cartesian3()), positionxoy);
        this._positions_circle_z.push(positionxoy);

        const positionxoz = new Cesium__namespace.Cartesian3();
        Cesium__namespace.Cartesian3.add(center, Cesium__namespace.Cartesian3.multiplyByScalar(this.normalX, x, new Cesium__namespace.Cartesian3()), positionxoz);
        Cesium__namespace.Cartesian3.add(positionxoz, Cesium__namespace.Cartesian3.multiplyByScalar(this.normalZ, y, new Cesium__namespace.Cartesian3()), positionxoz);
        this._positions_circle_x.push(positionxoz);

        const positionyoz = new Cesium__namespace.Cartesian3();
        Cesium__namespace.Cartesian3.add(center, Cesium__namespace.Cartesian3.multiplyByScalar(this.normalY, x, new Cesium__namespace.Cartesian3()), positionyoz);
        Cesium__namespace.Cartesian3.add(positionyoz, Cesium__namespace.Cartesian3.multiplyByScalar(this.normalZ, y, new Cesium__namespace.Cartesian3()), positionyoz);
        this._positions_circle_y.push(positionyoz);
      }

      if (this._graphic_rotate_z) {
        this._graphic_rotate_z.positions = this._positions_circle_z;
      }
      if (this._graphic_rotate_x) {
        this._graphic_rotate_x.positions = this._positions_circle_x;
      }
      if (this._graphic_rotate_y) {
        this._graphic_rotate_y.positions = this._positions_circle_y;
      }
    }

    // 旋转 的拖动计算
    _onMap_mouseMove(event) {
      const startPosition = event.startPosition;
      const endPosition = event.endPosition;

      // 计算一个比例因子，通过fov与z值计算该距离下的平行裁截面的面的宽度，与屏幕宽度做个比例
      const primitiveInCamera = new Cesium__namespace.Matrix4.multiplyByPoint(this._map.camera.viewMatrix, this.position, new Cesium__namespace.Cartesian3());
      const width = -primitiveInCamera.z * Math.tan(this._map.camera.frustum.fov / 2) * 2;
      let factor = width / this._map.canvas.width;

      // 判断一下平面是否和相机的夹角
      const toPlane = new Cesium__namespace.Cartesian3(1, 1, 1);
      let angle;
      const editType = this._graphic.attr.type;
      if (editType === Cesium__namespace.Axis.Z) {
        toPlane.z = 0;
        angle = Cesium__namespace.Cartesian3.angleBetween(
          Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, new Cesium__namespace.Cartesian3(0, 0, 1), new Cesium__namespace.Cartesian3()),
          this._map.camera.direction
        );
      }
      if (editType === Cesium__namespace.Axis.X) {
        toPlane.y = 0;
        angle = Cesium__namespace.Cartesian3.angleBetween(
          Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, new Cesium__namespace.Cartesian3(0, 1, 0), new Cesium__namespace.Cartesian3()),
          this._map.camera.direction
        );
      }
      if (editType === Cesium__namespace.Axis.Y) {
        toPlane.x = 0;
        angle = Cesium__namespace.Cartesian3.angleBetween(
          Cesium__namespace.Matrix4.multiplyByPointAsVector(this.matrix, new Cesium__namespace.Cartesian3(1, 0, 0), new Cesium__namespace.Cartesian3()),
          this._map.camera.direction
        );
      }
      if (Math.abs(angle - Math.PI / 2) < 0.1) {
        factor = 1;
        primitiveInCamera.z = 0;
      }

      // 旋转变换
      let startPoiCartesian3 = new Cesium__namespace.Cartesian3(
        (startPosition.x - this._map.canvas.width / 2) * factor,
        (-startPosition.y + this._map.canvas.height / 2) * factor,
        primitiveInCamera.z
      );
      let endPoiCartesian3 = new Cesium__namespace.Cartesian3(
        (endPosition.x - this._map.canvas.width / 2) * factor,
        (-endPosition.y + this._map.canvas.height / 2) * factor,
        primitiveInCamera.z
      );
      Cesium__namespace.Matrix4.multiplyByPoint(this._map.camera.inverseViewMatrix, startPoiCartesian3, startPoiCartesian3); // 转换到世界坐标
      Cesium__namespace.Matrix4.multiplyByPoint(this._map.camera.inverseViewMatrix, endPoiCartesian3, endPoiCartesian3);
      Cesium__namespace.Matrix4.multiplyByPoint(this.inverseMatrix, startPoiCartesian3, startPoiCartesian3); // 转换到坐标系坐标
      Cesium__namespace.Matrix4.multiplyByPoint(this.inverseMatrix, endPoiCartesian3, endPoiCartesian3);
      // 将坐标投影到所需的平面
      startPoiCartesian3 = new Cesium__namespace.Cartesian3(startPoiCartesian3.x * toPlane.x, startPoiCartesian3.y * toPlane.y, startPoiCartesian3.z * toPlane.z);
      // Cesium.Cartesian3.normalize(startPoiCartesian3,startPoiCartesian3);
      endPoiCartesian3 = new Cesium__namespace.Cartesian3(endPoiCartesian3.x * toPlane.x, endPoiCartesian3.y * toPlane.y, endPoiCartesian3.z * toPlane.z);
      // Cesium.Cartesian3.normalize(endPoiCartesian3,endPoiCartesian3);

      angle = Cesium__namespace.Cartesian3.angleBetween(startPoiCartesian3, endPoiCartesian3);
      let currentAxis; // 选中平面对应的旋转轴（在世界坐标下）
      if (editType === Cesium__namespace.Axis.Z) {
        const direct = startPoiCartesian3.x * endPoiCartesian3.y - startPoiCartesian3.y * endPoiCartesian3.x; // 为了判断旋转方向
        currentAxis = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.worldToModel, this.normalZ, new Cesium__namespace.Cartesian3()); // 计算选中的轴在模型坐标系下对应的向量
        if (direct > 0) {
          angle = -angle;
        }
        this.heading = (this.heading + Cesium__namespace.Math.toDegrees(angle)) % 360;
      } else if (editType === Cesium__namespace.Axis.X) {
        const direct = startPoiCartesian3.x * endPoiCartesian3.z - startPoiCartesian3.z * endPoiCartesian3.x;
        currentAxis = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.worldToModel, this.normalY, new Cesium__namespace.Cartesian3());
        if (direct > 0) {
          angle = -angle;
        }
        this.pitch = (this.pitch + Cesium__namespace.Math.toDegrees(angle)) % 360;
      } else if (editType === Cesium__namespace.Axis.Y) {
        const direct = startPoiCartesian3.y * endPoiCartesian3.z - startPoiCartesian3.z * endPoiCartesian3.y;
        currentAxis = Cesium__namespace.Matrix4.multiplyByPointAsVector(this.worldToModel, this.normalX, new Cesium__namespace.Cartesian3());
        if (direct < 0) {
          angle = -angle;
        }
        this.roll = (this.roll + Cesium__namespace.Math.toDegrees(angle)) % 360;
      }

      const inverseMatrix = Cesium__namespace.Matrix3.inverse(this.rotateMatrix, new Cesium__namespace.Matrix3()); // 旋转矩阵的逆矩阵，等于反向转
      const inModelAxis = Cesium__namespace.Matrix3.multiplyByVector(inverseMatrix, currentAxis, new Cesium__namespace.Cartesian3()); // 计算该轴在经过旋转后的模型中的位置
      const rotate = this._axisRotation(inModelAxis, angle); // 得到任意轴的旋转矩阵
      Cesium__namespace.Matrix3.multiply(this.rotateMatrix, rotate, this.rotateMatrix); // 更新旋转矩阵

      // this._initByPosition()
      // this._updatePositionHook(editType)

      // 提示移动距离
      // const newPosition = Cesium.Matrix4.multiplyByPoint(this.matrix, new Cesium.Cartesian3(this.radius, 0, 0), new Cesium.Cartesian3())
      // this._graphic_dragger_ing.positions = [this._graphic_dragger_ing.positions[0], newPosition]

      const result = {
        ...event,
        editType: editType,
        position: this.position,
        heading: this.heading,
        pitch: this.pitch,
        roll: this.roll
      };
      this.onChange(result);
    }

    _onMap_middleClick(event) {
      // 覆盖父类
    }
  }

  /**
   * 标绘处理对应的编辑基类
   *
   * @export
   * @class EditBase
   */
  class EditBase {
    //= ========= 构造方法 ==========
    constructor(graphic) {
      this._graphic = graphic;
      this._map = graphic._map;

      this.draggers = [];
    }

    get enabled() {
      return this._enabled
    }

    get map() {
      return this._map
    }

    get layer() {
      return this._graphic._layer
    }

    get style() {
      return this._graphic.style
    }

    // 是否贴地
    get clampToGround() {
      return this._graphic?.style?.clampToGround
    }

    get type() {
      return this._graphic.type
    }

    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Object}
     * @readonly
     */
    get entityGraphic() {
      return this._graphic.entityGraphic
    }

    set positions(value) {
      this._graphic._positions_draw = value;
    }

    get positions() {
      return this._graphic._positions_draw
    }

    fire(type, data = {}, propagate = true) {
      if (this._graphic) {
        const parent = this._graphic.parent; // 需要先记录

        data.editType = this.type;
        this._graphic.fire(type, data, propagate);

        if (parent) {
          data.editType = parent.type;
          parent.fire(type, data, propagate);
        }
      }
    }

    formatNum(num, digits) {
      return formatNum$1(num, digits)
    }

    /**
     * 激活绘制
     * @return {EditBase} 当前对象本身，可以链式调用
     * @memberof EditBase
     */
    activate() {
      if (this._enabled) {
        return this
      }
      this._enabled = true;

      if (this._graphic._setPositionsToCallback) {
        this._graphic._setPositionsToCallback();
      }

      this.destroyDraggers();
      this.bindDraggers();
      this.bindEvent();

      this.fire(EventType.editStart);

      return this
    }

    /**
     * 释放绘制
     * @return {EditBase} 当前对象本身，可以链式调用
     * @memberof EditBase
     */
    disable() {
      if (!this._enabled) {
        return this
      }
      this._enabled = false;

      this._removeMatrixMove();
      this._removeMatrixRotate();

      this.unbindEvent();
      this.destroyDraggers();
      this.finish();

      if (this._graphic?._layer?.options?.isRestorePositions) {
        this._graphic._cancelPositionsCallback(); // 坐标CallbackProperty属性改为实际值,提高效率
      }
      this.fire(EventType.editStop);

      return this
    }

    // 图形编辑结束后调用
    finish() {}
    // 拖拽点 事件
    bindEvent() {
      this._map.on(EventType.leftDown, this._onLeftDownHandler, this);
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);
      this._map.on(EventType.leftUp, this._onLeftUpHandler, this);
    }

    unbindEvent() {
      this._map.off(EventType.leftDown, this._onLeftDownHandler, this);
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);
      this._map.off(EventType.leftUp, this._onLeftUpHandler, this);

      if (this._hasChangeEnableInputs) {
        this._map.scene.screenSpaceCameraController.enableInputs = true;
        delete this._hasChangeEnableInputs;
      }

      this._map._setEditCursor(false);

      if (!this._graphic.show) {
        this._graphic.show = true;
      }
    }

    _onLeftDownHandler(event) {
      const result = this._map.mouseEvent.getPickTarget(event.position, event);
      if (result.layer !== this.layer) {
        return
      }

      const graphic = result?.graphic;
      if (!graphic || !graphic._isDragger) {
        return
      }

      if (this._map.scene.screenSpaceCameraController.enableInputs) {
        this._map.scene.screenSpaceCameraController.enableInputs = false;
        this._hasChangeEnableInputs = true;
      }

      this._map._setEditCursor(true);
      graphic._closeAllControl();

      this._draggerIng = graphic;
      this._draggerIng.show = graphic.options.drawShow ?? false;

      if (graphic.onDragStart) {
        graphic.onDragStart(graphic, result.cartesian || graphic.position);
      }

      this.fire(EventType.editMouseDown, { ...event, ...result, index: this._draggerIng.index });
    }

    _onMouseMoveHandler(event) {
      if (this._draggerIng) {
        this._onMouseMoveDraggerHandler(event);
      } else {
        this._onMouseMoveMapHandler(event);
      }
    }

    _onMouseMoveDraggerHandler(event) {
      let cartesian;
      switch (this._draggerIng._pointType) {
        case PointType.MoveHeight: {
          // 改变高度垂直拖动
          const dy = event.endPosition.y - event.startPosition.y;

          const position = getPositionValue(this._draggerIng.position, this._map?.clock.currentTime);
          const tangentPlane = new Cesium__namespace.EllipsoidTangentPlane(position);

          const scratchBoundingSphere = new Cesium__namespace.BoundingSphere();
          const zOffset = new Cesium__namespace.Cartesian3();

          scratchBoundingSphere.center = position;
          scratchBoundingSphere.radius = 1;

          const metersPerPixel =
            this._map.scene.frameState.camera.getPixelSize(
              scratchBoundingSphere,
              this._map.scene.frameState.context.drawingBufferWidth,
              this._map.scene.frameState.context.drawingBufferHeight
            ) * 1.5;

          Cesium__namespace.Cartesian3.multiplyByScalar(tangentPlane.zAxis, -dy * metersPerPixel, zOffset);
          cartesian = Cesium__namespace.Cartesian3.clone(position);
          Cesium__namespace.Cartesian3.add(position, zOffset, cartesian);

          this._draggerIng.position = cartesian;
          if (this._draggerIng.onDrag) {
            this._draggerIng.onDrag(this._draggerIng, cartesian, position);
          }

          this.updateAttrForEditing();

          this.fire(EventType.editStyle, event);
          break
        }
        default:
          {
            // 默认修改位置
            this._map.openSmallTooltip(event.endPosition, this._map.getLangText("_释放后完成修改"));

            let noPickEntity = this._graphic._entity;
            if (this.clampToGround) {
              noPickEntity = null;
            }

            cartesian = getCurrentMousePosition(this._map.scene, event.endPosition, noPickEntity);
            if (cartesian) {
              this._draggerIng.position = cartesian;
              if (this._draggerIng.onDrag) {
                this._draggerIng.onDrag(this._draggerIng, cartesian);
              }
              this.updateAttrForEditing();
            }
          }
          break
      }

      this.fire(EventType.editMouseMove, { ...event, index: this._draggerIng.index, cartesian: cartesian, windowPosition: event.endPosition });
    }

    _onMouseMoveMapHandler(event) {
      const result = this._map.mouseEvent.getPickTarget(event.endPosition, event);
      const graphic = result?.graphic;
      if (graphic == null) {
        this._map.closeSmallTooltip();
        return
      }

      if (result.layer !== this.layer || !graphic._isDragger) {
        return
      }
      // 右键菜单打开了，跳出
      if (this._map.contextmenu.show && this._map.contextmenu.target === graphic) {
        return
      }

      let _draw_tooltip = graphic._draw_tooltip;
      if (!_draw_tooltip) {
        return
      }
      if (PointType.Control === graphic._pointType && this._graphic?._positions_draw?.length > this._graphic._minPointNum) {
        // 可删除时，提示右击删除
        _draw_tooltip += "<br/>" + this._map.getLangText("_右击删除点");
      }

      this._map.openSmallTooltip(event.endPosition, _draw_tooltip);
    }

    _onLeftUpHandler(event) {
      if (!this._draggerIng) {
        return
      }

      this._draggerIng.show = true;

      const position = getPositionValue(this._draggerIng.position, this._map?.clock.currentTime);
      const index = this._draggerIng.index;
      if (this._draggerIng.onDragEnd) {
        this._draggerIng.onDragEnd(this._draggerIng, position);
      }
      this.updateAttrForEditing();

      this.fire(EventType.editMovePoint, { ...event, index: index, cartesian: position });

      this._draggerIng = null;
      this._map._setEditCursor(false);

      if (this._hasChangeEnableInputs) {
        this._map.scene.screenSpaceCameraController.enableInputs = true;
        delete this._hasChangeEnableInputs;
      }
    }

    openSmallTooltipByMinPointNum(position) {
      this._map.openSmallTooltip(position, this._map.getLangText("_无法删除不能少于最小点数") + " " + this._graphic._minPointNum);
    }

    // 创建Dragger拖动点的公共方法
    createDragger(options) {
      let dragger;
      if (options.dragger) {
        dragger = options.dragger;
      } else {
        dragger = new PointPrimitive({
          position: options.position ?? Cesium__namespace.Cartesian3.ZERO,
          style: getEditPointStyle(options.type),
          hasEdit: false,
          private: true
        });
        dragger.parent = this._graphic; // 右键删除时关联删除对应的graphic
        this.layer.addGraphic(dragger);
      }

      dragger._draw_tooltip = this._map.getLangText("_拖动该点后") + " " + (options.tooltip || this._map.getLangText("_修改位置"));
      dragger._isDragger = true;
      dragger._noMousePick = true; // 不被getCurrentMousePosition拾取
      dragger._pointType = options.type || PointType.Control; // 默认是位置控制拖拽点

      dragger.onDragStart = options.onDragStart;
      dragger.onDrag = options.onDrag;
      dragger.onDragEnd = options.onDragEnd;

      if (dragger._pointType === PointType.Control || dragger._pointType === PointType.MoveAll) {
        dragger._draw_tooltip += "<br/>" + this._map.getLangText("_更多功能请右击");
        dragger.bindContextMenu(this.getDraggerContextMenu(dragger));
      }
      return dragger
    }

    bindDraggers() {}
    destroyDraggers() {
      for (let i = 0, len = this.draggers.length; i < len; i++) {
        this.layer.removeGraphic(this.draggers[i], true);
      }
      this.draggers = [];
    }

    updateDraggers() {
      if (!this._enabled) {
        return this
      }

      const _matrixMove_index = this._matrixMove?._dragger_index;

      this.destroyDraggers();
      this.bindDraggers();

      if (Cesium__namespace.defined(_matrixMove_index)) {
        for (let i = 0, len = this.draggers.length; i < len; i++) {
          const dragger = this.draggers[i];
          if (dragger._pointType !== PointType.Control && dragger._pointType !== PointType.MoveAll) {
            continue
          }
          if (dragger.index === _matrixMove_index) {
            this._startMatrixMove(dragger);
            break
          }
        }
      }
    }

    updateAttrForEditing() {
      if (this._graphic.updateAttrForDrawing) {
        this._graphic.updateAttrForDrawing(true);
      }

      if (this._graphic._updateLabelPosition) {
        this._graphic._updateLabelPosition();
      }
    }

    getDraggerContextMenu(dragger) {
      return [
        {
          text: "停止编辑",
          icon: Icon.DrawEditNo,
          show: (event) => {
            return this._graphic?.isEditing
          },
          callback: (event) => {
            this._graphic.stopEditing();
          }
        },
        {
          text: "删除该点",
          icon: Icon.Delete,
          show: (event) => {
            if (!this._graphic?._positions_draw || dragger._pointType === PointType.MoveAll) {
              return false
            }
            if (this._graphic._positions_draw.length - 1 < this._graphic._minPointNum) {
              this.openSmallTooltipByMinPointNum(event.position);
              return false
            }
            return true
          },
          callback: (event) => {
            const graphic = event.graphic;
            if (graphic) {
              const index = graphic.index;
              if (index >= 0 && index < this._graphic._positions_draw.length) {
                this._graphic._positions_draw.splice(index, 1);
                this.updateDraggers();
                this.updateAttrForEditing();

                this.fire(EventType.editRemovePoint, { ...event, index: index });
              }
            }
          }
        },
        {
          text: "按轴平移",
          icon: Icon.DrawEditYes,
          show: (event) => {
            return !this._matrixMove || this._matrixMove._dragger_index !== dragger.index
          },
          callback: (event) => {
            const target = event.graphic?.position ? event.graphic : event.layer;
            this._startMatrixMove(target, event);
          }
        },
        {
          text: "停止按轴平移",
          icon: Icon.DrawEditNo,
          show: (event) => {
            return this._matrixMove && this._matrixMove._dragger_index === dragger.index
          },
          callback: (event) => {
            this._removeMatrixMove();
          }
        }
      ]
    }

    _updateStyleHook(newStyle) {
      if (Cesium__namespace.defined(newStyle.clampToGround)) {
        this._removeMatrixMove();
        this._removeMatrixRotate();

        this.updateDraggers();
      }
    }

    // 新增点事件
    _fireAddPoint(dragger, position) {
      this.fire(EventType.editAddPoint, { index: dragger.index, cartesian: position });
    }

    // 平移矩阵
    _startMatrixMove(graphic, eventRM = {}) {
      this._removeMatrixMove();
      this._removeMatrixRotate();

      if (!graphic) {
        return
      }

      let position = graphic.positionShow || graphic.position;
      if (this.clampToGround) {
        position = getSurfacePosition(this._map.scene, position); // 贴地时求贴模型和贴地的高度
      }

      this._matrixMove = new MatrixMove({
        map: this._map,
        position: position
      });
      this._map.addThing(this._matrixMove);

      // 贴地时，隐藏z轴移动
      if (this.clampToGround && this._matrixMove._graphic_move_z) {
        this._matrixMove._graphic_move_z.show = false;
      }

      this._matrixMove._dragger_index = graphic.index;

      this._matrixMove.on(EventType.start, (event) => {
        if (graphic.onDragStart) {
          graphic.onDragStart(graphic, this._matrixMove.position);
        }
      });
      this._matrixMove.on(EventType.stop, (event) => {
        if (graphic.onDragEnd) {
          graphic.onDragEnd(graphic, this._matrixMove.position);
        }
      });
      this._matrixMove.on(EventType.change, (event) => {
        const position = this._matrixMove.position;
        if (graphic.isPrivate) {
          graphic.position = position;
        } else {
          this._graphic._position_draw = position;
        }

        if (event.editType === Cesium__namespace.Axis.Z && this._updateHeight) {
          const height = Cesium__namespace.Cartographic.fromCartesian(position).height;
          this._updateHeight(height);
        } else if (graphic.onDrag) {
          graphic.onDrag(graphic, position);
        }

        this.updateAttrForEditing();

        this.fire(EventType.editMovePoint, { ...eventRM, ...event, index: graphic.index, cartesian: position });
      });

      // 同步坐标
      graphic.off(EventType.updatePosition, this._updateMatrixMovePosition, this);
      graphic.off(EventType.updatePosition, this._updateMatrixRotatePosition, this);

      graphic.on(EventType.updatePosition, this._updateMatrixMovePosition, this);
    }

    _updateMatrixMovePosition(e) {
      if (!this._matrixMove || this._matrixMove.isMoveing || !e.position || this._matrixMove._dragger_index !== e.graphic?.index) {
        return
      }
      this._matrixMove.position = e.position;
    }

    _removeMatrixMove() {
      if (this._matrixMove) {
        this._map.removeThing(this._matrixMove, true);
        delete this._matrixMove;
      }
    }

    // 旋转矩阵
    _startMatrixRotate(graphic, eventRM) {
      this._removeMatrixMove();
      this._removeMatrixRotate();

      this._matrixRotate = new MatrixRotate({
        map: this._map,
        position: graphic.positionShow || graphic.position,
        heading: this.style.heading,
        pitch: this.style.pitch,
        roll: this.style.roll
      });
      this._map.addThing(this._matrixRotate);

      this._matrixRotate.on(EventType.change, (event) => {
        this.style.heading = formatNum$1(event.heading, 2);
        this.style.pitch = formatNum$1(event.pitch, 2);
        this.style.roll = formatNum$1(event.roll, 2);
        this._graphic.updateOrientation();

        this.fire(EventType.editStyle);
      });

      // 同步坐标
      graphic.off(EventType.updatePosition, this._updateMatrixMovePosition, this);
      graphic.off(EventType.updatePosition, this._updateMatrixRotatePosition, this);

      graphic.on(EventType.updatePosition, this._updateMatrixRotatePosition, this);
    }

    _updateMatrixRotatePosition(e) {
      if (!this._matrixRotate || this._matrixRotate.isMoveing || !e.position || this._matrixRotate._dragger_index !== e.graphic?.index) {
        return
      }
      this._matrixRotate.position = e.position;
    }

    _removeMatrixRotate() {
      if (this._matrixRotate) {
        this._map.removeThing(this._matrixRotate, true);
        delete this._matrixRotate;
      }
    }

    destroy() {
      this.disable();

      // 删除所有绑定的数据
      for (const i in this) {
        delete this[i];
      }
    }
  }

  /**
   * Point 对象 标绘处理对应的编辑类
   *
   * @export
   * @class EditPoint
   * @extends {EditBase}
   */
  class EditPoint extends EditBase {
    bindDraggers() {
      this.createDragger({
        dragger: this._graphic,
        onDrag: (dragger, newPosition) => {
          this._graphic._position_draw = newPosition;
        }
      });
    }

    // 图形编辑结束后调用
    finish() {
      delete this._graphic._draw_tooltip;
      delete this._graphic._isDragger;
      delete this._graphic._noMousePick;
      delete this._graphic._pointType;
      delete this._graphic.onDrag;

      this._graphic.unbindContextMenu();
    }
  }

  /**
   * 单个坐标的点状Entity矢量数据 基类
   *
   * @param {Object} options 参数对象，包括以下：

  * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {Cesium.Property} [options.orientation] 指定实体方向的属性。
   * @param {Object} options.style 矢量数据的 样式信息，具体见各类数据的说明
   * @param {Object} [options.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   *
   * @param {Number} [options.maxCacheCount=50] 当使用addDynamicPosition设置为动画轨迹位置时，保留的坐标点数量
   * @param {Cesium.ExtrapolationType} [options.forwardExtrapolationType= Cesium.ExtrapolationType.HOLD]  当使用addDynamicPosition设置为动画轨迹位置时，在任何可用坐标之后一次请求值时要执行的推断类型，默认为最后一个坐标位置。
   * @param {Cesium.ExtrapolationType} [options.backwardExtrapolationType= Cesium.ExtrapolationType.HOLD] 当使用addDynamicPosition设置为动画轨迹位置时， 在任何可用坐标之前一次请求值时要执行的推断类型，默认为第一个坐标位置。
   * @param {Boolean} [options.clampToTileset] 当使用addDynamicPosition设置为动画轨迹位置时，是否进行贴模型。
   * @param {Number} [options.frameRateClamp=30] 当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，多少帧计算一次贴模型高度
   * @param {Object[]} [options.objectsToExclude]  当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   * @param {Cesium.ReferenceFrame} [options.referenceFrame=Cesium.ReferenceFrame.FIXED] 当使用addDynamicPosition设置为动画轨迹位置时，position位置被定义的参考系。
   * @param {Number} [options.numberOfDerivatives=0] 当使用addDynamicPosition设置为动画轨迹位置时，每个位置的导数的数量;即速度、加速度等。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
    * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class BasePointEntity
   * @extends {BaseEntity}
   *
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BasePointEntity extends BaseEntity {
    constructor(options = {}) {
      // 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
      options.drawShow = options.drawShow ?? true;

      super(options);

      // 配置的参数
      this._minPointNum = options.minPointNum ?? 1; // 至少需要点的个数
      this._maxPointNum = options.maxPointNum ?? 1; // 最多允许点的个数
      this._hasEdit = this.options.hasEdit ?? true; // 是否允许编辑

      // 坐标位置
      if (options.positions) {
        this.positions = options.positions;
      }
      if (options.position) {
        this.position = options.position;
      }
    }

    //= ============坐标相关==================
    /**
     * 编辑处理类
     * @type {EditPoint}
     * @readonly
     */
    get EditClass() {
      return EditPoint
    }

    /**
     * 位置坐标 （笛卡尔坐标）, 赋值时可以传入LatLngPoint对象
     * @type {Cesium.Cartesian3|LngLatPoint}
     */
    get position() {
      return this._position
    }

    set position(value) {
      this._point = LngLatPoint.parse(value);

      // 按配置调整高度值
      if (this._point) {
        let setHeight = this.style.setHeight;
        if (Cesium__namespace.defined(setHeight)) {
          if (isString(setHeight)) {
            setHeight = Number(template(setHeight, this.attr, true));
            if (isNaN(setHeight)) {
              setHeight = 0;
            }
          }
          this._point.alt = setHeight;
        }
        const addHeight = this.getAddHeight();
        if (addHeight !== 0) {
          this._point.alt = this._point.alt + addHeight;
        }
      }

      const _position = this._point?.toCartesian();
      if (this.editing?.enabled && _position instanceof Cesium__namespace.Cartesian3) {
        this._position_draw = _position;
        if (_position && this._positions_draw?.length > 0) {
          this._positions_draw[0] = _position;
        }
      } else {
        this._position = _position;
      }

      if (this._entity) {
        this._updatePositionsHook();
      }

      this.fire(EventType.updatePosition, { position: this._position });
    }

    /**
     * 当前实时位置坐标（笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get positionShow() {
      return getPositionValue(this.position, this._map?.clock.currentTime)
    }

    /**
     * 位置坐标
     * @type {LngLatPoint}
     * @readonly
     */
    get point() {
      if (!(this._position instanceof Cesium__namespace.Cartesian3)) {
        this._point = LngLatPoint.parse(this.positionShow);
      }
      return this._point
    }

    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @type {Array}
     * @readonly
     */
    get coordinate() {
      return this.getCoordinate()
    }

    /**
     * 中心点坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get center() {
      return getPositionValue(this.positionShow, this._map?.clock.currentTime) // 回调时需要取值
    }

    /**
     * 中心点坐标
     * @type {LngLatPoint}
     * @readonly
     */
    get centerPoint() {
      return this.point
    }

    // 兼容线面的属性，方便标绘统一控制。 start
    get positions() {
      if (this.position) {
        return [this.position]
      } else {
        return []
      }
    }

    set positions(value) {
      if (value && value.length > 0) {
        this.position = value[0];
      }
    }

    get points() {
      if (this.point) {
        return [this.point]
      } else {
        return []
      }
    }

    get coordinates() {
      if (this.coordinate) {
        return [this.coordinate]
      } else {
        return []
      }
    }

    get positionsShow() {
      if (this.positionShow) {
        return [this.positionShow]
      } else {
        return []
      }
    }
    // 兼容线面的属性，方便标绘统一控制。 end

    /**
     * 三维空间中的旋转。
     * @type {Cesium.Quaternion}
     * @readonly
     */
    get orientation() {
      return this.options.orientation
    }

    set orientation(val) {
      this.options.orientation = val;
      this.updateOrientation();
    }

    /**
     * 四周方向角，0-360度角度值
     * @type {Number}
     */
    get heading() {
      return this.style.heading ?? 0
    }

    set heading(val) {
      this.style.heading = val;
      this.updateOrientation();
    }

    /**
     * 俯仰角，上下摇摆的角度，0-360度角度值
     * @type {Number}
     */
    get pitch() {
      return this.style.pitch ?? 0
    }

    set pitch(val) {
      this.style.pitch = val;
      this.updateOrientation();
    }

    /**
     * 滚转角，左右摆动的角度，0-360度角度值
     * @type {Number}
     */
    get roll() {
      return this.style.roll ?? 0
    }

    set roll(val) {
      this.style.roll = val;
      this.updateOrientation();
    }

    /**
     * 坐标对应的高度值（单位：米）
     * @type {Number}
     */
    get height() {
      return this.point?.alt
    }

    set height(val) {
      this.point.alt = val;
      this.position = this.point;
    }

    /**
     * 获取当前转换计算模型矩阵。如果方向或位置未定义，则返回undefined。
     * @type {Cesium.Matrix4}
     * @readonly
     */
    get modelMatrix() {
      if (this._entity) {
        return this._entity.computeModelMatrix(this._map?.clock?.currentTime, new Cesium__namespace.Matrix4())
      } else {
        return undefined
      }
    }

    /**
     * 是否显示3个方向轴，用于对比测试
     * @type {Boolean}
     */
    get debugAxis() {
      return this._debugAxis
    }

    set debugAxis(value) {
      this._debugAxis = value;

      if (!this.debugAxisPrimitive) {
        const axislength = Math.max(Cesium__namespace.Cartographic.fromCartesian(this.positionShow).height * 0.06, 100);
        this.debugAxisPrimitive = this._layer.primitiveCollection.add(
          new Cesium__namespace.DebugModelMatrixPrimitive({
            modelMatrix: this.modelMatrix,
            length: axislength, // 默认 debugAxisLength
            width: 5.0
          })
        );
        this.debugAxisPrimitive._tooltipConfig = {
          content: `<span style="color: red;">红色</span> 是 X轴<br/>
                  <span style="color: green;">绿色</span> 是 Y轴<br/>
                  <span style="color: blue;">蓝色</span> 是 Z轴`,
          options: this.options.tooltipOptions
        };

        if (this.position instanceof Cesium__namespace.CallbackProperty || this.position instanceof Cesium__namespace.SampledPositionProperty) {
          this.debugAxisPrimitive._timeTik = setInterval(() => {
            this.debugAxisPrimitive.modelMatrix = this.modelMatrix;
          }, 300);
        }
        this.bindPickId(this.debugAxisPrimitive);
      }
      this.debugAxisPrimitive.show = value;
    }

    /**
     * 显示3个方向轴时的对应轴长度，用于对比测试
     * @type {Number}
     */
    get debugAxisLength() {
      if (this.debugAxisPrimitive) {
        return this.debugAxisPrimitive.length
      } else {
        return 0
      }
    }

    set debugAxisLength(value) {
      if (!this.debugAxisPrimitive) {
        this.debugAxis = true;
      }
      this.debugAxisPrimitive.length = value;
    }

    /**
     * 贴模型分析时，排除的不进行贴模型计算的模型对象，默认是当前本身，可以是： primitives, entities 等
     * @type {Object[]|undefined}
     */
    get objectsToExclude() {
      if (this.options.objectsToExclude) {
        return this.options.objectsToExclude
      }
      if (this._entity?.model) {
        return [this._entity]
      }
      return undefined
    }

    set objectsToExclude(value) {
      this.options.objectsToExclude = value;
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {}

    _removedHook() {
      super._removedHook();
      if (this.debugAxisPrimitive) {
        clearInterval(this.debugAxisPrimitive._timeTik);
        this._layer.primitiveCollection.remove(this.debugAxisPrimitive);
        delete this.debugAxisPrimitive;
      }
    }

    _updatePositionsHook() {
      this._entity.position = this._position;

      if (this.debugAxisPrimitive) {
        this.debugAxisPrimitive.modelMatrix = this.modelMatrix;
      }

      // 如果在编辑中，更新编辑的拖拽点。
      this._updateEditDraggers();

      this._updateLabelPosition();
    }

    /**
     * 更新 三维空间中的Quaternion旋转对象。
     *
     * @return {Cesium.Quaternion} 更新后的Quaternion旋转对象
     */
    updateOrientation() {
      this._entity.orientation = this.getOrientation();
      if (this.debugAxisPrimitive) {
        this.debugAxisPrimitive.modelMatrix = this.modelMatrix;
      }
      return this._entity.orientation
    }

    getOrientation() {
      if (this.options.orientation && !this.options.fixedHeading) {
        if (this.options.orientation instanceof Cesium__namespace.VelocityOrientationProperty && (this.style.heading || this.style.noPitchRoll)) {
          const originOrientation = this.options.orientation;
          // 由于模型不是标准的方向时的处理
          const heading = Cesium__namespace.Math.toRadians(this.style.heading || 0);

          this.options.orientation = new Cesium__namespace.CallbackProperty((time) => {
            const position = getPositionValue(this.position, time);
            const orientation = originOrientation.getValue(time);
            if (!position || !orientation) {
              return null
            }

            const hpr = getHeadingPitchRollByOrientation(position, orientation);
            if (this.style.noPitchRoll) {
              hpr.pitch = 0;
              hpr.roll = 0;
            }
            hpr.heading += heading;

            return Cesium__namespace.Transforms.headingPitchRollQuaternion(position, hpr, this._map?.scene?.globe.ellipsoid)
          }, false);
        }
        return this.options.orientation
      }

      const position = this.positionShow;
      if (position == null) {
        return
      }

      const heading = Cesium__namespace.Math.toRadians(this.heading);
      const pitch = Cesium__namespace.Math.toRadians(this.pitch);
      const roll = Cesium__namespace.Math.toRadians(this.roll);

      const hpr = new Cesium__namespace.HeadingPitchRoll(heading, pitch, roll);
      const orientation = Cesium__namespace.Transforms.headingPitchRollQuaternion(position, hpr);

      return orientation
    }

    _getGeoJsonGeometry(options) {
      return { type: "Point", coordinates: this.getCoordinate(options?.noAlt) }
    }

    /**
     * 清除addDynamicPosition添加的动态轨迹
     * @return {BasePointEntity} 当前对象本身，可以链式调用
     */
    clearDynamicPosition() {
      this.property = null;
      this.position = undefined;

      return this
    }

    _initSampledPositionProperty() {
      this._clampToTilesetFrame = -1;

      this._frameRateHeight = this.options.frameRateHeight ?? 30;
      this._maxCacheCount = this.options.maxCacheCount ?? 50; // 保留的坐标点数量

      const property = new Cesium__namespace.SampledPositionProperty(this.options.referenceFrame, this.options.numberOfDerivatives);
      property.forwardExtrapolationType = this.options.forwardExtrapolationType ?? Cesium__namespace.ExtrapolationType.HOLD;
      property.backwardExtrapolationType = this.options.backwardExtrapolationType ?? Cesium__namespace.ExtrapolationType.HOLD;

      if (!this.options.orientation) {
        this.options.orientation = new Cesium__namespace.VelocityOrientationProperty(property);
        if (this._entity) {
          this._entity.orientation = this.getOrientation();
        }
      }
      this.property = property;

      this.position = new Cesium__namespace.CallbackProperty((time) => {
        if (!this._map) {
          return undefined
        }
        let position = property.getValue(time);
        if (!position) {
          if (!this._last_isFireStop && this._stopTime && Cesium__namespace.JulianDate.greaterThanOrEquals(time, this._stopTime)) {
            this.fire(EventType.stop);
            this._last_isFireStop = true;
          }
          return this._last_position
        }

        if (position && this.options.clampToTileset) {
          // 贴模型
          this._clampToTilesetFrame++;
          if (!this._clampToTilesetHeight || this._clampToTilesetFrame % this._frameRateHeight === 0) {
            this._clampToTilesetHeight = getHeight(this._map.scene, position, {
              objectsToExclude: this.objectsToExclude
            });
          }
          if (this._clampToTilesetHeight) {
            const car = Cesium__namespace.Cartographic.fromCartesian(position);
            position = Cesium__namespace.Cartesian3.fromRadians(car.longitude, car.latitude, this._clampToTilesetHeight + this.getAddHeight());
          }
        }
        this._last_position = position;
        this._last_isFireStop = false;
        return position
      }, false);
    }

    /**
     * 设置并添加动画轨迹位置，按“指定时间”运动到达“指定位置”。
     *
     * @param {LngLatPoint|Cesium.Cartesian3|Number[]} point 指定位置坐标
     * @param {Cesium.JulianDate|Date|String|Number} [currTime] 指定时间, 默认为当前时间。当为String时，可以传入'2021-01-01 12:13:00'; 当为Number时，可以传入当前时间延迟的秒数。
     * @return {BasePointEntity} 当前对象本身，可以链式调用
     */
    addDynamicPosition(point, currTime) {
      if (!this.property) {
        this._initSampledPositionProperty();
      }

      this._removeDynamicPosition();

      if (!currTime) {
        currTime = this._map?.clock?.currentTime || Cesium__namespace.JulianDate.now();
      } else if (isNumber(currTime)) {
        const now = this._map?.clock?.currentTime || Cesium__namespace.JulianDate.now();
        currTime = Cesium__namespace.JulianDate.addSeconds(now, currTime, new Cesium__namespace.JulianDate());
      } else if (isString(currTime)) {
        if (currTime.indexOf("Z") === -1) {
          currTime = Cesium__namespace.JulianDate.fromDate(new Date(currTime));
        } else {
          currTime = Cesium__namespace.JulianDate.fromIso8601(currTime);
        }
      } else if (currTime instanceof Date) {
        currTime = Cesium__namespace.JulianDate.fromDate(currTime);
      }

      const pt = LngLatPoint.parse(point).toCartesian();
      this.property.addSample(currTime, pt);

      this._stopTime = currTime;
      return this
    }

    _removeDynamicPosition() {
      if (this._maxCacheCount < 1) {
        return
      }

      const times = this.property?._property?._times;
      if (!times || times?.length === 0) {
        return
      }

      const removeCount = times.length - this._maxCacheCount - 1;

      if (removeCount > 0) {
        this.property.removeSamples(
          new Cesium__namespace.TimeInterval({
            start: times[0],
            stop: times[removeCount]
          })
        );
      }
    }

    /**
     * 异步计算更新坐标高度进行贴地(或贴模型)，内部自动调用{@link PointUtil#getSurfaceHeight}方法处理。
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @return {Promise<Object>} 异步计算完成的Promise
     */
    autoSurfaceHeight(options = {}) {
      return getSurfaceHeight(this._map.scene, this.position, {
        objectsToExclude: this.objectsToExclude,
        ...options
      }).then((result) => {
        if (result.position) {
          this.position = result.position;
        }
      })
    }

    // 兼容旧版本命名，同updateSurfaceHeight
    clampToGround(options) {
      return this.autoSurfaceHeight(options)
    }

    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @param {Boolean} noAlt true时不导出高度值
     * @return {Array} 位置坐标(数组对象)
     */
    getCoordinate(noAlt) {
      if (this.point) {
        return this.point.toArray(noAlt)
      } else {
        return []
      }
    }

    //= =================Draw绘制相关=================
    /**
     * 按Cesium.CallbackProperty的方式 更新坐标（更加平滑）
     * @param {String|Array|Object|Cesium.Cartesian3|*} position 坐标
     * @return {Cesium.Cartesian3} 当前坐标
     */
    setCallbackPosition(position) {
      this._setPositionsToCallback();

      this._position_draw = LngLatPoint.toCartesian(position);

      return this._position_draw
    }

    // 将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑
    _setPositionsToCallback() {
      if (this._isCallbackPositions) {
        return
      }
      this._isCallbackPositions = true;

      // 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
      this.show = this.options.drawShow;

      this._position_draw = this.positionShow;
      this.position = new Cesium__namespace.CallbackProperty((time) => {
        return this._position_draw
      }, false);

      this.updateAttrForDrawing && this.updateAttrForDrawing(true);

      this._updateOutlineToCallback(); // 存在边线时
      this._updateLabelPosition(); // 中心文本处理
    }

    // 坐标CallbackProperty属性改为实际值
    _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return
      }
      this._isCallbackPositions = false;

      this._position = this._position_draw;
      this._point = LngLatPoint.fromCartesian(this._position);

      // this._updatePositionsHook()
      this._entity.position = this._position;
    }

    _startDrawHook() {
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler_point, this);
      this._map.on(EventType.click, this._onClickHandler_point, this);
    }

    _stopDrawHook() {
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler_point, this);
      this._map.off(EventType.click, this._onClickHandler_point, this);

      this.show = true; // 重置为 true
    }

    _onMouseMoveHandler_point(event) {
      const point = event.cartesian;
      if (point) {
        this._position_draw = point;
      }
      this._map.openSmallTooltip(event.endPosition, this._draw_tooltip || this._map.getLangText("_单击完成绘制"));

      this.fire(
        EventType.drawMouseMove,
        {
          ...event,
          drawtype: this.type,
          graphic: this
        },
        true
      );
    }

    _onClickHandler_point(event) {
      const point = event.cartesian;
      if (point) {
        this._position_draw = point;
      }
      if (this._position_draw) {
        this.stopDraw();
      }
    }
  }

  BasePointEntity.isPoint = true; // 对类是否为点状数据的判断,GraphicUtil内用到

  /**
   * 线面状对象 标绘处理对应的编辑类基类
   *
   * @export
   * @class EditPoly
   * @extends {EditBase}
   */
  class EditPoly extends EditBase {
    // 是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    get hasClosure() {
      return this.style.closure
    }

    // 是否可在中间新增点
    get hasMidPoint() {
      return this.positions.length < this._graphic._maxPointNum
    }

    bindDraggers() {
      const positions = this.positions;

      for (let i = 0, len = positions.length; i < len; i++) {
        const position = this.updatePositionsHeightByAttr(positions[i]);

        // 各顶点
        const dragger = this.createDragger({
          position: position,
          onDrag: (dragger, position) => {
            position = this.updatePositionsHeightByAttr(position);
            dragger.position = position;
            this.positions[dragger.index] = position;

            if (this._heightDraggers?.length > 0) {
              return
            }

            //= ===========新增点拖拽点处理=============
            if (this.hasMidPoint) {
              let draggersIdx;
              let nextPositionIdx;
              let midpoint;
              // 与前一个点之间的中点
              if (this.hasClosure || (!this.hasClosure && dragger.index !== 0)) {
                if (dragger.index === 0) {
                  draggersIdx = len * 2 - 1;
                  nextPositionIdx = len - 1;
                } else {
                  draggersIdx = dragger.index * 2 - 1;
                  nextPositionIdx = dragger.index - 1;
                }
                const nextPosition = positions[nextPositionIdx];
                midpoint = getMidpoint(position, nextPosition);
                midpoint = this.updatePositionsHeightByAttr(midpoint);

                this.draggers[draggersIdx].position = midpoint;
              }

              // 与后一个点之间的中点
              if (this.hasClosure || (!this.hasClosure && dragger.index !== len - 1)) {
                if (dragger.index === len - 1) {
                  draggersIdx = dragger.index * 2 + 1;
                  nextPositionIdx = 0;
                } else {
                  draggersIdx = dragger.index * 2 + 1;
                  nextPositionIdx = dragger.index + 1;
                }
                midpoint = getMidpoint(position, positions[nextPositionIdx]);
                midpoint = this.updatePositionsHeightByAttr(midpoint);

                this.draggers[draggersIdx].position = midpoint;
              }
            }

            //= ===========整体平移移动点处理=============
            if (this._draggerMove) {
              let positionMove = centerOfMass(positions);
              positionMove = this.updatePositionsHeightByAttr(positionMove);
              this._draggerMove.position = positionMove;
            }
          },
          onDragStart: (dragger, position) => {
            if (this._heightDraggers?.length > 0) {
              for (let i = 0, len = this.draggers.length; i < len; i++) {
                this.draggers[i].show = false;
              }
            }
          },
          onDragEnd: (dragger, position) => {
            if (this._heightDraggers?.length > 0) {
              this.updateDraggers();
            }
          }
        });
        dragger.index = i;
        this.draggers.push(dragger);

        // 中间点，拖动后新增点
        if (this.hasMidPoint && (this.hasClosure || (!this.hasClosure && i < len - 1))) {
          const nextIndex = (i + 1) % len;
          let midpoint = getMidpoint(position, positions[nextIndex]);
          midpoint = this.updatePositionsHeightByAttr(midpoint);

          const draggerMid = this.createDragger({
            position: midpoint,
            type: PointType.AddMidPoint,
            tooltip: this._map.getLangText("_增加点"),
            onDragStart: (dragger, position) => {
              this.positions.splice(dragger.index, 0, position); // 插入点
            },
            onDrag: (dragger, position) => {
              this.positions[dragger.index] = position;
            },
            onDragEnd: (dragger, position) => {
              this._fireAddPoint(dragger, position); // 新增点事件
              this.updateDraggers();
            }
          });
          draggerMid.index = nextIndex;
          this.draggers.push(draggerMid);
        }
      }

      // 整体平移移动点
      this._bindMoveAllDragger();

      // 创建高度拖拽点
      if (this.entityGraphic.extrudedHeight) {
        this._bindHeightDraggers();
      }
    }

    // 整体平移移动点
    _bindMoveAllDragger() {
      if (!this._graphic._hasMoveEdit) {
        return
      }

      let positionMove = centerOfMass(this.positions);
      positionMove = this.updatePositionsHeightByAttr(positionMove);

      const draggerMove = this.createDragger({
        position: positionMove,
        type: PointType.MoveAll,
        tooltip: this._map.getLangText("_整体平移"),
        onDragStart: (dragger, position) => {
          positionMove = position;
        },
        onDrag: (dragger, position) => {
          // 记录差值
          const diff = Cesium__namespace.Cartesian3.subtract(position, positionMove, new Cesium__namespace.Cartesian3());
          positionMove = position;

          this.positions.forEach((pos, index, arr) => {
            const newPos = Cesium__namespace.Cartesian3.add(pos, diff, new Cesium__namespace.Cartesian3());
            this.positions[index] = newPos;
          });
          if (this._graphic._draw_holes?.length > 0) {
            // 多环面的编辑支持
            for (let i = 0, len = this._graphic._draw_holes.length; i < len; i++) {
              const holes = this._graphic._draw_holes[i];
              holes.forEach((pos, index, arr) => {
                const newPos = Cesium__namespace.Cartesian3.add(pos, diff, new Cesium__namespace.Cartesian3());
                holes[index] = newPos;
              });
            }
          }

          for (let i = 0, len = this.draggers.length; i < len; i++) {
            if (draggerMove !== this.draggers[i]) {
              this.draggers[i].position = Cesium__namespace.Cartesian3.add(this.draggers[i].position, diff, new Cesium__namespace.Cartesian3());
            }
          }
          this._updateMoveAllHook(position);
        }
      });
      this._draggerMove = draggerMove;
      this.draggers.push(draggerMove);
    }

    _updateMoveAllHook(position) {}

    // 高度调整拖拽点
    _bindHeightDraggers(positions) {
      if (!this._graphic._hasHeightEdit) {
        return
      }

      this._heightDraggers = [];

      positions = positions || this.positions;
      const extrudedHeight = getCesiumValue(this.entityGraphic.extrudedHeight, Number, this._map.clock.currentTime);

      for (let i = 0, len = positions.length; i < len; i++) {
        const loc = setPositionsHeight(positions[i], extrudedHeight);

        const dragger = this.createDragger({
          position: loc,
          type: PointType.MoveHeight,
          tooltip: this._map.getLangText("_修改高度"),
          onDrag: (dragger, position) => {
            const thisHeight = Cesium__namespace.Cartographic.fromCartesian(position).height;
            this.entityGraphic.extrudedHeight = thisHeight;

            const maxHeight = getMaxHeight(this.positions);
            this.style.diffHeight = this.formatNum(thisHeight - maxHeight, 2);

            this.updateHeightDraggers(thisHeight);

            this.updateAttrForEditing();
            this.fire(EventType.editStyle);
          }
        });

        this.draggers.push(dragger);
        this._heightDraggers.push(dragger);
      }
    }

    updateHeightDraggers(extrudedHeight) {
      for (let i = 0; i < this._heightDraggers.length; i++) {
        const heightDragger = this._heightDraggers[i];

        const position = setPositionsHeight(getPositionValue(heightDragger.position, this._map?.clock.currentTime), extrudedHeight);
        heightDragger.position = position;
      }
    }

    // 根据属性更新坐标
    updatePositionsHeightByAttr(position) {
      if (this.clampToGround) {
        position = getSurfacePosition(this._map.scene, position); // 贴地时求贴模型和贴地的高度
      }
      return position
    }

    _updateStyleHook(newStyle) {
      super._updateStyleHook(newStyle);
      if (Cesium__namespace.defined(newStyle.diffHeight) || Cesium__namespace.defined(newStyle.height) || Cesium__namespace.defined(newStyle.clampToGround)) {
        this.updateDraggers();
      }
    }
  }

  /**
   *
   * 多个坐标的线面状  Entity矢量数据 基类
   *
   * @param {Object} options 参数对象，包括以下：

   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {Object} options.style 矢量数据的 样式信息，具体见各类数据的说明
   * @param {Object} [options.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class BasePolyEntity
   * @extends {BaseEntity}
   *
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BasePolyEntity extends BaseEntity {
    constructor(options = {}) {
      super(options);

      this._hasEdit = this.options.hasEdit ?? true; // 是否允许编辑

      // 配置的参数
      this._minPointNum = options.minPointNum ?? 2; // 至少需要点的个数
      this._maxPointNum = options.maxPointNum ?? 9999; // 最多允许点的个数
      this._hasMoveEdit = options.hasMoveEdit ?? true; // 是否可以整体平移
      this._hasHeightEdit = options.hasHeightEdit ?? true; // 当有diffHeight时，是否可以编辑高度

      // 坐标位置
      if (options.positions) {
        if (this.style.buffer > 0) {
          this.positions = bufferPoints(options.positions);
        } else {
          this.positions = options.positions;
        }
      }
    }

    /**
     * 编辑时，是否可以整体平移
     * @type {Boolean}
     * @readonly
     */
    get hasMoveEdit() {
      return this._hasMoveEdit
    }

    /**
     * 编辑时，当有diffHeight时，是否可以编辑高度
     * @type {Boolean}
     * @readonly
     */
    get hasHeightEdit() {
      return this._hasHeightEdit
    }

    //= ============坐标相关==================
    /**
     * 编辑处理类
     * @type {EditPoly}
     * @readonly
     */
    get EditClass() {
      return EditPoly
    }

    /**
     * 中心点坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get center() {
      if (this.style.closure) {
        return this.centerOfMass
      } else {
        return this.centerOfLine
      }
    }

    /**
     * 围合面的内部中心点坐标
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get centerOfMass() {
      return centerOfMass(this.positionsShow)
    }

    /**
     * 边线的中心点坐标
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get centerOfLine() {
      const pots = this.positionsShow;
      if (!pots || pots.length === 0) {
        return null
      } else if (pots.length === 1) {
        return pots[0]
      }

      if (pots.length < 10) {
        return sliceByMaxDistance(pots, this.distance / 2, { point: true })
      } else {
        return pots[Math.floor(pots.length / 2)]
      }
    }

    /**
     * 距离（单位：米）
     * @type {Number}
     * @readonly
     */
    get distance() {
      return getDistance(this.positionsShow)
    }

    /**
     * 面积（单位：平方米）
     * @type {Number}
     * @readonly
     */
    get area() {
      return getSurfaceArea(this.positionsShow)
    }

    /**
     * 位置坐标数组 （笛卡尔坐标）, 赋值时可以传入LatLngPoint数组对象
     * @type {Cesium.Cartesian3[]}
     */
    get positions() {
      if (this._getPositions) {
        return this._getPositions()
      }
      return this._positions
    }

    set positions(value) {
      if (!value) {
        return
      }

      if (Array.isArray(value)) {
        const _points = [];
        const _positions = [];
        value.forEach((item, index) => {
          const _point = LngLatPoint.parse(item);
          if (!_point || !_point.valid()) {
            return
          }

          // 按配置调整高度值
          let setHeight = this.style.setHeight;
          if (Cesium__namespace.defined(setHeight)) {
            if (isString(setHeight)) {
              setHeight = Number(template(setHeight, this.attr, true));
              if (isNaN(setHeight)) {
                setHeight = 0;
              }
            } else if (Array.isArray(setHeight)) {
              setHeight = setHeight[index] || 0;
            }
            _point.alt = setHeight;
          }
          const addHeight = this.getAddHeight(index);
          if (addHeight !== 0) {
            _point.alt = _point.alt + addHeight;
          }

          _points.push(_point);
          _positions.push(_point.toCartesian());
        });

        if (this.editing?.enabled) {
          this._positions_draw = _positions;
        } else {
          this._positions = _positions;
        }
        this._points = _points;
      } else {
        this._positions = value;
      }

      if (this._entity) {
        this._updatePositionsHook();
      }

      this.fire(EventType.updatePosition, { positions: this._positions });
    }

    /**
     * 实际显示的坐标数组 （笛卡尔坐标），
     * 如标绘中时positions对应的可能只是控制点坐标或CallbackProperty属性
     *
     * @type {Cesium.Cartesian3[]}
     * @readonly
     */
    get positionsShow() {
      let pots = getCesiumValue(this._positions);
      if (pots instanceof Cesium__namespace.Rectangle) {
        pots = this.outlinePositions;
      }
      return pots
    }

    /**
     * 位置坐标数组
     * @type {LngLatPoint[]|Cesium.Cartesian3[]|Array}
     * @readonly
     */
    get points() {
      if (this._positions instanceof Cesium__namespace.CallbackProperty) {
        // callback属性时
        let _positions;
        if (this._positions_draw) {
          _positions = this._positions_draw;
        } else {
          _positions = this.positionsShow;
          if (this.style.closure) {
            _positions.pop(); // 闭合时删除最后一个
          }
        }

        const _points = [];
        _positions.forEach(function (item) {
          const _point = LngLatPoint.parse(item);
          if (!_point) {
            return
          }
          _points.push(_point);
        });
        this._points = _points;
      }
      if (!this._points) {
        this._points = LngLatArray.toPoints(this._positions);
      }
      return this._points
    }

    /**
     * 位置坐标(数组对象)，示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
     * @type {Array[]}
     * @readonly
     */
    get coordinates() {
      return this.getCoordinates()
    }

    /**
     * 坐标数据对应的矩形边界
     * @type {Cesium.Rectangle}
     * @readonly
     */
    get rectangle() {
      return Cesium__namespace.Rectangle.fromCartesianArray(this.positions)
    }

    // 获取entity的实际坐标值
    getEntityPositions() {
      return this.entityGraphic.positions
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {}

    _updatePositionsHook() {
      this._updateLabelPosition();

      // 如果在编辑中，更新编辑的拖拽点。
      this._updateEditDraggers();
    }

    _getGeoJsonGeometry(options) {
      return { type: "LineString", coordinates: this.getCoordinates(options?.noAlt) }
    }

    /**
     * 位置坐标(数组对象)，示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
     * @param {Boolean} noAlt true时不导出高度值
     * @return {Array[]} 位置坐标(数组对象)
     */
    getCoordinates(noAlt) {
      const coords = [];
      this.points.forEach((item) => {
        coords.push(item.toArray(noAlt));
      });
      return coords
    }

    /**
     * 判断点是否在当前对象的坐标点围成的多边形内
     *
     * @param {Cesium.Cartesian3|LngLatPoint} position 需要判断的点
     * @return {Boolean} 是否在多边形内
     */
    isInPoly(position) {
      const point = LngLatPoint.parse(position);

      // 面的时候，为了提高效率，先判断是否在外接矩形内
      const isInArea = Cesium__namespace.Rectangle.contains(Cesium__namespace.Rectangle.fromCartesianArray(this.positionsShow), point.toCartographic());
      if (!isInArea) {
        return false
      }
      return isInPoly(point, this.coordinates)
    }

    /**
     * 异步计算更新坐标高度进行贴地(或贴模型)，内部自动调用{@link PolyUtil#computeSurfacePoints}方法处理。
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @param {Number} [options.offset=0]  可以按需增加偏移高度（单位：米），便于可视
     * @return {Promise<*>} 异步计算完成的Promise
     */
    autoSurfaceHeight(options = {}) {
      return computeSurfacePoints({
        ...options,
        map: this._map,
        positions: this.positionsShow // 需要计算的源路线坐标数组
      }).then((result) => {
        if (!result.noHeight) {
          this.positions = result.positions;
        }
        return result
      })
    }

    // 兼容旧版本命名，同updateSurfaceHeight
    clampToGround(options) {
      return this.autoSurfaceHeight(options)
    }

    //= =================Draw绘制相关=================
    /**
     * 按Cesium.CallbackProperty的方式 更新坐标集合（更加平滑）
     * @param {String[]|Array[]|LngLatPoint[]} positions 坐标数组
     * @return {Cesium.Cartesian3[]} 当前坐标集合
     */
    setCallbackPositions(positions) {
      this._setPositionsToCallback();

      this._positions_draw = LngLatArray.toCartesians(positions);

      return this._positions_draw
    }

    // 将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑
    _setPositionsToCallback() {
      if (this._isCallbackPositions) {
        return
      }
      this._isCallbackPositions = true;

      let pots = getCesiumValue(this._positions);
      if (pots instanceof Cesium__namespace.PolygonHierarchy) {
        pots = pots.positions;
      } else if (pots instanceof Cesium__namespace.Rectangle) {
        pots = this.outlinePositions;
      }

      this._positions_draw = pots || this.positionsShow || [];
      this.positions = new Cesium__namespace.CallbackProperty((time) => {
        return this._positions_CallbackProperty()
      }, false);

      // 存在边线时
      this._updateOutlineToCallback();

      this.updateAttrForDrawing && this.updateAttrForDrawing(true);

      this._updateLabelPosition(); // 中心文本处理
    }

    _positions_CallbackProperty() {
      return this._positions_draw
    }

    // 坐标CallbackProperty属性改为实际值
    _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return
      }
      this._isCallbackPositions = false;
      this._positions = this._positions_draw;
      this._points = LngLatArray.toPoints(this._positions_draw);

      this._updatePositionsHook();
      this._cancelOutlinePositionsCallback();
    }

    _startDrawHook() {
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);
      this._map.on(EventType.click, this._onClickHandler, this);
      this._map.on(EventType.rightClick, this._onRightClickHandler, this);
      this._map.on(EventType.dblClick, this._onDbClickHandler, this);
    }

    _stopDrawHook() {
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);
      this._map.off(EventType.click, this._onClickHandler, this);
      this._map.off(EventType.rightClick, this._onRightClickHandler, this);
      this._map.off(EventType.dblClick, this._onDbClickHandler, this);
    }
  }

  /**
   * 像素点 支持的样式信息
   *
   * @typedef {Object} PointEntity.StyleOptions
   *
   * @property {Number} [pixelSize = 10] 像素大小
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   * @property {Number} [outlineWidth = 2] 边框宽度
   *
   * @property {Boolean|Cesium.NearFarScalar} [scaleByDistance = false] 是否按视距缩放 或 指定用于基于距离缩放点。
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [visibleDepth = true] 是否被遮挡
   * @property {number} [disableDepthTestDistance] 指定从相机到禁用深度测试的距离。
   * @property {Cesium.NearFarScalar} [translucencyByDistance] 用于基于与相机的距离设置半透明度。
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {PointEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see Cesium.PointGraphics.ConstructorOptions
   */

  /**
   * 像素点 Entity对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {PointEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.maxCacheCount=50] 当使用addDynamicPosition设置为动画轨迹位置时，保留的坐标点数量
   * @param {Cesium.ExtrapolationType} [options.forwardExtrapolationType= Cesium.ExtrapolationType.HOLD]  当使用addDynamicPosition设置为动画轨迹位置时，在任何可用坐标之后一次请求值时要执行的推断类型，默认为最后一个坐标位置。
   * @param {Cesium.ExtrapolationType} [options.backwardExtrapolationType= Cesium.ExtrapolationType.HOLD] 当使用addDynamicPosition设置为动画轨迹位置时， 在任何可用坐标之前一次请求值时要执行的推断类型，默认为第一个坐标位置。
   * @param {Boolean} [options.clampToTileset] 当使用addDynamicPosition设置为动画轨迹位置时，是否进行贴模型。
   * @param {Number} [options.frameRateHeight=30] 当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，多少帧计算一次贴模型高度
   * @param {Object[]} [options.objectsToExclude]  当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {ModelEntity.StyleOptions|*} [options.model]  设置附加的 gltf模型 和对应的样式
   * @param {BillboardEntity.StyleOptions|*} [options.billboard]  设置附加的 图标 和对应的样式
   * @param {CircleEntity.StyleOptions|*} [options.circle]  设置附加的 圆 和对应的样式
   * @param {PathEntity.StyleOptions|*} [options.path]  设置附加的 轨迹路线 和对应的样式
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class PointEntity
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PointEntity extends BasePointEntity {
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.PointGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.point
    }

    _mountedHook() {
      const addattr = {
        position: this.position,
        point: PointStyleConver.toCesiumVal(this.style)
      };

      // 同时加文字
      if (this.style.label) {
        addattr.label = LabelStyleConver.toCesiumVal(this.style.label, {}, this.attr);
      }

      // 支持其他附带对象 start
      if (this.options.billboard) {
        addattr.billboard = BillboardStyleConver.toCesiumVal(this.options.billboard, {}, true);
      }
      if (this.options.circle) {
        addattr.ellipse = CircleStyleConver.toCesiumVal(this.options.circle, {}, true);
      }
      if (this.options.model && this.options.model.show) {
        addattr.model = ModelStyleConver.toCesiumVal(this.options.model, {}, true);
      }
      if (this.options.path) {
        const pathAttr = PathStyleConver.toCesiumVal(this.options.path, {}, true);
        if (!pathAttr.isAll) {
          pathAttr.leadTime = 0; // 只显示飞过的路线
          // pathAttr.trailTime = this.alltimes * 10
        }
        addattr.path = pathAttr;
        // 时间
        const times = this.position?._property?._times;
        if (times && times.length > 0) {
          const start = times[0];
          let stop = times[times.length - 1];
          if (this.property?.forwardExtrapolationType === Cesium__namespace.ExtrapolationType.HOLD) {
            stop = Cesium__namespace.JulianDate.fromDate(new Date(2100, 1, 1));
          }
          addattr.availability = new Cesium__namespace.TimeIntervalCollection([new Cesium__namespace.TimeInterval({ start: start, stop: stop })]);
        }
      }
      // 支持其他附带对象 end

      this._entity = this._createEntity(addattr);
    }

    // 覆盖父类
    _addLabel() {
      this._entity.label = this._entity.label || {};
      LabelStyleConver.toCesiumVal(this.style.label, this._entity.label, this.attr);
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      PointStyleConver.toCesiumVal(style, this.entityGraphic);
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PointStyleConver.toJSON(czmStyle, styleJson, true)
    }

    _setOptionsHook(options, newOptions) {
      if (newOptions.model) {
        ModelStyleConver.toCesiumVal(options.model, this._entity.model, true);
      }
      if (newOptions.billboard) {
        BillboardStyleConver.toCesiumVal(options.billboard, this._entity.billboard, true);
      }
      if (newOptions.path) {
        PathStyleConver.toCesiumVal(options.path, this._entity.path, true);
      }
      if (newOptions.circle) {
        CircleStyleConver.toCesiumVal(options.circle, this._entity.ellipse, true);
      }
    }

    _updateExOpacity(value) {
      if (this._entity.model) {
        this._entity.model.color = Cesium__namespace.Color.WHITE.withAlpha(value);
      }
      if (this._entity.billboard) {
        this._entity.billboard.color = Cesium__namespace.Color.WHITE.withAlpha(value);
      }
      if (this._entity.path) {
        const result = this._updateEntityOpacity(this._entity.path, value);
        if (!result) {
          PathStyleConver.toCesiumVal({ ...this.options.path, globalAlpha: value }, this._entity.path, true);
        }
      }
      if (this._entity.circle) {
        const result = this._updateEntityOpacity(this._entity.circle, value);
        if (!result) {
          CircleStyleConver.toCesiumVal({ ...this.options.circle, globalAlpha: value }, this._entity.ellipse, true);
        }
      }
    }

    // distanceDisplayCondition属性的特殊处理
    _updateDistanceDisplayConditionByEdit() {
      // 覆盖父类的
    }
  }
  // 注册下
  register$4("point", PointEntity);

  /**
   * 图标点 支持的样式信息
   *
   * @typedef {Object} BillboardEntity.StyleOptions
   *
   * @property {string | HTMLCanvasElement} [image] 用于矢量对象的 图像、URI或Canvas
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {Number} [scale = 1] 图像大小的比例
   * @property {Number} [rotation = 0] 旋转角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [rotationDegree = 0] 旋转角度（度数值，0-360度），与rotation二选一
   * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
   * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
   * @property {Number} [width] 指定广告牌的宽度(以像素为单位)，覆盖图片本身大小。
   * @property {Number} [height] 指定广告牌的高度(以像素为单位)，覆盖图片本身大小。
   *
   * @property {Boolean} [hasPixelOffset = false] 是否存在偏移量
   * @property {Number} [pixelOffsetX = 0] 横向偏移像素
   * @property {Number} [pixelOffsetY = 0] 纵向偏移像素
   * @property {Cesium.Cartesian2|Number[]} [pixelOffset=Cartesian2.ZERO]  指定像素偏移量。
   *
   * @property {Boolean|Cesium.NearFarScalar} [scaleByDistance = false] 是否按视距缩放 或 设置基于与相机的距离缩放点
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定该广告牌将显示在与摄像机的多大距离
   * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   *
   * @property {Boolean} [visibleDepth = true] 是否被遮挡
   * @property {Number} [disableDepthTestDistance] 指定从相机到禁用深度测试的距离。
   *
   * @property {Cesium.Color} [color=Color.WHITE] 附加的颜色
   * @property {Cesium.Cartesian3} [eyeOffset=Cartesian3.ZERO] 眼偏移量
   * @property {Cesium.Cartesian3} [alignedAxis=Cartesian3.ZERO] 指定单位旋转向量轴。
   * @property {boolean} [sizeInMeters] 指定该广告牌的大小是否应该以米来度量。
   * @property {Cesium.NearFarScalar} [translucencyByDistance] 用于基于与相机的距离设置半透明度。
   * @property {Cesium.NearFarScalar} [pixelOffsetScaleByDistance] 用于基于与相机的距离设置pixelOffset。
   * @property {Cesium.BoundingRectangle} [imageSubRegion] 定义用于广告牌的图像的子区域，而不是从左下角开始以像素为单位的整个图像。
   *
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {BillboardEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see Cesium.BillboardGraphics.ConstructorOptions
   */

  /**
   * 图标点  Entity对象
   *
   * @param {Object} options 参数对象，包括以下：

   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {BillboardEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.maxCacheCount=50] 当使用addDynamicPosition设置为动画轨迹位置时，保留的坐标点数量
   * @param {Cesium.ExtrapolationType} [options.forwardExtrapolationType= Cesium.ExtrapolationType.HOLD]  当使用addDynamicPosition设置为动画轨迹位置时，在任何可用坐标之后一次请求值时要执行的推断类型，默认为最后一个坐标位置。
   * @param {Cesium.ExtrapolationType} [options.backwardExtrapolationType= Cesium.ExtrapolationType.HOLD] 当使用addDynamicPosition设置为动画轨迹位置时， 在任何可用坐标之前一次请求值时要执行的推断类型，默认为第一个坐标位置。
   * @param {Boolean} [options.clampToTileset] 当使用addDynamicPosition设置为动画轨迹位置时，是否进行贴模型。
   * @param {Number} [options.frameRateHeight=30] 当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，多少帧计算一次贴模型高度
   * @param {Object[]} [options.objectsToExclude]  当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {ModelEntity.StyleOptions|*} [options.model]  设置附加的 gltf模型 和对应的样式
   * @param {PointEntity.StyleOptions|*} [options.point]  设置附加的 像素点 和对应的样式
   * @param {CircleEntity.StyleOptions|*} [options.circle]  设置附加的 圆 和对应的样式
   * @param {PathEntity.StyleOptions|*} [options.path]  设置附加的 轨迹路线 和对应的样式
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class BillboardEntity
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BillboardEntity extends BasePointEntity {
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.BillboardGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.billboard
    }

    /**
     * 图像、URI或Canvas
     * @type {string | HTMLCanvasElement}
     */
    get image() {
      return this.style.image
    }

    set image(val) {
      this.style.image = val;
      if (this._entity) {
        this._entity.billboard.image = val;
      }
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      const addattr = {
        position: this.position,
        billboard: BillboardStyleConver.toCesiumVal(this.style)
      };

      // 同时加文字
      if (this.style.label) {
        if (Cesium__namespace.defined(this.style.clampToGround) && !Cesium__namespace.defined(this.style.label.clampToGround)) {
          this.style.label.clampToGround = this.style.clampToGround;
        }
        addattr.label = LabelStyleConver.toCesiumVal(this.style.label, {}, this.attr);
      }

      // 支持其他附带对象 start
      if (this.options.point) {
        addattr.point = PointStyleConver.toCesiumVal(this.options.point, {}, true);
      }
      if (this.options.circle) {
        addattr.ellipse = CircleStyleConver.toCesiumVal(this.options.circle, {}, true);
      }
      if (this.options.model && this.options.model.show) {
        addattr.model = ModelStyleConver.toCesiumVal(this.options.model, {}, true);
      }
      if (this.options.path) {
        const pathAttr = PathStyleConver.toCesiumVal(this.options.path, {}, true);
        if (!pathAttr.isAll) {
          pathAttr.leadTime = 0; // 只显示飞过的路线
          // pathAttr.trailTime = this.alltimes * 10
        }
        addattr.path = pathAttr;
        // 时间
        const times = this.position?._property?._times;
        if (times && times.length > 0) {
          const start = times[0];
          let stop = times[times.length - 1];
          if (this.property?.forwardExtrapolationType === Cesium__namespace.ExtrapolationType.HOLD) {
            stop = Cesium__namespace.JulianDate.fromDate(new Date(2100, 1, 1));
          }
          addattr.availability = new Cesium__namespace.TimeIntervalCollection([new Cesium__namespace.TimeInterval({ start: start, stop: stop })]);
        }
      }
      // 支持其他附带对象 end

      this._entity = this._createEntity(addattr);
    }

    // 覆盖父类
    _addLabel() {
      this._entity.label = this._entity.label || {};
      LabelStyleConver.toCesiumVal(this.style.label, this._entity.label, this.attr);
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return BillboardStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      BillboardStyleConver.toCesiumVal(style, this.entityGraphic);
    }

    _setOptionsHook(options, newOptions) {
      if (newOptions.model) {
        ModelStyleConver.toCesiumVal(options.model, this._entity.model, true);
      }
      if (newOptions.point) {
        PointStyleConver.toCesiumVal(options.point, this._entity.point, true);
      }
      if (newOptions.path) {
        PathStyleConver.toCesiumVal(options.path, this._entity.path, true);
      }
      if (newOptions.circle) {
        CircleStyleConver.toCesiumVal(options.circle, this._entity.ellipse, true);
      }
    }

    _updateExOpacity(value) {
      if (this._entity.model) {
        this._entity.model.color = Cesium__namespace.Color.WHITE.withAlpha(value);
      }
      if (this._entity.point) {
        const result = this._updateEntityOpacity(this._entity.point, value);
        if (!result) {
          PointStyleConver.toCesiumVal({ ...this.options.point, globalAlpha: value }, this._entity.point, true);
        }
      }
      if (this._entity.path) {
        const result = this._updateEntityOpacity(this._entity.path, value);
        if (!result) {
          PathStyleConver.toCesiumVal({ ...this.options.path, globalAlpha: value }, this._entity.path, true);
        }
      }
      if (this._entity.circle) {
        const result = this._updateEntityOpacity(this._entity.circle, value);
        if (!result) {
          CircleStyleConver.toCesiumVal({ ...this.options.circle, globalAlpha: value }, this._entity.ellipse, true);
        }
      }
    }

    // distanceDisplayCondition属性的特殊处理
    _updateDistanceDisplayConditionByEdit() {
      // 覆盖父类的
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this.style.globalAlpha = value;

      if (this._entity) {
        this._entity.billboard.color = Cesium__namespace.Color.WHITE.withAlpha(value);
      }
      this._updateLabelOpacity(value);
    }

    /**
     * 开始执行弹跳动画
     *
     * @param {Object} [options] 参数，包括
     * @param {Number} [options.maxHeight=50] 弹跳的最大高度, 单位：像素
     * @param {Number} [options.step=1] 弹跳增量, 控制速度，单位：像素
     * @param {boolean} [options.autoStop] 是否自动停止，true时：会逐渐减弱至停止状态
     * @return {void}  无
     */
    startBounce(options = {}) {
      if (!this._entity) {
        return
      }

      let maxHeight = -(options.maxHeight || 50); // 高度,图标往上是负值
      const step = options.step || 1; // 增量
      const autoStop = options.autoStop;
      let currentY = maxHeight;
      let isUp = -1;

      const that = this;
      function update() {
        if (currentY <= maxHeight && isUp !== 1) {
          isUp = 1;
          if (autoStop) {
            // 到顶部后
            maxHeight *= 0.55;
            if (step * 2 >= -maxHeight) {
              that.stopBounce();
            }
          }
        } else if (currentY >= 0 && isUp !== -1) {
          isUp = -1;
        }
        currentY += step * isUp;
      }

      const pixelOffset_original = getCesiumValue(this.entityGraphic.pixelOffset, Cesium__namespace.Cartesian2) || new Cesium__namespace.Cartesian2(0, 0);
      const currentOffset = pixelOffset_original.clone();
      this.entityGraphic.pixelOffset_original = pixelOffset_original;
      this.entityGraphic.pixelOffset = new Cesium__namespace.CallbackProperty((e) => {
        update();
        currentOffset.y = pixelOffset_original.y + currentY;
        return currentOffset
      });

      if (this._entity.label) {
        const pixelLabelOffset_original = getCesiumValue(this._entity.label.pixelOffset, Cesium__namespace.Cartesian2) || new Cesium__namespace.Cartesian2(0, 0);
        const currentLabelOffset = pixelLabelOffset_original.clone();
        this._entity.label.pixelOffset_original = pixelLabelOffset_original;
        this._entity.label.pixelOffset = new Cesium__namespace.CallbackProperty((e) => {
          currentLabelOffset.y = pixelLabelOffset_original.y + currentY;
          return currentLabelOffset
        });
      }
    }

    /**
     * 停止弹跳动画
     * @return {void}  无
     */
    stopBounce() {
      this.entityGraphic.pixelOffset = this.entityGraphic.pixelOffset_original;
      if (this._entity.label) {
        this._entity.label.pixelOffset = this._entity.label.pixelOffset_original;
      }
    }
  }

  // 注册下
  register$4("billboard", BillboardEntity);

  /**
   * HTML转图片后的图标点Entity 支持的样式信息
   *
   * @typedef {Object} DivBillboardEntity.StyleOptions
   *
   * @property {String} html Html内容
   *
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {Number} [scale = 1] 图像大小的比例
   * @property {Number} [rotation = 0] 旋转角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [rotationDegree = 0] 旋转角度（度数值，0-360度），与rotation二选一
   * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
   * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
   * @property {Number} [width] 指定广告牌的宽度(以像素为单位)，覆盖图片本身大小。
   * @property {Number} [height] 指定广告牌的高度(以像素为单位)，覆盖图片本身大小。
   *
   * @property {Boolean} [hasPixelOffset = false] 是否存在偏移量
   * @property {Number} [pixelOffsetX = 0] 横向偏移像素
   * @property {Number} [pixelOffsetY = 0] 纵向偏移像素
   * @property {Cesium.Cartesian2|Number[]} [pixelOffset=Cartesian2.ZERO]  指定像素偏移量。
   *
   * @property {Boolean|Cesium.NearFarScalar} [scaleByDistance = false] 是否按视距缩放 或 设置基于与相机的距离缩放点
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定该广告牌将显示在与摄像机的多大距离
   * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   *
   * @property {Boolean} [visibleDepth = true] 是否被遮挡
   * @property {Number} [disableDepthTestDistance] 指定从相机到禁用深度测试的距离。
   *
   * @property {Cesium.Color} [color=Color.WHITE] 附加的颜色
   * @property {Cesium.Cartesian3} [eyeOffset=Cartesian3.ZERO] 眼偏移量
   * @property {Cesium.Cartesian3} [alignedAxis=Cartesian3.ZERO] 指定单位旋转向量轴。
   * @property {boolean} [sizeInMeters] 指定该广告牌的大小是否应该以米来度量。
   * @property {Cesium.NearFarScalar} [translucencyByDistance] 用于基于与相机的距离设置半透明度。
   * @property {Cesium.NearFarScalar} [pixelOffsetScaleByDistance] 用于基于与相机的距离设置pixelOffset。
   * @property {Cesium.BoundingRectangle} [imageSubRegion] 定义用于广告牌的图像的子区域，而不是从左下角开始以像素为单位的整个图像。
   *
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {BillboardEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see Cesium.BillboardGraphics.ConstructorOptions
   * @see {BillboardEntity.StyleOptions}
   */

  /**
   * HTML转图片后的 图标点Entity，
   * 需要引入html2canvas或domtoimage插件进行DOM转图片
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {DivBillboardEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class DivBillboardEntity
   * @extends {BillboardEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class DivBillboardEntity extends BillboardEntity {
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      super._mountedHook();
      this._updateImage_delay();
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      delete style.image;
      super._updateStyleHook(style, newStyle);

      if (newStyle && (newStyle.html || newStyle.iconSize || newStyle.color)) {
        this._updateImage_delay();
      }
    }

    _updateImage_delay() {
      // setTimeout是为了优化效率
      if (this.updateTimer) {
        clearTimeout(this.updateTimer);
      }
      this.updateTimer = setTimeout(() => {
        delete this.updateTimer;
        if (!this._entity) {
          return
        }
        this._updateImage();
      }, 300);
    }

    // 更新图标
    _updateImage() {
      const container = create$3("div", "mars3d-hideDiv");
      const content = this.style.html;
      if (isString(content)) {
        container.innerHTML = content;
      } else if (content instanceof Element) {
        container.appendChild(content);
      }

      document.body.appendChild(container);

      this._islosdImg = true;
      if (window.domtoimage) {
        // lib/dom2img/dom-to-image.js
        window.domtoimage
          .toPng(container)
          .then((base64) => {
            this.entityGraphic.image = "" + base64;

            document.body.removeChild(container);
            this._islosdImg = false;
            this.fire("image", { image: base64 });
          })
          .catch((error) => {
            logError("未知原因，导出失败!", error);

            document.body.removeChild(container);
            this._islosdImg = false;
          });
      } else if (window.html2canvas) {
        // lib/dom2img/html2canvas.js
        window
          .html2canvas(container, {
            backgroundColor: null,
            allowTaint: true
          })
          .then((canvas) => {
            this.entityGraphic.image = canvas;

            document.body.removeChild(container);
            this._islosdImg = false;
            this.fire("image", { canvas: canvas });
          })
          .catch((error) => {
            logError("未知原因，导出失败!", error);

            document.body.removeChild(container);
            this._islosdImg = false;
          });
      }
    }


  }

  // 注册下
  register$4("divBillboard", DivBillboardEntity);

  /**
   * Font CSS字体点转图片后的图标点  Entity 支持的样式信息
   *
   * @typedef {Object} FontBillboardEntity.StyleOptions
   *
   * @property {String} [iconClass = ""] 字体css样式
   * @property {Number} [iconSize = 50] 字体大小
   * @property {String} [color='#ff0000'] 字体颜色
   *
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {Number} [scale = 1] 图像大小的比例
   * @property {Number} [rotation = 0] 旋转角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [rotationDegree = 0] 旋转角度（度数值，0-360度），与rotation二选一
   * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
   * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
   * @property {Number} [width] 指定广告牌的宽度(以像素为单位)，覆盖图片本身大小。
   * @property {Number} [height] 指定广告牌的高度(以像素为单位)，覆盖图片本身大小。
   *
   * @property {Boolean} [hasPixelOffset = false] 是否存在偏移量
   * @property {Number} [pixelOffsetX = 0] 横向偏移像素
   * @property {Number} [pixelOffsetY = 0] 纵向偏移像素
   * @property {Cesium.Cartesian2|Number[]} [pixelOffset=Cartesian2.ZERO]  指定像素偏移量。
   *
   * @property {Boolean|Cesium.NearFarScalar} [scaleByDistance = false] 是否按视距缩放 或 设置基于与相机的距离缩放点
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定该广告牌将显示在与摄像机的多大距离
   * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   *
   * @property {Boolean} [visibleDepth = true] 是否被遮挡
   * @property {Number} [disableDepthTestDistance] 指定从相机到禁用深度测试的距离。
   *
   * @property {Cesium.Cartesian3} [eyeOffset=Cartesian3.ZERO] 眼偏移量
   * @property {Cesium.Cartesian3} [alignedAxis=Cartesian3.ZERO] 指定单位旋转向量轴。
   * @property {boolean} [sizeInMeters] 指定该广告牌的大小是否应该以米来度量。
   * @property {Cesium.NearFarScalar} [translucencyByDistance] 用于基于与相机的距离设置半透明度。
   * @property {Cesium.NearFarScalar} [pixelOffsetScaleByDistance] 用于基于与相机的距离设置pixelOffset。
   * @property {Cesium.BoundingRectangle} [imageSubRegion] 定义用于广告牌的图像的子区域，而不是从左下角开始以像素为单位的整个图像。
   *
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {BillboardEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see BillboardEntity.StyleOptions
   */

  /**
   * Font CSS字体点转图片后的图标点  Entity,
   * 需要引入html2canvas或domtoimage插件进行DOM转图片
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {FontBillboardEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   *
   * @export
   * @class FontBillboardEntity
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class FontBillboardEntity extends DivBillboardEntity {
    // 更新图标
    _updateImage() {
      const size = this.style.iconSize ?? 50;
      const color = this.style.color ?? "#ff0000";

      const container = create$3("div", "mars3d-hideDiv");
      container.setAttribute("style", "padding: 10px;text-align:center;max-width:" + (size + 10) + "px;max-height:" + (size + 10) + "px;");
      const jd = document.createElement("i");
      jd.setAttribute("class", this.style.iconClass);
      jd.setAttribute("style", "font-size:" + size + "px;color:" + color + ";");
      container.appendChild(jd);
      document.body.appendChild(container);

      this._islosdImg = true;
      if (window.domtoimage) {
        // lib/dom2img/dom-to-image.js
        window.domtoimage
          .toPng(container)
          .then((base64) => {
            this.entityGraphic.image = "" + base64;

            document.body.removeChild(container);
            this._islosdImg = false;
            this.fire("image", { image: base64 });
          })
          .catch((error) => {
            logError("未知原因，导出失败!", error);

            document.body.removeChild(container);
            this._islosdImg = false;
          });
      } else if (window.html2canvas) {
        // lib/dom2img/html2canvas.js
        window
          .html2canvas(container, {
            backgroundColor: null,
            allowTaint: true
          })
          .then((canvas) => {
            this.entityGraphic.image = canvas;

            document.body.removeChild(container);
            this._islosdImg = false;
            this.fire("image", { canvas: canvas });
          })
          .catch((error) => {
            logError("未知原因，导出失败!", error);

            document.body.removeChild(container);
            this._islosdImg = false;
          });
      }
    }
  }
  // 注册下
  register$4("fontBillboard", FontBillboardEntity);

  /**
   * 文本点 支持的样式信息
   *
   * @typedef {Object} LabelEntity.StyleOptions
   *
   * @property {String} [text = "文字"] 文本内容，换行可以用换行符'\n'。
   *
   * @property {number} [scale=1.0] 指定缩放比例。
   * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
   * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
   *
   * @property {String} [font_family = "楷体"] 字体 ,可选项：微软雅黑,宋体,楷体,隶书,黑体 等
   * @property {Number} [font_size = 30] 字体大小
   * @property {String} [font_weight = "normal"] 是否加粗 ,可选项：bold (解释：是),normal (解释：否),
   * @property {String} [font_style = "normal"] 是否斜体 ,可选项：italic (解释：是),normal (解释：否),
   * @property {string} [font='30px normal normal 楷体'] 上叙4个属性的一次性指定CSS字体的属性。
   *
   * @property {Boolean} [fill = true] 是否填充
   * @property {String|Cesium.Color} [color = "#ffffff"] 文本颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否衬色
   * @property {String|Cesium.Color} [outlineColor = "#000000"] 衬色颜色
   * @property {Number} [outlineOpacity = 0.6] 衬色透明度
   * @property {Number} [outlineWidth = 2.0] 衬色宽度
   *
   * @property {Boolean} [background = false] 是否背景
   * @property {String|Cesium.Color} [backgroundColor = "#000000"] 背景颜色
   * @property {Number} [backgroundOpacity = 0.5] 背景透明度
   * @property {Number|Cesium.Cartesian2} [backgroundPadding=new Cesium.Cartesian2(7, 5)] 背景内边距，指定文字与填充边界内容之间的空间(以像素为单位)。
   *
   * @property {Boolean} [hasPixelOffset = false] 是否存在偏移量
   * @property {Number} [pixelOffsetX = 0] 横向偏移像素
   * @property {Number} [pixelOffsetY = 0] 纵向偏移像素
   * @property {Cesium.Cartesian2|Number[]} [pixelOffset=Cartesian2.ZERO] A {@link Cartesian2} Property specifying the pixel offset.
   * @property {Cesium.NearFarScalar} [pixelOffsetScaleByDistance] A {@link NearFarScalar} Property used to set pixelOffset based on distance from the camera.
   * @property {Cesium.Cartesian3} [eyeOffset=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the eye offset.
   *
   * @property {Boolean|Cesium.NearFarScalar} [scaleByDistance = false] 是否按视距缩放 或 设定基于与相机的距离设置比例。
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   *
   * @property {Boolean} [visibleDepth = true] 是否被遮挡
   * @property {number} [disableDepthTestDistance] 指定从相机到禁用深度测试的距离。
   *
   * @property {Cesium.NearFarScalar} [translucencyByDistance] 用于基于与相机的距离设置半透明度。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @see Cesium.LabelGraphics.ConstructorOptions
   */

  /**
   * 文字  Entity对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {LabelEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class LabelEntity extends BasePointEntity {
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.LabelGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.label
    }

    get label() {
      if (this._entity) {
        return this._entity.label
      } else {
        return this.style
      }
    }

    /**
     * 文本内容
     * @type {String}
     * @readonly
     */
    get text() {
      return this.style.text
    }

    set text(value) {
      this.style.text = value;

      if (this._entity) {
        this.entityGraphic.text = value;
      }
    }

    _mountedHook() {
      const addattr = {
        position: this.position,
        label: LabelStyleConver.toCesiumVal(this.style)
      };
      this._entity = this._createEntity(addattr);
    }

    // 覆盖父类
    _addLabel() {}

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return LabelStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      LabelStyleConver.toCesiumVal(style, this.entityGraphic);
    }

    // distanceDisplayCondition属性的特殊处理
    _updateDistanceDisplayConditionByEdit() {
      // 覆盖父类的
    }

    /**
     * 开始执行弹跳动画
     *
     * @param {Object} [options] 参数，包括
     * @param {Number} [options.maxHeight=50] 弹跳的最大高度, 单位：像素
     * @param {Number} [options.step=1] 弹跳增量, 控制速度，单位：像素
     * @param {boolean} [options.autoStop] 是否自动停止，true时：会逐渐减弱至停止状态
     * @return {void}  无
     */
    startBounce(options = {}) {
      if (!this._entity) {
        return
      }

      let maxHeight = -(options.maxHeight || 50); // 高度,图标往上是负值
      const step = options.step || 1; // 增量
      const autoStop = options.autoStop;
      let currentY = maxHeight;
      let isUp = -1;

      const that = this;
      function update() {
        if (currentY <= maxHeight && isUp !== 1) {
          isUp = 1;
          if (autoStop) {
            // 到顶部后
            maxHeight *= 0.55;
            if (step * 2 >= -maxHeight) {
              that.stopBounce();
            }
          }
        } else if (currentY >= 0 && isUp !== -1) {
          isUp = -1;
        }
        currentY += step * isUp;
      }

      const pixelOffset_original = getCesiumValue(this.entityGraphic.pixelOffset, Cesium__namespace.Cartesian2) || new Cesium__namespace.Cartesian2(0, 0);
      const currentOffset = pixelOffset_original.clone();
      this.entityGraphic.pixelOffset_original = pixelOffset_original;
      this.entityGraphic.pixelOffset = new Cesium__namespace.CallbackProperty((e) => {
        update();
        currentOffset.y = pixelOffset_original.y + currentY;
        return currentOffset
      });
    }

    /**
     * 停止弹跳动画
     * @return {void}  无
     */
    stopBounce() {
      this.entityGraphic.pixelOffset = this.entityGraphic.pixelOffset_original;
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this.style.globalAlpha = value;
      if (this._entity) {
        LabelStyleConver.setOpacity(this.entityGraphic, value);
      }
    }
  }
  // 注册下
  register$4("label", LabelEntity);

  /**
   * Canvas 文本点（label转图片） 支持的样式信息
   *
   * @typedef {Object} CanvasLabelEntity.StyleOptions
   *
   * @property {String} [text = "文字"] 文本内容，换行可以用换行符'\n'。
   *
   * @property {number} [scale=1.0] 指定缩放比例。
   * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
   * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
   *
   * @property {String} [font_family = "楷体"] 字体 ,可选项：微软雅黑,宋体,楷体,隶书,黑体 等
   * @property {Number} [font_size = 30] 字体大小
   * @property {String} [font_weight = "normal"] 是否加粗 ,可选项：bold (解释：是),normal (解释：否),
   * @property {String} [font_style = "normal"] 是否斜体 ,可选项：italic (解释：是),normal (解释：否),
   * @property {string} [font='30px normal normal 楷体'] 上叙4个属性的一次性指定CSS字体的属性。
   * @property {String} [textBaseline='bottom'] 文本的基线。
   *
   * @property {Boolean} [fill = true] 是否填充
   * @property {String|Cesium.Color} [color = "#ffffff"] 文本颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   *
   * @property {Boolean} [stroke = false] 是否衬色
   * @property {String|Cesium.Color} [strokeColor = "#000000"] 衬色颜色
   * @property {Number} [strokeWidth = 2] 衬色宽度
   *
   * @property {Boolean} [outline = false] 是否矩形边框
   * @property {String|Cesium.Color} [outlineColor = "#000000"] 矩形边框的颜色。
   * @property {Number} [outlineWidth = 4] 边框的宽度
   *
   * @property {Boolean} [background = false] 是否背景
   * @property {String|Cesium.Color} [backgroundColor = "#000000"] 背景颜色
   * @property {Number} [backgroundPadding=0] 背景内边距，指定文字与填充边界内容之间的空间(以像素为单位)。
   *
   * @property {Boolean} [hasPixelOffset = false] 是否存在偏移量
   * @property {Number} [pixelOffsetX = 0] 横向偏移像素
   * @property {Number} [pixelOffsetY = 0] 纵向偏移像素
   * @property {Cesium.Cartesian2|Number[]} [pixelOffset=Cartesian2.ZERO]  指定像素偏移量。
   *
   * @property {Boolean|Cesium.NearFarScalar} [scaleByDistance = false] 是否按视距缩放 或 设定基于与相机的距离设置比例。
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   *
   * @property {Boolean} [visibleDepth = true] 是否被遮挡
   * @property {number} [disableDepthTestDistance] 指定从相机到禁用深度测试的距离。
   *
   * @property {Cesium.NearFarScalar} [translucencyByDistance] 用于基于与相机的距离设置半透明度。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @see Cesium.LabelGraphics.ConstructorOptions
   */

  /**
   * Canvas 文本点（label转图片）
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {CanvasLabelEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */

  class CanvasLabelEntity extends BillboardEntity {
    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      super._mountedHook();
      this._updateImage_delay(this.style);
    }

    _onBeforeCreate(addattr) {
      if (Cesium__namespace.defined(addattr?.billboard?.image)) {
        delete addattr.billboard.image;
      }
      if (Cesium__namespace.defined(addattr?.billboard?.color)) {
        delete addattr.billboard.color;
      }
      return addattr
    }

    _updateStyleHook(style, newStyle) {
      const styleCopy = { ...style };
      delete styleCopy.image;
      delete styleCopy.color;
      super._updateStyleHook(styleCopy, newStyle);

      this._updateImage_delay(style);
    }

    _updateImage_delay(style) {
      // setTimeout是为了优化效率
      if (this.updateTimer) {
        clearTimeout(this.updateTimer);
      }
      this.updateTimer = setTimeout(() => {
        delete this.updateTimer;
        if (!this._entity) {
          return
        }
        this._updateImage(style);
      }, 100);
    }

    // 更新图标
    _updateImage(style) {
      const textStyles = LabelStyleConver.toCesiumVal(style);

      const canvas = getTextImage(textStyles.text, textStyles);
      if (canvas) {
        this.entityGraphic.image = canvas;
      }
    }


  }

  // 注册下
  register$4("canvasLabel", CanvasLabelEntity);

  /**
   * Model对象 标绘处理对应的编辑类
   *
   * @export
   * @class EditModel
   * @extends {EditBase}
   */
  class EditModel extends EditBase {
    get position() {
      return this._graphic._position_draw
    }

    set position(value) {
      this._graphic._position_draw = value;
    }

    // 根据属性更新坐标
    updatePositionsHeightByAttr(position) {
      if (this.clampToGround) {
        // 贴地时求贴模型和贴地的高度
        position = getSurfacePosition(this._map.scene, position);
      }
      return position
    }

    bindDraggers() {
      this._graphic._draw_tooltip = this._map.getLangText("_拖动该点后") + "<br/>" + this._map.getLangText("_修改位置");

      this.createDragger({
        dragger: this._graphic,
        onDragStart: (dragger, newPosition) => {
          for (let i = 0, len = this.draggers.length; i < len; i++) {
            this.draggers[i].show = false;
          }
        },
        onDrag: (dragger, newPosition) => {
          this.position = newPosition;
        },
        onDragEnd: (dragger, newPosition) => {
          this.updateDraggers();
        }
      });

      const radius = this.style.radius;
      const modelPosition = this.updatePositionsHeightByAttr(this.position);
      // const height = Cesium.Cartographic.fromCartesian(modelPosition).height

      // 辅助显示：创建角度调整底部圆
      // if (this._hasEditHeading && !this._matrixMove && !this._matrixRotate) {
      //   this.entityAngle = new CircleEntity({
      //     name: "角度调整底部圆",
      //     position: new Cesium.CallbackProperty((time) => {
      //       return modelPosition
      //     }, false),
      //     style: {
      //       fill: false,
      //       outline: true,
      //       outlineColor: "#ffff00",
      //       outlineOpacity: 0.8,
      //       radius: radius,
      //       height: height
      //     },
      //     private: true
      //   })
      //   this.layer.addGraphic(this.entityAngle)

      //   // 创建角度调整 拖拽点
      //   const majorPos = getPositionByDirectionAndLen(modelPosition, this.style.heading, radius)
      //   const majorDragger = this.createDragger({
      //     position: majorPos,
      //     type: PointType.EditAttr,
      //     tooltip: this._map.getLangText("_修改方向"),
      //     onDrag: (dragger, position) => {
      //       const heading = getAngle(modelPosition, position) // 模型是正东为0

      //       // this.style.radius = Cesium.Cartesian3.distance(this.position, position)
      //       // this.entityAngle.radius = this.style.radius

      //       this.style.heading = formatNum(heading, 2)
      //       dragger.position = getPositionByDirectionAndLen(modelPosition, this.style.heading, this.style.radius)

      //       this._graphic.updateOrientation(modelPosition)
      //     }
      //   })
      //   this.draggers.push(majorDragger)
      // }

      // 缩放控制点
      if (this._hasEditScale) {
        const position_scale = addPositionsHeight(modelPosition, radius);
        const draggerScale = this.createDragger({
          position: position_scale,
          type: PointType.MoveHeight,
          tooltip: this._map.getLangText("_修改缩放比例"),
          onDragStart: (dragger, position) => {
            if (this.entityAngle) {
              this.entityAngle.show = false;
            }
            for (let i = 0, len = this.draggers.length; i < len; i++) {
              this.draggers[i].show = false;
            }
          },
          onDrag: (dragger, positionNew) => {
            const radiusNew = Cesium__namespace.Cartesian3.distance(positionNew, modelPosition);

            const radiusOld = dragger.radius / (this.style.scale || 1);
            let scale = formatNum$1(radiusNew / radiusOld, 3);
            if (isNaN(scale)) {
              return
            }
            if (scale <= 0) {
              scale = 0.001;
            }

            this.style.scale = scale;
            this.entityGraphic.scale = scale;
            dragger.radius = radiusNew;
            this.style.radius = radiusNew;
          },
          onDragEnd: (dragger, position) => {
            this.updateDraggers();
            this.fire(EventType.editStyle);
          }
        });
        draggerScale.radius = radius;
        this.draggers.push(draggerScale);
      }
    }

    // destroyDraggers() {
    //   super.destroyDraggers()

    //   if (this.entityAngle) {
    //     this.layer.removeGraphic(this.entityAngle, true)
    //     delete this.entityAngle
    //   }
    // }

    getDraggerContextMenu(dragger) {
      const arr = super.getDraggerContextMenu(dragger);

      // 3轴方向
      if (this.style.hasEditRotate ?? true) {
        arr.push({
          text: "按轴旋转",
          icon: Icon.BloomEffectYes,
          show: (event) => {
            return !this._matrixRotate || this._matrixRotate._dragger_index !== dragger.index
          },
          callback: (event) => {
            this._startMatrixRotate(event.graphic, event);
          }
        });
        arr.push({
          text: "停止按轴旋转",
          icon: Icon.BloomEffectNo,
          show: (event) => {
            return this._matrixRotate && this._matrixRotate._dragger_index === dragger.index
          },
          callback: (event) => {
            this._removeMatrixRotate();
          }
        });
      }

      // 四周方向
      // if (!Cesium.defined(this._hasEditHeading)) {
      //   this._hasEditHeading = (this._graphic.options.hasEditHeading ?? false)
      // }
      // arr.push({
      //   text: "编辑方向",
      //   icon: Icon.DrawCircle,
      //   show: (event) => {
      //     return !this._hasEditHeading
      //   },
      //   callback: (event) => {
      //     this._hasEditHeading = true
      //     this.updateDraggers()
      //   }
      // })
      // arr.push({
      //   text: "停止编辑方向",
      //   icon: Icon.DrawCircle,
      //   show: (event) => {
      //     return this._hasEditHeading
      //   },
      //   callback: (event) => {
      //     this._hasEditHeading = false
      //     this.updateDraggers()
      //   }
      // })

      // 缩放比例
      if (!Cesium__namespace.defined(this._hasEditScale)) {
        this._hasEditScale = this._graphic.options.hasEditScale ?? false;
      }
      arr.push({
        text: "调整比例",
        icon: Icon.UndergroundYes,
        show: (event) => {
          return !this._hasEditScale
        },
        callback: (event) => {
          this._hasEditScale = true;
          this.updateDraggers();
        }
      });
      arr.push({
        text: "停止调整比例",
        icon: Icon.UndergroundNo,
        show: (event) => {
          return this._hasEditScale
        },
        callback: (event) => {
          this._hasEditScale = false;
          this.updateDraggers();
        }
      });
      return arr
    }

    // 图形编辑结束后调用
    finish() {
      delete this._graphic._draw_tooltip;
      delete this._graphic._isDragger;
      delete this._graphic._noMousePick;
      delete this._graphic._pointType;
      delete this._graphic.onDrag;

      this._graphic.unbindContextMenu();
    }
  }

  /**
   * gltf小模型 支持的样式信息
   *
   * @typedef {Object} ModelEntity.StyleOptions
   *
   * @property {String| Cesium.Resource} [url] glTF模型的URI的字符串或资源属性。
   * @property {Number} [scale = 1] 比例
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   * @property {Boolean} [noPitchRoll] 当addDynamicPosition时，设置为true时，可以设置模型只动态更改方向，内部固定模型的Pitch和Roll方向值为0
   *
   * @property {Number} [radius] 编辑时，半径圆圈的半径，默认自动
   *
   * @property {number} [minimumPixelSize=0.0] 指定模型的近似最小像素大小，而不考虑缩放。
   * @property {number} [maximumScale] 模型的最大比例尺寸。minimumPixelSize的上限。
   *
   * @property {Boolean} [fill = false] 是否填充，指定与模型渲染颜色混合
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {Cesium.ColorBlendMode} [colorBlendMode=ColorBlendMode.HIGHLIGHT] 指定颜色如何与模型混合。
   * @property {number} [colorBlendAmount=0.5] 当colorBlendMode为MIX时指定颜色强度的数字属性。0.0的值表示模型渲染的颜色，1.0的值表示纯色，任何介于两者之间的值表示两者的混合。
   *
   * @property {Boolean} [silhouette = false] 是否轮廓
   * @property {String|Cesium.Color} [silhouetteColor = "#ff0000"] 轮廓颜色
   * @property {Number} [silhouetteSize = 2] 轮廓宽度
   * @property {Number} [silhouetteAlpha = 0.8] 轮廓透明度
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {PointEntity.StyleOptions} [distanceDisplayPoint] 当视角距离超过一定距离后(distanceDisplayCondition_far定义的) 后显示为 像素点 对象的样式，仅在distanceDisplayCondition设置时有效。
   * @property {BillboardEntity.StyleOptions} [distanceDisplayBillboard]  当视角距离超过一定距离后(distanceDisplayCondition_far定义的) 后显示为 图标 对象的样式，仅在distanceDisplayCondition设置时有效。
   *
   * @property {Boolean} [hasShadows = true] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=ShadowMode.ENABLED] 指定模型是投射还是接收来自光源的阴影。
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   *
   * @property {boolean} [incrementallyLoadTextures=true] 确定模型加载后纹理是否会继续流进来。
   * @property {boolean} [runAnimations=true]  指定模型中指定的glTF动画是否应该启动。
   * @property {boolean} [clampAnimations=true]  指定在没有关键帧的情况下，glTF动画是否应该保持最后一个姿势。
   *
   * @property {Cesium.Color} [lightColor]  在为模型着色时指定光的颜色的属性。当undefined场景的浅色被使用代替。
   * @property {Cesium.PropertyBag | Object.<string, Cesium.TranslationRotationScale>} [nodeTransformations] 一个对象，其中键是节点的名称，值是{@link TranslationRotationScale}属性，描述要应用到该节点的转换。该转换是在节点的现有转换之后(如glTF中指定的那样)应用的，并且不会替换节点的现有转换。
   * @property {Cesium.PropertyBag | Object.<string, number>} [articulations] An object, where keys are composed of an articulation name, a single space, and a stage name, and the values are numeric properties.
   * @property {Cesium.ClippingPlaneCollection} [clippingPlanes]  用于裁剪模型的Plane平面集合
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {ModelEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see Cesium.ModelGraphics.ConstructorOptions
   */



  /**
   * gltf小模型  Entity对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {ModelEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.Property} [options.orientation] 实体方向
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.maxCacheCount=50] 当使用addDynamicPosition设置为动画轨迹位置时，保留的坐标点数量
   * @param {Boolean} [options.fixedHeading] 当使用addDynamicPosition设置为动画轨迹位置时，是否使用固定的heading角度，而不用路线的自动方向角度。
   * @param {Cesium.ExtrapolationType} [options.forwardExtrapolationType= Cesium.ExtrapolationType.HOLD]  当使用addDynamicPosition设置为动画轨迹位置时，在任何可用坐标之后一次请求值时要执行的推断类型，默认为最后一个坐标位置。
   * @param {Cesium.ExtrapolationType} [options.backwardExtrapolationType= Cesium.ExtrapolationType.HOLD] 当使用addDynamicPosition设置为动画轨迹位置时， 在任何可用坐标之前一次请求值时要执行的推断类型，默认为第一个坐标位置。
   * @param {Boolean} [options.clampToTileset] 当使用addDynamicPosition设置为动画轨迹位置时，是否进行贴模型。
   * @param {Number} [options.frameRateHeight=30] 当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，多少帧计算一次贴模型高度
   * @param {Object[]} [options.objectsToExclude]  当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   * @param {Cesium.ReferenceFrame} [options.referenceFrame=Cesium.ReferenceFrame.FIXED] 当使用addDynamicPosition设置为动画轨迹位置时，position位置被定义的参考系。
   * @param {Number} [options.numberOfDerivatives=0] 当使用addDynamicPosition设置为动画轨迹位置时，每个位置的导数的数量;即速度、加速度等。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Number} [options.hasEditScale=false] 编辑时，是否自动启用调整缩放比例
   * @param {Number} [options.hasEditRotate=false] 编辑时，是否自动启用调整方向
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {BillboardEntity.StyleOptions|*} [options.billboard]  设置附加的 图标 和对应的样式。
   * @param {PointEntity.StyleOptions|*} [options.point]  设置附加的 像素点 和对应的样式
   * @param {CircleEntity.StyleOptions|*} [options.circle]  设置附加的 圆 和对应的样式
   * @param {PathEntity.StyleOptions|*} [options.path]  设置附加的 轨迹路线 和对应的样式
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class ModelEntity
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class ModelEntity extends BasePointEntity {
    constructor(options = {}) {
      // 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
      options.drawShow = options.drawShow ?? true;
      super(options);

      this.style.radius = this.style.radius ?? 50; // 默认值
      this.style.heading = this.style.heading ?? 0; // 默认值
    }

    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.ModelGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.model
    }

    /**
     * 编辑处理类
     * @type {EditModel}
     * @readonly
     */
    get EditClass() {
      return EditModel
    }

    /**
     * 模型整体的缩放比例
     * @type {Number}
     */
    get scale() {
      return this.style.scale ?? 1
    }

    set scale(val) {
      this.style.scale = val;
      this._updateStyleHook(this.style, { scale: val });
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      // marsOptions用于传递给 mars3d-cesium 内部
      const _marsOptions = {
        occlusion: this.style.marsOcclusion // gltf部分材质的混乱问题控制
      };
      if (isMars3DCesium) {
        this.loadOk = false;
        this._draw_tooltip = this._map.getLangText("_加载模型中");

        // readyPromise为修改cesium内部源码来实现的回调
        _marsOptions.callback = (entity, model) => {
          delete this._draw_tooltip;

          this.loadOk = true;

          if (model.boundingSphere.radius < (this.style.maxRadius, 1000)) {
            this.style.radius = model.boundingSphere.radius;
          }

          this.fire(
            EventType.load,
            {
              drawtype: this.type,
              entity: entity,
              model: model,
              graphic: this
            },
            true
          );
        };
      }

      const addattr = {
        position: this.position,
        orientation: this.getOrientation(),
        model: ModelStyleConver.toCesiumVal(this.style, {}, true)
      };
      if (!addattr.model.uri && this.options.url) {
        addattr.model.uri = this.options.url;
        addattr.model.show = true;
      }

      // 同时加文字
      if (this.style.label) {
        addattr.label = LabelStyleConver.toCesiumVal(this.style.label, {}, this.attr);
      }

      // 支持其他附带对象 start
      if (this.options.billboard) {
        addattr.billboard = BillboardStyleConver.toCesiumVal(this.options.billboard, {}, true);
      }
      if (this.options.point) {
        addattr.point = PointStyleConver.toCesiumVal(this.options.point, {}, true);
      }
      if (this.options.circle) {
        addattr.ellipse = CircleStyleConver.toCesiumVal(this.options.circle, {}, true);
      }
      if (this.options.path) {
        const pathAttr = PathStyleConver.toCesiumVal(this.options.path, {}, true);
        if (!pathAttr.isAll) {
          pathAttr.leadTime = 0; // 只显示飞过的路线
          // pathAttr.trailTime = this.alltimes * 10
        }
        addattr.path = pathAttr;

        // 时间
        const times = this.position?._property?._times;
        if (times && times.length > 0) {
          const start = times[0];
          let stop = times[times.length - 1];
          if (this.property?.forwardExtrapolationType === Cesium__namespace.ExtrapolationType.HOLD) {
            stop = Cesium__namespace.JulianDate.fromDate(new Date(2100, 1, 1));
          }
          addattr.availability = new Cesium__namespace.TimeIntervalCollection([new Cesium__namespace.TimeInterval({ start: start, stop: stop })]);
        }
      }
      // 支持其他附带对象 end

      // 当视角距离超过一定距离后(distanceDisplayCondition_far定义的) 后显示的对象处理
      if (this.style.distanceDisplayCondition) {
        if (this.style.distanceDisplayPoint) {
          addattr.point = PointStyleConver.toCesiumVal(this.style.distanceDisplayPoint);
          addattr.point.distanceDisplayCondition = this._getTargetDistanceDisplayCondition(this.style.distanceDisplayPoint);
        } else if (this.style.distanceDisplayBillboard) {
          addattr.billboard = BillboardStyleConver.toCesiumVal(this.style.distanceDisplayBillboard);
          addattr.billboard.distanceDisplayCondition = this._getTargetDistanceDisplayCondition(this.style.distanceDisplayBillboard);
        }
      }

      // 与mars3d-cesium
      addattr.model.marsOptions = _marsOptions;
      this._entity = this._createEntity(addattr);
    }

    _removedHook() {
      this.rotateStop();

      super._removedHook();
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      const json = ModelStyleConver.toJSON(czmStyle, styleJson, true);

      // 当视角距离超过一定距离后(distanceDisplayCondition_far定义的) 后显示的对象处理
      if (this.style.distanceDisplayPoint) {
        json.distanceDisplayPoint = PointStyleConver.toJSON(this.style.distanceDisplayPoint, {}, true);
      } else if (this.style.distanceDisplayBillboard) {
        json.distanceDisplayBillboard = BillboardStyleConver.toJSON(this.style.distanceDisplayBillboard, {}, true);
      }
      return json
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      this._entity.orientation = this.getOrientation();

      ModelStyleConver.toCesiumVal(style, this.entityGraphic, true);

      // 同时加文字
      if (newStyle?.label) {
        if (Cesium__namespace.defined(style.clampToGround) && !Cesium__namespace.defined(style.label.clampToGround)) {
          newStyle.label.clampToGround = style.clampToGround;
        }
        this._entity.label = this._entity.label || {};
        LabelStyleConver.toCesiumVal(style.label, this._entity.label, this.attr);
      }
    }

    _setOptionsHook(options, newOptions) {
      if (newOptions.billboard) {
        BillboardStyleConver.toCesiumVal(options.billboard, this._entity.billboard, true);
      }
      if (newOptions.point) {
        PointStyleConver.toCesiumVal(options.point, this._entity.point, true);
      }
      if (newOptions.path) {
        PathStyleConver.toCesiumVal(options.path, this._entity.path, true);
      }
      if (newOptions.circle) {
        CircleStyleConver.toCesiumVal(options.circle, this._entity.ellipse, true);
      }
    }

    // 覆盖父类
    _addLabel() {
      this._entity.label = this._entity.label || {};
      LabelStyleConver.toCesiumVal(this.style.label, this._entity.label, this.attr);
    }

    updateAttrForDrawing(isEditing) {}

    // distanceDisplayCondition属性的特殊处理
    _updateDistanceDisplayConditionByEdit() {
      // 覆盖父类的
    }

    // 当视角距离超过一定距离后(distanceDisplayCondition_far定义的) 后显示的对象处理
    // 获取其对应的distanceDisplayCondition属性
    _getTargetDistanceDisplayCondition(pointAttr) {
      let model_far;
      if (this.style.distanceDisplayCondition instanceof Cesium__namespace.DistanceDisplayCondition) {
        model_far = this.style.distanceDisplayCondition.far;
      } else if (this.style.distanceDisplayCondition_far) {
        model_far = this.style.distanceDisplayCondition_far;
      }

      return new Cesium__namespace.DistanceDisplayCondition(
        (pointAttr.distanceDisplayCondition_near, model_far),
        (pointAttr.distanceDisplayCondition_far, Number.MAX_VALUE)
      )
    }

    //= =================常用util方法=================
    /**
     * 获取模型的当前时间的实际hpr角度(如动态模型)
     *
     * @return {Cesium.HeadingPitchRoll} Heading Pitch Roll方向
     */
    getHeadingPitchRoll() {
      const time = this._map.clock.currentTime;
      const position = this.positionShow;
      const orientation = Cesium__namespace.Property.getValueOrUndefined(this._entity.orientation, time, new Cesium__namespace.Quaternion());
      const hpr = getHeadingPitchRollByOrientation(position, orientation);
      return hpr
    }

    /**
     * 开始运行 自旋转动画效果
     *
     * @param {Object} [options={}] 参数包括：
     * @param {Boolean} [options.direction=false] 旋转方向, true逆时针，false顺时针
     * @param {Number} [options.time=60] 飞行一周所需时间(单位 秒)，控制速度
     * @param {Number} [options.autoStopAngle]  自动停止的角度值（0-360度），未设置时不自动停止
     * @return {void}  无
     */
    rotateStart(options = {}) {
      if (this._isRotateStart) {
        this.rotateStop();
      }

      this._rotateDirection = options.direction ? 1 : -1; // 控制方向, true逆时针，false顺时针
      this._rotateAngle = 360 / (60 * (options.time || 60)); // time：给定飞行一周所需时间(单位 秒)，控制速度
      this._rotateAutoStopAngle = options.autoStopAngle; // 自动停止

      this._rotateHpr = this.getHeadingPitchRoll();
      this._startHeading = this._rotateHpr.heading; // 相机的当前heading
      this._tikRender = 0;

      this._isRotateStart = true;

      this.entity.orientation = new Cesium__namespace.CallbackProperty((time) => {
        const position = getPositionValue(this.position, time);
        return Cesium__namespace.Transforms.headingPitchRollQuaternion(position, this._rotateHpr, this._map?.scene?.globe.ellipsoid)
      }, false);

      this._map.on(EventType.preRender, this._rotate_onPreRenderHandler, this);
    }

    _rotate_onPreRenderHandler(e) {
      if (!this._map) {
        return
      }
      this._tikRender++;

      const angle = this._tikRender * this._rotateAngle;
      if (this._rotateAutoStopAngle && angle >= this._rotateAutoStopAngle) {
        this.rotateStop();
      }
      const heading = Cesium__namespace.Math.toRadians(angle * this._rotateDirection) + this._startHeading;
      this._rotateHpr.heading = heading;
    }

    /**
     * 停止运行 自旋转动画效果
     * @return {void}  无
     */
    rotateStop() {
      if (!this._isRotateStart) {
        return
      }
      this._isRotateStart = false;
      this._map.off(EventType.preRender, this._rotate_onPreRenderHandler, this);

      this.heading = Cesium__namespace.Math.toDegrees(this._rotateHpr.heading);

      delete this._rotateDirection;
      delete this._rotateAngle;
      delete this._rotateAutoStopAngle;
      delete this._rotateHpr;
      delete this._startHeading;
      delete this._tikRender;
    }

    /**
     * 动画移动到指定目标位置
     *
     * @param {Object} [options={}] 参数包括：
     * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 指定目标位置的坐标
     * @param {Number} [options.time=5] 移动的时长(单位 秒)，控制速度
     * @param {Function} [options.onEnd]  移动完成的回调方法
     * @return {void}  无
     */
    moveTo(options) {
      const property = new Cesium__namespace.SampledPositionProperty();
      property.forwardExtrapolationType = Cesium__namespace.ExtrapolationType.HOLD;

      const startTime = this._map.clock.currentTime.clone(); // 飞行开始时间

      const pointStart = this.positionShow;
      property.addSample(startTime, pointStart);

      const pointEnd = LngLatPoint.parse(options.position).toCartesian();

      const time = options.time || 5; // 移动的时长(单位 秒)
      const stopTime = Cesium__namespace.JulianDate.addSeconds(startTime, time, new Cesium__namespace.JulianDate()); // 飞行结束时间
      property.addSample(stopTime, pointEnd);

      this._entity.position = property;

      const _bak_multiplier = this._map.clock.multiplier;

      this._map.clock.shouldAnimate = true;
      this._map.clock.multiplier = options.speed || 1; // 飞行速度

      setTimeout(() => {
        if (!this._map) {
          return
        }

        this.position = pointEnd;
        this._map.clock.multiplier = _bak_multiplier;

        if (options.onEnd) {
          options.onEnd();
        }
      }, time * 1000);
    }

    /**
     * 飞行定位至数据所在的视角
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.scale=1.2] 缩放比例，可以根据控制视角比模型大小略大一些，这样效果更友好。
     * @param {Number} options.radius  相机距离目标点的距离（单位：米），与scale二选一
     *
     * @param {Number} [options.minHeight] 定位时相机的最小高度值，用于控制避免异常数据
     * @param {Number} [options.maxHeight] 定位时相机的最大高度值，用于控制避免异常数据
     * @param {Number} [options.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} [options.pitch] 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} [options.roll] 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Cesium.Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     */
    flyTo(options = {}) {
      if (!this._map) {
        return Promise.resolve(false)
      }
      if (!Cesium__namespace.defined(options.radius)) {
        options.radius = this.style.radius * 2 * (options.scale || 1.8);
      }
      return this._map.flyToPoint(this.point, options)
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this.style.globalAlpha = value;
      if (this._entity) {
        ModelStyleConver.setOpacity(this.entityGraphic, value);
        this._updateLabelOpacity(value);
      }
    }
  }
  // 注册下
  register$4("model", ModelEntity);

  /**
   * BoxEntity对象，标绘处理对应的编辑类
   *
   * @export
   * @class EditBox
   * @extends {EditBase}
   */
  class EditBox extends EditBase {
    /**
     * 位置坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     */
    get position() {
      return this._graphic._position_draw
    }

    set position(value) {
      this._graphic._position_draw = value;
    }

    bindDraggers() {
      const style = this.style;

      let dragger;

      // 位置中心点
      const positionZXD = this.position;
      dragger = this.createDragger({
        position: positionZXD,
        onDrag: (dragger, position) => {
          // 记录差值
          const diff = Cesium__namespace.Cartesian3.subtract(position, this.position, new Cesium__namespace.Cartesian3());
          this.position = position;

          for (let i = 0, len = this.draggers.length; i < len; i++) {
            if (this.draggers[i] === dragger) {
              continue
            }
            this.draggers[i].position = Cesium__namespace.Cartesian3.add(this.draggers[i].position, diff, new Cesium__namespace.Cartesian3());
          }
        }
      });
      this.draggers.push(dragger);

      // 方向
      const heading = Cesium__namespace.Math.toRadians(this._graphic.heading);
      const pitch = Cesium__namespace.Math.toRadians(this._graphic.pitch);
      const roll = Cesium__namespace.Math.toRadians(this._graphic.roll);
      const hpr = new Cesium__namespace.HeadingPitchRoll(heading, pitch, roll);

      // x长度调整
      const positionX = getPositionByHprAndOffset(positionZXD, new Cesium__namespace.Cartesian3(style.dimensions_x / 2, 0, 0), hpr);
      dragger = this.createDragger({
        position: positionX,
        type: PointType.EditAttr,
        tooltip: this._map.getLangText("_修改长度"),
        onDrag: (dragger, position) => {
          const newHeight = Cesium__namespace.Cartographic.fromCartesian(this.position).height;
          position = setPositionsHeight(position, newHeight);
          dragger.position = position;

          const radius = this.formatNum(Cesium__namespace.Cartesian3.distance(this.position, position), 2);
          style.dimensions_x = radius * 2;

          this.updateBox(style);
          this.fire(EventType.editStyle);
        },
        onDragEnd: (dragger, position) => {
          this.updateDraggers();
        }
      });
      this.draggers.push(dragger);

      // y宽度调整
      const positionY = getPositionByHprAndOffset(positionZXD, new Cesium__namespace.Cartesian3(0, style.dimensions_y / 2, 0), hpr);
      dragger = this.createDragger({
        position: positionY,
        type: PointType.EditAttr,
        tooltip: this._map.getLangText("_修改宽度"),
        onDrag: (dragger, position) => {
          const newHeight = Cesium__namespace.Cartographic.fromCartesian(positionZXD).height;
          position = setPositionsHeight(position, newHeight);
          dragger.position = position;

          const radius = this.formatNum(Cesium__namespace.Cartesian3.distance(this.position, position), 2);
          style.dimensions_y = radius * 2;

          this.updateBox(style);
          this.fire(EventType.editStyle);
        },
        onDragEnd: (dragger, position) => {
          this.updateDraggers();
        }
      });
      this.draggers.push(dragger);

      // z高度调整
      const positionZ = getPositionByHprAndOffset(positionZXD, new Cesium__namespace.Cartesian3(0, 0, style.dimensions_z / 2), hpr);
      dragger = this.createDragger({
        position: positionZ,
        type: PointType.MoveHeight,
        tooltip: this._map.getLangText("_修改高度"),
        onDrag: (dragger, position) => {
          const radius = this.formatNum(Cesium__namespace.Cartesian3.distance(this.position, position), 2);
          style.dimensions_z = radius * 2;

          this.updateBox(style);
          this.fire(EventType.editStyle);
        },
        onDragEnd: (dragger, position) => {
          this.updateDraggers();
        }
      });
      this.draggers.push(dragger);
    }

    updateBox(style) {
      const dimensions = new Cesium__namespace.Cartesian3(style.dimensions_x, style.dimensions_y, style.dimensions_z);
      this.entityGraphic.dimensions.setValue(dimensions);
    }

    _updateStyleHook(newStyle) {
      super._updateStyleHook(newStyle);
      if (Cesium__namespace.defined(newStyle.dimensions_x) || Cesium__namespace.defined(newStyle.dimensions_y) || Cesium__namespace.defined(newStyle.dimensions_z)) {
        this.updateDraggers();
      }
    }
  }

  /**
   * 盒子 支持的样式信息
   *
   * @typedef {Object} BoxEntity.StyleOptions
   *
   * @property {Cesium.Cartesian3|Cesium.Property} [dimensions] 指定盒子的长度、宽度和高度。
   * @property {Number} [dimensions_x = 100] 盒子长度
   * @property {Number} [dimensions_y = 100] 盒子宽度
   * @property {Number} [dimensions_z = 100] 盒子高度
   *
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   *
   * @property {Boolean} [fill = true] 是否填充
   * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
   * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String} [outlineWidth = 1.0] 边框宽度
   * @property {String|Cesium.Color} [outlineColor = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [hasShadows = false] 是否投射阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 是投射还是接收来自光源的阴影。
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定从实体位置到它的相对高度。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {BoxEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see Cesium.BoxGraphics.ConstructorOptions
   */

  /**
   * 盒子  Entity对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {BoxEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.Property} [options.orientation] 实体方向
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BoxEntity extends BasePointEntity {
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.BoxGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.box
    }

    /**
     * 编辑处理类
     * @type {EditBox}
     * @readonly
     */
    get EditClass() {
      return EditBox
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      const addattr = {
        position: this.position,
        orientation: this.getOrientation(),
        box: BoxStyleConver.toCesiumVal(this.style, {}, true)
      };
      this._entity = this._createEntity(addattr);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return BoxStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      if (newStyle && (Cesium__namespace.defined(newStyle.heading) || Cesium__namespace.defined(newStyle.pitch) || Cesium__namespace.defined(newStyle.roll))) {
        this._entity.orientation = this.getOrientation();
      }
      BoxStyleConver.toCesiumVal(style, this.entityGraphic, true);
    }

    _setPositionsToCallback() {
      super._setPositionsToCallback();

      const dimensions = getCesiumValue(this.entityGraphic.dimensions, Number, this._map.clock.currentTime);
      this.style.dimensions_x = this.style.dimensions_x ?? dimensions.x;
      this.style.dimensions_y = this.style.dimensions_y ?? dimensions.y;
      this.style.dimensions_z = this.style.dimensions_z ?? dimensions.z;
    }
  }

  // 注册下
  register$4("box", BoxEntity);

  /**
   * Plane对象 标绘处理对应的编辑类
   *
   * @export
   * @class EditPlane
   * @extends {EditBase}
   */
  class EditPlane extends EditBase {
    get position() {
      return this._graphic._position_draw
    }

    set position(value) {
      this._graphic._position_draw = value;
    }

    bindDraggers() {
      const style = this.style;
      let dragger;

      // 位置中心点
      const positionZXD = this.position;
      dragger = this.createDragger({
        position: positionZXD,
        onDrag: (dragger, position) => {
          // 记录差值
          const diff = Cesium__namespace.Cartesian3.subtract(position, this.position, new Cesium__namespace.Cartesian3());
          this.position = position;

          for (let i = 0, len = this.draggers.length; i < len; i++) {
            if (this.draggers[i] === dragger) {
              continue
            }
            this.draggers[i].position = Cesium__namespace.Cartesian3.add(this.draggers[i].position, diff, new Cesium__namespace.Cartesian3());
          }
        }
      });
      this.draggers.push(dragger);

      // 方向
      const heading = Cesium__namespace.Math.toRadians(this._graphic.heading);
      const pitch = Cesium__namespace.Math.toRadians(this._graphic.pitch);
      const roll = Cesium__namespace.Math.toRadians(this._graphic.roll);
      const hpr = new Cesium__namespace.HeadingPitchRoll(heading, pitch, roll);

      // 平面的x长度调整
      const offest = new Cesium__namespace.Cartesian3();
      switch (style.plane_normal) {
        case "x":
          offest.y = style.dimensions_x / 2;
          break
        default:
          offest.x = style.dimensions_x / 2;
          break
      }

      dragger = this.createDragger({
        position: getPositionByHprAndOffset(positionZXD, offest, hpr),
        type: PointType.EditAttr,
        tooltip: this._map.getLangText("_修改长度"),
        onDrag: (dragger, position) => {
          const newHeight = Cesium__namespace.Cartographic.fromCartesian(this.position).height;
          position = setPositionsHeight(position, newHeight);
          dragger.position = position;

          const radius = this.formatNum(Cesium__namespace.Cartesian3.distance(this.position, position), 2);
          style.dimensions_x = radius * 2;

          this.updatePlane(style);
        },
        onDragEnd: (dragger, position) => {
          this.updateDraggers();
        }
      });
      this.draggers.push(dragger);

      // 平面的y宽度调整
      if (style.plane_normal === "z") {
        dragger = this.createDragger({
          position: getPositionByHprAndOffset(positionZXD, new Cesium__namespace.Cartesian3(0, style.dimensions_y / 2, 0), hpr),
          type: PointType.EditAttr,
          tooltip: this._map.getLangText("_修改宽度"),
          onDrag: (dragger, position) => {
            const newHeight = Cesium__namespace.Cartographic.fromCartesian(this.position).height;
            position = setPositionsHeight(position, newHeight);
            dragger.position = position;

            const radius = this.formatNum(Cesium__namespace.Cartesian3.distance(this.position, position), 2);
            style.dimensions_y = radius * 2;

            this.updatePlane(style);
          },
          onDragEnd: (dragger, position) => {
            this.updateDraggers();
          }
        });
        this.draggers.push(dragger);
      } else {
        const offestTop = { x: 0, y: 0, z: 0 };
        switch (style.plane_normal) {
          case "x":
          case "y":
            offestTop.z = style.dimensions_y / 2;
            break
          default:
            offestTop.y = style.dimensions_y / 2;
            break
        }
        // 顶部的 高半径 编辑点
        dragger = this.createDragger({
          position: getPositionByHprAndOffset(positionZXD, offestTop, hpr),
          type: PointType.MoveHeight,
          tooltip: this._map.getLangText("_修改宽度"),
          onDrag: (dragger, position) => {
            const radius = this.formatNum(Cesium__namespace.Cartesian3.distance(this.position, position), 2);
            style.dimensions_y = radius * 2;

            this.updatePlane(style);
          },
          onDragEnd: (dragger, position) => {
            this.updateDraggers();
          }
        });
        this.draggers.push(dragger);
      }
    }

    updatePlane(style) {
      const dimensions = new Cesium__namespace.Cartesian2(style.dimensions_x, style.dimensions_y);
      this.entityGraphic.dimensions.setValue(dimensions);

      this.fire(EventType.editStyle);
    }

    _updateStyleHook(newStyle) {
      super._updateStyleHook(newStyle);
      if (Cesium__namespace.defined(newStyle.dimensions_x) || Cesium__namespace.defined(newStyle.dimensions_y)) {
        this.updateDraggers();
      }
    }
  }

  /**
   * 平面 支持的样式信息
   *
   * @typedef {Object} PlaneEntity.StyleOptions
   *
   * @property {Cesium.Cartesian2} [dimensions] 指定平面的宽度和高度。
   * @property {Number} [dimensions_x = 100] 长度
   * @property {Number} [dimensions_y = 100] 宽度
   * @property {Cesium.Plane} [plane] 指定平面的法线和距离。
   * @property {String|Cesium.Cartesian3} [plane_normal = "z"] 方向 ,可选项：x (解释：X轴),y (解释：Y轴),z (解释：Z轴),
   * @property {Number} [plane_distance = 0] 偏移距离
   *
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   *
   * @property {Boolean} [fill = true] 是否填充

   * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {Boolean} [randomColor = false] 是否随机颜色
   * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String} [outlineWidth = 1] 边框宽度
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定平面是投射还是接收来自光源的阴影。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {PlaneEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see Cesium.PlaneGraphics.ConstructorOptions
   */

  /**
   * 平面  Entity对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {PlaneEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.Property} [options.orientation] 实体方向
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PlaneEntity extends BasePointEntity {
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.PlaneGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.plane
    }

    /**
     * 编辑处理类
     * @type {EditPlane}
     * @readonly
     */
    get EditClass() {
      return EditPlane
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      const addattr = {
        position: this.position,
        orientation: this.getOrientation(),
        plane: PlaneStyleConver.toCesiumVal(this.style, {}, true)
      };
      this._entity = this._createEntity(addattr);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PlaneStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      if (newStyle && (Cesium__namespace.defined(newStyle.heading) || Cesium__namespace.defined(newStyle.pitch) || Cesium__namespace.defined(newStyle.roll))) {
        this._entity.orientation = this.getOrientation();
      }
      PlaneStyleConver.toCesiumVal(style, this.entityGraphic, true);
    }

    _setPositionsToCallback() {
      super._setPositionsToCallback();

      const dimensions = getCesiumValue(this.entityGraphic.dimensions, Cesium__namespace.Cartesian2, this._map.clock.currentTime);
      if (dimensions) {
        PlaneStyleConver.toOneJson("dimensions", dimensions, this.style);
      }

      const plane = getCesiumValue(this.entityGraphic.plane, Cesium__namespace.Plane, this._map.clock.currentTime);
      if (plane) {
        PlaneStyleConver.toOneJson("plane", plane, this.style);
      }
    }
  }
  // 注册下
  register$4("plane", PlaneEntity);

  /**
   * Circle对象 标绘处理对应的编辑类
   *
   * @export
   * @class EditCircle
   * @extends {EditPoly}
   */
  class EditCircle extends EditPoly {
    bindDraggers() {
      const positions = this.positions;
      // 中心点
      const position = this.updatePositionsHeightByAttr(positions[0]);
      const time = this._map.clock.currentTime;

      // 获取圆（或椭圆）边线上的坐标点数组
      const outerPositions = getEllipseOuterPositions({
        position: position,
        semiMajorAxis: getCesiumValue(this.entityGraphic.semiMajorAxis, Number, time), // 长半轴
        semiMinorAxis: getCesiumValue(this.entityGraphic.semiMinorAxis, Number, time), // 短半轴
        rotation: getCesiumValue(this.entityGraphic.rotation, Number, time) ?? 0,
        count: 1
      });

      // 长半轴上的坐标点
      const majorPos = this.updatePositionsHeightByAttr(outerPositions[1]);
      positions[1] = majorPos;
      const majorDragger = this.createDragger({
        position: majorPos,
        type: PointType.EditAttr,
        tooltip: this._map.getLangText("_修改半径"),
        onDragStart: (dragger, position) => {
          if (!this._heightDraggers) {
            return
          }
          for (let i = 0, len = this._heightDraggers.length; i < len; i++) {
            this._heightDraggers[i].show = false;
          }
        },
        onDrag: (dragger, position) => {
          if (this.entityGraphic.height !== undefined) {
            const newHeight = getCesiumValue(this.entityGraphic.height, Number, time);
            position = setPositionsHeight(position, newHeight);
            dragger.position = position;
          }
          positions[dragger.index] = position;

          const radius = this.formatNum(Cesium__namespace.Cartesian3.distance(positions[0], position), 2);
          this.entityGraphic.semiMajorAxis = radius;

          if (this._graphic._maxPointNum === 3 || !Cesium__namespace.defined(this.style.radius)) {
            // 椭圆
            this.style.semiMajorAxis = radius;
          } else {
            // 圆
            this.entityGraphic.semiMinorAxis = radius;
            this.style.radius = radius;
          }
          this.fire(EventType.editStyle);
        },
        onDragEnd: (dragger, position) => {
          this.updateDraggers();
        }
      });
      majorDragger.index = 1;
      this.draggers.push(majorDragger);

      // 短半轴上的坐标点
      let minorDragger;
      if (this._graphic._maxPointNum === 3) {
        // 椭圆
        // 短半轴上的坐标点
        const minorPos = this.updatePositionsHeightByAttr(outerPositions[0]);

        positions[2] = minorPos;
        minorDragger = this.createDragger({
          position: minorPos,
          type: PointType.EditAttr,
          tooltip: this._map.getLangText("_修改半径"),
          onDragStart: (dragger, position) => {
            if (!this._heightDraggers) {
              return
            }
            for (let i = 0, len = this._heightDraggers.length; i < len; i++) {
              this._heightDraggers[i].show = false;
            }
          },
          onDrag: (dragger, position) => {
            if (this.entityGraphic.height !== undefined) {
              const newHeight = getCesiumValue(this.entityGraphic.height, Number, time);
              position = setPositionsHeight(position, newHeight);
              dragger.position = position;
            }
            positions[dragger.index] = position;

            let semiMinorAxis = this.formatNum(Cesium__namespace.Cartesian3.distance(positions[0], position), 2);
            const semiMajorAxis = getCesiumValue(this.entityGraphic.semiMajorAxis, Number, time); // 长半轴
            if (semiMinorAxis > semiMajorAxis) {
              semiMinorAxis = semiMajorAxis;
            }
            this.entityGraphic.semiMinorAxis = semiMinorAxis;

            if (this._graphic._maxPointNum === 3 || !Cesium__namespace.defined(this.style.radius)) {
              // 椭圆
              this.style.semiMinorAxis = semiMinorAxis;
            } else {
              // 圆
              this.entityGraphic.semiMajorAxis = semiMinorAxis;
              this.style.radius = semiMinorAxis;
            }
            this.fire(EventType.editStyle);
          },
          onDragEnd: (dragger, position) => {
            this.updateDraggers();
          }
        });
        minorDragger.index = 2;
        this.draggers.push(minorDragger);
      }

      if (this._graphic._hasMoveEdit) {
        const dragger = this.createDragger({
          position: position,
          onDragStart: (dragger, position) => {
            for (let i = 0, len = this.draggers.length; i < len; i++) {
              this.draggers[i].show = false;
            }
          },
          onDrag: (dragger, position) => {
            positions[0] = position;
          },
          onDragEnd: (dragger, position) => {
            this.updateDraggers();
          }
        });
        dragger.index = 0;
        this.draggers.push(dragger);

        dragger.majorDragger = majorDragger;
        dragger.minorDragger = minorDragger;
      }

      // 创建高度拖拽点
      if (this.entityGraphic.extrudedHeight) {
        const _pos = this._graphic._maxPointNum === 3 ? [positions[1], positions[2]] : [positions[1]];
        this._bindHeightDraggers(_pos);
      }
    }

    // 根据属性更新坐标
    updatePositionsHeightByAttr(position) {
      if (this.clampToGround) {
        // 贴地时求贴模型和贴地的高度
        position = getSurfacePosition(this._map.scene, position);
      }
      if (this.entityGraphic.height !== undefined) {
        const newHeight = getCesiumValue(this.entityGraphic.height, Number, this._map.clock.currentTime);
        position = setPositionsHeight(position, newHeight);
      }
      return position
    }

    _updateStyleHook(newStyle) {
      super._updateStyleHook(newStyle);
      if (
        Cesium__namespace.defined(newStyle.radius) ||
        Cesium__namespace.defined(newStyle.semiMinorAxis) ||
        Cesium__namespace.defined(newStyle.semiMajorAxis) ||
        Cesium__namespace.defined(newStyle.height) ||
        Cesium__namespace.defined(newStyle.diffHeight)
      ) {
        this.updateDraggers();
      }
    }

    openSmallTooltipByMinPointNum(position) {
      // 覆盖父类
    }
  }

  /**
   * 圆、圆柱 支持的样式信息
   *
   * @typedef {Object} CircleEntity.StyleOptions
   *
   * @property {Number} [radius = 100] 半径
   *
   * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   * @property {Number} [diffHeight = 100] 高度差（圆柱本身的高度），与extrudedHeight二选一。
   * @property {number} [extrudedHeight] 指定椭圆的挤压面相对于椭球面的高度。
   * @property {Cesium.HeightReference} [extrudedHeightReference=Cesium.HeightReference.NONE] 指定挤压高度相对于什么的属性。
   *
   * @property {Boolean} [fill = true] 是否填充
   * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
   * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`material材质参数`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#3388ff"] 填充颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {Number} [outlineWidth = 1] 边框宽度
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   * @property {PolylineEntity.StyleOptions} [outlineStyle] 边框的完整自定义样式，会覆盖outlineWidth、outlineColor等参数。
   *
   * @property {Number|Cesium.Property} [rotation = 0] 旋转角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [rotationDegree = 0] 旋转角度（度数值，0-360度），与rotation二选一
   * @property {Number|Cesium.Property} [stRotation = 0] 椭圆纹理的角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [stRotationDegree = 0] 椭圆纹理的角度（度数值，0-360度），与stRotation二选一
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定椭圆上各点之间的角距离。
   * @property {number} [numberOfVerticalLines=16] 指定沿轮廓的周长绘制的垂直线的数量。
   *
   * @property {Boolean} [hasShadows = false] 是否投射阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定椭圆是投射还是接收来自光源的阴影。
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
   * @property {Number} [zIndex = 0] 层级顺序。用于排序地面几何。只有在椭圆为常量且没有指定height或exturdedHeight时才有效果。
   *
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {CircleEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see Cesium.EllipseGraphics.ConstructorOptions
   */

  /**
   * 圆、圆柱  Entity对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {CircleEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShowRadius=true] 绘制时，是否显示圆的半径。
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class CircleEntity
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class CircleEntity extends BasePointEntity {
    constructor(options = {}) {
      super(options);

      // 配置的参数
      this._minPointNum = 2; // 至少需要点的个数
      this._maxPointNum = 2; // 最多允许点的个数
      this._hasMoveEdit = options.hasMoveEdit ?? true; // 是否可以整体平移

      this.options.drawShowRadius = this.options.drawShowRadius ?? true;
    }

    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.EllipseGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.ellipse
    }

    /**
     * 编辑处理类
     * @type {EditCircle}
     * @readonly
     */
    get EditClass() {
      return EditCircle
    }

    /**
     * 圆的边线坐标集合（笛卡尔坐标）
     * @type {Cesium.Cartesian3[]}
     */
    get outlinePositions() {
      if (this._entity) {
        this._outlinePositions = this.getOutlinePositions();
      }
      return this._outlinePositions
    }

    set outlinePositions(value) {
      this._outlinePositions = value;
    }

    /**
     * 圆的边线坐标集合（经纬度二维数组），示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7], …… ]
     * @type {Array[]}
     * @readonly
     */
    get outlineCoordinates() {
      return cartesians2lonlats(this.outlinePositions)
    }

    // 距离长度（单位：米）
    get distance() {
      return Math.PI * 2 * this.radius
    }

    // 面积（单位：平方米）
    get area() {
      const radius = this.radius;
      return Math.PI * radius * radius
    }

    /**
     * 圆的半径（单位：米）
     * @type {Number}
     */
    get radius() {
      if (this.style.radius) {
        return this.style.radius
      }
      return getCesiumValue(this.entityGraphic?.semiMajorAxis, Number, Cesium__namespace.JulianDate.now()) // 长半轴
    }

    set radius(value) {
      this.style.radius = value;
      if (this.entityGraphic) {
        this.entityGraphic.semiMajorAxis = value;
        this.entityGraphic.semiMinorAxis = value;

        // 更改了坐标
        this._updateOutlineStyle(this._getOutlinePositions(), this.style); // 边线
      }
    }

    /**
     * 高度（单位：米）
     * @type {Number}
     */
    get height() {
      if (this.style.height) {
        return this.style.height
      }
      return getCesiumValue(this.entityGraphic?.height, Number) ?? 0
    }

    set height(value) {
      this.style.height = value;
      if (this.entityGraphic) {
        this.entityGraphic.height = value;
      }
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      const addattr = {
        position: this.position,
        ellipse: CircleStyleConver.toCesiumVal(this.style, {}, true)
      };
      this._entity = this._createEntity(addattr);

      this._updateHeight();

      this._updateOutlineStyle(this._getOutlinePositions(), this.style); // 边线

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return CircleStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 将矢量数据导出为GeoJSON格式规范对象。
     * @param {Object} [options] 参数对象:
     * @param {Boolean} [options.outline] 是否导出边线的坐标
     * @param {Boolean} [options.closure] 导出outline时，是否闭合，true时会添加第0个点进行闭合。
     * @param {Boolean} [options.count] 导出outline时，点的数量，返回的总数为 count*4
     * @param {Boolean} [options.noAlt] 不导出高度值
     * @return {Object} GeoJSON格式规范对象
     */
    toGeoJSON(options) {
      return super.toGeoJSON(options)
    }

    _getGeoJsonGeometry(options) {
      if (options?.outline) {
        return { type: "Polygon", coordinates: [this.getOutlineCoordinates(options?.closure, options?.count, options?.noAlt)] }
      } else {
        return { type: "Point", coordinates: this.getCoordinate(options?.noAlt) }
      }
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      CircleStyleConver.toCesiumVal(style, this.entityGraphic, true);

      if (Cesium__namespace.defined(newStyle.diffHeight) || Cesium__namespace.defined(newStyle.height)) {
        this._updateHeight();
      }
    }

    _updatePositionsHook() {
      this._entity.position = this.position;

      this._updateHeight();

      // 更改了坐标
      this._updateOutlineStyle(this._getOutlinePositions(), this.style); // 边线
      this._updateLabelPosition();

      this._updateEditDraggers();
    }

    _getOutlinePositions() {
      return [this.outlinePositions]
    }

    //= =================Draw绘制相关=================
    // 将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑
    _setPositionsToCallback() {
      if (this._isCallbackPositions) {
        return
      }
      this._isCallbackPositions = true;

      this._positions_draw = this.positions || [];
      this.position = new Cesium__namespace.CallbackProperty((time) => {
        if (this._positions_draw.length < 1) {
          return null
        }
        return this._positions_draw[0]
      }, false);

      this._updateOutlineToCallback();
    }

    // 坐标CallbackProperty属性改为实际值
    _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return
      }
      this._isCallbackPositions = false;
      this._position = this._positions_draw[0];
      this._point = LngLatPoint.fromCartesian(this._position);
      this._updatePositionsHook();
    }

    // 高度处理
    _updateHeight() {
      if (this.style.clampToGround) {
        return
      }

      let position = this._position;
      if (this._positions_draw?.length > 0) {
        position = this._positions_draw[0];
      }

      if (!position) {
        return
      }

      const height = LngLatPoint.fromCartesian(position).alt;

      this.entityGraphic.height = height;
      this.style.height = height;

      // 存在extrudedHeight高度设置时
      if (Cesium__namespace.defined(this.style.diffHeight)) {
        if (Cesium__namespace.defined(this.style.diffHeight) && this.style.diffHeight !== 0) {
          this.entityGraphic.extrudedHeight = height + this.style.diffHeight;
        } else {
          this.entityGraphic.extrudedHeight = undefined;
        }
      }

      this.fire(EventType.editStyle);
    }

    //= =================Draw绘制相关=================

    _startDrawHook() {
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);
      this._map.on(EventType.click, this._onClickHandler, this);
      this._map.on(EventType.rightClick, this._onRightClickHandler, this);
      this._map.on(EventType.dblClick, this._onDbClickHandler, this);
    }

    _stopDrawHook() {
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);
      this._map.off(EventType.click, this._onClickHandler, this);
      this._map.off(EventType.rightClick, this._onRightClickHandler, this);
      this._map.off(EventType.dblClick, this._onDbClickHandler, this);
    }

    _showDrawMouseMoveSmallTooltip(event) {
      if (this._positions_draw.length <= 1) {
        this._map.openSmallTooltip(event.endPosition, this._map.getLangText("_单击开始绘制"));
        return
      }
      let disableStr = "";
      if (this.options.drawShowRadius && this._positions_draw.length > 0 && event.cartesian) {
        const distance = Cesium__namespace.Cartesian3.distance(this._positions_draw[0], event.cartesian);
        if (distance > 0) {
          disableStr = `半径：${formatDistance(distance)}<br />`;
        }
      }
      this._map.openSmallTooltip(event.endPosition, disableStr + this._map.getLangText("_单击完成绘制"));
    }

    updateAttrForDrawing(isEditing) {
      if (this._positions_draw.length < 2) {
        return
      }

      // 高度处理
      this._updateHeight();

      // 编辑时无需更新半径
      if (!isEditing) {
        // 半径处理
        const radius = formatNum$1(Cesium__namespace.Cartesian3.distance(this._positions_draw[0], this._positions_draw[1]), 2);
        if (radius < 1) {
          return
        }
        if (this._maxPointNum === 3) {
          let semiMinorAxis = radius; // 短半轴
          let semiMajorAxis = radius; // 长半轴
          if (this._positions_draw.length === 3) {
            semiMajorAxis = formatNum$1(Cesium__namespace.Cartesian3.distance(this._positions_draw[0], this._positions_draw[2]), 2);
          }
          if (semiMinorAxis > semiMajorAxis) {
            // semiMajorAxis must be greater than or equal to the semiMinorAxis. 所以交换下
            const temp = semiMinorAxis;
            semiMinorAxis = semiMajorAxis;
            semiMajorAxis = temp;
          }

          this.entityGraphic.semiMajorAxis = semiMajorAxis;
          this.entityGraphic.semiMinorAxis = semiMinorAxis;

          this.style.semiMajorAxis = semiMajorAxis;
          this.style.semiMinorAxis = semiMinorAxis;
        } else {
          this.entityGraphic.semiMajorAxis = radius; // 长半轴
          this.entityGraphic.semiMinorAxis = radius; // 短半轴

          this.style.radius = radius;
        }
      }

      if (this._entity_outlines) {
        this._outlinePositions = this.getOutlinePositions();
        this._updateOutlineToCallback();
      }
    }

    _onRightClickHandler(event) {
      super._onRightClickHandler(event);

      this.entityGraphic.semiMajorAxis = 0; // 长半轴
      this.entityGraphic.semiMinorAxis = 0; // 短半轴
      this.style.radius = 0;
    }

    //= =================其他方法=================

    /**
     * 获取圆的边线坐标集合（笛卡尔坐标）
     *
     * @param {Boolean} [closure=true] 是否闭合，true时会添加第0个点进行闭合。
     * @param {Number} [count] 象限内点的数量，返回的总数为 count*4
     * @return  {Cesium.Cartesian3[]} 边线坐标数组
     */
    getOutlinePositions(closure = true, count) {
      const time = Cesium__namespace.JulianDate.now();

      // 获取圆（或椭圆）边线上的坐标点数组
      const outerPositions = getEllipseOuterPositions({
        position: getPositionValue(this._entity.position),
        semiMajorAxis: getCesiumValue(this._entity.ellipse?.semiMajorAxis, Number, time), // 长半轴
        semiMinorAxis: getCesiumValue(this._entity.ellipse?.semiMinorAxis, Number, time), // 短半轴
        rotation: getCesiumValue(this._entity.ellipse?.rotation, Number, time) ?? 0,
        granularity: getCesiumValue(this._entity.ellipse?.granularity, Number, time),
        count: count // 共返回count*4个点
      });

      if (closure && outerPositions) {
        outerPositions.push(outerPositions[0]);
      }
      return outerPositions
    }

    /**
     *  获取圆的边线坐标集合（经纬度二维数组）
     *
     * @param {Boolean} [closure=true] 是否闭合，true时会添加第0个点进行闭合。
     * @param {Number} [count=90] 象限内点的数量，返回的总数为 count*4
     * @param {Boolean} [noAlt] 是否包含高度值
     * @return  {Array[]} 边线坐标数组（经纬度二维数组）
     */
    getOutlineCoordinates(closure, count, noAlt) {
      return cartesians2lonlats(this.getOutlinePositions(closure, count), noAlt)
    }

    _getOutlineStyle(style, exStyle) {
      const outlineStyle = super._getOutlineStyle(style, exStyle);
      outlineStyle.arcType = Cesium__namespace.ArcType.RHUMB;
      return outlineStyle
    }

    /**
     * 获取数据的矩形边界
     * @param {Boolean} [options] 控制参数
     * @param {Boolean} [options.isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */
    getRectangle(options) {
      const positions = this.getOutlinePositions(false, 1);
      if (!positions || positions.length === 0) {
        return
      }

      const extent = getRectangle(positions, options?.isFormat);
      return extent
    }

    /**
     * 判断点是否在圆内
     *
     * @param {Cesium.Cartesian3|LngLatPoint} position 需要判断的点
     * @return {Boolean} 是否在圆内
     */
    isInPoly(position) {
      position = LngLatPoint.parse(position).toCartesian();

      position = setPositionsHeight(position, this.height);
      const len = Cesium__namespace.Cartesian3.distance(this.positionShow, position);
      return len <= this.radius // 小于半径的说明在圆内
    }

    // 定位至数据区域
    flyTo(options = {}) {
      if (!this._map) {
        return Promise.resolve(false)
      }
      options.radius = this.radius * 2 * (options.scale || 1.8);
      return this._map.flyToPoint(this.point, options)
    }
  }

  // 注册下
  register$4("circle", CircleEntity);

  /**
   * Cylinder对象 标绘处理对应的编辑类
   *
   * @export
   * @class EditCylinder
   * @extends {EditPoly}
   */
  class EditCylinder extends EditPoly {
    bindDraggers() {
      const positions = this.positions;

      const center = positions[0];

      // 中心点
      let index = 0;
      const dragger = this.createDragger({
        position: center,
        onDragStart: (dragger, position) => {
          for (let i = 0, len = this.draggers.length; i < len; i++) {
            this.draggers[i].show = false;
          }
        },
        onDrag: (dragger, position) => {
          positions[0] = position;
        },
        onDragEnd: (dragger, position) => {
          this.updateDraggers();
        }
      });
      dragger.index = index;
      this.draggers.push(dragger);

      // 获取圆（或椭圆）边线上的坐标点数组
      const outerPositions = getEllipseOuterPositions({
        position: center,
        semiMajorAxis: this.style.bottomRadius, // 长半轴
        semiMinorAxis: this.style.bottomRadius, // 短半轴
        rotation: Cesium__namespace.Math.toRadians(Number(this.style.rotation || 0))
      });

      // 底部半径 拖拽点
      index = 1;
      const majorPos = outerPositions[0];
      positions[index] = majorPos;
      const bottomRadiusDragger = this.createDragger({
        position: majorPos,
        type: PointType.EditAttr,
        tooltip: this._map.getLangText("_修改半径"),
        onDrag: (dragger, position) => {
          positions[1] = position;

          const radius = this.formatNum(Cesium__namespace.Cartesian3.distance(positions[0], position), 2);
          this.style.bottomRadius = radius;
          this.fire(EventType.editStyle);
        },
        onDragEnd: (dragger, position) => {
          this.updateDraggers();
        }
      });
      bottomRadiusDragger.index = index;
      this.draggers.push(bottomRadiusDragger);

      // 高度 拖拽点
      index = 2;
      const positionTop = addPositionsHeight(center, this.style.length);
      positions[index] = positionTop;
      const draggerTop = this.createDragger({
        position: positionTop,
        type: PointType.MoveHeight,
        tooltip: this._map.getLangText("_修改高度"),
        onDrag: (dragger, position) => {
          positions[dragger.index] = position;
          const length = this.formatNum(Cesium__namespace.Cartesian3.distance(positions[0], position), 2);
          this.style.length = length;
          this.fire(EventType.editStyle);
        },
        onDragEnd: (dragger, position) => {
          this.updateDraggers();
        }
      });
      draggerTop.index = index;
      this.draggers.push(draggerTop);
    }

    _updateStyleHook(newStyle) {
      super._updateStyleHook(newStyle);
      if (
        Cesium__namespace.defined(newStyle.topRadius) ||
        Cesium__namespace.defined(newStyle.bottomRadius) ||
        Cesium__namespace.defined(newStyle.length) ||
        Cesium__namespace.defined(newStyle.diffHeight)
      ) {
        this.updateDraggers();
      }
    }
  }

  /**
   * 圆锥 支持的样式信息
   *
   * @typedef {Object} CylinderEntity.StyleOptions
   *
   * @property {Number} [topRadius = 0] 顶部半径，指定圆柱体顶部的半径，当为0时即为圆锥。
   * @property {Number} [bottomRadius = 100] 底部半径，指定圆柱体底部半径。
   * @property {Number} [length = 100] 高度，柱面长度。
   *
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   *
   * @property {Boolean} [fill = true] 是否填充
   * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#00FF00"] 填充颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String} [outlineWidth = 1] 边框宽度
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {number} [numberOfVerticalLines=16] 指定沿轮廓的周长绘制的垂直线的数量。
   * @property {number} [slices=128] 圆柱体周长周围的边数。
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定圆柱是投射还是接收来自光源的阴影。
   *
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定从实体位置到它的相对高度。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {CylinderEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   *  @see Cesium.CylinderGraphics.ConstructorOptions
   */

  /**
   * 圆锥  Entity对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {CylinderEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.Property} [options.orientation] 实体方向
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class CylinderEntity
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class CylinderEntity extends BasePointEntity {
    constructor(options = {}) {
      super(options);

      // 配置的参数
      this._minPointNum = 2; // 至少需要点的个数
      this._maxPointNum = 2; // 最多允许点的个数
    }

    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.CylinderGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.cylinder
    }

    /**
     * 编辑处理类
     * @type {EditCylinder}
     * @readonly
     */
    get EditClass() {
      return EditCylinder
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._entity = this._createEntity(this._getCreateEntityAttr());

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    _getCreateEntityAttr() {
      const addattr = {
        position: this.position,
        orientation: this.getOrientation(),
        cylinder: CylinderStyleConver.toCesiumVal(this.style, {}, true)
      };
      return addattr
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return CylinderStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      CylinderStyleConver.toCesiumVal(style, this.entityGraphic, {}, true);

      if (Cesium__namespace.defined(newStyle.heading) || Cesium__namespace.defined(newStyle.pitch) || Cesium__namespace.defined(newStyle.roll)) {
        this._entity.orientation = this.getOrientation();
      }
      if (Cesium__namespace.defined(newStyle.length) || Cesium__namespace.defined(newStyle.diffHeight)) {
        if (this._positions_draw?.length > 0) {
          this._position_show = addPositionsHeight(this._positions_draw[0], style.length / 2);
        }
      }
    }

    _updatePositionsHook() {
      if (this.editing?.enabled && this._positions_draw?.length > 0) {
        this._position_show = addPositionsHeight(this._positions_draw[0], this.style.length / 2);
      }
      super._updatePositionsHook();
    }

    //= =================Draw绘制相关=================
    // 将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑
    _setPositionsToCallback() {
      if (this._isCallbackPositions) {
        return
      }
      this._isCallbackPositions = true;

      const time = this._map.clock.currentTime;

      this.style.topRadius = getCesiumValue(this.entityGraphic.topRadius, Number, time);
      this.entityGraphic.topRadius = new Cesium__namespace.CallbackProperty((time) => {
        return this.style.topRadius
      }, false);

      this.style.bottomRadius = getCesiumValue(this.entityGraphic.bottomRadius, Number, time);
      this.entityGraphic.bottomRadius = new Cesium__namespace.CallbackProperty((time) => {
        return this.style.bottomRadius
      }, false);

      this.style.length = getCesiumValue(this.entityGraphic.length, Number, time);
      this.entityGraphic.length = new Cesium__namespace.CallbackProperty((time) => {
        return this.style.length
      }, false);

      // 位置
      if (this.position) {
        this._positions_draw = this.positions;
        this._positions_draw[0] = addPositionsHeight(this.position, -this.style.length / 2);
      } else {
        this._positions_draw = [];
      }
      this._position_show = this.position;
      this.position = new Cesium__namespace.CallbackProperty((time) => {
        return this._position_show
      }, false);
    }



    // 坐标CallbackProperty属性改为实际值
    _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return
      }
      this._isCallbackPositions = false;

      this.entityGraphic.length = this.style.length;
      this.entityGraphic.topRadius = this.style.topRadius;
      this.entityGraphic.bottomRadius = this.style.bottomRadius;
      this._position = this._position_show;
      this._point = LngLatPoint.fromCartesian(this._position);
      this._updatePositionsHook();
    }

    _startDrawHook() {
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);
      this._map.on(EventType.click, this._onClickHandler, this);
      this._map.on(EventType.rightClick, this._onRightClickHandler, this);
      this._map.on(EventType.dblClick, this._onDbClickHandler, this);
    }

    _stopDrawHook() {
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);
      this._map.off(EventType.click, this._onClickHandler, this);
      this._map.off(EventType.rightClick, this._onRightClickHandler, this);
      this._map.off(EventType.dblClick, this._onDbClickHandler, this);
    }

    updateAttrForDrawing(isEditing) {
      this._position_show = addPositionsHeight(this._positions_draw[0], this.style.length / 2);

      // 半径处理
      if (!isEditing && this._positions_draw.length > 1) {
        const radius = formatNum$1(Cesium__namespace.Cartesian3.distance(this._positions_draw[0], this._positions_draw[1]), 2);
        this.style.bottomRadius = radius;

        this.style.length = radius * 2;
      }
    }

    _onRightClickHandler(event) {
      super._onRightClickHandler(event);

      this.style.bottomRadius = 0;
      this.style.length = 0;
    }
  }

  // 注册下
  register$4("cylinder", CylinderEntity);

  /**
   * 圆锥追踪体 支持的样式信息
   *
   * @typedef {Object} ConeTrack.StyleOptions
   *
   * @property {Number} [angle] 圆锥追踪体张角（角度值，取值范围 0.01-89.99）
   * @property {Number} [bottomRadius = 100] 不指定angle时，也可以直接指定圆锥底部半径（单位：米）
   *
   * @property {Number} [length = 100]  圆锥追踪体长度值（单位：米），没有指定targetPosition时有效
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度），没有指定targetPosition时有效
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度），没有指定targetPosition时有效
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度），没有指定targetPosition时有效
   *
   * @property {Boolean} [fill = true] 是否填充
   * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
   * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#00FF00"] 填充颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String} [outlineWidth = 1] 边框宽度
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {number} [numberOfVerticalLines=16] 指定沿轮廓的周长绘制的垂直线的数量。
   * @property {number} [slices=128] 圆柱体周长周围的边数。
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定圆柱是投射还是接收来自光源的阴影。
   *
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定从实体位置到它的相对高度。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {CylinderEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   *  @see Cesium.CylinderGraphics.ConstructorOptions
   *  @see CylinderEntity.StyleOptions
   */

  /**
   * 圆锥追踪体
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} [options.targetPosition] 追踪的目标位置
   * @param {ConeTrack.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class ConeTrack
   * @extends {CylinderEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class ConeTrack extends CylinderEntity {
    constructor(options = {}) {
      super(options);

      if (options.targetPosition) {
        this.targetPosition = options.targetPosition;
      }
    }

    // 禁用编辑
    get hasEdit() {
      return false
    }

    get EditClass() {
      return undefined
    }

    /**
     * 追踪的目标位置(确定了方向和距离)
     * @type {Cesium.Cartesian3|LngLatPoint}
     */
    get targetPosition() {
      return this._targetPosition
    }

    set targetPosition(value) {
      this._targetPoint = LngLatPoint.parse(value);
      this._targetPosition = this._targetPoint.toCartesian();
    }

    /**
     * 追踪的目标位置
     * @type {LngLatPoint}
     * @readonly
     */
    get targetPoint() {
      return this._targetPoint
    }

    /**
     * 夹角，半场角度，取值范围 0.01-89.99
     * @type {Number}
     */
    get angle() {
      return this.style.angle
    }

    set angle(val) {
      this.style.angle = val;
    }

    _getCreateEntityAttr() {
      const addattr = super._getCreateEntityAttr();

      addattr.position = new Cesium__namespace.CallbackProperty((time) => {
        this._update(time);
        return this._cylinderPosition
      }, false);
      addattr.orientation = new Cesium__namespace.CallbackProperty((time) => {
        return this._orientation
      }, false);
      addattr.cylinder.length = new Cesium__namespace.CallbackProperty((time) => {
        return this._cylinderLength
      }, false);

      if (!Cesium__namespace.defined(addattr.cylinder.topRadius)) {
        addattr.cylinder.topRadius = 0.0;
      }
      if (Cesium__namespace.defined(this.style.angle)) {
        addattr.cylinder.bottomRadius = new Cesium__namespace.CallbackProperty((time) => {
          return this._cylinderBottomRadius
        }, false);
      }

      return addattr
    }

    _update(time) {
      const position = getPositionValue(this.position, time);
      if (!position) {
        this._cylinderPosition = undefined;
        return
      }

      if (Cesium__namespace.defined(this.targetPosition)) {
        const targetPosition = getPositionValue(this.targetPosition, time);
        if (targetPosition) {
          this._cylinderLength = Cesium__namespace.Cartesian3.distance(position, targetPosition);
          this._cylinderPosition = Cesium__namespace.Cartesian3.midpoint(position, targetPosition, new Cesium__namespace.Cartesian3());

          this._orientation = Cesium__namespace.Transforms.headingPitchRollQuaternion(targetPosition, getHeadingPitchRollForLine(targetPosition, position));
        }
      } else {
        this._cylinderLength = this.style.length;

        if (!this._cylinderLength) {
          const point = LngLatPoint.parse(position);
          this._cylinderLength = point.alt - getHeight(this._map.scene, point, { has3dtiles: false });
        }

        const hpr = new Cesium__namespace.HeadingPitchRoll(
          Cesium__namespace.Math.toRadians(this.heading),
          Cesium__namespace.Math.toRadians(this.pitch),
          Cesium__namespace.Math.toRadians(this.roll)
        );
        this._orientation = Cesium__namespace.Transforms.headingPitchRollQuaternion(position, hpr);
        this._cylinderPosition = getPositionByHprAndLen(position, hpr, this._cylinderLength / 2);
      }

      if (Cesium__namespace.defined(this.style.angle)) {
        this._cylinderBottomRadius = this._cylinderLength * Math.cos(Cesium__namespace.Math.toRadians(90 - this.angle));
      }
    }

    _updatePositionsHook() {
      // 无需计算，覆盖下父类
    }
  }

  // 注册下
  register$4("coneTrack", ConeTrack);

  /**
   * Ellipsoid对象 标绘处理对应的编辑类
   *
   * @export
   * @class EditEllipsoid
   * @extends {EditBase}
   */
  class EditEllipsoid extends EditBase {
    bindDraggers() {
      let dragger;

      const center = this.positions[0];

      // 位置中心点
      dragger = this.createDragger({
        position: center,
        onDragStart: (dragger, position) => {
          for (let i = 0, len = this.draggers.length; i < len; i++) {
            this.draggers[i].show = false;
          }
        },
        onDrag: (dragger, position) => {
          this.positions[0] = position;
        },
        onDragEnd: (dragger, position) => {
          this.updateDraggers();
        }
      });
      dragger.index = 0; // matrixMove需要
      this.draggers.push(dragger);

      const _hasEditRadii = this._graphic.options.hasEditRadii ?? true;
      if (_hasEditRadii) {
        // 顶部的 高半径 编辑点
        dragger = this.createDragger({
          position: addPositionsHeight(center, this.style.radii_z),
          type: PointType.MoveHeight,
          tooltip: this._map.getLangText("_修改半径"),
          onDrag: (dragger, position) => {
            const positionZXD = this.positions[0];
            const length = this.formatNum(Cesium__namespace.Cartesian3.distance(positionZXD, position), 2);
            this.style.radii_z = length; // 高半径

            this._graphic.updateRadii(this.style);

            this.fire(EventType.editStyle);
          }
        });
        this.draggers.push(dragger);

        // 获取圆（或椭圆）边线上的坐标点数组
        const outerPositions = getEllipseOuterPositions({
          position: center,
          semiMajorAxis: Number(this.style.radii_x),
          semiMinorAxis: Number(this.style.radii_y),
          rotation: Cesium__namespace.Math.toRadians(Number(this.style.rotation || 0))
        });

        // 长半轴上的坐标点
        const majorPos = outerPositions[0];
        const majorDragger = this.createDragger({
          position: majorPos,
          type: PointType.EditAttr,
          tooltip: this._map.getLangText("_修改半径"),
          onDrag: (dragger, position) => {
            const positionZXD = this.positions[0];
            const newHeight = Cesium__namespace.Cartographic.fromCartesian(positionZXD).height;
            position = setPositionsHeight(position, newHeight);
            dragger.position = position;

            const radius = this.formatNum(Cesium__namespace.Cartesian3.distance(positionZXD, position), 2);
            this.style.radii_y = radius; // 长半轴

            this._graphic.updateRadii(this.style);
            this.fire(EventType.editStyle);
          }
        });
        dragger.majorDragger = majorDragger;
        this.draggers.push(majorDragger);

        // 短半轴上的坐标点
        const minorPos = outerPositions[1];
        const minorDragger = this.createDragger({
          position: minorPos,
          type: PointType.EditAttr,
          tooltip: this._map.getLangText("_修改半径"),
          onDrag: (dragger, position) => {
            const positionZXD = this.positions[0];
            const newHeight = Cesium__namespace.Cartographic.fromCartesian(positionZXD).height;
            position = setPositionsHeight(position, newHeight);
            dragger.position = position;

            const radius = this.formatNum(Cesium__namespace.Cartesian3.distance(positionZXD, position), 2);
            this.style.radii_x = radius; // 短半轴

            this._graphic.updateRadii(this.style);
            this.fire(EventType.editStyle);
          }
        });
        dragger.minorDragger = minorDragger;
        this.draggers.push(minorDragger);
      }
    }

    _updateStyleHook(newStyle) {
      super._updateStyleHook(newStyle);
      if (Cesium__namespace.defined(newStyle.radii_x) || Cesium__namespace.defined(newStyle.radii_y) || Cesium__namespace.defined(newStyle.radii_z)) {
        this.updateDraggers();
      }
    }
  }

  /**
   * 球、半球、椭球 支持的 样式信息
   *
   * @typedef {Object} EllipsoidEntity.StyleOptions
   *
   * @property {Cesium.Cartesian3} [radii] 指定椭球半径。
   * @property {Number} [radii_x = 100] X半径
   * @property {Number} [radii_y = 100] Y半径
   * @property {Number} [radii_z = 100] Z半径
   * @property {Cesium.Cartesian3} [innerRadii] 指定椭球的内半径。
   * @property {Number} [innerRadii_x = 0] 内部X半径
   * @property {Number} [innerRadii_y = 0] 内部Y半径
   * @property {Number} [innerRadii_z = 0] 内部Z半径
   *
   * @property {Number} [minimumClock = 0] 最小时钟角度（弧度值）
   * @property {Number} [minimumClockDegree = 0] 最小时钟角度（度数值，0-360度），与minimumClock二选一
   * @property {Number} [maximumClock = 360] 最大时钟角度（弧度值）
   * @property {Number} [maximumClockDegree = 360] 最大时钟角度（度数值，0-360度），与maximumClock二选一
   * @property {Number} [minimumCone = 0] 最小锥角（弧度值）
   * @property {Number} [minimumConeDegree = 0] 最小锥角（度数值，0-360度），与minimumCone二选一
   * @property {Number} [maximumCone = 180] 最大圆锥角（弧度值）
   * @property {Number} [maximumConeDegree = 180] 最大圆锥角（度数值，0-360度），与maximumCone二选一
   *
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   *
   * @property {Boolean} [fill = true] 是否填充

   * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String} [outlineWidth = 1] 边框宽度
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {number} [stackPartitions=64] 指定竖向划分数量
   * @property {number} [slicePartitions=64] 指定横向划分数量
   * @property {number} [subdivisions=128] 指定每个轮廓环的样本数量，确定曲率的粒度。
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定从实体位置到它的相对高度。
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   *
   * @property {Boolean} [hasShadows = false] 是否投射阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定椭球是否投射或接收来自光源的阴影。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {EllipsoidEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see Cesium.EllipsoidGraphics.ConstructorOptions
   */

  /**
   * 动态扫描面 参数
   * @typedef {Object} EllipsoidEntity.ScanPlaneOptions
   *
   * @property {Object} planeOptions 扫描面构造参数
   * @property {String} [planeOptions.type='heading'] 扫描旋转的方向，可选值：'heading'，'pitch'，'roll'
   * @property {Number} [planeOptions.step=0.5] 旋转的步长（角度），控制速度
   * @property {EllipsoidEntity.StyleOptions} [planeOptions.style] 样式信息
   */

  /**
   * 球、半球、椭球  Entity对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {EllipsoidEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.Property} [options.orientation] 实体方向
   * @param {EllipsoidEntity.ScanPlaneOptions|EllipsoidEntity.ScanPlaneOptions[]} [options.scanPlane] 动态扫描面
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasEditRadii=true] 编辑时，是否可以编辑半径
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class EllipsoidEntity
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class EllipsoidEntity extends BasePointEntity {
    constructor(options = {}) {
      super(options);

      // 配置的参数
      this._minPointNum = 2; // 至少需要点的个数
      this._maxPointNum = 3; // 最多允许点的个数
    }

    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.EllipsoidGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.ellipsoid
    }

    /**
     * 编辑处理类
     * @type {EditEllipsoid}
     * @readonly
     */
    get EditClass() {
      return EditEllipsoid
    }

    // 内部用，文本等附加对象
    get czmObjectEx() {
      let arr = [];
      if (this._primitive_label) {
        arr.push(this._primitive_label);
      }
      if (this._entity_scanPlane) {
        arr = arr.concat(this._entity_scanPlane);
      }
      return arr
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      const addattr = {
        position: this.position,
        orientation: this.getOrientation(),
        ellipsoid: EllipsoidStyleConver.toCesiumVal(this.style, {}, true)
      };
      this._entity = this._createEntity(addattr);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }

      const scanPlane = this.options.scanPlane;
      if (scanPlane) {
        if (Array.isArray(scanPlane)) {
          scanPlane.forEach((item) => {
            this.addScanPlane(item);
          });
        } else {
          this.addScanPlane(scanPlane);
        }
      }
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      styleJson = EllipsoidStyleConver.toJSON(czmStyle, styleJson, true);

      if (this._entity_scanPlane && this._entity_scanPlane.length > 0) {
        const scanPlane = [];
        this._entity_scanPlane.forEach((entity) => {
          scanPlane.push(entity._planeOptions);
        });
        styleJson.scanPlane = scanPlane;
      }

      return styleJson
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      EllipsoidStyleConver.toCesiumVal(style, this.entityGraphic, true);

      if (Cesium__namespace.defined(newStyle.heading) || Cesium__namespace.defined(newStyle.pitch) || Cesium__namespace.defined(newStyle.roll)) {
        this._entity.orientation = this.getOrientation();
      }
      if (Cesium__namespace.defined(newStyle.radii_x) || Cesium__namespace.defined(newStyle.radii_y) || Cesium__namespace.defined(newStyle.radii_z)) {
        this.updateRadii(style);
      }
    }

    _updatePositionsHook() {
      super._updatePositionsHook();

      if (this._entity_scanPlane) {
        this._entity_scanPlane.forEach((entity) => {
          entity.position = this.position;
        });
      }
    }

    _setOptionsHook(options, newOptions) {
      const scanPlane = newOptions.scanPlane;
      if (scanPlane) {
        this.removeAllScanPlan();

        if (Array.isArray(scanPlane)) {
          scanPlane.forEach((item) => {
            this.addScanPlane(item);
          });
        } else {
          this.addScanPlane(scanPlane);
        }
      }
    }

    _updateExOpacity(value) {
      if (this._entity_scanPlane?.length > 0) {
        this._entity_scanPlane.forEach((entity) => {
          const result = this._updateEntityOpacity(entity.ellipsoid, value);
          if (!result) {
            entity._planeOptions.style.globalAlpha = value;
            EllipsoidStyleConver.toCesiumVal(entity._planeOptions.style, entity.ellipsoid, true);
          }
        });
      }
    }

    // 更新球的半径
    updateRadii(style) {
      const radii = new Cesium__namespace.Cartesian3(style.radii_x, style.radii_y, style.radii_z);
      if (this.entityGraphic.radii) {
        this.entityGraphic.radii.setValue(radii);
      } else {
        this.entityGraphic.radii = radii;
      }
    }

    //= =================Draw绘制相关=================
    // 将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑
    _setPositionsToCallback() {
      if (this._isCallbackPositions) {
        return
      }
      this._isCallbackPositions = true;

      const radii = getCesiumValue(this.entityGraphic.radii, Cesium__namespace.Cartesian3, this._map.clock.currentTime);
      if (radii) {
        this.style.radii_x = this.style.radii_x ?? radii.x;
        this.style.radii_y = this.style.radii_y ?? radii.y;
        this.style.radii_z = this.style.radii_z ?? radii.z;
      }

      this._positions_draw = this.positions || [];
      this.position = new Cesium__namespace.CallbackProperty((time) => {
        if (this._positions_draw.length < 1) {
          return null
        }
        return this._positions_draw[0]
      }, false);
    }

    // 坐标CallbackProperty属性改为实际值
    _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return
      }
      this._isCallbackPositions = false;

      this._position = this._positions_draw[0];
      this._point = LngLatPoint.fromCartesian(this._position);
      this._updatePositionsHook();
    }

    _startDrawHook() {
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);
      this._map.on(EventType.click, this._onClickHandler, this);
      this._map.on(EventType.rightClick, this._onRightClickHandler, this);
      this._map.on(EventType.dblClick, this._onDbClickHandler, this);
    }

    _stopDrawHook() {
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);
      this._map.off(EventType.click, this._onClickHandler, this);
      this._map.off(EventType.rightClick, this._onRightClickHandler, this);
      this._map.off(EventType.dblClick, this._onDbClickHandler, this);
    }

    updateAttrForDrawing(isEditing) {
      if (this._positions_draw.length < 2) {
        return
      }

      if (!isEditing) {
        // 半径处理
        const radius = formatNum$1(Cesium__namespace.Cartesian3.distance(this._positions_draw[0], this._positions_draw[1]), 2);
        this.style.radii_x = radius; // 短半轴
        this.style.radii_z = radius;

        // 长半轴
        let semiMajorAxis;
        if (this._positions_draw.length === 3) {
          semiMajorAxis = formatNum$1(Cesium__namespace.Cartesian3.distance(this._positions_draw[0], this._positions_draw[2]), 2);
        } else {
          semiMajorAxis = radius;
        }
        this.style.radii_y = semiMajorAxis;

        this.updateRadii(this.style);
      }
    }

    _onRightClickHandler(event) {
      super._onRightClickHandler(event);

      this.style.radii_y = 0;
      if (this._positions_draw.length === 1) {
        this.style.radii_x = 0; // 短半轴
        this.style.radii_z = 0;
      }
      this.updateRadii(this.style);
    }

    /**
     * 添加 动态扫描面
     * @param {EllipsoidEntity.ScanPlaneOptions} planeOptions 扫描面构造参数
     * @return {Cesium.Entity} 矢量对象
     */
    addScanPlane(planeOptions = {}) {
      this._entity_scanPlane = this._entity_scanPlane || [];

      planeOptions.style = planeOptions.style || {};

      // 默认样式
      const defStyle = {
        radii: this.entityGraphic.radii,
        innerRadii: 0.00001,
        minimumClockDegree: -0.00001,
        maximumClockDegree: 0.00001,
        minimumConeDegree: this.style.minimumConeDegree || 0.0,
        maximumConeDegree: this.style.maximumConeDegree || 90.0,
        outline: false
      };
      if (this.style.color) {
        defStyle.color = this.style.color;
        if (this.style.opacity) {
          defStyle.opacity = this.style.opacity;
        }
      } else if (this.style.outlineColor) {
        defStyle.color = this.style.outlineColor;
        if (this.style.outlineOpacity) {
          defStyle.opacity = this.style.outlineOpacity;
        }
      }

      // 旋转动画回调
      let orientation;
      const step = Cesium__namespace.Math.toRadians(planeOptions.step || 0.5);
      const headingPitchRoll = new Cesium__namespace.HeadingPitchRoll(
        Cesium__namespace.Math.toRadians(planeOptions.style.heading || this.heading),
        Cesium__namespace.Math.toRadians(planeOptions.style.pitch || this.pitch),
        Cesium__namespace.Math.toRadians(planeOptions.style.roll || this.roll)
      );
      let callbackHprQ = Cesium__namespace.Transforms.headingPitchRollQuaternion(this.positionShow, headingPitchRoll);
      switch (planeOptions.type) {
        case "pitch":
          {
            // pitch环绕
            const minimumCone = 0.0;
            const maximumCone = Cesium__namespace.Math.PI;
            orientation = new Cesium__namespace.CallbackProperty((e) => {
              if (!this._map.clock.shouldAnimate) {
                return callbackHprQ
              }

              headingPitchRoll.pitch += step;
              if (headingPitchRoll.pitch >= maximumCone) {
                headingPitchRoll.pitch = minimumCone; // Cesium.Math.PI_OVER_TWO为90度
              }

              callbackHprQ = Cesium__namespace.Transforms.headingPitchRollQuaternion(this.positionShow, headingPitchRoll);
              return callbackHprQ
            }, false);
          }
          break
        case "roll":
          {
            // roll环绕
            const minimumCone = -Cesium__namespace.Math.PI_OVER_TWO; // Cesium.Math.PI_OVER_TWO为90度
            const maximumCone = Cesium__namespace.Math.PI_OVER_TWO;
            orientation = new Cesium__namespace.CallbackProperty((e) => {
              if (!this._map.clock.shouldAnimate) {
                return callbackHprQ
              }

              headingPitchRoll.roll += step;
              if (headingPitchRoll.roll >= maximumCone) {
                headingPitchRoll.roll = minimumCone;
              }
              callbackHprQ = Cesium__namespace.Transforms.headingPitchRollQuaternion(this.positionShow, headingPitchRoll);
              return callbackHprQ
            }, false);
          }
          break
        case "heading":
        default: {
          // heading四周环绕
          orientation = new Cesium__namespace.CallbackProperty((e) => {
            if (!this._map.clock.shouldAnimate) {
              return callbackHprQ
            }

            headingPitchRoll.heading = (headingPitchRoll.heading + step) % Cesium__namespace.Math.TWO_PI;
            callbackHprQ = Cesium__namespace.Transforms.headingPitchRollQuaternion(this.positionShow, headingPitchRoll);
            return callbackHprQ
          }, false);
          break
        }
      }

      const addattr = {
        id: "scanPlane-" + createGuid(),
        position: this.position,
        orientation: orientation,
        ellipsoid: EllipsoidStyleConver.toCesiumVal(
          {
            ...defStyle,
            ...planeOptions.style
          },
          {},
          true
        )
      };
      const entity = this._createEntity(addattr);
      if (this.dataSource && this.isAdded) {
        this.dataSource.entities.add(entity);
      }
      this.bindPickId(entity);

      entity._planeOptions = planeOptions; // 用于导出数据
      this._entity_scanPlane.push(entity);

      return entity
    }

    /**
     * 移除单个指定的扫描面
     * @param {Cesium.Entity} entity addScanPlane返回的矢量对象
     * @return {void}  无
     */
    removeScanPlan(entity) {
      if (this.dataSource && this.isAdded) {
        this.dataSource.entities.remove(entity);
      }
      removeArrayItem(this._entity_scanPlane, entity);
    }

    /**
     * 清除所有扫描面
     * @return {void}  无
     */
    removeAllScanPlan() {
      if (this.dataSource && this.isAdded) {
        this._entity_scanPlane.forEach((entity) => {
          this.dataSource.entities.remove(entity);
        });
      }
      this._entity_scanPlane = [];
    }
  }
  // 注册下
  register$4("ellipsoid", EllipsoidEntity);

  /**
   * 线 支持的样式信息
   *
   * @typedef {Object} PolylineEntity.StyleOptions
   *
   * @property {String} [materialType = "Color"] 线型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {Number} [width = 4] 线宽
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {Boolean} [randomColor = false] 是否随机颜色
   * @property {Cesium.MaterialProperty |Cesium.Color} [depthFailMaterial] 指定当折线位于地形之下时用于绘制折线的材质。
   *
   * @property {Boolean} [closure = false] 是否闭合, 在positions是属性机制的回调对象时无效
   *
   * @property {Boolean} [outline = false] 是否衬色
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 衬色颜色
   * @property {Number} [outlineWidth = 2] 衬色宽度
   *
   * @property {Boolean} [depthFail] 是否显示遮挡
   * @property {String} [depthFailColor] 遮挡处颜色
   * @property {Number} [depthFailOpacity] 遮挡处透明度
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Cesium.ArcType} [arcType=Cesium.ArcType.GEODESIC]  折线段必须遵循的线的类型。
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 如果arcType不是arcType.none，则指定每个纬度和经度之间的角距离的数字属性。
   *
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
   * @property {Number} [zIndex = 0] 层级顺序,指定用于排序地面几何的zIndex。只有当' clampToGround '为真且支持地形上的折线时才会有效果。
   *
   * @property {Number|Number[]} [setHeight=0] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
   * @property {Number|Number[]} [addHeight=0] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
   *
   * @property {PolylineEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions|Object} [label] 支持附带文字的显示，额外支持：<br />
  //  * @property {String} [label.text = "文字"] 文本内容，换行可以用换行符'\n'。
  //  * @property {String|LngLatPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
  //  * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
   *
   * @see Cesium.PolylineGraphics.ConstructorOptions
   */

  /**
   * 线  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolylineEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class PolylineEntity
   * @extends {BasePolyEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PolylineEntity extends BasePolyEntity {
    constructor(options = {}) {
      options.styleType = options.styleType ?? "polyline";
      super(options);
    }

    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.PolylineGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.polyline
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      const addattr = {
        polyline: PolylineStyleConver.toCesiumVal(this.style, {}, true)
      };
      addattr.polyline.positions = this.getShowPositon(this.positions);
      this._entity = this._createEntity(addattr);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    getShowPositon(positions) {
      if (this.style.closure && positions?.length > 0) {
        return positions.concat(positions[0])
      } else {
        return positions
      }
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PolylineStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      PolylineStyleConver.toCesiumVal(style, this.entityGraphic, true);

      if (Cesium__namespace.defined(newStyle?.closure)) {
        this.updateAttrForDrawing();
      }
    }

    _updatePositionsHook() {
      this.entityGraphic.positions = this.getShowPositon(this._positions);

      // 中心文本处理
      this._updateLabelPosition();

      // 如果在编辑中，更新编辑的拖拽点。
      this._updateEditDraggers();
    }

    //= =================Draw绘制相关=================
    _positions_CallbackProperty() {
      return this.getShowPositon(this._positions_draw)
    }

    updateAttrForDrawing(isEditing) {
      // 显示depthFailMaterial时，不能使用CallbackProperty属性，否则depthFailMaterial不显示
      if (Cesium__namespace.defined(this.entityGraphic.depthFailMaterial)) {
        this.entityGraphic.positions = this._positions_CallbackProperty();
      }
    }

    _stopDrawHook() {
      super._stopDrawHook();

      // 显示depthFailMaterial时，不能使用CallbackProperty属性，否则depthFailMaterial不显示
      if (Cesium__namespace.defined(this.entityGraphic.depthFailMaterial)) {
        this.positions = this._positions_draw;
      }
    }

    // distanceDisplayCondition属性的特殊处理
    _updateDistanceDisplayConditionByEdit() {
      if (this._isCallbackPositions && this.style.clampToGround) {
        this.updateDistanceDisplayCondition(6356752); // 6378137为地球半径
      } else {
        this.updateDistanceDisplayCondition();
      }
    }
  }
  // 注册下
  register$4("polyline", PolylineEntity);

  /**
   * 曲线
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolylineEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class CurveEntity
   * @extends {PolylineEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class CurveEntity extends PolylineEntity {
    getShowPositon(positions) {
      if (positions instanceof Cesium__namespace.CallbackProperty) {
        this._positions_curve = this.getShowPositon(this._positions_draw);
        return positions
      }
      return getBezierCurve(positions, this.style.closure)
    }

    //= =================Draw绘制相关=================
    _positions_CallbackProperty() {
      return this._positions_curve
    }

    updateAttrForDrawing(isEditing) {
      this._positions_curve = this.getShowPositon(this._positions_draw);
    }


  }

  // 注册下
  register$4("curve", CurveEntity);

  /**
   * PolylineVolume对象 标绘处理对应的编辑类
   *
   * @export
   * @class EditPolylineVolume
   * @extends {EditPoly}
   */
  class EditPolylineVolume extends EditPoly {
    // _updateHeight(height) {
    //   this.entityGraphic.height = height
    //   this.style.height = this.formatNum(height, 2)
    //   const positions = this.positions
    //   for (let i = 0, len = positions.length; i < len; i++) {
    //     positions[i] = setPositionsHeight(positions[i], height)
    //   }
    //   for (let i = 0, len = this.draggers.length; i < len; i++) {
    //     const draggerItem = this.draggers[i]
    //     draggerItem.position = setPositionsHeight(draggerItem.position, height)
    //   }
    // }
  }

  /**
   * 管道线 支持的样式信息
   *
   * @typedef {Object} PolylineVolumeEntity.StyleOptions
   *
   * @property {String|Array<Cesium.Cartesian2>} [shape = "pipeline"] 形状类型 或 定义要挤压的形状。类型可选项：pipeline (解释：空心管),circle (解释：实心管),star (解释：星状管),
   * @property {Number} [radius = 10] 半径(单位：米)
   * @property {Number} [thicknes = radius/3] 厚度(单位：米)，空心管/星状管 的外层厚度
   * @property {Number} [slices] 边数，比如为4时是矩形管；星状管代表角的个数；
   * @property {Number} [startAngle=0] 开始角度，取值范围0-360
   * @property {Number} [endAngle=360] 结束角度，取值范围0-360，比如endAngle=180的空心管是拱形半圆管道
   *
   * @property {boolean} [fill=true] 是否填充
   * @property {String|Cesium.Color} [color = "#FFFF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后fillType和color属性将被覆盖。
   *
   * @property {Boolean} [outline = false] 是否边线
   * @property {number} [outlineWidth=1.0] 边线宽度
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边线颜色
   * @property {Number} [outlineOpacity = opacity] 边框透明度
   *
   * @property {Cesium.CornerType} [cornerType=CornerType.ROUNDED] 指定边角的样式。
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定每个纬度点和经度点之间的角距离。
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [hasShadows = false] 是否投射阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定管道是否投射或接收来自光源的阴影。
   *
   * @property {Number|Number[]} [setHeight=0] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
   * @property {Number|Number[]} [addHeight=0] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
   *
   *
   * @property {PolylineVolumeEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see Cesium.PolylineVolumeGraphics.ConstructorOptions
   */

  /**
   * 管道线  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolylineVolumeEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class PolylineVolumeEntity
   * @extends {BasePolyEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PolylineVolumeEntity extends BasePolyEntity {
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.PolygonGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.polylineVolume
    }

    /**
     * 编辑处理类
     * @type {EditPolylineVolume}
     * @readonly
     */
    get EditClass() {
      return EditPolylineVolume
    }

    _mountedHook() {
      const addattr = {
        polylineVolume: PolylineVolumeStyleConver.toCesiumVal(this.style, {}, true)
      };
      addattr.polylineVolume.positions = this.positions;

      this._entity = this._createEntity(addattr);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PolylineVolumeStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      PolylineVolumeStyleConver.toCesiumVal(style, this.entityGraphic, true);
    }

    _updatePositionsHook() {
      this.entityGraphic.positions = this.positions;

      this._updateLabelPosition();
      // 如果在编辑中，更新编辑的拖拽点。
      this._updateEditDraggers();
    }
  }
  // 注册下
  register$4("polylineVolume", PolylineVolumeEntity);

  /**
   * path路径 支持的样式信息
   *
   * @typedef {Object} PathEntity.StyleOptions
   *
   * @property {Number} [width=1.0] 以像素为单位指定宽度的数字属性。
   * @property {String|Cesium.Color} [color = "#FFFF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后fillType和color属性将被覆盖。
   * @property {Number} [leadTime] 提前显示轨迹的时间长度（单位：秒），比如不显示前方路线，可以设置为0
   * @property {Number} [trailTime] 保留历史轨迹的时间长度（单位：秒）
   * @property {Number} [resolution=60]  指定在对位置进行采样时步进的最大秒数。
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @see Cesium.PathGraphics.ConstructorOptions
   */

  /**
   * path路径  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {Cesium.SampledPositionProperty} options.position 坐标位置（含时序的点集合）
   * @param {Cesium.Property} [options.orientation] 实体方向
   * @param {PathEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {LabelEntity.StyleOptions} [options.label]  设置是否显示 文本 和对应的样式
   * @param {ModelEntity.StyleOptions|*} [options.model]  设置附加的 gltf模型 和对应的样式
   * @param {BillboardEntity.StyleOptions|*} [options.billboard]  设置附加的 图标 和对应的样式。
   * @param {PointEntity.StyleOptions|*} [options.point]  设置附加的 像素点 和对应的样式
   * @param {CircleEntity.StyleOptions|*} [options.circle]  设置附加的 圆 和对应的样式
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class PathEntity
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PathEntity extends BasePointEntity {
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.PathGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.path
    }

    /**
     * 获取当前时间的三维空间中的旋转。
     * @type {Cesium.Quaternion}
     * @readonly
     */
    get orientationShow() {
      const _orientation = Cesium__namespace.Property.getValueOrUndefined(this.orientation, this._map.clock.currentTime, new Cesium__namespace.Quaternion());
      return _orientation
    }

    /**
     * 获取当前时间的方向角
     * @type {Cesium.HeadingPitchRoll}
     * @readonly
     */
    get hpr() {
      return getHeadingPitchRollByOrientation(this.positionShow, this.orientationShow)
    }

    /**
     * 俯仰角，上下摇摆的角度，0-360度角度值
     * @type {Number}
     */
    get pitch() {
      return this.style.pitch ?? 0
    }

    set pitch(val) {
      this.style.pitch = val;
      this.updateOrientation();
    }

    /**
     * 滚转角，左右摆动的角度，0-360度角度值
     * @type {Number}
     */
    get roll() {
      return this.style.roll ?? 0
    }

    set roll(val) {
      this.style.roll = val;
      this.updateOrientation();
    }

    /**
     * 位置坐标数组 （笛卡尔坐标）, 赋值时可以传入LatLngPoint数组对象
     * @type {Array[]|LngLatPoint[]}
     */
    get positions() {
      return this._positions
    }

    set positions(value) {
      if (!value) {
        return
      }

      const property = new Cesium__namespace.SampledPositionProperty();
      value.forEach((item, index) => {
        const thisTime = Cesium__namespace.JulianDate.fromDate(new Date(item[3]));
        property.addSample(thisTime, Cesium__namespace.Cartesian3.fromDegrees(item[0], item[1], item[2]));
      });

      this.position = property;
    }

    /**
     * 位置坐标(数组对象)，示例 [ [123.123456,32.654321,198.7,time], [111.123456,22.654321,50.7,time] ]
     * @type {Array[]}
     * @readonly
     */
    get coordinates() {
      return this.getCoordinates()
    }

    _updatePositionsHook() {
      super._updatePositionsHook();

      if (!this.position || this.position instanceof Cesium__namespace.Cartesian3) {
        this._entity.orientation = undefined;
        this._entity.availability = undefined;
      } else {
        if (this.options._auto_orientation) {
          this._entity.orientation = new Cesium__namespace.VelocityOrientationProperty(this.position); // 基于移动位置自动计算方位
        }
        if (this.options._auto_availability && this.position?._property?._times?.length > 0) {
          const times = this.position._property._times;
          const start = times[0];
          let stop = times[times.length - 1];
          if (this.position?.forwardExtrapolationType === Cesium__namespace.ExtrapolationType.HOLD) {
            stop = Cesium__namespace.JulianDate.fromDate(new Date(2100, 1, 1));
          }
          this._entity.availability = new Cesium__namespace.TimeIntervalCollection([new Cesium__namespace.TimeInterval({ start: start, stop: stop })]);
        }
      }
    }

    _mountedHook() {
      if (this.position && !this.options.orientation) {
        this.options.orientation = new Cesium__namespace.VelocityOrientationProperty(this.position); // 基于移动位置自动计算方位
        this._auto_orientation = true;
      }

      const addattr = {
        position: this.position,
        orientation: this.options.orientation,
        path: PathStyleConver.toCesiumVal(this.style || this.options.path, {}, true)
      };

      if (!this.options.availability && this.position?._property?._times?.length > 0) {
        const times = this.position._property._times;
        const start = times[0];
        let stop = times[times.length - 1];
        if (this.position?.forwardExtrapolationType === Cesium__namespace.ExtrapolationType.HOLD) {
          stop = Cesium__namespace.JulianDate.fromDate(new Date(2100, 1, 1));
        }
        addattr.availability = new Cesium__namespace.TimeIntervalCollection([new Cesium__namespace.TimeInterval({ start: start, stop: stop })]);
        this._auto_availability = true;
      }

      // 支持其他附带对象 start
      if (this.options.label) {
        this.options.label.text = this.options.label.text || this.name;
        addattr.label = LabelStyleConver.toCesiumVal(this.options.label);
      }
      if (this.options.billboard) {
        addattr.billboard = BillboardStyleConver.toCesiumVal(this.options.billboard);
      }
      if (this.options.point) {
        addattr.point = PointStyleConver.toCesiumVal(this.options.point);
      }
      if (this.options.circle) {
        addattr.ellipse = CircleStyleConver.toCesiumVal(this.options.circle, {}, true);
      }
      if (this.options.model) {
        addattr.model = ModelStyleConver.toCesiumVal(this.options.model, {}, true);
        if (Cesium__namespace.defined(this.options.model.heading)) {
          // 由于模型不是标准的方向时的处理
          const heading = Cesium__namespace.Math.toRadians(this.options.model.heading);
          addattr.orientation = new Cesium__namespace.CallbackProperty((time) => {
            const position = this.position;
            let hpr;
            if (this.options.orientation) {
              const orientation = this.options.orientation.getValue(time);
              hpr = getHeadingPitchRollByOrientation(position, orientation);
              hpr.heading += heading;
            } else {
              hpr = new Cesium__namespace.HeadingPitchRoll(heading);
            }
            return Cesium__namespace.Transforms.headingPitchRollQuaternion(position, hpr, this._map?.scene?.globe.ellipsoid)
          }, false);
        }
      }
      // 支持其他附带对象 end

      this._entity = this._createEntity(addattr);
    }

    _initSampledPositionProperty() {
      this._maxCacheCount = this.options.maxCacheCount ?? 50; // 保留的坐标点数量

      if (!this.position) {
        const property = new Cesium__namespace.SampledPositionProperty(this.options.referenceFrame);
        property.forwardExtrapolationType = this.options.forwardExtrapolationType ?? Cesium__namespace.ExtrapolationType.HOLD;
        property.backwardExtrapolationType = this.options.backwardExtrapolationType ?? Cesium__namespace.ExtrapolationType.HOLD;

        if (!this.options.orientation) {
          this.options.orientation = new Cesium__namespace.VelocityOrientationProperty(property);
          if (this._entity) {
            this._entity.orientation = this.getOrientation();
          }
        }
        if (this._entity && !this._entity.availability && this._map) {
          const start = this._map.clock.currentTime;
          let stop = Cesium__namespace.JulianDate.addDays(start, 1, new Cesium__namespace.JulianDate());
          if (this.position?.forwardExtrapolationType === Cesium__namespace.ExtrapolationType.HOLD) {
            stop = Cesium__namespace.JulianDate.addDays(stop, 365, new Cesium__namespace.JulianDate());
          }

          this._entity.availability = new Cesium__namespace.TimeIntervalCollection([
            new Cesium__namespace.TimeInterval({
              start: start,
              stop: stop
            })
          ]);
        }
        this.position = property;
      }

      this.property = this.position;
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      PathStyleConver.toCesiumVal(style, this.entityGraphic, {}, true);
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PathStyleConver.toJSON(czmStyle, styleJson, true)
    }

    _getGeoJsonGeometry(options) {
      return { type: "LineString", coordinates: this.getCoordinates(options?.noAlt) }
    }

    _getJsonPositions(json) {
      json.positions = this.getCoordinates();
    }

    _toJSON_Ex(json) {
      if (this.options.label) {
        json.label = {};
        LabelStyleConver.toJSON(this.options.label, json.label, true);
      }
      if (this.options.model) {
        json.model = {};
        ModelStyleConver.toJSON(this.options.model, json.model, true);
      }
      if (this.options.billboard) {
        json.billboard = {};
        BillboardStyleConver.toJSON(this.options.billboard, json.billboard, true);
      }
      if (this.options.point) {
        json.point = {};
        PointStyleConver.toJSON(this.options.point, json.point, true);
      }
      if (this.options.circle) {
        json.circle = {};
        CircleStyleConver.toJSON(this.options.circle, json.circle, true);
      }
    }

    _setOptionsHook(options, newOptions) {
      if (newOptions.label) {
        LabelStyleConver.toCesiumVal(options.label, this._entity.label, this);
      }
      if (newOptions.model) {
        ModelStyleConver.toCesiumVal(options.model, this._entity.model, true);
      }
      if (newOptions.billboard) {
        BillboardStyleConver.toCesiumVal(options.billboard, this._entity.billboard, true);
      }
      if (newOptions.point) {
        PointStyleConver.toCesiumVal(options.point, this._entity.point, true);
      }
      if (newOptions.circle) {
        CircleStyleConver.toCesiumVal(options.circle, this._entity.ellipse, true);
      }
    }

    _updateExOpacity(value) {
      // if (this._entity.label) { }

      if (this._entity.model) {
        this._entity.model.color = Cesium__namespace.Color.WHITE.withAlpha(value);
      }
      if (this._entity.billboard) {
        this._entity.billboard.color = Cesium__namespace.Color.WHITE.withAlpha(value);
      }
      if (this._entity.point) {
        const result = this._updateEntityOpacity(this._entity.point, value);
        if (!result) {
          PointStyleConver.toCesiumVal({ ...this.options.point, globalAlpha: value }, this._entity.point, true);
        }
      }
      if (this._entity.circle) {
        const result = this._updateEntityOpacity(this._entity.circle, value);
        if (!result) {
          CircleStyleConver.toCesiumVal({ ...this.options.circle, globalAlpha: value }, this._entity.ellipse, true);
        }
      }
    }

    /**
     * 当前飞行过的positions轨迹点 数组的index
     *
     * @param {Cesium.JulianDate} [currentTime] 指定的时间，默认为map当前时间
     * @return {Number}  数组的顺序
     */
    getIndex(currentTime) {
      const times = this.position?._property?._times;
      const timesLength = times.length;
      if (timesLength === 0) {
        return 0
      }

      // 计算位置
      const time = currentTime || this._map?.clock?.currentTime || Cesium__namespace.JulianDate.now();
      let index = Cesium__namespace.binarySearch(times, time, Cesium__namespace.JulianDate.compare);
      if (index < 0) {
        index = ~index;
      }

      // 容错处理
      if (index < 0) {
        index = 0;
      }
      if (index >= timesLength) {
        index = timesLength - 1;
      }
      return index
    }

    /**
     * 获取数据的矩形边界
     * @param {Boolean} [options] 控制参数
     * @param {Boolean} [options.isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */
    getRectangle(options) {
      const times = this.position?._property?._times;
      const values = this.position?._property?._values;

      if (!times || times.length === 0) {
        return
      }

      const positions = [];
      for (let i = 0, len = times.length; i < len; i++) {
        positions.push(new Cesium__namespace.Cartesian3(values[i * 3], values[i * 3 + 1], values[i * 3 + 2]));
      }

      const extent = getRectangle(positions, options?.isFormat);
      return extent
    }

    /**
     * 位置坐标(数组对象)，示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
     * @param {Boolean} noAlt true时不导出高度值
     * @return {Array[]} 位置坐标(数组对象)
     */
    getCoordinates(noAlt) {
      const times = this.position?._property?._times;
      const values = this.position?._property?._values;

      if (!times || times.length === 0) {
        return []
      }

      const coords = [];
      for (let i = 0, len = times.length; i < len; i++) {
        const point = LngLatPoint.fromCartesian(new Cesium__namespace.Cartesian3(values[i * 3], values[i * 3 + 1], values[i * 3 + 2]));
        const arr = point.toArray(noAlt);
        arr.push(Cesium__namespace.JulianDate.toDate(times[i]).getTime());
        coords.push(arr);
      }
      return coords
    }

    /**
     * 定位至当前时间所在的位置 (非相机位置)
     *
     * @param {Object} [options={}] 具有以下属性的对象:
     * @param {Number} [options.radius] 相机距离目标点的距离（单位：米）
     * @param {Number} [options.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} [options.pitch] 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} [options.roll] 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行持续时间（秒）。如果省略，内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Matrix4} [options.endTransform] 表示飞行完成后摄像机将位于的参考帧的变换矩阵。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机的飞行角度高于该值，请在飞行过程中调整俯仰角度以向下看，并将地球保持在视口中。
     * @param {Number} [options.flyOverLongitude] 地球上2点之间总是有两种方式。此选项会迫使相机选择战斗方向以在该经度上飞行。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction]  控制在飞行过程中如何插值时间。
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     */
    flyToPoint(options = {}) {
      if (!this._map) {
        return Promise.resolve(false)
      }

      const position = this.positionShow;
      if (!position) {
        return Promise.resolve(false)
      }

      let heading;
      if (Cesium__namespace.defined(options.heading)) {
        heading = options.heading + Cesium__namespace.Math.toDegrees(this.hpr?.heading || 0);
      }
      return this._map.flyToPoint(position, { ...options, heading: heading })
    }
  }
  // 注册下
  register$4("path", PathEntity);

  /**
   * Corridor对象 标绘处理对应的编辑类
   *
   * @export
   * @class EditCorridor
   * @extends {EditPoly}
   */
  class EditCorridor extends EditPoly {
    // 继承父类，根据属性更新坐标
    updatePositionsHeightByAttr(position) {
      if (this.entityGraphic.height !== undefined) {
        const newHeight = getCesiumValue(this.entityGraphic.height, Number, this._map.clock.currentTime);
        position = setPositionsHeight(position, newHeight);
      }
      return position
    }

    // 创建Dragger拖动点的公共方法
    createDragger(options) {
      if (this.clampToGround) {
        options.position = getSurfacePosition(this._map.scene, options.position);
      }
      return super.createDragger(options)
    }

    _updateMoveAllHook(position) {
      const height = Cesium__namespace.Cartographic.fromCartesian(position).height;
      this.entityGraphic.height = height;
      this.style.height = this.formatNum(height, 2);
    }

    _updateHeight(height) {
      this.entityGraphic.height = height;
      this.style.height = this.formatNum(height, 2);

      const positions = this.positions;
      for (let i = 0, len = positions.length; i < len; i++) {
        positions[i] = setPositionsHeight(positions[i], height);
      }
      for (let i = 0, len = this.draggers.length; i < len; i++) {
        const draggerItem = this.draggers[i];
        draggerItem.position = setPositionsHeight(draggerItem.position, height);
      }

      this.fire(EventType.editStyle);
    }
  }

  /**
   * 走廊 支持的样式信息
   *
   * @typedef {Object} CorridorEntity.StyleOptions
   *
   * @property {Number} [width = 100] 走廊宽度，指定走廊边缘之间的距离。
   * @property {String|Cesium.CornerType} [cornerType] 指定边角的样式。
   *
   * @property {Number|Cesium.Property} [height = 0] 高程，圆相对于椭球面的高度。
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
   * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。
   * @property {Cesium.HeightReference} [extrudedHeightReference=Cesium.HeightReference.NONE] 指定挤压高度相对于什么的属性。
   *
   * @property {boolean} [fill=true] 是否填充。
   * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {Number} [outlineWidth = 1] 边框宽度
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定每个纬度和经度之间的距离。
   *
   * @property {Boolean} [hasShadows = false] 是否投射阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定走廊是投射还是接收来自光源的阴影。
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
   * @property {Number} [zIndex = 0] 层级顺序，用于排序。只有在高度和挤压高度未定义，并且走廊是静态的情况下才有效果。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {CorridorEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see Cesium.CorridorGraphics.ConstructorOptions
   */

  /**
   * 走廊  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {CorridorEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePolyEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class CorridorEntity extends BasePolyEntity {
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.CorridorGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.corridor
    }

    /**
     * 编辑处理类
     * @type {EditCorridor}
     * @readonly
     */
    get EditClass() {
      return EditCorridor
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      const addattr = {
        corridor: CorridorStyleConver.toCesiumVal(this.style, {}, true)
      };
      addattr.corridor.positions = this.positions;

      this._entity = this._createEntity(addattr);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return CorridorStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      CorridorStyleConver.toCesiumVal(style, this.entityGraphic, true);

      if (newStyle && (Cesium__namespace.defined(newStyle.diffHeight) || Cesium__namespace.defined(newStyle.height))) {
        this._updateHeight();
      }
    }

    _updatePositionsHook() {
      this.entityGraphic.positions = this.positions;

      this._updateLabelPosition();

      // 如果在编辑中，更新编辑的拖拽点。
      this._updateEditDraggers();
    }

    // 高度处理
    _updateHeight(fetchStyle = true) {
      if (this.style.clampToGround) {
        return
      }

      let height = 0;
      if (fetchStyle && Cesium__namespace.defined(this.style.height)) {
        height = this.style.height;
      } else {
        height = getMaxHeight(this._positions_draw || this._positions);
      }
      this.entityGraphic.height = height;
      this.style.height = height;

      // 存在extrudedHeight高度设置时
      if (Cesium__namespace.defined(this.style.diffHeight)) {
        if (Cesium__namespace.defined(this.style.diffHeight) && this.style.diffHeight !== 0) {
          this.entityGraphic.extrudedHeight = height + this.style.diffHeight;
        } else {
          this.entityGraphic.extrudedHeight = undefined;
        }
      }
    }

    //= =================Draw绘制相关=================

    updateAttrForDrawing(isEditing) {
      if (!isEditing) {
        if (!this.style.clampToGround) {
          const maxHight = getMaxHeight(this._positions_draw);
          if (maxHight !== 0) {
            this.entityGraphic.height = maxHight;
            this.style.height = maxHight;

            if (Cesium__namespace.defined(this.style.diffHeight)) {
              if (Cesium__namespace.defined(this.style.diffHeight) && this.style.diffHeight !== 0) {
                this.entityGraphic.extrudedHeight = maxHight + Number(this.style.diffHeight);
              } else {
                this.entityGraphic.extrudedHeight = undefined;
              }
            }
          }
        }
      } else {
        this._updateHeight();
      }
    }
  }

  // 注册下
  register$4("corridor", CorridorEntity);

  /**
   * Wall对象 标绘处理对应的编辑类，
   *
   * @export
   * @class EditWall
   * @extends {EditPoly}
   */
  class EditWall extends EditPoly {
    bindDraggers() {
      const positions = this.positions;
      const style = this.style;
      const hasMidPoint = this.hasMidPoint; // 是否有新增点

      for (let i = 0, len = positions.length; i < len; i++) {
        const position = positions[i];

        // 各顶点
        const dragger = this.createDragger({
          position: position,
          onDrag: (dragger, position) => {
            positions[dragger.index] = position;

            //= ===========高度调整拖拽点处理=============
            if (this._heightDraggers && this._heightDraggers.length > 0) {
              this._heightDraggers[dragger.index].position = addPositionsHeight(position, style.diffHeight);
            }

            //= ===========新增点拖拽点处理=============
            if (hasMidPoint) {
              if (dragger.index > 0) {
                // 与前一个点之间的中点
                this.draggers[dragger.index * 2 - 1].position = getMidpoint(position, positions[dragger.index - 1], new Cesium__namespace.Cartesian3());
              }
              if (dragger.index < positions.length - 1) {
                // 与后一个点之间的中点
                this.draggers[dragger.index * 2 + 1].position = getMidpoint(position, positions[dragger.index + 1]);
              }
            }

            //= ===========整体平移移动点处理=============
            const positionMove = centerOfMass(positions);
            this._draggerMove.position = positionMove;
          }
        });
        dragger.index = i;
        this.draggers.push(dragger);

        // 中间点，拖动后新增点
        if (this.hasMidPoint && (this.hasClosure || (!this.hasClosure && i < len - 1))) {
          const nextIndex = (i + 1) % len;
          const midpoint = getMidpoint(position, positions[nextIndex]);

          const draggerMid = this.createDragger({
            position: midpoint,
            type: PointType.AddMidPoint,
            tooltip: this._map.getLangText("_增加点"),
            onDragStart: (dragger, position) => {
              this.positions.splice(dragger.index, 0, position); // 插入点
              this.updateAttrForEditing();
            },
            onDrag: (dragger, position) => {
              this.positions[dragger.index] = position;
            },
            onDragEnd: (dragger, position) => {
              this._fireAddPoint(dragger, position); // 新增点事件
              this.updateDraggers();
            }
          });
          draggerMid.index = nextIndex;
          this.draggers.push(draggerMid);
        }
      }

      // 整体平移移动点
      this._bindMoveAllDragger();

      // 创建高程拖拽点
      this._bindHeightDraggers();
    }

    // 高度调整拖拽点
    _bindHeightDraggers() {
      if (!this._graphic._hasHeightEdit) {
        return
      }

      this._heightDraggers = [];

      const positions = this.positions;
      const diffHeight = Number(this.style.diffHeight);

      for (let i = 0, len = positions.length; i < len; i++) {
        const position = addPositionsHeight(positions[i], diffHeight);

        const dragger = this.createDragger({
          position: position,
          type: PointType.MoveHeight,
          tooltip: this._map.getLangText("_修改高度"),
          onDrag: (dragger, position) => {
            const thisHeight = Cesium__namespace.Cartographic.fromCartesian(position).height;
            this.style.diffHeight = formatNum$1(thisHeight - this._graphic._minimumHeights[dragger.index], 2);

            for (let i = 0; i < positions.length; i++) {
              if (i === dragger.index) {
                continue
              }
              this._heightDraggers[i].position = addPositionsHeight(positions[i], this.style.diffHeight);
            }
            this.updateAttrForEditing();
            this.fire(EventType.editStyle);
          }
        });
        dragger.index = i;

        this.draggers.push(dragger);
        this._heightDraggers.push(dragger);
      }
    }
  }

  /**
   * 墙 支持的样式信息
   *
   * @typedef {Object} WallEntity.StyleOptions
   *
   * @property {Number} [diffHeight = 100] 墙高
   * @property {Array<number>} [minimumHeights] 没有指定diffHeight时，可以指定用于墙壁底部而不是球体表面的高度数组。
   * @property {Array<number>} [maximumHeights] 没有指定diffHeight时，可以指定用于墙顶的高度数组，而不是每个位置的高度。
   *
   * @property {Boolean} [fill = true] 是否填充
   * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [closure = false] 是否闭合, 在positions是属性机制的回调对象时无效
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String} [outlineWidth = 1] 边框宽度
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定墙壁是投射还是接收来自光源的阴影。
   *
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定每个纬度点和经度点之间的角距离。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {WallEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions|Object} [label] 支持附带文字的显示，额外支持：<br />
  //  * @property {String|LngLatPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
  //  * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
   *
   * @see Cesium.WallGraphics.ConstructorOptions
   */

  /**
   * 墙  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {WallEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class WallEntity
   * @extends {BasePolyEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class WallEntity extends BasePolyEntity {
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.WallGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.wall
    }

    /**
     * 编辑处理类
     * @type {EditWall}
     * @readonly
     */
    get EditClass() {
      return EditWall
    }

    _mountedHook() {
      this.style.diffHeight = this.style.diffHeight || 100; // 必须得有墙高

      const addattr = {
        wall: WallStyleConver.toCesiumVal(this.style, {}, true)
      };

      if (this.style.closure && this.positions?.length > 0) {
        addattr.wall.positions = this.positions.concat(this.positions[0]);
      } else {
        addattr.wall.positions = this.positions;
      }

      if (!this.style.maximumHeights || !this.style.minimumHeights) {
        this._updateMaxMinHeights(addattr);
      }
      this._entity = this._createEntity(addattr);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return WallStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      WallStyleConver.toCesiumVal(style, this.entityGraphic, true);
      if (newStyle?.diffHeight) {
        this._updateMaxMinHeights(this._entity);
      }
    }

    _updatePositionsHook() {
      if (this.style.closure && this.positions?.length > 0) {
        this.entityGraphic.positions = this.positions.concat(this.positions[0]);
      } else {
        this.entityGraphic.positions = this.positions;
      }

      if (!this.style.maximumHeights || !this.style.minimumHeights) {
        this._updateMaxMinHeights(this._entity);
      }

      this._updateLabelPosition();

      // 如果在编辑中，更新编辑的拖拽点。
      this._updateEditDraggers();
    }

    _updateMaxMinHeights(target) {
      const points = this.points;
      if (!points || points.length === 0) {
        return
      }

      const len = points.length;

      const minimumHeights = new Array(len);
      const maximumHeights = new Array(len);

      for (let i = 0; i < len; i++) {
        const height = points[i].alt;
        minimumHeights[i] = height;
        maximumHeights[i] = height + this.style.diffHeight;
      }
      if (this.style.closure && len > 0) {
        minimumHeights.push(minimumHeights[0]);
        maximumHeights.push(maximumHeights[0]);
      }

      this._minimumHeights = minimumHeights;
      this._maximumHeights = maximumHeights;

      if (target) {
        if (!(target.wall.minimumHeights instanceof Cesium__namespace.CallbackProperty)) {
          target.wall.minimumHeights = minimumHeights;
        }
        if (!(target.wall.maximumHeights instanceof Cesium__namespace.CallbackProperty)) {
          target.wall.maximumHeights = maximumHeights;
        }
      }
    }

    //= =================Draw绘制相关=================
    // 将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑
    _setPositionsToCallback() {
      if (this._isCallbackPositions) {
        return
      }
      super._setPositionsToCallback();

      this.entityGraphic.minimumHeights = new Cesium__namespace.CallbackProperty((time) => {
        return this._minimumHeights
      }, false);
      this.entityGraphic.maximumHeights = new Cesium__namespace.CallbackProperty((time) => {
        return this._maximumHeights
      }, false);
    }

    _positions_CallbackProperty() {
      if (this.style.closure && this._positions_draw?.length > 0) {
        return this._positions_draw.concat(this._positions_draw[0]) // 闭合线
      } else {
        return this._positions_draw
      }
    }

    // 坐标CallbackProperty属性改为实际值
    _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return
      }
      super._cancelPositionsCallback();

      this.entityGraphic.minimumHeights = this._minimumHeights;
      this.entityGraphic.maximumHeights = this._maximumHeights;
    }

    updateAttrForDrawing(isEditing) {
      this._updateMaxMinHeights(this._entity);
    }
  }
  // 注册下
  register$4("wall", WallEntity);

  /**
   * Rectangle对象 标绘处理对应的编辑类，
   *
   * @export
   * @class EditRectangle
   * @extends {EditPoly}
   */
  class EditRectangle extends EditPoly {
    bindDraggers() {
      const positions = this.positions;

      for (let i = 0, len = positions.length; i < len; i++) {
        const position = this.updatePositionsHeightByAttr(positions[i]);

        // 各顶点
        const dragger = this.createDragger({
          position: position,
          onDrag: (dragger, position) => {
            const time = this._map.clock.currentTime;
            const newHeight = getCesiumValue(this.entityGraphic.height, Number, time);

            this.positions[dragger.index] = position;

            if (this.entityGraphic.height !== undefined) {
              for (let i = 0, len = this.draggers.length; i < len; i++) {
                const draggerItem = this.draggers[i];

                const position = setPositionsHeight(this.positions[draggerItem.index], newHeight);
                draggerItem.position = position;
                this.positions[draggerItem.index] = position;
              }
            }

            //= ===========高度调整拖拽点处理=============
            if (this._heightDraggers && this._heightDraggers.length > 0) {
              const extrudedHeight = getCesiumValue(this.entityGraphic.extrudedHeight, Number, time);
              this._heightDraggers[dragger.index].position = setPositionsHeight(position, extrudedHeight);
            }

            //= ===========整体平移移动点处理=============
            let positionMove = centerOfMass(this.positions);
            positionMove = this.updatePositionsHeightByAttr(positionMove);
            this._draggerMove.position = positionMove;
          }
        });
        dragger.index = i;
        this.draggers.push(dragger);
      }

      // 整体平移移动点
      this._bindMoveAllDragger();

      // 创建高程拖拽点
      if (this.entityGraphic.extrudedHeight) {
        this._bindHeightDraggers();
      }
    }

    // 根据属性更新坐标
    updatePositionsHeightByAttr(position) {
      if (this.clampToGround) {
        // 贴地时求贴模型和贴地的高度
        position = getSurfacePosition(this._map.scene, position);
      }
      if (this.entityGraphic.height !== undefined) {
        const newHeight = getCesiumValue(this.entityGraphic.height, Number, this._map.clock.currentTime);
        position = setPositionsHeight(position, newHeight);
      }
      return position
    }

    _updateHeight(height) {
      this.entityGraphic.height = height;
      this.style.height = this.formatNum(height, 2);

      const positions = this.positions;
      for (let i = 0, len = positions.length; i < len; i++) {
        positions[i] = setPositionsHeight(positions[i], height);
      }

      for (let i = 0, len = this.draggers.length; i < len; i++) {
        const draggerItem = this.draggers[i];
        draggerItem.position = setPositionsHeight(draggerItem.position, height);
      }

      this.fire(EventType.editStyle);
    }
  }

  /**
   * 矩形 支持的样式信息
   *
   * @typedef {Object} RectangleEntity.StyleOptions
   *
   *
   *
   * @property {Boolean} [fill = true] 是否填充

   * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {Number} [outlineWidth = 1] 边框宽度
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   * @property {PolylineEntity.StyleOptions} [outlineStyle] 边框的完整自定义样式，会覆盖outlineWidth、outlineColor等参数。
   *
   * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
   * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。
   * @property {Cesium.HeightReference} [extrudedHeightReference=Cesium.HeightReference.NONE] 指定挤压高度相对于什么的属性。
   *
   * @property {Number} [rotation = 0] 旋转角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [rotationDegree = 0] 旋转角度（度数值，0-360度），与rotation二选一
   * @property {Number} [stRotation = 0] 矩形纹理的角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [stRotationDegree = 0] 矩形纹理的角度（度数值，0-360度），与stRotation二选一
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定矩形是投射还是接收来自光源的阴影。
   *
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定矩形上各点之间的角距离。
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
   * @property {Number} [zIndex = 0] 层级顺序，指定用于排序地面几何的zIndex。只有当矩形为常量且没有指定height或extrdedheight时才有效果。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {RectangleEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see Cesium.RectangleGraphics.ConstructorOptions
   */

  /**
   * 矩形  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array|Cesium.PositionProperty|Cesium.CallbackProperty} [options.positions] 坐标位置
   * @param {Cesium.Rectangle|Cesium.PositionProperty|Cesium.CallbackProperty} [options.rectangle]  矩形范围，与positions二选一。
   * @param {RectangleEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class RectangleEntity
   * @extends {BasePolyEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class RectangleEntity extends BasePolyEntity {
    constructor(options = {}) {
      super(options);

      // 配置的参数
      this._minPointNum = 2; // 至少需要点的个数
      this._maxPointNum = 2; // 最多允许点的个数

      if (this.options.rectangle) {
        this._rectangle = this.options.rectangle;
      } else if (this.options.coordinates) {
        this._rectangle = this.options.coordinates;
      }
    }

    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.RectangleGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.rectangle
    }

    /**
     * 编辑处理类
     * @type {EditRectangle}
     * @readonly
     */
    get EditClass() {
      return EditRectangle
    }

    // 中心点坐标，覆盖父类
    get center() {
      const rectangle = getCesiumValue(this.rectangle);
      if (!rectangle) {
        return null
      }
      const position = Cesium__namespace.Cartographic.toCartesian(Cesium__namespace.Rectangle.center(rectangle));
      return position
    }

    /**
     * 矩形的边线坐标集合（笛卡尔坐标）
     * @type {Cesium.Cartesian3[]}
     */
    get outlinePositions() {
      if (this._entity) {
        this._outlinePositions = getOutlinePositions(this._entity);
      }
      return this._outlinePositions
    }

    set outlinePositions(value) {
      this._outlinePositions = value;
    }

    /**
     * 矩形的边线坐标集合（经纬度二维数组），示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7], …… ]
     * @type {Array[]}
     * @readonly
     */
    get outlineCoordinates() {
      return cartesians2lonlats(this.outlinePositions)
    }

    /**
     * 坐标数据对应的矩形边界对象
     * @type {Cesium.Rectangle}
     */
    get rectangle() {
      if (!this._rectangle && this.positions) {
        this._rectangle = Cesium__namespace.Rectangle.fromCartesianArray(this.positions);
      }
      return this._rectangle
    }

    set rectangle(value) {
      if (this.editing?.enabled && !(value instanceof Cesium__namespace.CallbackProperty)) {
        this._rectangle_draw = value;
      } else {
        this._rectangle = value;
        if (this._entity) {
          this.entityGraphic.coordinates = value;
        }
      }
    }

    get points() {
      const _points = [];

      let _positions;
      if (this._positions_draw) {
        _positions = this._positions_draw;
      } else {
        _positions = this._positions;
      }

      if (!_positions) {
        _positions = getOutlinePositions(this._entity, false);
      }

      _positions.forEach(function (item) {
        const _point = LngLatPoint.parse(item);
        if (!_point || !_point.valid()) {
          return
        }
        _points.push(_point);
      });
      this._points = _points;

      return this._points
    }

    /**
     * 周长 距离（单位：米）
     * @type {Number}
     * @readonly
     */
    get distance() {
      return getDistance(this.outlinePositions, true)
    }

    // 面积（单位：平方米）
    get area() {
      return getSurfaceArea(this.outlinePositions)
    }

    // 获取entity的实际坐标值
    getEntityPositions() {
      if (!this._entity.rectangle) {
        return null
      }
      const re = getCesiumValue(this._entity.rectangle.coordinates, Cesium__namespace.Rectangle); // Rectangle
      const height = getCesiumValue(this._entity.rectangle.height, Number) || 0;

      const ptMin = Cesium__namespace.Cartesian3.fromRadians(re.west, re.south, height); // 西、南
      const ptMax = Cesium__namespace.Cartesian3.fromRadians(re.east, re.north, height); // 东、北
      return [ptMin, ptMax]
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      const addattr = {
        rectangle: RectangleStyleConver.toCesiumVal(this.style, {}, true)
      };
      addattr.rectangle.coordinates = this.rectangle;

      if (this._positions instanceof Cesium__namespace.CallbackProperty) {
        // 回调中返回的坐标数组时
        addattr.rectangle.coordinates = new Cesium__namespace.CallbackProperty((time) => {
          const positions = this._positions.getValue(time);
          if (positions && positions.length > 0) {
            this._rectangle = Cesium__namespace.Rectangle.fromCartesianArray(positions);
            return this._rectangle
          } else {
            return undefined
          }
        }, false);
      }

      this._entity = this._createEntity(addattr);

      this._updateHeight();

      // 边线
      this._updateOutlineStyle(this._getOutlinePositions(), this.style);
      if (this._entity_outlines && this.entityGraphic.coordinates instanceof Cesium__namespace.CallbackProperty) {
        this._updateOutlineToCallback();
      }


      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return RectangleStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      RectangleStyleConver.toCesiumVal(style, this.entityGraphic, true);

      if (Cesium__namespace.defined(newStyle.diffHeight) || Cesium__namespace.defined(newStyle.height)) {
        // 高度处理
        this._updateHeight();
      }
    }

    _updatePositionsHook() {
      if (this.positions) {
        this.rectangle = Cesium__namespace.Rectangle.fromCartesianArray(this.positions);
      } else {
        this._rectangle_draw = Cesium__namespace.Rectangle.fromCartesianArray(this._positions_draw);
      }

      this.outlinePositions = getOutlinePositions(this._entity);

      // 边线处理
      this._updateOutlineStyle(this._getOutlinePositions(), this.style);

      // 中心文本处理
      this._updateLabelPosition();

      // 高度处理
      this._updateHeight();

      // 如果在编辑中，更新编辑的拖拽点。
      this._updateEditDraggers();
    }

    _getOutlineStyle(style, exStyle) {
      const outlineStyle = super._getOutlineStyle(style, exStyle);
      outlineStyle.arcType = Cesium__namespace.ArcType.RHUMB;
      return outlineStyle
    }

    _getOutlinePositions() {
      return [this.outlinePositions]
    }

    /**
     * 将矢量数据导出为GeoJSON格式规范对象。
     * @param {Object} [options] 参数对象:
     * @param {Boolean} [options.outline] 是否导出边线的坐标
     * @param {Boolean} [options.closure] 导出outline时，是否闭合，true时会添加第0个点进行闭合。
     * @param {Boolean} [options.noAlt] 不导出高度值
     * @return {Object} GeoJSON格式规范对象
     */
    toGeoJSON(options) {
      return super.toGeoJSON(options)
    }

    _getGeoJsonGeometry(options) {
      if (options?.outline) {
        return { type: "Polygon", coordinates: [this.getOutlineCoordinates(options?.closure, options?.noAlt)] }
      } else {
        return { type: "LineString", coordinates: this.getCoordinates(options?.noAlt) }
      }
    }

    //= =================Draw绘制相关=================
    // 将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑
    _setPositionsToCallback() {
      if (this._isCallbackPositions) {
        return
      }
      this._isCallbackPositions = true;

      if (this.positions) {
        this._positions_draw = this.positions;
        this._rectangle_draw = Cesium__namespace.Rectangle.fromCartesianArray(this.positions);
      } else {
        this._positions_draw = [];
        this._rectangle_draw = null;
      }

      this.rectangle = new Cesium__namespace.CallbackProperty((time) => {
        return this._rectangle_draw
      }, false);

      // 存在边线时
      this._updateOutlineToCallback();
    }

    // 坐标CallbackProperty属性改为实际值
    _cancelPositionsCallback() {
      if (!this._isCallbackPositions) {
        return
      }
      this._isCallbackPositions = false;

      this._positions = this._positions_draw;
      this.rectangle = this._rectangle_draw;

      delete this._positions_draw;
      delete this._rectangle_draw;

      this._cancelOutlinePositionsCallback();
    }

    updateAttrForDrawing(isEditing) {
      this._rectangle_draw = Cesium__namespace.Rectangle.fromCartesianArray(this._positions_draw);
      if (this._entity_outlines) {
        this._updateOutlineToCallback();
        this._outlinePositions = getOutlinePositions(this._entity);
      }

      // 高度处理
      this._updateHeight(false);
    }

    // 高度处理
    _updateHeight(fetchStyle = true) {
      if (this.style.clampToGround) {
        return
      }

      let height = 0;
      if (fetchStyle && Cesium__namespace.defined(this.style.height)) {
        height = this.style.height;
      } else {
        height = getMaxHeight(this._positions_draw || this._positions);
      }
      this.entityGraphic.height = height;
      this.style.height = height;

      // 存在extrudedHeight高度设置时
      if (Cesium__namespace.defined(this.style.diffHeight)) {
        if (Cesium__namespace.defined(this.style.diffHeight) && this.style.diffHeight !== 0) {
          this.entityGraphic.extrudedHeight = height + this.style.diffHeight;
        } else {
          this.entityGraphic.extrudedHeight = undefined;
        }
      }

      this.fire(EventType.editStyle);
    }

    /**
     * 获取矩形的4个边线坐标集合（笛卡尔坐标）
     *
     * @param {Boolean} [closure=true] 是否闭合，true时会添加第0个点进行闭合。
     * @return  {Cesium.Cartesian3[]} 边线坐标数组
     */
    getOutlinePositions(closure) {
      return getOutlinePositions(this._entity, closure)
    }

    /**
     * 获取矩形的4个边线坐标集合（经纬度二维数组）
     *
     * @param {Boolean} [closure=true] 是否闭合，true时会添加第0个点进行闭合。
     * @param {Boolean} [noAlt] 是否包含高度值
     * @return  {Array[]} 边线坐标数组（经纬度二维数组）
     */
    getOutlineCoordinates(closure, noAlt) {
      return cartesians2lonlats(this.getOutlinePositions(closure), noAlt)
    }

    /**
     * 获取数据的矩形边界
     * @param {Boolean} [options] 控制参数
     * @param {Boolean} [options.isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */
    getRectangle(options) {
      const rectangle = this._rectangle_draw || this.rectangle;

      if (options?.isFormat) {
        return formatRectangle(rectangle)
      } else {
        return rectangle
      }
    }

    /**
     * 判断点是否在矩形内
     *
     * @param {Cesium.Cartesian3|LngLatPoint} position 需要判断的点
     * @return {Boolean} 是否在矩形内
     */
    isInPoly(position) {
      const rectangle = getCesiumValue(this._entity.rectangle?.coordinates, Cesium__namespace.Rectangle);

      const isInRectangle = Cesium__namespace.Rectangle.contains(rectangle, LngLatPoint.parse(position).toCartographic());
      return isInRectangle
    }

    // 飞行定位至图层数据所在的视角
    flyTo(options = {}) {
      if (!this._map) {
        return
      }
      options.clampToGround = this.style.clampToGround;
      this._map.flyToExtent(getCesiumValue(this.rectangle, Cesium__namespace.Rectangle), options);
      return this
    }
  }
  // 注册下
  register$4("rectangle", RectangleEntity);

  // 获取entity对应的 边界 的坐标
  function getOutlinePositions(entity, closure = true) {
    if (!entity || !entity.rectangle) {
      return []
    }

    const re = getCesiumValue(entity.rectangle.coordinates, Cesium__namespace.Rectangle);
    if (!re) {
      return []
    }

    const rotation = getCesiumValue(entity.rectangle.rotation, Number) || 0; // Rectangle
    const height = getCesiumValue(entity.rectangle.height, Number) || 0;

    const arr = getRectangleOuterPositions({
      rectangle: re,
      rotation: rotation,
      height: height
    });

    if (closure) {
      arr.push(arr[0]);
    }
    return arr
  }

  // 获取entity的多个坐标【只取多圈的坐标，如挖洞多边形】
  function getAllPositions(entity) {
    const arr = getCesiumValue(entity.polygon.hierarchy, Cesium__namespace.PolygonHierarchy);
    const result = getHierarchyVal(arr);
    return result
  }

  // 获取entity的坐标【只取最外层圈坐标】
  function getPositions(entity, isShowPositions) {
    if (!isShowPositions && entity._positions_draw && entity._positions_draw.length > 0) {
      return entity._positions_draw // 箭头标绘等情形时，取绑定的数据
    }
    let arr = getCesiumValue(entity.polygon.hierarchy, Cesium__namespace.PolygonHierarchy);
    if (arr && arr instanceof Cesium__namespace.PolygonHierarchy) {
      arr = arr.positions;
    }
    return arr
  }

  // 获取entity的挖洞内环坐标
  function getHolesPositions(entity) {
    const arr = getCesiumValue(entity.polygon.hierarchy, Cesium__namespace.PolygonHierarchy);

    const result = getHierarchyVal(arr);
    if (result.length > 1) {
      return result.slice(1)
    } else {
      return null
    }
  }

  function getHierarchyVal(arr) {
    if (!arr) {
      return []
    }

    if (arr && arr instanceof Cesium__namespace.PolygonHierarchy) {
      let result = [arr.positions];
      for (let i = 0, len = arr.holes.length; i < len; i++) {
        const item = arr.holes[i]; // PolygonHierarchy
        result = result.concat(getHierarchyVal(item));
      }
      return result
    } else {
      return [arr]
    }
  }

  // 取PolygonHierarchy
  function getPolygonHierarchy(coordinates, defHeight) {
    if (coordinates.length === 0) {
      return new Cesium__namespace.PolygonHierarchy()
    }

    const holes = [];
    if (coordinates.length > 1) {
      for (let i = 1, len = coordinates.length; i < len; i++) {
        holes.push(new Cesium__namespace.PolygonHierarchy(lonlats2cartesians(coordinates[i], defHeight)));
      }
    }

    const positions = coordinates[0];
    const hierarchy = new Cesium__namespace.PolygonHierarchy(lonlats2cartesians(positions, defHeight), holes);
    return hierarchy
  }

  // 取PolygonHierarchy
  function getPolygonHierarchy2(coordinates) {
    if (coordinates.length === 0) {
      return new Cesium__namespace.PolygonHierarchy()
    }

    const holes = [];
    if (coordinates.length > 1) {
      for (let i = 1, len = coordinates.length; i < len; i++) {
        holes.push(new Cesium__namespace.PolygonHierarchy(LngLatArray.toCartesians(coordinates[i])));
      }
    }

    const positions = coordinates[0];
    const hierarchy = new Cesium__namespace.PolygonHierarchy(LngLatArray.toCartesians(positions), holes);
    return hierarchy
  }

  /**
   * Polygon对象 标绘处理对应的编辑类
   *
   * @export
   * @class EditPolygon
   * @extends {EditPoly}
   */
  class EditPolygon extends EditPoly {
    // 是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    get hasClosure() {
      return this._graphic.hasClosure ?? true
    }

    // 是否贴地
    get clampToGround() {
      return this.style.clampToGround ?? !getCesiumValue(this._graphic?.entityGraphic?.perPositionHeight, Boolean)
    }

    bindDraggers() {
      super.bindDraggers();

      // 多环面的编辑支持
      if (this._graphic._draw_holes?.length > 0) {
        for (let i = 0, len = this._graphic._draw_holes.length; i < len; i++) {
          this.bindHolesDraggers(this._graphic._draw_holes[i], i);
        }
      }
    }

    bindHolesDraggers(positions, holesIndex) {
      for (let i = 0, len = positions.length; i < len; i++) {
        const position = this.updatePositionsHeightByAttr(positions[i]);

        // 各顶点
        const dragger = this.createDragger({
          position: position,
          onDrag: (dragger, position) => {
            position = this.updatePositionsHeightByAttr(position);
            dragger.position = position;
            positions[dragger.index] = position;
          },
          // onDragStart: (dragger, position) => {
          //   for (let i = 0, len = this.draggers.length; i < len; i++) {
          //     this.draggers[i].show = false
          //   }
          // },
          onDragEnd: (dragger, position) => {
            this.updateDraggers();
          }
        });
        dragger.index = i;

        this.draggers.push(dragger);

        // 中间点，拖动后新增点
        if (this.hasMidPoint && (this.hasClosure || (!this.hasClosure && i < len - 1))) {
          const nextIndex = (i + 1) % len;
          let midpoint = getMidpoint(position, positions[nextIndex]);
          midpoint = this.updatePositionsHeightByAttr(midpoint);

          const draggerMid = this.createDragger({
            position: midpoint,
            type: PointType.AddMidPoint,
            tooltip: this._map.getLangText("_增加点"),
            onDragStart: (dragger, position) => {
              positions.splice(dragger.index, 0, position); // 插入点
            },
            onDrag: (dragger, position) => {
              positions[dragger.index] = position;
            },
            onDragEnd: (dragger, position) => {
              this._fireAddPoint(dragger, position); // 新增点事件
              this.updateDraggers();
            }
          });
          draggerMid.index = nextIndex;
          this.draggers.push(draggerMid);
        }
      }
    }
  }

  const nullColor$1 = new Cesium__namespace.Color(0.0, 0.0, 0.0, 0.01);

  /**
   * 面 支持的样式信息
   *
   * @typedef {Object} PolygonEntity.StyleOptions
   *
   * @property {Boolean} [fill = true] 是否填充

   * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   * @property {Boolean} [randomColor = false] 是否随机颜色
   *
   * @property {Number} [stRotation = 0] 多边形纹理的角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [stRotationDegree = 0] 多边形纹理的角度（度数值，0-360度），与stRotation二选一
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {Number} [outlineWidth = 1] 边框宽度
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   * @property {PolylineEntity.StyleOptions} [outlineStyle] 边框的完整自定义样式，会覆盖outlineWidth、outlineColor等参数。
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
   * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。
   * @property {Cesium.HeightReference} [extrudedHeightReference=Cesium.HeightReference.NONE] 指定挤压高度相对于什么的属性。
   *
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE]  指定每个纬度点和经度点之间的角距离。
   * @property {Boolean} [closeTop=true]  当为false时，离开一个挤压多边形的顶部打开。
   * @property {Boolean} [closeBottom=true]  当为false时，离开挤压多边形的底部打开。
   * @property {Cesium.ArcType} [arcType=Cesium.ArcType.GEODESIC]  多边形的边缘必须遵循的线条类型。
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定多边形是投射还是接收来自光源的阴影。
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {boolean} [perPositionHeight=false] 指定是否使用每个位置的高度。同clampToGround，与clampToGround反之
   * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
   * @property {Number} [zIndex = 0] 层级顺序，指定用于排序地面几何的zIndex。只有当多边形是常数且没有指定高度或挤压高度时才有效果。
   *
   *
   * @property {Number} [buffer] 对坐标进行缓冲扩大buffer指定的半径范围，单位：米。如用于单体化建筑物扩大点方便鼠标拾取。
   * @property {Number|Number[]} [setHeight=0] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
   * @property {Number|Number[]} [addHeight=0] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
   *
   * @property {PolygonEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions|Object} [label] 支持附带文字的显示，额外支持：<br />
  //  * @property {String|LngLatPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
  //  * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
   *
   * @see Cesium.PolygonGraphics.ConstructorOptions
   */

  /**
   * 面  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class PolygonEntity
   * @extends {BasePolyEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PolygonEntity extends BasePolyEntity {
    constructor(options = {}) {
      options.styleType = options.styleType ?? "polygon";
      super(options);

      // 配置的参数
      this._minPointNum = options.minPointNum ?? 3; // 至少需要点的个数
    }

    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {Cesium.PolygonGraphics}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.polygon
    }

    /**
     * 编辑处理类
     * @type {EditPolygon}
     * @readonly
     */
    get EditClass() {
      return EditPolygon
    }

    // 中心点坐标，覆盖父类
    get center() {
      return this.centerOfMass
    }

    /**
     * 周长 距离（单位：米）
     * @type {Number}
     * @readonly
     */
    get distance() {
      return getDistance(this.positionsShow, true)
    }

    /**
     * 实际显示的坐标数组 （笛卡尔坐标），
     * 如标绘中时positions对应的可能只是控制点坐标或CallbackProperty属性
     *
     * @type {Cesium.Cartesian3[]}
     * @readonly
     */
    get positionsShow() {
      let pots = getCesiumValue(this._positions);
      if (pots instanceof Cesium__namespace.PolygonHierarchy) {
        pots = pots.positions;
      }
      return this._positions_show ?? this.getShowPositions(pots)
    }

    /**
     * 对应的Cesium面entity内部位置对象
     * @type {Cesium.PolygonHierarchy}
     * @readonly
     */
    get hierarchy() {
      return this._hierarchy || this.entityGraphic?.hierarchy
    }

    /**
     * 位置坐标数组 （笛卡尔坐标）, 赋值时可以传入LatLngPoint数组对象 或 Cesium.PolygonHierarchy
     * @type {Cesium.Cartesian3[]}
     */
    get positions() {
      return this._positions
    }

    set positions(value) {
      if (!value) {
        return
      }

      if (value instanceof Cesium__namespace.PolygonHierarchy) {
        this._hierarchy = value;
        value = this._hierarchy.positions;
      }

      if (Array.isArray(value)) {
        // 判断是否为存在holes的面
        if (value.length > 0 && Array.isArray(value[0]) && value[0].length > 0) {
          const firstItem = value[0][0];
          if (Array.isArray(firstItem) && isNumber(firstItem[0])) {
            this._hierarchy = getPolygonHierarchy(value, this.style.height || this.style.setHeight || this.style.addHeight);
            value = this._hierarchy.positions;
          } else if (firstItem instanceof Cesium__namespace.Cartesian3) {
            this._hierarchy = getPolygonHierarchy2(value);
            value = this._hierarchy.positions;
          }
        }

        const _points = [];
        const _positions = [];
        value.forEach((item, index) => {
          const _point = LngLatPoint.parse(item);
          if (!_point) {
            return
          }
          // 按配置调整高度值
          let setHeight = this.style.setHeight;
          if (Cesium__namespace.defined(setHeight)) {
            if (isString(setHeight)) {
              setHeight = Number(template(setHeight, this.attr, true));
              if (isNaN(setHeight)) {
                setHeight = 0;
              }
            } else if (Array.isArray(setHeight)) {
              setHeight = setHeight[index] || 0;
            }
            _point.alt = setHeight;
          }
          const addHeight = this.getAddHeight(index);
          if (addHeight !== 0) {
            _point.alt = _point.alt + addHeight;
          }

          _points.push(_point);
          _positions.push(_point.toCartesian());
        });
        this._points = _points;
        if (this.editing?.enabled) {
          this._positions_draw = _positions;
        } else {
          this._hierarchy = null;
          this._positions = _positions;
        }
      } else {
        this._positions = value;
      }

      this._positions_show = null;

      if (this._entity) {
        this._updatePositionsHook();
      }

      this.fire(EventType.updatePosition, { positions: this._positions });
    }

    // 获取entity的实际坐标值
    getEntityPositions() {
      return getPositions(this._entity)
    }

    // 方便子类覆盖
    getShowPositions(positions) {
      return positions
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      const addattr = {
        polygon: PolygonStyleConver.toCesiumVal(this.style, {}, true)
      };

      if (this._positions instanceof Cesium__namespace.CallbackProperty) {
        const testType = this._positions.getValue(this._map.clock.currentTime);
        if (testType && Array.isArray(testType)) {
          // 回调中返回的坐标数组时
          const hierarchy = new Cesium__namespace.PolygonHierarchy();
          addattr.polygon.hierarchy = new Cesium__namespace.CallbackProperty((time) => {
            const positions = this._positions.getValue(time);
            this._positions_show = this.getShowPositions(positions);
            hierarchy.positions = this._positions_show;
            if (this._entity_outlines && this._positions_show?.length > 0) {
              this.outlinePositions = this._positions_show.concat(this._positions_show[0]);
            }
            return hierarchy
          }, false);
          this._hierarchy = hierarchy;
        } else {
          addattr.polygon.hierarchy = this._positions;
        }
      } else if (this._hierarchy) {
        addattr.polygon.hierarchy = this._hierarchy;
      } else {
        if (!this._positions_show) {
          this._positions_show = this.getShowPositions(this.positions);
        }
        addattr.polygon.hierarchy = new Cesium__namespace.PolygonHierarchy(this._positions_show);
      }
      this._entity = this._createEntity(addattr);

      // 存在extrudedHeight高度设置时
      this._updateDiffHeight();

      this._bindExType();

      // 边线
      this._updateOutlineStyle(this._getOutlinePositions(), this.style); // 边线
      if (this._entity.polygon.hierarchy instanceof Cesium__namespace.CallbackProperty) {
        this._updateOutlineToCallback();
      }

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    // 是特殊的面类型的处理
    _bindExType() {
      // 如果是建筑物时
      const buildings = this.options.buildings || this._layer.options.buildings;
      if (buildings) {
        if (buildings.bottomHeight) {
          const bottomHeight = Number(this.attr[buildings.bottomHeight] || 0); // 底部高度
          this._entity.polygon.height = bottomHeight;
        }

        const floor = Number(this.attr[buildings.cloumn] || 1); // 层数
        let height; // 层高
        if (isNumber(buildings.height)) {
          height = buildings.height;
        } else if (isString(buildings.height)) {
          height = this.attr[buildings.height] || height;
        } else {
          height = 3.5; // 默认值
        }
        const bottomHeight = getCesiumValue(this._entity.polygon.height) || 0;
        this._entity.polygon.extrudedHeight = bottomHeight + floor * height; // 顶部高度
      }

      // 是建筑物单体化时(兼容v3.0)
      const dthCfg = this.options.dth || this._layer.options.dth;
      if (dthCfg) {
        this._entity.polygon.classificationType = Cesium__namespace.ClassificationType.BOTH;
        if (!Cesium__namespace.defined(this.style.color)) {
          this._entity.polygon.material = nullColor$1;
        }
        if (!Cesium__namespace.defined(this.style.height)) {
          this._entity.polygon.perPositionHeight = false;
        }
        this._entity.polygon.zIndex = 99;
      }
    }

    _updateDiffHeight() {
      if (!Cesium__namespace.defined(this.style.diffHeight) || this.entityGraphic.extrudedHeight instanceof Cesium__namespace.CallbackProperty) {
        return
      }

      // 存在extrudedHeight高度设置时
      if (Cesium__namespace.defined(this.style.diffHeight) && this.style.diffHeight !== 0) {
        let height = 0;
        if (Cesium__namespace.defined(this.style.height)) {
          height = this.style.height;
        } else {
          height = getMaxHeight(this._positions_draw || this._positions);
        }
        this.entityGraphic.extrudedHeight = height + this.style.diffHeight;
      } else {
        this.entityGraphic.extrudedHeight = undefined;
      }
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PolygonStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      PolygonStyleConver.toCesiumVal(style, this.entityGraphic, true);

      if (Cesium__namespace.defined(newStyle.diffHeight) || Cesium__namespace.defined(newStyle.height)) {
        this._updateDiffHeight();
      }
    }

    _updatePositionsHook() {
      if (this._positions instanceof Cesium__namespace.CallbackProperty) {
        this.entityGraphic.hierarchy = this._positions;
        if (this.editing?.enabled && this._hierarchy) {
          this._positions_show = this.getShowPositions(this._positions_draw);
          this._hierarchy.positions = this._positions_show;
        }
      } else if (this._hierarchy) {
        this.entityGraphic.hierarchy = this._hierarchy;
      } else {
        this._positions_show = this.getShowPositions(this.positions);
        this.entityGraphic.hierarchy = new Cesium__namespace.PolygonHierarchy(this._positions_show);
      }

      // 边线处理
      this._updateOutlineStyle(this._getOutlinePositions(), this.style);

      // 中心文本处理
      this._updateLabelPosition();

      // 存在extrudedHeight高度设置时
      this._updateDiffHeight();

      // 如果在编辑中，更新编辑的拖拽点。
      this._updateEditDraggers();
    }

    _getOutlinePositions() {
      return getAllPositions(this._entity)
    }

    /**
     * 将矢量数据导出为GeoJSON格式规范对象。
     * @param {Object} [options] 参数对象:
     * @param {Boolean} [options.closure] 是否闭合，true时增加第1个点。
     * @param {Boolean} [options.noAlt] 不导出高度值
     * @return {Object} GeoJSON格式规范对象
     */
    toGeoJSON(options) {
      return super.toGeoJSON(options)
    }

    _getGeoJsonGeometry(options) {
      let coords = this.getCoordinates(options?.noAlt);
      if (options?.closure && coords.length > 0) {
        coords.push(coords[0]);
      }

      // 多环面时
      if (this._hierarchy?.holes?.length > 0) {
        coords = [coords]; // 外环

        const arrHoles = getHolesPositions(this._entity);
        arrHoles.forEach((arr) => {
          coords.push(LngLatArray.toArray(arr)); // 内环
        });
      }

      return { type: "Polygon", coordinates: [coords] }
    }

    setCallbackPositions(positions) {
      this._setPositionsToCallback();

      this._positions_draw = positions;
      this._hierarchy.positions = positions;
    }

    //= =================Draw绘制相关=================
    _positions_CallbackProperty() {
      return this._hierarchy
    }

    _cancelPositionsCallback() {
      super._cancelPositionsCallback();
      this._hierarchy = null;
    }

    _startDrawHook() {
      super._startDrawHook();

      // 边线处理
      this._updateOutlineStyle(
        [
          new Cesium__namespace.CallbackProperty((time) => {
            return this.outlinePositions
          }, false)
        ],
        this.style,
        {
          show: true,
          width: 2,
          color: this.style.color
        }
      );
    }

    // 将坐标更改为CallbackProperty属性方式，编辑绘制时更加平滑
    _setPositionsToCallback() {
      if (this._isCallbackPositions) {
        return
      }

      this._draw_holes = getHolesPositions(this._entity);

      super._setPositionsToCallback();
    }

    updateAttrForDrawing(isEditing) {
      if (!this._hierarchy) {
        this._hierarchy = new Cesium__namespace.PolygonHierarchy();
        if (this._draw_holes) {
          this._hierarchy.holes = this._draw_holes;
        }
      }

      this._positions_show = this.getShowPositions(this._positions_draw);
      this._hierarchy.positions = this._positions_show;

      // 边线处理
      if (this._positions_show?.length > 0) {
        this.outlinePositions = this._positions_show.concat(this._positions_show[0]);
      }
      // 绘制2个点时显示线
      let exStyle;
      if (this._positions_draw.length < this._minPointNum) {
        exStyle = { show: true, width: 2, color: this.style.color };
      }
      this._updateOutlineToCallback();
      this._updateOutlineStyle(null, this.style, exStyle);

      // 存在extrudedHeight高度设置时
      this._updateDiffHeight();
    }
  }
  // 注册下
  register$4("polygon", PolygonEntity);

  /**
   * 获取entity的坐标【只取最外层圈坐标】
   *
   * @param {Cesium.Entity} entity polygon面对象
   * @return  {Cesium.Cartesian3[]} 最外层圈坐标数组
   * @function
   */
  PolygonEntity.getPositions = getPositions;

  /**
   * 获取entity的多个坐标【只取多圈的坐标，如挖洞多边形】
   *
   * @param {Cesium.Entity} entity polygon面对象
   * @return  {Array[]}  多个 坐标数组
   * @function
   */
  PolygonEntity.getAllPositions = getAllPositions;

  /**
   * 椭圆、椭圆柱 支持的样式信息
   *
   * @typedef {Object} EllipseEntity.StyleOptions
   *
   * @property {Number|Cesium.Property} [semiMinorAxis = 100] 椭圆时的 短半径
   * @property {Number|Cesium.Property} [semiMajorAxis = 100] 椭圆时的 长半径
   *
   * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   * @property {Number} [diffHeight = 100] 高度差（圆柱本身的高度），与extrudedHeight二选一。
   * @property {number} [extrudedHeight] 指定椭圆的挤压面相对于椭球面的高度。
   * @property {Cesium.HeightReference} [extrudedHeightReference=Cesium.HeightReference.NONE] 指定挤压高度相对于什么的属性。
   *
   * @property {Boolean} [fill = true] 是否填充
   * @property {String} [materialType = "Color"] 填充类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#3388ff"] 填充颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {Number} [outlineWidth = 1] 边框宽度
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   * @property {PolylineEntity.StyleOptions} [outlineStyle] 边框的完整自定义样式，会覆盖outlineWidth、outlineColor等参数。
   *
   * @property {Number} [rotation = 0] 旋转角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [rotationDegree = 0] 旋转角度（度数值，0-360度），与rotation二选一
   * @property {Number} [stRotation = 0] 椭圆纹理的角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [stRotationDegree = 0] 椭圆纹理的角度（度数值，0-360度），与stRotation二选一
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定椭圆上各点之间的角距离。
   * @property {number} [numberOfVerticalLines=16] 指定沿轮廓的周长绘制的垂直线的数量。
   *
   * @property {Boolean} [hasShadows = false] 是否投射阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定椭圆是投射还是接收来自光源的阴影。
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
   * @property {Number} [zIndex = 0] 层级顺序。用于排序地面几何。只有在椭圆为常量且没有指定height或exturdedHeight时才有效果。
   *
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {CircleEntity.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   * @see Cesium.EllipseGraphics.ConstructorOptions
   * @see CircleEntity.StyleOptions
   */

  /**
   * 椭圆、椭圆柱  Entity对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {EllipseEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class EllipseEntity
   * @extends {CircleEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class EllipseEntity extends CircleEntity {
    constructor(options = {}) {
      super(options);

      this._maxPointNum = 3; // 最多允许点的个数
    }
  }

  // 注册下
  register$4("ellipse", EllipseEntity);

  /**
   * 相控阵雷达范围 Entity对象
   *
   * @alias RectangularSensorGraphics
   * @constructor
   *
   * @param {Object} [options] Object with the following properties:
   * @param {Number} [options.radius] 传感器的半径
   * @private
   */
  function RectangularSensorGraphics(options) {
    this._show = undefined;
    this._radius = undefined;
    this._xHalfAngle = undefined;
    this._yHalfAngle = undefined;
    this._lineColor = undefined;
    this._showSectorLines = undefined;
    this._showSectorSegmentLines = undefined;
    this._showLateralSurfaces = undefined;
    this._material = undefined;
    this._showDomeSurfaces = undefined;
    this._showDomeLines = undefined;
    this._showIntersection = undefined;
    this._intersectionColor = undefined;
    this._intersectionWidth = undefined;
    this._showThroughEllipsoid = undefined;
    this._gaze = undefined;
    this._showScanPlane = undefined;
    this._scanPlaneColor = undefined;
    this._scanPlaneMode = undefined;
    this._scanPlaneRate = undefined;
    this._definitionChanged = new Cesium__namespace.Event();
    this.merge(Cesium__namespace.defaultValue(options, Cesium__namespace.defaultValue.EMPTY_OBJECT));
  }

  Object.defineProperties(RectangularSensorGraphics.prototype, {
    definitionChanged: {
      get: function () {
        return this._definitionChanged
      }
    },

    show: Cesium__namespace.createPropertyDescriptor("show"),
    radius: Cesium__namespace.createPropertyDescriptor("radius"),
    xHalfAngle: Cesium__namespace.createPropertyDescriptor("xHalfAngle"),
    yHalfAngle: Cesium__namespace.createPropertyDescriptor("yHalfAngle"),
    lineColor: Cesium__namespace.createPropertyDescriptor("lineColor"),
    showSectorLines: Cesium__namespace.createPropertyDescriptor("showSectorLines"),
    showSectorSegmentLines: Cesium__namespace.createPropertyDescriptor("showSectorSegmentLines"),
    showLateralSurfaces: Cesium__namespace.createPropertyDescriptor("showLateralSurfaces"),
    material: Cesium__namespace.createMaterialPropertyDescriptor("material"),
    showDomeSurfaces: Cesium__namespace.createPropertyDescriptor("showDomeSurfaces"),
    showDomeLines: Cesium__namespace.createPropertyDescriptor("showDomeLines"),
    showIntersection: Cesium__namespace.createPropertyDescriptor("showIntersection"),
    intersectionColor: Cesium__namespace.createPropertyDescriptor("intersectionColor"),
    intersectionWidth: Cesium__namespace.createPropertyDescriptor("intersectionWidth"),
    showThroughEllipsoid: Cesium__namespace.createPropertyDescriptor("showThroughEllipsoid"),
    gaze: Cesium__namespace.createPropertyDescriptor("gaze"),
    showScanPlane: Cesium__namespace.createPropertyDescriptor("showScanPlane"),
    scanPlaneColor: Cesium__namespace.createPropertyDescriptor("scanPlaneColor"),
    scanPlaneMode: Cesium__namespace.createPropertyDescriptor("scanPlaneMode"),
    scanPlaneRate: Cesium__namespace.createPropertyDescriptor("scanPlaneRate")
  });

  RectangularSensorGraphics.prototype.clone = function (result) {
    if (!Cesium__namespace.defined(result)) {
      result = new RectangularSensorGraphics();
    }

    result.show = this.show;
    result.radius = this.radius;
    result.xHalfAngle = this.xHalfAngle;
    result.yHalfAngle = this.yHalfAngle;
    result.lineColor = this.lineColor;
    result.showSectorLines = this.showSectorLines;
    result.showSectorSegmentLines = this.showSectorSegmentLines;
    result.showLateralSurfaces = this.showLateralSurfaces;
    result.material = this.material;
    result.showDomeSurfaces = this.showDomeSurfaces;
    result.showDomeLines = this.showDomeLines;
    result.showIntersection = this.showIntersection;
    result.intersectionColor = this.intersectionColor;
    result.intersectionWidth = this.intersectionWidth;
    result.showThroughEllipsoid = this.showThroughEllipsoid;
    result.gaze = this.gaze;
    result.showScanPlane = this.showScanPlane;
    result.scanPlaneColor = this.scanPlaneColor;
    result.scanPlaneMode = this.scanPlaneMode;
    result.scanPlaneRate = this.scanPlaneRate;

    return result
  };

  RectangularSensorGraphics.prototype.merge = function (source) {
    if (!Cesium__namespace.defined(source)) {
      throw new Cesium__namespace.DeveloperError("source is required.")
    }
    this.slice = Cesium__namespace.defaultValue(this.slice, source.slice);
    this.show = Cesium__namespace.defaultValue(this.show, source.show);
    this.radius = Cesium__namespace.defaultValue(this.radius, source.radius);
    this.xHalfAngle = Cesium__namespace.defaultValue(this.xHalfAngle, source.xHalfAngle);
    this.yHalfAngle = Cesium__namespace.defaultValue(this.yHalfAngle, source.yHalfAngle);
    this.lineColor = Cesium__namespace.defaultValue(this.lineColor, source.lineColor);
    this.showSectorLines = Cesium__namespace.defaultValue(this.showSectorLines, source.showSectorLines);
    this.showSectorSegmentLines = Cesium__namespace.defaultValue(this.showSectorSegmentLines, source.showSectorSegmentLines);
    this.showLateralSurfaces = Cesium__namespace.defaultValue(this.showLateralSurfaces, source.showLateralSurfaces);
    this.material = Cesium__namespace.defaultValue(this.material, source.material);
    this.showDomeSurfaces = Cesium__namespace.defaultValue(this.showDomeSurfaces, source.showDomeSurfaces);
    this.showDomeLines = Cesium__namespace.defaultValue(this.showDomeLines, source.showDomeLines);
    this.showIntersection = Cesium__namespace.defaultValue(this.showIntersection, source.showIntersection);
    this.intersectionColor = Cesium__namespace.defaultValue(this.intersectionColor, source.intersectionColor);
    this.intersectionWidth = Cesium__namespace.defaultValue(this.intersectionWidth, source.intersectionWidth);
    this.showThroughEllipsoid = Cesium__namespace.defaultValue(this.showThroughEllipsoid, source.showThroughEllipsoid);
    this.gaze = Cesium__namespace.defaultValue(this.gaze, source.gaze);
    this.showScanPlane = Cesium__namespace.defaultValue(this.showScanPlane, source.showScanPlane);
    this.scanPlaneColor = Cesium__namespace.defaultValue(this.scanPlaneColor, source.scanPlaneColor);
    this.scanPlaneMode = Cesium__namespace.defaultValue(this.scanPlaneMode, source.scanPlaneMode);
    this.scanPlaneRate = Cesium__namespace.defaultValue(this.scanPlaneRate, source.scanPlaneRate);
  };

  var RectangularSensorVS = "attribute vec4 position;\nattribute vec3 normal;\nvarying vec3 v_position;\nvarying vec3 v_positionWC;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main() {\n  gl_Position = czm_modelViewProjection * position;\n  v_position = vec3(position);\n  v_positionWC = (czm_model * position).xyz;\n  v_positionEC = (czm_modelView * position).xyz;\n  v_normalEC = czm_normal * normal;\n}\n"; // eslint-disable-line

  var RectangularSensorFS = "#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform bool u_showIntersection;\nuniform bool u_showThroughEllipsoid;\n\nuniform float u_radius;\nuniform float u_xHalfAngle;\nuniform float u_yHalfAngle;\nuniform float u_normalDirection;\nuniform float u_type;\n\nvarying vec3 v_position;\nvarying vec3 v_positionWC;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvec4 getColor(float sensorRadius, vec3 pointEC) {\n  czm_materialInput materialInput;\n\n  vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\n  materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n  materialInput.str = pointMC / sensorRadius;\n\n  vec3 positionToEyeEC = -v_positionEC;\n  materialInput.positionToEyeEC = positionToEyeEC;\n\n  vec3 normalEC = normalize(v_normalEC);\n  materialInput.normalEC = u_normalDirection * normalEC;\n\n  czm_material material = czm_getMaterial(materialInput);\n    // czm_lightDirectionEC在cesium1.66开始加入的\n  return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\n\n}\n\nbool isOnBoundary(float value, float epsilon) {\n  float width = getIntersectionWidth();\n  float tolerance = width * epsilon;\n\n#ifdef GL_OES_standard_derivatives\n  float delta = max(abs(dFdx(value)), abs(dFdy(value)));\n  float pixels = width * delta;\n  float temp = abs(value);\n  return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\n#else\n  return abs(value) < tolerance;\n#endif\n}\n\nvec4 shade(bool isOnBoundary) {\n  if(u_showIntersection && isOnBoundary) {\n    return getIntersectionColor();\n  }\n  if(u_type == 1.0) {\n    return getLineColor();\n  }\n  return getColor(u_radius, v_positionEC);\n}\n\nfloat ellipsoidSurfaceFunction(vec3 point) {\n  vec3 scaled = czm_ellipsoidInverseRadii * point;\n  return dot(scaled, scaled) - 1.0;\n}\n\nvoid main() {\n  vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\n\n  float positionX = v_position.x;\n  float positionY = v_position.y;\n  float positionZ = v_position.z;\n\n  vec3 zDir = vec3(0.0, 0.0, 1.0);\n  vec3 lineX = vec3(positionX, 0, positionZ);\n  vec3 lineY = vec3(0, positionY, positionZ);\n  float resX = dot(normalize(lineX), zDir);\n  if(resX < cos(u_xHalfAngle) - 0.00001) {\n    discard;\n  }\n  float resY = dot(normalize(lineY), zDir);\n  if(resY < cos(u_yHalfAngle) - 0.00001) {\n    discard;\n  }\n\n  float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);\n  if(!u_showThroughEllipsoid) {\n    if(ellipsoidValue < 0.0) {\n      discard;\n    }\n    if(inSensorShadow(sensorVertexWC, v_positionWC)) {\n      discard;\n    }\n  }\n\n  bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\n  gl_FragColor = shade(isOnEllipsoid);\n}\n"; // eslint-disable-line

  var RectangularSensor$1 = "uniform vec4 u_intersectionColor;\nuniform float u_intersectionWidth;\nuniform vec4 u_lineColor;\n\nbool inSensorShadow(vec3 coneVertexWC, vec3 pointWC) {\n    // Diagonal matrix from the unscaled ellipsoid space to the scaled space.\n  vec3 D = czm_ellipsoidInverseRadii;\n\n    // Sensor vertex in the scaled ellipsoid space\n  vec3 q = D * coneVertexWC;\n  float qMagnitudeSquared = dot(q, q);\n  float test = qMagnitudeSquared - 1.0;\n\n    // Sensor vertex to fragment vector in the ellipsoid's scaled space\n  vec3 temp = D * pointWC - q;\n  float d = dot(temp, q);\n\n    // Behind silhouette plane and inside silhouette cone\n  return (d < -test) && (d / length(temp) < -sqrt(test));\n}\n\n\nvec4 getLineColor() {\n  return u_lineColor;\n}\n\nvec4 getIntersectionColor() {\n  return u_intersectionColor;\n}\n\nfloat getIntersectionWidth() {\n  return u_intersectionWidth;\n}\n\nvec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC) {\n    // (s, t) both in the range [0, 1]\n  float t = pointMC.z / sensorRadius;\n  float s = 1.0 + (atan(pointMC.y, pointMC.x) / czm_twoPi);\n  s = s - floor(s);\n\n  return vec2(s, t);\n}\n"; // eslint-disable-line

  var RectangularSensorScanPlaneFS = "#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform bool u_showIntersection;\nuniform bool u_showThroughEllipsoid;\n\nuniform float u_radius;\nuniform float u_xHalfAngle;\nuniform float u_yHalfAngle;\nuniform float u_normalDirection;\nuniform vec4 u_color;\n\nvarying vec3 v_position;\nvarying vec3 v_positionWC;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvec4 getColor(float sensorRadius, vec3 pointEC) {\n  czm_materialInput materialInput;\n\n  vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\n  materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n  materialInput.str = pointMC / sensorRadius;\n\n  vec3 positionToEyeEC = -v_positionEC;\n  materialInput.positionToEyeEC = positionToEyeEC;\n\n  vec3 normalEC = normalize(v_normalEC);\n  materialInput.normalEC = u_normalDirection * normalEC;\n\n  czm_material material = czm_getMaterial(materialInput);\n\n  material.diffuse = u_color.rgb;\n  material.alpha = u_color.a;\n    // czm_lightDirectionEC在cesium1.66开始加入的\n  return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\n\n}\n\nbool isOnBoundary(float value, float epsilon) {\n  float width = getIntersectionWidth();\n  float tolerance = width * epsilon;\n\n#ifdef GL_OES_standard_derivatives\n  float delta = max(abs(dFdx(value)), abs(dFdy(value)));\n  float pixels = width * delta;\n  float temp = abs(value);\n  return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\n#else\n  return abs(value) < tolerance;\n#endif\n}\n\nvec4 shade(bool isOnBoundary) {\n  if(u_showIntersection && isOnBoundary) {\n    return getIntersectionColor();\n  }\n  return getColor(u_radius, v_positionEC);\n}\n\nfloat ellipsoidSurfaceFunction(vec3 point) {\n  vec3 scaled = czm_ellipsoidInverseRadii * point;\n  return dot(scaled, scaled) - 1.0;\n}\n\nvoid main() {\n  vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\n\n  float positionX = v_position.x;\n  float positionY = v_position.y;\n  float positionZ = v_position.z;\n\n  vec3 zDir = vec3(0.0, 0.0, 1.0);\n  vec3 lineX = vec3(positionX, 0, positionZ);\n  vec3 lineY = vec3(0, positionY, positionZ);\n  float resX = dot(normalize(lineX), zDir);\n  if(resX < cos(u_xHalfAngle) - 0.0001) {\n    discard;\n  }\n  float resY = dot(normalize(lineY), zDir);\n  if(resY < cos(u_yHalfAngle) - 0.0001) {\n    discard;\n  }\n\n  float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);\n\n  if(!u_showThroughEllipsoid) {\n    if(ellipsoidValue < 0.0) {\n      discard;\n    }\n    if(inSensorShadow(sensorVertexWC, v_positionWC)) {\n      discard;\n    }\n  }\n  bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\n  gl_FragColor = shade(isOnEllipsoid);\n}\n"; // eslint-disable-line

  // 相控阵雷达范围

  const BoundingSphere = Cesium__namespace.BoundingSphere;
  const Cartesian3$1 = Cesium__namespace.Cartesian3;
  const Color$1 = Cesium__namespace.Color;
  const combine = Cesium__namespace.combine;
  const ComponentDatatype = Cesium__namespace.ComponentDatatype;
  const defaultValue = Cesium__namespace.defaultValue;
  const defined$1 = Cesium__namespace.defined;
  const DeveloperError$1 = Cesium__namespace.DeveloperError;
  const Matrix4$1 = Cesium__namespace.Matrix4;
  const PrimitiveType = Cesium__namespace.PrimitiveType;
  const Buffer = Cesium__namespace.Buffer;
  const BufferUsage = Cesium__namespace.BufferUsage;
  const DrawCommand = Cesium__namespace.DrawCommand;
  const Pass = Cesium__namespace.Pass;
  const RenderState = Cesium__namespace.RenderState;
  const ShaderProgram = Cesium__namespace.ShaderProgram;
  const ShaderSource = Cesium__namespace.ShaderSource;
  const VertexArray = Cesium__namespace.VertexArray;
  const BlendingState = Cesium__namespace.BlendingState;
  const CullFace = Cesium__namespace.CullFace;
  const Material = Cesium__namespace.Material;
  const SceneMode = Cesium__namespace.SceneMode;
  const VertexFormat = Cesium__namespace.VertexFormat;
  const CesiumMath = Cesium__namespace.Math;
  const Matrix3$1 = Cesium__namespace.Matrix3;
  const JulianDate = Cesium__namespace.JulianDate;

  // var BoxGeometry = Cesium.BoxGeometry;
  // var EllipsoidGeometry = Cesium.EllipsoidGeometry;

  const sin = Math.sin;
  const cos = Math.cos;
  const tan = Math.tan;
  const atan = Math.atan;

  const attributeLocations = {
    position: 0,
    normal: 1
  };

  function RectangularSensorPrimitive(options) {
    const that = this;

    options = defaultValue(options, defaultValue.EMPTY_OBJECT);

    // 是否显示
    this.show = defaultValue(options.show, true);

    // 切分程度
    this.slice = defaultValue(options.slice, 32);

    // 传感器的模型矩阵
    this.modelMatrix = Matrix4$1.clone(options.modelMatrix, new Matrix4$1());
    this._modelMatrix = new Matrix4$1();
    this._computedModelMatrix = new Matrix4$1();
    this._computedScanPlaneModelMatrix = new Matrix4$1();

    // 传感器的半径
    this.radius = defaultValue(options.radius, Number.POSITIVE_INFINITY);
    this._radius = undefined;

    // 传感器水平半角
    this.xHalfAngle = defaultValue(options.xHalfAngle, 0);
    this._xHalfAngle = undefined;

    // 传感器垂直半角
    this.yHalfAngle = defaultValue(options.yHalfAngle, 0);
    this._yHalfAngle = undefined;

    // 线的颜色
    this.lineColor = defaultValue(options.lineColor, Color$1.WHITE);

    // 是否显示扇面的线
    this.showSectorLines = defaultValue(options.showSectorLines, true);

    // 是否显示扇面和圆顶面连接的线
    this.showSectorSegmentLines = defaultValue(options.showSectorSegmentLines, true);

    // 是否显示侧面
    this.showLateralSurfaces = defaultValue(options.showLateralSurfaces, true);

    // 目前用的统一材质
    this.material = defined$1(options.material) ? options.material : Material.fromType(Material.ColorType);
    this._material = undefined;
    this._translucent = undefined;

    // 侧面材质
    this.lateralSurfaceMaterial = defined$1(options.lateralSurfaceMaterial) ? options.lateralSurfaceMaterial : Material.fromType(Material.ColorType);
    this._lateralSurfaceMaterial = undefined;
    this._lateralSurfaceTranslucent = undefined;

    // 是否显示圆顶表面
    this.showDomeSurfaces = defaultValue(options.showDomeSurfaces, true);

    // 圆顶表面材质
    this.domeSurfaceMaterial = defined$1(options.domeSurfaceMaterial) ? options.domeSurfaceMaterial : Material.fromType(Material.ColorType);
    this._domeSurfaceMaterial = undefined;

    // 是否显示圆顶面线
    this.showDomeLines = defaultValue(options.showDomeLines, true);

    // 是否显示与地球相交的线
    this.showIntersection = defaultValue(options.showIntersection, true);

    // 与地球相交的线的颜色
    this.intersectionColor = defaultValue(options.intersectionColor, Color$1.WHITE);

    // 与地球相交的线的宽度（像素）
    this.intersectionWidth = defaultValue(options.intersectionWidth, 5.0);

    // 是否穿过地球
    this.showThroughEllipsoid = defaultValue(options.showThroughEllipsoid, false);
    this._showThroughEllipsoid = undefined;

    // 是否显示扫描面
    this.showScanPlane = defaultValue(options.showScanPlane, true);

    // 扫描面颜色
    this.scanPlaneColor = defaultValue(options.scanPlaneColor, Color$1.WHITE);

    // 扫描面模式 垂直vertical/水平horizontal
    this.scanPlaneMode = defaultValue(options.scanPlaneMode, "horizontal");

    // 扫描速率
    this.scanPlaneRate = defaultValue(options.scanPlaneRate, 10);

    this._scanePlaneXHalfAngle = 0;
    this._scanePlaneYHalfAngle = 0;

    // 时间计算的起点
    this._time = JulianDate.now();

    this._boundingSphere = new BoundingSphere();
    this._boundingSphereWC = new BoundingSphere();

    // 扇面 sector
    this._sectorFrontCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.TRIANGLES,
      boundingVolume: this._boundingSphereWC
    });
    this._sectorBackCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.TRIANGLES,
      boundingVolume: this._boundingSphereWC
    });
    this._sectorVA = undefined;

    // 扇面边线 sectorLine
    this._sectorLineCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.LINES,
      boundingVolume: this._boundingSphereWC
    });
    this._sectorLineVA = undefined;

    // 扇面分割线 sectorSegmentLine
    this._sectorSegmentLineCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.LINES,
      boundingVolume: this._boundingSphereWC
    });
    this._sectorSegmentLineVA = undefined;

    // 弧面 dome
    this._domeFrontCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.TRIANGLES,
      boundingVolume: this._boundingSphereWC
    });
    this._domeBackCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.TRIANGLES,
      boundingVolume: this._boundingSphereWC
    });
    this._domeVA = undefined;

    // 弧面线 domeLine
    this._domeLineCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.LINES,
      boundingVolume: this._boundingSphereWC
    });
    this._domeLineVA = undefined;

    // 扫描面 scanPlane/scanRadial
    this._scanPlaneFrontCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.TRIANGLES,
      boundingVolume: this._boundingSphereWC
    });
    this._scanPlaneBackCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.TRIANGLES,
      boundingVolume: this._boundingSphereWC
    });

    this._scanRadialCommand = undefined;

    this._colorCommands = [];

    this._frontFaceRS = undefined;
    this._backFaceRS = undefined;
    this._sp = undefined;

    this._uniforms = {
      u_type: function () {
        return 0 // 面
      },
      u_xHalfAngle: function () {
        return that.xHalfAngle
      },
      u_yHalfAngle: function () {
        return that.yHalfAngle
      },
      u_radius: function () {
        return that.radius
      },
      u_showThroughEllipsoid: function () {
        return that.showThroughEllipsoid
      },
      u_showIntersection: function () {
        return that.showIntersection
      },
      u_intersectionColor: function () {
        return that.intersectionColor
      },
      u_intersectionWidth: function () {
        return that.intersectionWidth
      },
      u_normalDirection: function () {
        return 1.0
      },
      u_lineColor: function () {
        return that.lineColor
      }
    };

    this._scanUniforms = {
      u_xHalfAngle: function () {
        return that._scanePlaneXHalfAngle
      },
      u_yHalfAngle: function () {
        return that._scanePlaneYHalfAngle
      },
      u_radius: function () {
        return that.radius
      },
      u_color: function () {
        return that.scanPlaneColor
      },
      u_showThroughEllipsoid: function () {
        return that.showThroughEllipsoid
      },
      u_showIntersection: function () {
        return that.showIntersection
      },
      u_intersectionColor: function () {
        return that.intersectionColor
      },
      u_intersectionWidth: function () {
        return that.intersectionWidth
      },
      u_normalDirection: function () {
        return 1.0
      },
      u_lineColor: function () {
        return that.lineColor
      }
    };
  }

  RectangularSensorPrimitive.prototype.update = function (frameState) {
    const mode = frameState.mode;
    if (!this.show || mode !== SceneMode.SCENE3D) {
      return
    }
    let createVS = false;
    let createRS = false;
    let createSP = false;

    const xHalfAngle = this.xHalfAngle;
    const yHalfAngle = this.yHalfAngle;

    if (xHalfAngle < 0.0 || yHalfAngle < 0.0) {
      throw new DeveloperError$1("halfAngle must be greater than or equal to zero.")
    }
    if (xHalfAngle === 0.0 || yHalfAngle === 0.0) {
      return
    }
    if (this._xHalfAngle !== xHalfAngle || this._yHalfAngle !== yHalfAngle) {
      this._xHalfAngle = xHalfAngle;
      this._yHalfAngle = yHalfAngle;
      createVS = true;
    }

    const radius = this.radius;
    if (radius < 0.0) {
      throw new DeveloperError$1("this.radius must be greater than or equal to zero.")
    }
    let radiusChanged = false;
    if (this._radius !== radius) {
      radiusChanged = true;
      this._radius = radius;
      this._boundingSphere = new BoundingSphere(Cartesian3$1.ZERO, this.radius);
    }

    const modelMatrixChanged = !Matrix4$1.equals(this.modelMatrix, this._modelMatrix);
    if (modelMatrixChanged || radiusChanged) {
      Matrix4$1.clone(this.modelMatrix, this._modelMatrix);
      Matrix4$1.multiplyByUniformScale(this.modelMatrix, this.radius, this._computedModelMatrix);
      BoundingSphere.transform(this._boundingSphere, this.modelMatrix, this._boundingSphereWC);
    }

    const showThroughEllipsoid = this.showThroughEllipsoid;
    if (this._showThroughEllipsoid !== this.showThroughEllipsoid) {
      this._showThroughEllipsoid = showThroughEllipsoid;
      createRS = true;
    }

    const material = this.material;
    if (this._material !== material) {
      this._material = material;
      createRS = true;
      createSP = true;
    }
    const translucent = material.isTranslucent();
    if (this._translucent !== translucent) {
      this._translucent = translucent;
      createRS = true;
    }

    if (this.showScanPlane) {
      const time = frameState.time;
      const timeDiff = JulianDate.secondsDifference(time, this._time);
      if (timeDiff < 0) {
        this._time = JulianDate.clone(time, this._time);
      }
      const percentage = Math.max((timeDiff % this.scanPlaneRate) / this.scanPlaneRate, 0);
      let angle;

      const matrix3Scratch = new Matrix3$1();

      if (this.scanPlaneMode === "horizontal") {
        angle = 2 * yHalfAngle * percentage - yHalfAngle;
        const cosYHalfAngle = cos(angle);
        const tanXHalfAngle = tan(xHalfAngle);

        const maxX = atan(cosYHalfAngle * tanXHalfAngle);
        this._scanePlaneXHalfAngle = maxX;
        this._scanePlaneYHalfAngle = angle;
        Cesium__namespace.Matrix3.fromRotationX(this._scanePlaneYHalfAngle, matrix3Scratch);
      } else {
        angle = 2 * xHalfAngle * percentage - xHalfAngle;
        const tanYHalfAngle = tan(yHalfAngle);
        const cosXHalfAngle = cos(angle);

        const maxY = atan(cosXHalfAngle * tanYHalfAngle);
        this._scanePlaneXHalfAngle = angle;
        this._scanePlaneYHalfAngle = maxY;
        Cesium__namespace.Matrix3.fromRotationY(this._scanePlaneXHalfAngle, matrix3Scratch);
      }

      Cesium__namespace.Matrix4.multiplyByMatrix3(this.modelMatrix, matrix3Scratch, this._computedScanPlaneModelMatrix);
      Matrix4$1.multiplyByUniformScale(this._computedScanPlaneModelMatrix, this.radius, this._computedScanPlaneModelMatrix);
    }

    if (createVS) {
      createVertexArray(this, frameState);
    }
    if (createRS) {
      createRenderState(this, showThroughEllipsoid, translucent);
    }
    if (createSP) {
      createShaderProgram(this, frameState, material);
    }
    if (createRS || createSP) {
      createCommands(this, translucent);
    }

    const commandList = frameState.commandList;
    const passes = frameState.passes;
    const colorCommands = this._colorCommands;
    if (passes.render) {
      for (let i = 0, len = colorCommands.length; i < len; i++) {
        const colorCommand = colorCommands[i];
        commandList.push(colorCommand);
      }
    }
  };

  const nScratch = new Cartesian3$1();

  // region -- VertexArray --

  // /**
  //  * 计算zoy面和zoy面单位扇形位置
  //  * @param primitive
  //  * @returns {{zoy: Array, zox: Array}}
  //  */
  function computeUnitPosiiton(primitive, xHalfAngle, yHalfAngle) {
    const slice = primitive.slice;

    // 以中心为角度
    const cosYHalfAngle = cos(yHalfAngle);
    const tanYHalfAngle = tan(yHalfAngle);
    const cosXHalfAngle = cos(xHalfAngle);
    const tanXHalfAngle = tan(xHalfAngle);

    const maxY = atan(cosXHalfAngle * tanYHalfAngle);
    const maxX = atan(cosYHalfAngle * tanXHalfAngle);

    // ZOY面单位圆
    const zoy = [];
    for (let i = 0; i < slice; i++) {
      const phi = (2 * maxY * i) / (slice - 1) - maxY;
      zoy.push(new Cartesian3$1(0, sin(phi), cos(phi)));
    }
    // zox面单位圆
    const zox = [];
    for (let i = 0; i < slice; i++) {
      const phi = (2 * maxX * i) / (slice - 1) - maxX;
      zox.push(new Cartesian3$1(sin(phi), 0, cos(phi)));
    }

    return {
      zoy: zoy,
      zox: zox
    }
  }

  // /**
  //  * 计算扇面的位置
  //  * @param unitPosition
  //  * @returns {Array}
  //  */
  function computeSectorPositions(primitive, unitPosition) {
    const xHalfAngle = primitive.xHalfAngle;
      const yHalfAngle = primitive.yHalfAngle;
      const zoy = unitPosition.zoy;
      const zox = unitPosition.zox;
    const positions = [];

    const matrix3Scratch = new Matrix3$1();

    // zoy面沿y轴逆时针转xHalfAngle
    let matrix3 = Matrix3$1.fromRotationY(xHalfAngle, matrix3Scratch);
    positions.push(
      zoy.map(function (p) {
        return Matrix3$1.multiplyByVector(matrix3, p, new Cesium__namespace.Cartesian3())
      })
    );
    // zox面沿x轴顺时针转yHalfAngle
    matrix3 = Matrix3$1.fromRotationX(-yHalfAngle, matrix3Scratch);
    positions.push(
      zox
        .map(function (p) {
          return Matrix3$1.multiplyByVector(matrix3, p, new Cesium__namespace.Cartesian3())
        })
        .reverse()
    );
    // zoy面沿y轴顺时针转xHalfAngle
    matrix3 = Matrix3$1.fromRotationY(-xHalfAngle, matrix3Scratch);
    positions.push(
      zoy
        .map(function (p) {
          return Matrix3$1.multiplyByVector(matrix3, p, new Cesium__namespace.Cartesian3())
        })
        .reverse()
    );
    // zox面沿x轴逆时针转yHalfAngle
    matrix3 = Matrix3$1.fromRotationX(yHalfAngle, matrix3Scratch);
    positions.push(
      zox.map(function (p) {
        return Matrix3$1.multiplyByVector(matrix3, p, new Cesium__namespace.Cartesian3())
      })
    );
    return positions
  }

  // /**
  //  * 创建扇面顶点
  //  * @param context
  //  * @param positions
  //  * @returns {*}
  //  */
  function createSectorVertexArray(context, positions) {
    const planeLength = Array.prototype.concat.apply([], positions).length - positions.length;
    const vertices = new Float32Array(2 * 3 * 3 * planeLength);

    let k = 0;
    for (let i = 0, len = positions.length; i < len; i++) {
      const planePositions = positions[i];
      const n = Cartesian3$1.normalize(Cartesian3$1.cross(planePositions[0], planePositions[planePositions.length - 1], nScratch), nScratch);
      for (let j = 0, planeLen = planePositions.length - 1; j < planeLen; j++) {
        vertices[k++] = 0.0;
        vertices[k++] = 0.0;
        vertices[k++] = 0.0;
        vertices[k++] = -n.x;
        vertices[k++] = -n.y;
        vertices[k++] = -n.z;

        vertices[k++] = planePositions[j].x;
        vertices[k++] = planePositions[j].y;
        vertices[k++] = planePositions[j].z;
        vertices[k++] = -n.x;
        vertices[k++] = -n.y;
        vertices[k++] = -n.z;

        vertices[k++] = planePositions[j + 1].x;
        vertices[k++] = planePositions[j + 1].y;
        vertices[k++] = planePositions[j + 1].z;
        vertices[k++] = -n.x;
        vertices[k++] = -n.y;
        vertices[k++] = -n.z;
      }
    }

    const vertexBuffer = Buffer.createVertexBuffer({
      context: context,
      typedArray: vertices,
      usage: BufferUsage.STATIC_DRAW
    });

    const stride = 2 * 3 * Float32Array.BYTES_PER_ELEMENT;

    const attributes = [
      {
        index: attributeLocations.position,
        vertexBuffer: vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 0,
        strideInBytes: stride
      },
      {
        index: attributeLocations.normal,
        vertexBuffer: vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 3 * Float32Array.BYTES_PER_ELEMENT,
        strideInBytes: stride
      }
    ];

    return new VertexArray({
      context: context,
      attributes: attributes
    })
  }

  // /**
  //  * 创建扇面边线顶点
  //  * @param context
  //  * @param positions
  //  * @returns {*}
  //  */
  function createSectorLineVertexArray(context, positions) {
    const planeLength = positions.length;
    const vertices = new Float32Array(3 * 3 * planeLength);

    let k = 0;
    for (let i = 0, len = positions.length; i < len; i++) {
      const planePositions = positions[i];
      vertices[k++] = 0.0;
      vertices[k++] = 0.0;
      vertices[k++] = 0.0;

      vertices[k++] = planePositions[0].x;
      vertices[k++] = planePositions[0].y;
      vertices[k++] = planePositions[0].z;
    }

    const vertexBuffer = Buffer.createVertexBuffer({
      context: context,
      typedArray: vertices,
      usage: BufferUsage.STATIC_DRAW
    });

    const stride = 3 * Float32Array.BYTES_PER_ELEMENT;

    const attributes = [
      {
        index: attributeLocations.position,
        vertexBuffer: vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 0,
        strideInBytes: stride
      }
    ];

    return new VertexArray({
      context: context,
      attributes: attributes
    })
  }

  // /**
  //  * 创建扇面圆顶面连接线顶点
  //  * @param context
  //  * @param positions
  //  * @returns {*}
  //  */
  function createSectorSegmentLineVertexArray(context, positions) {
    const planeLength = Array.prototype.concat.apply([], positions).length - positions.length;
    const vertices = new Float32Array(3 * 3 * planeLength);

    let k = 0;
    for (let i = 0, len = positions.length; i < len; i++) {
      const planePositions = positions[i];

      for (let j = 0, planeLen = planePositions.length - 1; j < planeLen; j++) {
        vertices[k++] = planePositions[j].x;
        vertices[k++] = planePositions[j].y;
        vertices[k++] = planePositions[j].z;

        vertices[k++] = planePositions[j + 1].x;
        vertices[k++] = planePositions[j + 1].y;
        vertices[k++] = planePositions[j + 1].z;
      }
    }

    const vertexBuffer = Buffer.createVertexBuffer({
      context: context,
      typedArray: vertices,
      usage: BufferUsage.STATIC_DRAW
    });

    const stride = 3 * Float32Array.BYTES_PER_ELEMENT;

    const attributes = [
      {
        index: attributeLocations.position,
        vertexBuffer: vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 0,
        strideInBytes: stride
      }
    ];

    return new VertexArray({
      context: context,
      attributes: attributes
    })
  }

  // /**
  //  * 创建圆顶面顶点
  //  * @param context
  //  */
  function createDomeVertexArray(context) {
    const geometry = Cesium__namespace.EllipsoidGeometry.createGeometry(
      new Cesium__namespace.EllipsoidGeometry({
        vertexFormat: VertexFormat.POSITION_ONLY,
        stackPartitions: 32,
        slicePartitions: 32
      })
    );

    const vertexArray = VertexArray.fromGeometry({
      context: context,
      geometry: geometry,
      attributeLocations: attributeLocations,
      bufferUsage: BufferUsage.STATIC_DRAW,
      interleave: false
    });
    return vertexArray
  }

  // /**
  //  * 创建圆顶面连线顶点
  //  * @param context
  //  */
  function createDomeLineVertexArray(context) {
    const geometry = Cesium__namespace.EllipsoidOutlineGeometry.createGeometry(
      new Cesium__namespace.EllipsoidOutlineGeometry({
        vertexFormat: VertexFormat.POSITION_ONLY,
        stackPartitions: 32,
        slicePartitions: 32
      })
    );

    const vertexArray = VertexArray.fromGeometry({
      context: context,
      geometry: geometry,
      attributeLocations: attributeLocations,
      bufferUsage: BufferUsage.STATIC_DRAW,
      interleave: false
    });
    return vertexArray
  }

  // /**
  //  * 创建扫描面顶点
  //  * @param context
  //  * @param positions
  //  * @returns {*}
  //  */
  function createScanPlaneVertexArray(context, positions) {
    const planeLength = positions.length - 1;
    const vertices = new Float32Array(3 * 3 * planeLength);

    let k = 0;
    for (let i = 0; i < planeLength; i++) {
      vertices[k++] = 0.0;
      vertices[k++] = 0.0;
      vertices[k++] = 0.0;

      vertices[k++] = positions[i].x;
      vertices[k++] = positions[i].y;
      vertices[k++] = positions[i].z;

      vertices[k++] = positions[i + 1].x;
      vertices[k++] = positions[i + 1].y;
      vertices[k++] = positions[i + 1].z;
    }

    const vertexBuffer = Buffer.createVertexBuffer({
      context: context,
      typedArray: vertices,
      usage: BufferUsage.STATIC_DRAW
    });

    const stride = 3 * Float32Array.BYTES_PER_ELEMENT;

    const attributes = [
      {
        index: attributeLocations.position,
        vertexBuffer: vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 0,
        strideInBytes: stride
      }
    ];

    return new VertexArray({
      context: context,
      attributes: attributes
    })
  }

  function createVertexArray(primitive, frameState) {
    const context = frameState.context;

    const unitSectorPositions = computeUnitPosiiton(primitive, primitive.xHalfAngle, primitive.yHalfAngle);
    const positions = computeSectorPositions(primitive, unitSectorPositions);

    // 显示扇面
    if (primitive.showLateralSurfaces) {
      primitive._sectorVA = createSectorVertexArray(context, positions);
    }

    // 显示扇面线
    if (primitive.showSectorLines) {
      primitive._sectorLineVA = createSectorLineVertexArray(context, positions);
    }

    // 显示扇面圆顶面的交线
    if (primitive.showSectorSegmentLines) {
      primitive._sectorSegmentLineVA = createSectorSegmentLineVertexArray(context, positions);
    }

    // 显示弧面
    if (primitive.showDomeSurfaces) {
      primitive._domeVA = createDomeVertexArray(context);
    }

    // 显示弧面线
    if (primitive.showDomeLines) {
      primitive._domeLineVA = createDomeLineVertexArray(context);
    }

    // 显示扫描面
    if (primitive.showScanPlane) {
      if (primitive.scanPlaneMode === "horizontal") {
        const unitScanPlanePositions = computeUnitPosiiton(primitive, CesiumMath.PI_OVER_TWO, 0);
        primitive._scanPlaneVA = createScanPlaneVertexArray(context, unitScanPlanePositions.zox);
      } else {
        const unitScanPlanePositions = computeUnitPosiiton(primitive, 0, CesiumMath.PI_OVER_TWO);
        primitive._scanPlaneVA = createScanPlaneVertexArray(context, unitScanPlanePositions.zoy);
      }
    }
  }

  // endregion

  // region -- ShaderProgram --

  function createCommonShaderProgram(primitive, frameState, material) {
    const context = frameState.context;

    const vs = RectangularSensorVS;
    const fs = new ShaderSource({
      sources: [RectangularSensor$1, material.shaderSource, RectangularSensorFS]
    });

    primitive._sp = ShaderProgram.replaceCache({
      context: context,
      shaderProgram: primitive._sp,
      vertexShaderSource: vs,
      fragmentShaderSource: fs,
      attributeLocations: attributeLocations
    });

    const pickFS = new ShaderSource({
      sources: [RectangularSensor$1, material.shaderSource, RectangularSensorFS],
      pickColorQualifier: "uniform"
    });

    primitive._pickSP = ShaderProgram.replaceCache({
      context: context,
      shaderProgram: primitive._pickSP,
      vertexShaderSource: vs,
      fragmentShaderSource: pickFS,
      attributeLocations: attributeLocations
    });
  }

  function createScanPlaneShaderProgram(primitive, frameState, material) {
    const context = frameState.context;

    const vs = RectangularSensorVS;
    const fs = new ShaderSource({
      sources: [RectangularSensor$1, material.shaderSource, RectangularSensorScanPlaneFS]
    });

    primitive._scanePlaneSP = ShaderProgram.replaceCache({
      context: context,
      shaderProgram: primitive._scanePlaneSP,
      vertexShaderSource: vs,
      fragmentShaderSource: fs,
      attributeLocations: attributeLocations
    });
  }

  function createShaderProgram(primitive, frameState, material) {
    createCommonShaderProgram(primitive, frameState, material);

    if (primitive.showScanPlane) {
      createScanPlaneShaderProgram(primitive, frameState, material);
    }
  }

  // endregion

  // region -- RenderState --

  function createRenderState(primitive, showThroughEllipsoid, translucent) {
    if (translucent) {
      primitive._frontFaceRS = RenderState.fromCache({
        depthTest: {
          enabled: !showThroughEllipsoid
        },
        depthMask: false,
        blending: BlendingState.ALPHA_BLEND,
        cull: {
          enabled: true,
          face: CullFace.BACK
        }
      });

      primitive._backFaceRS = RenderState.fromCache({
        depthTest: {
          enabled: !showThroughEllipsoid
        },
        depthMask: false,
        blending: BlendingState.ALPHA_BLEND,
        cull: {
          enabled: true,
          face: CullFace.FRONT
        }
      });

      primitive._pickRS = RenderState.fromCache({
        depthTest: {
          enabled: !showThroughEllipsoid
        },
        depthMask: false,
        blending: BlendingState.ALPHA_BLEND
      });
    } else {
      primitive._frontFaceRS = RenderState.fromCache({
        depthTest: {
          enabled: !showThroughEllipsoid
        },
        depthMask: true
      });

      primitive._pickRS = RenderState.fromCache({
        depthTest: {
          enabled: true
        },
        depthMask: true
      });
    }
  }

  // endregion

  // region -- Command --

  function createCommand(primitive, frontCommand, backCommand, frontFaceRS, backFaceRS, sp, va, uniforms, modelMatrix, translucent, pass, isLine) {
    if (translucent && backCommand) {
      backCommand.vertexArray = va;
      backCommand.renderState = backFaceRS;
      backCommand.shaderProgram = sp;
      backCommand.uniformMap = combine(uniforms, primitive._material._uniforms);
      backCommand.uniformMap.u_normalDirection = function () {
        return -1.0
      };
      backCommand.pass = pass;
      backCommand.modelMatrix = modelMatrix;
      primitive._colorCommands.push(backCommand);
    }

    frontCommand.vertexArray = va;
    frontCommand.renderState = frontFaceRS;
    frontCommand.shaderProgram = sp;
    frontCommand.uniformMap = combine(uniforms, primitive._material._uniforms);
    if (isLine) {
      frontCommand.uniformMap.u_type = function () {
        return 1
      };
    }
    frontCommand.pass = pass;
    frontCommand.modelMatrix = modelMatrix;
    primitive._colorCommands.push(frontCommand);
  }

  function createCommands(primitive, translucent) {
    primitive._colorCommands.length = 0;

    const pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;

    // 显示扇面
    if (primitive.showLateralSurfaces) {
      createCommand(
        primitive,
        primitive._sectorFrontCommand,
        primitive._sectorBackCommand,
        primitive._frontFaceRS,
        primitive._backFaceRS,
        primitive._sp,
        primitive._sectorVA,
        primitive._uniforms,
        primitive._computedModelMatrix,
        translucent,
        pass
      );
    }
    // 显示扇面线
    if (primitive.showSectorLines) {
      createCommand(
        primitive,
        primitive._sectorLineCommand,
        undefined,
        primitive._frontFaceRS,
        primitive._backFaceRS,
        primitive._sp,
        primitive._sectorLineVA,
        primitive._uniforms,
        primitive._computedModelMatrix,
        translucent,
        pass,
        true
      );
    }
    // 显示扇面交接线
    if (primitive.showSectorSegmentLines) {
      createCommand(
        primitive,
        primitive._sectorSegmentLineCommand,
        undefined,
        primitive._frontFaceRS,
        primitive._backFaceRS,
        primitive._sp,
        primitive._sectorSegmentLineVA,
        primitive._uniforms,
        primitive._computedModelMatrix,
        translucent,
        pass,
        true
      );
    }
    // 显示弧面
    if (primitive.showDomeSurfaces) {
      createCommand(
        primitive,
        primitive._domeFrontCommand,
        primitive._domeBackCommand,
        primitive._frontFaceRS,
        primitive._backFaceRS,
        primitive._sp,
        primitive._domeVA,
        primitive._uniforms,
        primitive._computedModelMatrix,
        translucent,
        pass
      );
    }
    // 显示弧面线
    if (primitive.showDomeLines) {
      createCommand(
        primitive,
        primitive._domeLineCommand,
        undefined,
        primitive._frontFaceRS,
        primitive._backFaceRS,
        primitive._sp,
        primitive._domeLineVA,
        primitive._uniforms,
        primitive._computedModelMatrix,
        translucent,
        pass,
        true
      );
    }
    // 显示扫描面
    if (primitive.showScanPlane) {
      createCommand(
        primitive,
        primitive._scanPlaneFrontCommand,
        primitive._scanPlaneBackCommand,
        primitive._frontFaceRS,
        primitive._backFaceRS,
        primitive._scanePlaneSP,
        primitive._scanPlaneVA,
        primitive._scanUniforms,
        primitive._computedScanPlaneModelMatrix,
        translucent,
        pass
      );
    }
  }

  const AssociativeArray = Cesium__namespace.AssociativeArray;
  const Cartesian3 = Cesium__namespace.Cartesian3;
  const Color = Cesium__namespace.Color;
  const defined = Cesium__namespace.defined;
  const DeveloperError = Cesium__namespace.DeveloperError;
  const Matrix3 = Cesium__namespace.Matrix3;
  const Matrix4 = Cesium__namespace.Matrix4;
  const Quaternion = Cesium__namespace.Quaternion;
  const MaterialProperty = Cesium__namespace.MaterialProperty;
  const Property = Cesium__namespace.Property;

  const matrix3Scratch = new Matrix3();
  // var matrix4Scratch = new Matrix4();
  const cachedPosition = new Cartesian3();
  const cachedGazePosition = new Cartesian3();
  const cachedOrientation = new Quaternion();
  const diffVectorScratch = new Cartesian3();
  const orientationScratch = new Quaternion();

  function removePrimitive(entity, hash, primitives) {
    const data = hash[entity.id];
    if (Cesium__namespace.defined(data)) {
      const primitive = data.primitive;
      try {
        primitives.remove(primitive);
      } catch (e) {
        //
      }
      if (primitive.isDestroyed && !primitive.isDestroyed()) {
        primitive.destroy();
      }
      delete hash[entity.id];
    }
  }

  // /**
  //  *  相控阵雷达范围
  //  */
  function RectangularSensorVisualizer(scene, entityCollection) {
    // >>includeStart('debug', pragmas.debug);
    if (!defined(scene)) {
      throw new DeveloperError("scene is required.")
    }
    if (!defined(entityCollection)) {
      throw new DeveloperError("entityCollection is required.")
    }
    // >>includeEnd('debug');

    entityCollection.collectionChanged.addEventListener(RectangularSensorVisualizer.prototype._onCollectionChanged, this);

    this._scene = scene;
    this._primitives = scene.primitives;
    this._entityCollection = entityCollection;
    this._hash = {};
    this._entitiesToVisualize = new AssociativeArray();

    this._onCollectionChanged(entityCollection, entityCollection.values, [], []);
  }

  // /**
  //  * Updates the primitives created by this visualizer to match their
  //  * Entity counterpart at the given time.
  //  *
  //  * @param {Cesium.JulianDate} time The time to update to.
  //  * @returns {Boolean} This function always returns true.
  //  */
  RectangularSensorVisualizer.prototype.update = function (time) {
    // >>includeStart('debug', pragmas.debug);
    if (!defined(time)) {
      throw new DeveloperError("time is required.")
    }
    // >>includeEnd('debug');

    const entities = this._entitiesToVisualize.values;
    const hash = this._hash;
    const primitives = this._primitives;

    let position;
    let orientation;
    let radius;
    let xHalfAngle;
    let yHalfAngle;

    for (let i = 0, len = entities.length; i < len; i++) {
      const entity = entities[i];
      const rectangularSensorGraphics = entity._rectangularSensorMars;

      let data = hash[entity.id];
      let show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(rectangularSensorGraphics._show, time, true);

      if (show) {
        position = Property.getValueOrUndefined(entity._position, time, cachedPosition);
        orientation = Property.getValueOrUndefined(entity._orientation, time, cachedOrientation);
        radius = Property.getValueOrUndefined(rectangularSensorGraphics._radius, time);
        xHalfAngle = Property.getValueOrUndefined(rectangularSensorGraphics._xHalfAngle, time);
        yHalfAngle = Property.getValueOrUndefined(rectangularSensorGraphics._yHalfAngle, time);
        show = defined(position) && defined(xHalfAngle) && defined(yHalfAngle);
      }

      if (!show) {
        // don't bother creating or updating anything else
        if (defined(data)) {
          data.primitive.show = false;
        }
        continue
      }

      let primitive = defined(data) ? data.primitive : undefined;
      if (!defined(primitive)) {
        primitive = new RectangularSensorPrimitive();
        primitive.id = entity;
        primitives.add(primitive);

        data = {
          primitive: primitive,
          position: undefined,
          orientation: undefined
        };
        hash[entity.id] = data;
      }

      const gaze = Property.getValueOrUndefined(rectangularSensorGraphics._gaze, time);
      if (defined(gaze)) {
        const targetPosition = Property.getValueOrUndefined(gaze._position, time, cachedGazePosition);

        if (!defined(position) || !defined(targetPosition)) {
          continue
        }

        const diffVector = Cartesian3.subtract(position, targetPosition, diffVectorScratch);
        const rotate = Cartesian3.angleBetween(Cesium__namespace.Cartesian3.UNIT_Z, diffVector);
        const cross = Cartesian3.cross(Cesium__namespace.Cartesian3.UNIT_Z, diffVector, diffVectorScratch);
        orientation = Quaternion.fromAxisAngle(cross, rotate - Math.PI, orientationScratch);

        // replace original radius
        radius = Cartesian3.distance(position, targetPosition);
        primitive.modelMatrix = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, primitive.modelMatrix);
      } else {
        if (!Cartesian3.equals(position, data.position) || !Quaternion.equals(orientation, data.orientation)) {
          if (defined(orientation)) {
            primitive.modelMatrix = Matrix4.fromRotationTranslation(
              Matrix3.fromQuaternion(orientation, matrix3Scratch),
              position,
              primitive.modelMatrix
            );
            data.position = Cartesian3.clone(position, data.position);
            data.orientation = Quaternion.clone(orientation, data.orientation);
          } else {
            primitive.modelMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(position);
            data.position = Cartesian3.clone(position, data.position);
          }
        }
      }

      primitive.show = true;
      primitive.gaze = gaze;
      primitive.radius = radius;
      primitive.xHalfAngle = xHalfAngle;
      primitive.yHalfAngle = yHalfAngle;
      primitive.lineColor = Property.getValueOrDefault(rectangularSensorGraphics._lineColor, time, Color.WHITE);
      primitive.showSectorLines = Property.getValueOrDefault(rectangularSensorGraphics._showSectorLines, time, true);
      primitive.showSectorSegmentLines = Property.getValueOrDefault(rectangularSensorGraphics._showSectorSegmentLines, time, true);
      primitive.showLateralSurfaces = Property.getValueOrDefault(rectangularSensorGraphics._showLateralSurfaces, time, true);
      primitive.material = MaterialProperty.getValue(time, rectangularSensorGraphics._material, primitive.material);
      primitive.showDomeSurfaces = Property.getValueOrDefault(rectangularSensorGraphics._showDomeSurfaces, time, true);
      primitive.showDomeLines = Property.getValueOrDefault(rectangularSensorGraphics._showDomeLines, time, true);
      primitive.showIntersection = Property.getValueOrDefault(rectangularSensorGraphics._showIntersection, time, true);
      primitive.intersectionColor = Property.getValueOrDefault(rectangularSensorGraphics._intersectionColor, time, Color.WHITE);
      primitive.intersectionWidth = Property.getValueOrDefault(rectangularSensorGraphics._intersectionWidth, time, 1);
      primitive.showThroughEllipsoid = Property.getValueOrDefault(rectangularSensorGraphics._showThroughEllipsoid, time, false);
      primitive.scanPlaneMode = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneMode, time);
      primitive.scanPlaneColor = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneColor, time, Color.WHITE);
      primitive.showScanPlane = Property.getValueOrDefault(rectangularSensorGraphics._showScanPlane, time, true);
      primitive.scanPlaneRate = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneRate, time, 1);
    }
    return true
  };

  RectangularSensorVisualizer.prototype.isDestroyed = function () {
    return false
  };

  RectangularSensorVisualizer.prototype.destroy = function () {
    const entities = this._entitiesToVisualize.values;
    const hash = this._hash;
    const primitives = this._primitives;
    for (let i = entities.length - 1; i > -1; i--) {
      removePrimitive(entities[i], hash, primitives);
    }

    // 删除所有绑定的数据
    for (const i in this) {
      delete this[i];
    }

    return Cesium__namespace.destroyObject(this)
  };

  RectangularSensorVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {
    const entities = this._entitiesToVisualize;
    if (!entities) {
      return
    }

    const hash = this._hash;
    const primitives = this._primitives;

    let i;
    let entity;
    for (i = added.length - 1; i > -1; i--) {
      entity = added[i];
      if (defined(entity._rectangularSensorMars) && defined(entity._position)) {
        entities.set(entity.id, entity);
      }
    }

    for (i = changed.length - 1; i > -1; i--) {
      entity = changed[i];
      if (defined(entity._rectangularSensorMars) && defined(entity._position)) {
        entities.set(entity.id, entity);
      } else {
        removePrimitive(entity, hash, primitives);
        entities.remove(entity.id);
      }
    }

    for (i = removed.length - 1; i > -1; i--) {
      entity = removed[i];
      removePrimitive(entity, hash, primitives);
      entities.remove(entity.id);
    }
  };

  const originalDefaultVisualizersCallback = Cesium__namespace.DataSourceDisplay.defaultVisualizersCallback;
  Cesium__namespace.DataSourceDisplay.defaultVisualizersCallback = function (scene, entityCluster, dataSource) {
    const entities = dataSource.entities;
    const array = originalDefaultVisualizersCallback(scene, entityCluster, dataSource);
    return array.concat([new RectangularSensorVisualizer(scene, entities)])
  };

  /**
   * 相控阵雷达 支持的样式信息
   *
   * @typedef {Object} RectangularSensor.StyleOptions
   *
   * @property {Number} radius 半径
   * @property {Number} [xHalfAngle = 0] 传感器水平半角（弧度值）
   * @property {Number} [xHalfAngleDegree = 0] 传感器水平半角（度数值，0-360度），与xHalfAngle二选一
   * @property {Number} [yHalfAngle = 0] 传感器垂直半角（弧度值）
   * @property {Number} [yHalfAngleDegree = 0] 传感器垂直半角（度数值，0-360度），与yHalfAngle二选一
   *
   * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
   * @property {Number} [opacity = 0.4] 透明度
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material= new Cesium.Color(0.0, 1.0, 1.0, 0.4)] 指定用于填充的材质，指定material后color属性将被覆盖。
   *
   * @property {String|Cesium.Color} [lineColor = "#ffffff"] 边线颜色
   * @property {Number} [lineOpacity = 0.6] 边线透明度
   *
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   *
   * @property {Boolean} [showScanPlane = true] 是否显示扫描面
   * @property {String|Cesium.Color} [scanPlaneColor = new Cesium.Color(0.0, 1.0, 1.0, 1.0)] 扫描面颜色
   * @property {Number} [scanPlaneOpacity = 0.9] 扫描面透明度
   * @property {Number} [scanPlaneMode = 'vertical'] 扫描面方向模式,可选值：vertical（解释：垂直方向）、horizontal（解释：水平方向）
   * @property {Number} [scanPlaneRate = 3] 扫描速率
   *
   * @property {Boolean} [showSectorLines = true] 是否显示扇面的线
   * @property {Boolean} [showSectorSegmentLines = true] 是否显示扇面和圆顶面连接的线
   *
   * @property {Boolean} [showLateralSurfaces = true] 是否显示侧面
   * @property {Cesium.MaterialProperty } [lateralSurfaceMaterial] 侧面材质
   *
   * @property {Boolean} [showDomeSurfaces = true] 是否显示圆顶表面
   * @property {Cesium.MaterialProperty } [domeSurfaceMaterial] 圆顶表面材质
   * @property {Boolean} [showDomeLines = true] 是否显示圆顶面线
   *
   * @property {Boolean} [showIntersection = true] 是否显示与地球相交的线
   * @property {Cesium.Color} [intersectionColor = Cesium.Color.WHITE] 与地球相交的线的颜色
   * @property {Cesium.Color} [intersectionWidth = 5.0] 与地球相交的线的宽度（像素）
   *
   * @property {Number} [slice = 32] 切分程度
   * @property {Boolean} [depthTest = true] 是否被遮挡
   */

  /**
   * 相控阵雷达  Entity对象，该对象暂不支持鼠标交互和拾取
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {RectangularSensor.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.Property} [options.orientation] 实体方向
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @extends {BasePointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class RectangularSensor extends BasePointEntity {
    /**
     * 矢量数据对应的 Cesium内部对象的具体类型对象
     * @type {*}
     * @readonly
     */
    get entityGraphic() {
      return this._entity?.rectangularSensorMars
    }

    /**
     * 圆的半径（单位：米）
     * @type {Number}
     */
    get radius() {
      return this.style.radius
    }

    set radius(val) {
      this.style.radius = val;

      if (this._entity) {
        this.entityGraphic.radius = val;
      }
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      const addattr = {
        position: this.position,
        orientation: this.getOrientation(),
        rectangularSensorMars: new RectangularSensorGraphics(RectangularSensorStyleConver.toCesiumVal(this.style))
      };
      this._entity = this._createEntity(addattr);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      if (this._entity && this._state === State.ADDED) {
        const dataSource = this._layer.dataSource;

        dataSource.entities.remove(this._entity);
        delete this._entity;

        this._mountedHook();
        dataSource.entities.add(this._entity);
      }
    }

    _updateEntityOpacity(entityGraphic, value) {
      const material = entityGraphic?.material;
      if (!material) {
        return false
      }

      // 纯色时
      const color = getCesiumColor(material.color, Cesium__namespace.Color.WHITE);
      if (!Cesium__namespace.defined(this._material_color_alpha)) {
        this._material_color_alpha = color.alpha;
      }
      material.color = color.withAlpha(this._material_color_alpha * value);
      return true
    }

    _updateExOpacity(value) {
      const lineColor = getCesiumColor(this.entityGraphic.lineColor, Cesium__namespace.Color.WHITE);
      if (!Cesium__namespace.defined(this._lineColor_alpha)) {
        this._lineColor_alpha = lineColor.alpha;
      }
      this.entityGraphic.lineColor = lineColor.withAlpha(this._lineColor_alpha * value);

      const scanPlaneColor = getCesiumColor(this.entityGraphic.scanPlaneColor, Cesium__namespace.Color.WHITE);
      if (!Cesium__namespace.defined(this._scanPlaneColor_alpha)) {
        this._scanPlaneColor_alpha = scanPlaneColor.alpha;
      }
      this.entityGraphic.scanPlaneColor = scanPlaneColor.withAlpha(this._scanPlaneColor_alpha * value);
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return RectangularSensorStyleConver.toJSON(czmStyle, styleJson, true)
    }
  }
  // 注册下
  register$4("rectangularSensor", RectangularSensor);

  const DEF_STYLE$j = {
    distance: 0.1,
    perPositionHeight: true,
    showFrustum: false,
    opacity: 1.0
  };

  // 不能用primitive，因为primitive不支持DOM材质

  /**
   * 视频融合（投射2D平面） 支持的样式信息
   *
   * @typedef {Object} Video2D.StyleOptions
   *
   * @property {HTMLVideoElement} options.container 视频对应的video标签
   * @property {Number} angle  水平张角(度数)
   * @property {Number} angle2  垂直张角(度数)
   * @property {Number} distance 投射距离
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   *
   * @property {Number} [opacity = 1.0] 透明度
   * @property {Cesium.MaterialProperty | BaseMaterialProperty| Cesium.Color} [material=Cesium.Color.WHITE] 指定用于填充的材质，指定material后。
   *
   * @property {Number} [stRotation = 0] 多边形纹理的角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [stRotationDegree = 0] 多边形纹理的角度（度数值，0-360度），与stRotation二选一
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {Number} [outlineWidth = 1] 边框宽度
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   * @property {PolylineEntity.StyleOptions} [outlineStyle] 边框的完整自定义样式，会覆盖outlineWidth、outlineColor等参数。
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定多边形是投射还是接收来自光源的阴影。
   * @property {Boolean} [showFrustum=false] 是否显示视椎体框线
   *
   * @see PolygonEntity.StyleOptions
   */

  /**
   * 视频融合（投射2D平面）,
   * 根据相机位置、方向等参数，在相机前面生成一个PolygonEntity面，然后贴视频纹理
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 相机坐标位置
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} [options.targetPosition] 目标视点位置,可以替代style中的相机heading\pitch\roll方向和distance距离参数
   * @param {Video2D.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class Video2D
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class Video2D extends PolygonEntity {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$j,
        ...(options.style || {})
      };
      super(options);

      delete options.styleType;

      if (options.position) {
        this.position = options.position;
      }

      this._videoPlay = true;
    }

    // 文本等附加对象
    get czmObjectEx() {
      let arr = [];
      if (this._frustumPrimitive) {
        arr.push(this._frustumPrimitive);
      }

      if (this._entity_label) {
        arr.push(this._entity_label);
      }
      if (this._entity_outlines) {
        arr = arr.concat(this._entity_outlines);
      }
      return arr
    }

    /**
     * 位置坐标 （笛卡尔坐标）, 赋值时可以传入LatLngPoint对象
     * @type {Cesium.Cartesian3|LngLatPoint}
     */
    get position() {
      return this._position
    }

    set position(value) {
      this._point = LngLatPoint.parse(value);
      this._position = this._point?.toCartesian();
      if (this._entity) {
        this._updatePositionsHook();
        this._updateDraw();
      }
    }

    /**
     * 位置坐标 （笛卡尔坐标）
     * @type {LngLatPoint}
     * @readonly
     */
    get point() {
      return this._point
    }

    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @type {Array}
     * @readonly
     */
    get coordinate() {
      return this.point.toArray()
    }

    /**
     * 目标点位置(笛卡尔坐标)
     * @type {Cesium.Cartesian3|LngLatPoint}
     */
    get targetPosition() {
      return this.options.targetPosition
    }

    set targetPosition(value) {
      this.options.targetPosition = value;
      if (!this._map) {
        return
      }

      const cameraPosition = this.position;
      if (!cameraPosition) {
        return
      }
      const targetPosition = LngLatPoint.toCartesian(value, this._map?.currentTime);
      this.distance = Cesium__namespace.Cartesian3.distance(cameraPosition, targetPosition);

      const direction = Cesium__namespace.Cartesian3.normalize(
        Cesium__namespace.Cartesian3.subtract(targetPosition, cameraPosition, new Cesium__namespace.Cartesian3()),
        new Cesium__namespace.Cartesian3()
      );
      const up = Cesium__namespace.Cartesian3.normalize(cameraPosition, new Cesium__namespace.Cartesian3());
      const camera = new Cesium__namespace.Camera(this._map.scene);
      camera.position = cameraPosition;
      camera.direction = direction;
      camera.up = up;
      this.style.heading = Cesium__namespace.Math.toDegrees(camera.heading);
      this.style.pitch = Cesium__namespace.Math.toDegrees(camera.pitch);
      // this.style.roll = Cesium.Math.toDegrees(camera.roll);

      this._updateDraw();
    }

    /**
     * 四周方向角，0-360度角度值
     * <br/>提示：父类属性，非所有子类都具备
     * @type {Number}
     */
    get heading() {
      return this.style.heading ?? 0
    }

    set heading(val) {
      this.style.heading = val;
      this._updateDraw();
    }

    /**
     * 俯仰角，上下摇摆的角度，0-360度角度值
     * <br/>提示：父类属性，非所有子类都具备
     * @type {Number}
     */
    get pitch() {
      return this.style.pitch ?? 0
    }

    set pitch(val) {
      this.style.pitch = val;
      this._updateDraw();
    }

    /**
     * 滚转角，左右摆动的角度，0-360度角度值
     * <br/>提示：父类属性，非所有子类都具备
     * @type {Number}
     */
    get roll() {
      return this.style.roll ?? 0
    }

    set roll(val) {
      this.style.roll = val;
      this._updateDraw();
    }

    /**
     * 水平张角，半场角度
     * @type {Number}
     */
    get angle() {
      return this.style.angle
    }

    set angle(val) {
      this.style.angle = val;
      this._updateDraw();
    }

    /**
     * 垂直张角，半场角度
     * @type {Number}
     */
    get angle2() {
      return this.style.angle2 ?? this.style.angle
    }

    set angle2(val) {
      this.style.angle2 = val;
      this._updateDraw();
    }

    /**
     * 投射距离（单位：米）
     * @type {Number}
     */
    get distance() {
      return this.style.distance
    }

    set distance(val) {
      this.style.distance = val;
      this._updateDraw();
    }

    /**
     * 混合系数0-1
     * @type {Number}
     */
    get opacity() {
      return this.style.opacity
    }

    set opacity(val) {
      this.style.opacity = val;
      if (this._entity) {
        this._entity.polygon.material._color._value.alpha = val;
        this._entity.polygon.material.transparent = val !== 1;
      }
    }

    /**
     * 是否显示视椎体框线
     * @type {Boolean}
     */
    get showFrustum() {
      return this.style.showFrustum
    }

    set showFrustum(val) {
      this.style.showFrustum = val;
      this._frustumPrimitive.show = val;
    }

    /**
     * 暂停或播放 视频
     * @type {Boolean}
     */
    get play() {
      return this._videoPlay
    }

    set play(val) {
      this._videoPlay = val;
      if (!this._videoContainer) {
        return
      }

      try {
        if (this._videoPlay) {
          this._videoContainer.play();
        } else {
          this._videoContainer.pause();
        }
      } catch (e) {
        // 规避浏览器权限异常
      }
    }

    _mountedHook() {
      super._mountedHook();

      // targetPosition的处理
      if (this.options.targetPosition) {
        this.targetPosition = this.options.targetPosition;
      }

      // 创建DOM
      if (this.style.container) {
        this._videoContainer = this.style.container;
      } else if (this.style.url) {
        this._videoContainer = createVideo(this.style.url, this.style.fileType, "", document.body);
        this._videoContainer.style.display = "none";
        this._hasRemoveElement = true;
      }

      if (this._videoContainer) {
        this._entity.polygon.material = new Cesium__namespace.ImageMaterialProperty({
          image: this._videoContainer,
          color: Cesium__namespace.Color.WHITE.withAlpha(this.style.opacity),
          transparent: this.style.opacity !== 1
        });
      }
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      this._updateDraw();
      this.dataSource.entities.add(this._entity);
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this._frustumPrimitive) {
        this._layer.primitiveCollection.remove(this._frustumPrimitive);
        delete this._frustumPrimitive;
      }
      this.dataSource.entities.remove(this._entity);

      if (this._hasRemoveElement && this._videoContainer?.parentNode) {
        this._videoContainer.parentNode.removeChild(this._videoContainer);
        delete this._hasRemoveElement;
        delete this._videoContainer;
      }
    }

    _updateDraw() {
      if (!this._map) {
        return
      }

      // 计算视频面的边界顶点
      const cameraPosition = this.position;
      if (!cameraPosition) {
        return
      }
      const hpr = new Cesium__namespace.HeadingPitchRoll(Cesium__namespace.Math.toRadians(this.heading), Cesium__namespace.Math.toRadians(this.pitch), Cesium__namespace.Math.toRadians(this.roll));

      const _camera = new Cesium__namespace.Camera(this._map.scene);
      _camera.position = cameraPosition;
      _camera.frustum.fov = Cesium__namespace.Math.toRadians(this.angle * 2);
      _camera.frustum.aspectRatio = this.angle / this.angle2;
      _camera.frustum.near = 0.01;
      _camera.frustum.far = this.style.distance;
      _camera.setView({
        destination: cameraPosition,
        orientation: {
          heading: hpr.heading,
          pitch: hpr.pitch,
          roll: hpr.roll
        }
      });

      this._createFrustumPrimitive(_camera);

      const direction = _camera.directionWC;
      const up = _camera.upWC;
      const right = _camera.rightWC;

      const vray = new Cesium__namespace.Ray(cameraPosition, direction);
      const vmbpos = Cesium__namespace.Ray.getPoint(vray, this.style.distance, new Cesium__namespace.Cartesian3());
      const halfFov = Cesium__namespace.Math.toRadians(this.angle);
      const tanres = Math.tan(halfFov);
      const horiDis = this.style.distance * tanres;
      const vertDis = horiDis / _camera.frustum.aspectRatio;
      const xbDis = Math.sqrt(horiDis * horiDis + vertDis * vertDis);

      const pointYS = new Cesium__namespace.Cartesian3();
      const rightRay = new Cesium__namespace.Ray(vmbpos, right);
      const rightPos = Cesium__namespace.Ray.getPoint(rightRay, horiDis, new Cesium__namespace.Cartesian3());
      const upRay = new Cesium__namespace.Ray(rightPos, up);
      Cesium__namespace.Ray.getPoint(upRay, vertDis, pointYS);

      const pointYX = new Cesium__namespace.Cartesian3();
      const fvup = Cesium__namespace.Cartesian3.negate(up, new Cesium__namespace.Cartesian3());
      const fupRay = new Cesium__namespace.Ray(rightPos, fvup);
      Cesium__namespace.Ray.getPoint(fupRay, vertDis, pointYX);

      const pointZX = new Cesium__namespace.Cartesian3();
      const djdir1 = Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(vmbpos, pointYS, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3());
      const djRay1 = new Cesium__namespace.Ray(vmbpos, djdir1);
      Cesium__namespace.Ray.getPoint(djRay1, xbDis, pointZX);

      const pointZS = new Cesium__namespace.Cartesian3();
      const djdir2 = Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(vmbpos, pointYX, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3());
      const djRay2 = new Cesium__namespace.Ray(vmbpos, djdir2);
      Cesium__namespace.Ray.getPoint(djRay2, xbDis, pointZS);

      const positions = [pointZS, pointYS, pointYX, pointZX];
      // if (this.style.reverse) {
      //   positions = [pointYS, pointZS, pointZX, pointYX];
      // }
      this._positions = positions;
      if (this._entity) {
        this._entity.polygon.hierarchy = new Cesium__namespace.PolygonHierarchy(positions);
      }
    }

    // 创建 视椎体框线
    _createFrustumPrimitive(_camera) {
      // 计算视锥姿态
      const direction = _camera.directionWC;
      const up = _camera.upWC;
      let right = _camera.rightWC;
      right = Cesium__namespace.Cartesian3.negate(right, new Cesium__namespace.Cartesian3());

      const rotation = new Cesium__namespace.Matrix3();
      Cesium__namespace.Matrix3.setColumn(rotation, 0, right, rotation);
      Cesium__namespace.Matrix3.setColumn(rotation, 1, up, rotation);
      Cesium__namespace.Matrix3.setColumn(rotation, 2, direction, rotation);
      const orientation = Cesium__namespace.Quaternion.fromRotationMatrix(rotation, new Cesium__namespace.Quaternion());

      // 构造 FrustumOutlineGeometry
      if (this._frustumPrimitive) {
        this._layer.primitiveCollection.remove(this._frustumPrimitive);
      }
      this._frustumPrimitive = new Cesium__namespace.Primitive({
        geometryInstances: new Cesium__namespace.GeometryInstance({
          id: this.id,
          geometry: new Cesium__namespace.FrustumOutlineGeometry({
            origin: _camera.position,
            orientation: orientation,
            frustum: _camera.frustum,
            _drawNearPlane: true
          }),
          attributes: {
            color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(Cesium__namespace.Color.AZURE)
          }
        }),
        appearance: new Cesium__namespace.PerInstanceColorAppearance({
          translucent: false,
          flat: true
        }),
        asynchronous: false,
        show: this.showFrustum && this.show
      });
      this._layer.primitiveCollection.add(this._frustumPrimitive);
    }

    // style样式转object
    _style2JsonBase(style, isGeoJSON) {
      const stylyJson = getAttrVal(style, { onlySimpleType: true });
      if (this.style.container) {
        stylyJson.container = `document.getElementById(${this._videoContainer.id})`;
      }
      return stylyJson
    }

    _getGeoJsonGeometry(options) {
      return { type: "Point", coordinates: this.getCoordinate(options?.noAlt) }
    }


    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @param {Boolean} noAlt true时不导出高度值
     * @return {Array} 位置坐标(数组对象)
     */
    getCoordinate(noAlt) {
      if (this.point) {
        return this.point.toArray(noAlt)
      } else {
        return []
      }
    }

    /**
     * 定位至相机的第一视角
     * @return {void}  无
     */
    setView() {
      if (!this._map) {
        return
      }

      this._map.camera.setView({
        destination: this.position,
        orientation: {
          heading: Cesium__namespace.Math.toRadians(this.heading),
          pitch: Cesium__namespace.Math.toRadians(this.pitch),
          roll: Cesium__namespace.Math.toRadians(this.roll)
        }
      });
    }

    //= =================Draw绘制相关=================
    /**
     * 开始绘制矢量数据，绘制的数据会加载在layer图层。
     *
     * @param {GraphicLayer} layer 图层
     * @return {void}  无
     */
    startDraw(layer) {
      if (this._enabledDraw) {
        return this
      }
      this._enabledDraw = true;

      if (layer) {
        this.addTo(layer);
      }
      if (!this._map) {
        throw new Error("绘制时_map不能为空,请将对象添加到图层，并且图层已添加到Map")
      }

      this._map._setEditCursor(true);
      this.enableControl(false);

      this._startDrawHook();

      this.fire(EventType.drawStart, { drawtype: this.type, graphic: this }, true);
    }

    /**
     * 停止绘制
     * @return {void}  无
     */
    stopDraw() {
      if (!this._enabledDraw) {
        return this
      }

      this._stopDrawHook();

      this._map._setEditCursor(false);
      this.enableControl(true);
      this._map.closeSmallTooltip();

      this._enabledDraw = false;

      if (!this.position || !this.distance) {
        this.remove(true);
        return
      }
      this.fire(EventType.drawCreated, { drawtype: this.type, graphic: this }, true);

      if (this.options?.success) {
        this.options.success(this);
      }
      if (this.options?._promise?.resolve) {
        this.options._promise.resolve(this);
      }
    }

    _startDrawHook() {
      this._map.on(EventType.click, this._onClickHandler, this);
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);
    }

    _stopDrawHook() {
      this._map.off(EventType.click, this._onClickHandler, this);
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);
    }

    _onClickHandler(event) {
      const cartesian = event.cartesian;
      if (!cartesian) {
        return
      }

      this.fire(EventType.drawAddPoint, { ...event, drawtype: this.type, graphic: this }, true);

      if (!this.position) {
        this.position = cartesian; // 相机位置
        return
      }
      this.targetPosition = cartesian;

      this.stopDraw();
      this.fire(EventType.drawCreated, event);
    }

    _onMouseMoveHandler(event) {
      const targetPosition = event.cartesian;
      if (!targetPosition) {
        return
      }

      const position = this.position;
      if (position) {
        this.targetPosition = targetPosition;

        this.fire(EventType.drawMouseMove, { ...event, drawtype: this.type, graphic: this }, true);

        this._map.openSmallTooltip(event.endPosition, this._map.getLangText("_单击完成绘制"));
      } else {
        this._map.openSmallTooltip(event.endPosition, this._map.getLangText("_单击开始绘制"));
      }
    }
  }
  Video2D.isPoint = true; // 对类是否为点状数据的判断,GraphicUtil内用到

  // 注册下
  register$4("video2D", Video2D);

  // 基本计算方法
  class AlgorithmUtil {
    constructor() {
      this.HALF_PI = Math.PI / 2;
      this.ZERO_TOLERANCE = 0.0001;
    }

    toRadians(degrees) {
      return (degrees * Math.PI) / 180.0
    }

    // 获取第三点
    getThirdPoint(startPnt, endPnt, angle, distance, clockWise) {
      const azimuth = this.getAzimuth(startPnt, endPnt);
      const alpha = clockWise ? azimuth + angle : azimuth - angle;
      const dx = distance * Math.cos(alpha);
      const dy = distance * Math.sin(alpha);
      return [endPnt[0] + dx, endPnt[1] + dy]
    }

    // 计算夹角(弧度值)
    getAzimuth(startPoint, endPoint) {
      let azimuth = 0;
      const angle = Math.asin(Math.abs(endPoint[1] - startPoint[1]) / this.MathDistance(startPoint, endPoint));
      if (endPoint[1] >= startPoint[1] && endPoint[0] >= startPoint[0]) {
        azimuth = angle + Math.PI;
      } else if (endPoint[1] >= startPoint[1] && endPoint[0] < startPoint[0]) {
        azimuth = Math.PI * 2 - angle;
      } else if (endPoint[1] < startPoint[1] && endPoint[0] < startPoint[0]) {
        azimuth = angle;
      } else if (endPoint[1] < startPoint[1] && endPoint[0] >= startPoint[0]) {
        azimuth = Math.PI - angle;
      }
      return azimuth
    }

    MathDistance(pnt1, pnt2) {
      return Math.sqrt(Math.pow(pnt1[0] - pnt2[0], 2) + Math.pow(pnt1[1] - pnt2[1], 2))
    }

    // 计算闭合曲面上的点
    isClockWise(pnt1, pnt2, pnt3) {
      if (!pnt3) {
        return false
      }
      return (pnt3[1] - pnt1[1]) * (pnt2[0] - pnt1[0]) > (pnt2[1] - pnt1[1]) * (pnt3[0] - pnt1[0])
    }

    getBisectorNormals(t, pnt1, pnt2, pnt3) {
      const normal = this.getNormal(pnt1, pnt2, pnt3);
      let bisectorNormalRight = null;
        let bisectorNormalLeft = null;
        let dt = null;
        let x = null;
        let y = null;

      const dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
      const uX = normal[0] / dist;
      const uY = normal[1] / dist;
      const d1 = this.MathDistance(pnt1, pnt2);
      const d2 = this.MathDistance(pnt2, pnt3);
      if (dist > this.ZERO_TOLERANCE) {
        if (this.isClockWise(pnt1, pnt2, pnt3)) {
          dt = t * d1;
          x = pnt2[0] - dt * uY;
          y = pnt2[1] + dt * uX;
          bisectorNormalRight = [x, y];
          dt = t * d2;
          x = pnt2[0] + dt * uY;
          y = pnt2[1] - dt * uX;
          bisectorNormalLeft = [x, y];
        } else {
          dt = t * d1;
          x = pnt2[0] + dt * uY;
          y = pnt2[1] - dt * uX;
          bisectorNormalRight = [x, y];
          dt = t * d2;
          x = pnt2[0] - dt * uY;
          y = pnt2[1] + dt * uX;
          bisectorNormalLeft = [x, y];
        }
      } else {
        x = pnt2[0] + t * (pnt1[0] - pnt2[0]);
        y = pnt2[1] + t * (pnt1[1] - pnt2[1]);
        bisectorNormalRight = [x, y];
        x = pnt2[0] + t * (pnt3[0] - pnt2[0]);
        y = pnt2[1] + t * (pnt3[1] - pnt2[1]);
        bisectorNormalLeft = [x, y];
      }
      return [bisectorNormalRight, bisectorNormalLeft]
    }

    getCubicValue(t, startPnt, cPnt1, cPnt2, endPnt) {
      t = Math.max(Math.min(t, 1), 0);
      const tp = 1 - t;
        const t2 = t * t;

      const t3 = t2 * t;
      const tp2 = tp * tp;
      const tp3 = tp2 * tp;
      const x = tp3 * startPnt[0] + 3 * tp2 * t * cPnt1[0] + 3 * tp * t2 * cPnt2[0] + t3 * endPnt[0];
      const y = tp3 * startPnt[1] + 3 * tp2 * t * cPnt1[1] + 3 * tp * t2 * cPnt2[1] + t3 * endPnt[1];
      return [x, y]
    }

    getNormal(pnt1, pnt2, pnt3) {
      let dX1 = pnt1[0] - pnt2[0];
      let dY1 = pnt1[1] - pnt2[1];
      const d1 = Math.sqrt(dX1 * dX1 + dY1 * dY1);
      dX1 /= d1;
      dY1 /= d1;
      let dX2 = pnt3[0] - pnt2[0];
      let dY2 = pnt3[1] - pnt2[1];
      const d2 = Math.sqrt(dX2 * dX2 + dY2 * dY2);
      dX2 /= d2;
      dY2 /= d2;
      const uX = dX1 + dX2;
      const uY = dY1 + dY2;
      return [uX, uY]
    }

    getArcPoints(center, radius, startAngle, endAngle) {
      let x = null;
        let y = null;
        const pnts = [];
        let angleDiff = endAngle - startAngle;
      angleDiff = angleDiff < 0 ? angleDiff + Math.PI * 2 : angleDiff;
      for (let i = 0; i <= 100; i++) {
        const angle = startAngle + (angleDiff * i) / 100;
        x = center[0] + radius * Math.cos(angle);
        y = center[1] + radius * Math.sin(angle);
        pnts.push([x, y]);
      }
      return pnts
    }

    getPointByAngleAndLen(center, radius, angle) {
      const x = center[0] + radius * Math.cos(angle);
      const y = center[1] + radius * Math.sin(angle);
      return [x, y]
    }

    getBaseLength(points) {
      return Math.pow(this.wholeDistance(points), 0.99)
    }

    // 全部距离长度
    wholeDistance(points) {
      let distance = 0;
      const that = this;
      if (points && Array.isArray(points) && points.length > 0) {
        points.forEach(function (item, index) {
          if (index < points.length - 1) {
            distance += that.MathDistance(item, points[index + 1]);
          }
        });
      }
      return distance
    }

    getArrowHeadPoints(obj) {
      if (!obj) {
        return []
      }
      const points = obj.points;
      if (points.length < 2) {
        return []
      }
      const tailLeft = obj.tailLeft;
      const tailRight = obj.tailRight;
      const headTailFactor = obj.headTailFactor;
      const neckWidthFactor = obj.neckWidthFactor;
      const neckHeightFactor = obj.neckHeightFactor;
      const headWidthFactor = obj.headWidthFactor;
      const headHeightFactor = obj.headHeightFactor;
      let len = this.getBaseLength(points);
      let headHeight = len * headHeightFactor;
      const headPnt = points[points.length - 1];
      len = this.MathDistance(headPnt, points[points.length - 2]);
      const tailWidth = this.MathDistance(tailLeft, tailRight);
      if (headHeight > tailWidth * headTailFactor) {
        headHeight = tailWidth * headTailFactor;
      }
      const headWidth = headHeight * headWidthFactor;
      const neckWidth = headHeight * neckWidthFactor;
      headHeight = headHeight > len ? len : headHeight;
      const neckHeight = headHeight * neckHeightFactor;
      const headEndPnt = this.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
      const neckEndPnt = this.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
      const headLeft = this.getThirdPoint(headPnt, headEndPnt, this.HALF_PI, headWidth, false);
      const headRight = this.getThirdPoint(headPnt, headEndPnt, this.HALF_PI, headWidth, true);
      const neckLeft = this.getThirdPoint(headPnt, neckEndPnt, this.HALF_PI, neckWidth, false);
      const neckRight = this.getThirdPoint(headPnt, neckEndPnt, this.HALF_PI, neckWidth, true);
      return [neckLeft, headLeft, headPnt, headRight, neckRight]
    }

    getTailPoints(obj) {
      if (!obj) {
        return
      }
      const points = obj.points;
      const tailWidthFactor = obj.tailWidthFactor;
      const swallowTailFactor = obj.swallowTailFactor;
      const allLen = this.getBaseLength(points);
      const tailWidth = allLen * tailWidthFactor;
      const tailLeft = this.getThirdPoint(points[1], points[0], this.HALF_PI, tailWidth, false);
      const tailRight = this.getThirdPoint(points[1], points[0], this.HALF_PI, tailWidth, true);
      const len = tailWidth * swallowTailFactor;
      const swallowTailPnt = this.getThirdPoint(points[1], points[0], 0, len, true);
      return [tailLeft, swallowTailPnt, tailRight]
    }

    getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
      const allLen = this.wholeDistance(points);
      const len = this.getBaseLength(points);
      const tailWidth = len * tailWidthFactor;
      const neckWidth = this.MathDistance(neckLeft, neckRight);
      const widthDif = (tailWidth - neckWidth) / 2;
      let tempLen = 0;
        const leftBodyPnts = [];
        const rightBodyPnts = [];

      for (let i = 1; i < points.length - 1; i++) {
        const angle = this.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
        tempLen += this.MathDistance(points[i - 1], points[i]);
        const w = (tailWidth / 2 - (tempLen / allLen) * widthDif) / Math.sin(angle);
        const left = this.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
        const right = this.getThirdPoint(points[i - 1], points[i], angle, w, false);
        leftBodyPnts.push(left);
        rightBodyPnts.push(right);
      }
      return leftBodyPnts.concat(rightBodyPnts)
    }

    getAngleOfThreePoints(pntA, pntB, pntC) {
      const angle = this.getAzimuth(pntB, pntA) - this.getAzimuth(pntB, pntC);
      return angle < 0 ? angle + Math.PI * 2 : angle
    }

    getQBSplinePoints(points) {
      if (points.length <= 2) {
        return points
      } else {
        const n = 2;
          const bSplinePoints = [];

        const m = points.length - n - 1;
        bSplinePoints.push(points[0]);
        for (let i = 0; i <= m; i++) {
          for (let t = 0; t <= 1; t += 0.05) {
            let x = 0;
              let y = 0;

            for (let k = 0; k <= n; k++) {
              const factor = this.getQuadricBSplineFactor(k, t);
              x += factor * points[i + k][0];
              y += factor * points[i + k][1];
            }
            bSplinePoints.push([x, y]);
          }
        }
        bSplinePoints.push(points[points.length - 1]);
        return bSplinePoints
      }
    }

    getQuadricBSplineFactor(k, t) {
      let res = 0;
      if (k === 0) {
        res = Math.pow(t - 1, 2) / 2;
      } else if (k === 1) {
        res = (-2 * Math.pow(t, 2) + 2 * t + 1) / 2;
      } else if (k === 2) {
        res = Math.pow(t, 2) / 2;
      }
      return res
    }

    Mid(point1, point2) {
      return [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2, (point1[2] || 0 + point2[2] || 0) / 2]
    }

    getCircleCenterOfThreePoints(point1, point2, point3) {
      const height = point1[2] || 0;
      const pntA = [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2, height];
      const pntB = [pntA[0] - point1[1] + point2[1], pntA[1] + point1[0] - point2[0], height];
      const pntC = [(point1[0] + point3[0]) / 2, (point1[1] + point3[1]) / 2, height];
      const pntD = [pntC[0] - point1[1] + point3[1], pntC[1] + point1[0] - point3[0], height];
      return this.getIntersectPoint(pntA, pntB, pntC, pntD)
    }

    getIntersectPoint(pntA, pntB, pntC, pntD) {
      if (pntA[1] === pntB[1]) {
        const _f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
        const _x = _f * (pntA[1] - pntC[1]) + pntC[0];
        const _y = pntA[1];
        return [_x, _y]
      }
      if (pntC[1] === pntD[1]) {
        const _e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
        const _x2 = _e * (pntC[1] - pntA[1]) + pntA[0];
        const _y2 = pntC[1];
        return [_x2, _y2]
      }
      const e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
      const f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
      const y = (e * pntA[1] - pntA[0] - f * pntC[1] + pntC[0]) / (e - f);
      const x = e * y - e * pntA[1] + pntA[0];
      return [x, y, pntA[2] || 0]
    }

    getBezierPoints(points) {
      if (points.length <= 2) {
        return points
      } else {
        const bezierPoints = [];
        const n = points.length - 1;
        for (let t = 0; t <= 1; t += 0.01) {
          let x = 0;
            let y = 0;

          for (let index = 0; index <= n; index++) {
            const factor = this.getBinomialFactor(n, index);
            const a = Math.pow(t, index);
            const b = Math.pow(1 - t, n - index);
            x += factor * a * b * points[index][0];
            y += factor * a * b * points[index][1];
          }
          bezierPoints.push([x, y]);
        }
        // bezierPoints.push(points[n]);
        return bezierPoints
      }
    }

    getFactorial(n) {
      let result = 1;
      switch (n) {
        case n <= 1:
          result = 1;
          break
        case n === 2:
          result = 2;
          break
        case n === 3:
          result = 6;
          break
        case n === 24:
          result = 24;
          break
        case n === 5:
          result = 120;
          break
        default:
          for (let i = 1; i <= n; i++) {
            result *= i;
          }
          break
      }
      return result
    }

    getBinomialFactor(n, index) {
      return this.getFactorial(n) / (this.getFactorial(index) * this.getFactorial(n - index))
    }
  }

  // 外部使用，单例模式
  const algorithmUtil = new AlgorithmUtil();

  const minAnalge = algorithmUtil.toRadians(20);
  const maxAnalge = algorithmUtil.toRadians(160);

  // 箭头的父类
  class ArrowParentUtil {
    constructor() {
      this.algorithmUtil = algorithmUtil;
    }

    getMaxHeight(pnts) {
      let maxHeight = pnts[0][2] || 0;
      for (let i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }
      return maxHeight
    }

    getArrowHeadPoints(points, tailLeft, tailRight) {
      if (!points || points.length < 2) {
        return null
      }

      let headHeight = this.algorithmUtil.getBaseLength(points) * this.headHeightFactor;
      const tailWidth = this.algorithmUtil.MathDistance(tailLeft, tailRight);
      if (headHeight > tailWidth * this.headTailFactor) {
        headHeight = tailWidth * this.headTailFactor;
      }

      const headPnt = points[points.length - 1];
      const lintPoint2 = points[points.length - 2];
      const len = this.algorithmUtil.MathDistance(headPnt, lintPoint2);
      headHeight = headHeight > len ? len : headHeight;

      const headWidth = headHeight * this.headWidthFactor;
      const neckWidth = headHeight * this.neckWidthFactor;
      const neckHeight = headHeight * this.neckHeightFactor;
      const headEndPnt = this.algorithmUtil.getThirdPoint(lintPoint2, headPnt, 0, headHeight, true);
      const neckEndPnt = this.algorithmUtil.getThirdPoint(lintPoint2, headPnt, 0, neckHeight, true);
      const headLeft = this.algorithmUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, false);
      const headRight = this.algorithmUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, true);
      const neckLeft = this.algorithmUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, false);
      const neckRight = this.algorithmUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, true);
      return [neckLeft, headLeft, headPnt, headRight, neckRight]
    }

    getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
      const allLen = this.algorithmUtil.wholeDistance(points); // 全部距离长度
      const len = this.algorithmUtil.getBaseLength(points);
      const tailWidth = len * tailWidthFactor;
      const neckWidth = this.algorithmUtil.MathDistance(neckLeft, neckRight); // 箭头宽度
      const widthDif = (tailWidth - neckWidth) / 2;

      let tempLen = 0;
      const leftBodyPnts = [];
      const rightBodyPnts = [];

      for (let i = 1; i < points.length - 1; i++) {
        let angle = this.algorithmUtil.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
        if (angle < minAnalge) {
          angle = minAnalge;
        } else if (angle > maxAnalge) {
          angle = maxAnalge;
        }

        tempLen += this.algorithmUtil.MathDistance(points[i - 1], points[i]);
        const w = (tailWidth / 2 - (tempLen / allLen) * widthDif) / Math.sin(angle);

        const left = this.algorithmUtil.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
        const right = this.algorithmUtil.getThirdPoint(points[i - 1], points[i], angle, w, false);
        leftBodyPnts.push(left);
        rightBodyPnts.push(right);
      }
      return leftBodyPnts.concat(rightBodyPnts)
    }
  }

  // 攻击箭头
  class AttackArrowUtil extends ArrowParentUtil {
    // 相关参数
    setOptions(opt = {}) {
      this.headHeightFactor = opt.headHeightFactor || 0.18;
      this.headWidthFactor = opt.headWidthFactor || 0.3;
      this.neckHeightFactor = opt.neckHeightFactor || 0.85;
      this.neckWidthFactor = opt.neckWidthFactor || 0.15;
      this.headTailFactor = opt.headTailFactor || 0.8;
    }

    // 开始计算
    startCompute(positions, opt) {
      if (!positions || positions.length === 0) {
        return positions
      }
      this.positions = positions;

      this.setOptions(opt);

      const pnts = cartesians2mercators(positions);
      const maxHeight = this.getMaxHeight(pnts);

      const ptEnd1 = pnts[pnts.length - 1];
      const ptEnd2 = pnts[pnts.length - 2];
      const len = this.algorithmUtil.MathDistance(ptEnd1, ptEnd2);
      if (len < 1 && pnts.length > 2) { // 如果最后2个点很近的特殊处理
        pnts.splice(pnts.length - 2, 1);
      }


      // 箭头尾巴上的2个点
      let tailLeft = pnts[0];
      let tailRight = pnts[1];

      if (this.algorithmUtil.isClockWise(pnts[0], pnts[1], pnts[2])) {
        tailLeft = pnts[1];
        tailRight = pnts[0];
      }
      const midTail = this.algorithmUtil.Mid(tailLeft, tailRight); // 尾巴中点

      const bonePnts = [midTail].concat(pnts.slice(2)); // 尾巴中点+其他点连成的直线

      // 计算箭头
      const headPnts = this.getArrowHeadPoints(bonePnts, tailLeft, tailRight);
      if (!headPnts || headPnts.length < 4) {
        return positions
      }
      const neckLeft = headPnts[0];
      const neckRight = headPnts[4];

      // 计算箭身
      const tailWidthFactor = this.algorithmUtil.MathDistance(tailLeft, tailRight) / this.algorithmUtil.getBaseLength(bonePnts);
      const bodyPnts = this.getArrowBodyPoints(bonePnts, neckLeft, neckRight, tailWidthFactor);
      const count = bodyPnts.length;

      // 左边点
      let leftPnts = [tailLeft].concat(bodyPnts.slice(0, count / 2));
      leftPnts.push(neckLeft);

      // 右边点
      let rightPnts = [tailRight].concat(bodyPnts.slice(count / 2, count));
      rightPnts.push(neckRight);

      // 计算曲线
      leftPnts = this.algorithmUtil.getQBSplinePoints(leftPnts);
      rightPnts = this.algorithmUtil.getQBSplinePoints(rightPnts);

      // 左边点+箭头+右边点 连接起来
      const pList = leftPnts.concat(headPnts, rightPnts.reverse());

      const returnArr = mercators2cartesians(pList, maxHeight);
      return returnArr
    }
  }

  // 主要算法
  const attackArrowUtil$1 = new AttackArrowUtil();

  /**
   *  攻击箭头  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class AttackArrow
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class AttackArrow extends PolygonEntity {
    // 是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    get hasClosure() {
      return false
    }

    getShowPositions(positions) {
      if (!positions || positions.length < 2) {
        return positions
      }
      return attackArrowUtil$1.startCompute(positions, this.style)
    }


  }

  // 注册下
  register$4("attackArrow", AttackArrow);

  // 攻击箭头（燕尾）
  class AttackArrowPWUtil extends ArrowParentUtil {
    // 相关参数
    setOptions(opt = {}) {
      this.headHeightFactor = opt.headHeightFactor || 0.18;
      this.headWidthFactor = opt.headWidthFactor || 0.3;
      this.neckHeightFactor = opt.neckHeightFactor || 0.85;
      this.neckWidthFactor = opt.neckWidthFactor || 0.15;
      this.tailWidthFactor = opt.tailWidthFactor || 0.1;
    }

    // 开始计算
    startCompute(positions, opt) {
      if (!positions || positions.length === 0) {
        return positions
      }
      this.positions = positions;

      this.setOptions(opt);

      const pnts = cartesians2mercators(positions);
      const maxHeight = this.getMaxHeight(pnts);

      const tailPnts = this.getTailPoints(pnts);
      const headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[1]);
      if (!headPnts || headPnts.length < 4) {
        return positions
      }
      const neckLeft = headPnts[0];
      const neckRight = headPnts[4];
      const bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this.tailWidthFactor);
      const _count = bodyPnts.length;
      let leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, _count / 2));
      leftPnts.push(neckLeft);
      let rightPnts = [tailPnts[1]].concat(bodyPnts.slice(_count / 2, _count));
      rightPnts.push(neckRight);
      leftPnts = this.algorithmUtil.getQBSplinePoints(leftPnts);
      rightPnts = this.algorithmUtil.getQBSplinePoints(rightPnts);
      const pList = leftPnts.concat(headPnts, rightPnts.reverse());

      const returnArr = mercators2cartesians(pList, maxHeight);
      return returnArr
    }

    getTailPoints(points) {
      const allLen = this.algorithmUtil.getBaseLength(points);
      const tailWidth = allLen * this.tailWidthFactor;
      const tailLeft = this.algorithmUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, false);
      const tailRight = this.algorithmUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, true);
      return [tailLeft, tailRight]
    }
  }

  // 主要算法
  const attackArrowPWUtil = new AttackArrowPWUtil();

  /**
   *  攻击箭头(平尾)  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class AttackArrowPW
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class AttackArrowPW extends PolygonEntity {
    // 是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    get hasClosure() {
      return false
    }

    getShowPositions(positions) {
      if (!positions || positions.length < 2) {
        return positions
      }
      return attackArrowPWUtil.startCompute(positions, this.style)
    }

    //= =================静态方法=================



    /**
     * 计算当前军标对象的边界坐标点
     * @static
     * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} positions 坐标位置
     * @param {Object} [options] 控制参数(预留)
     * @return {Cesium.Cartesian3[]} 边界坐标点
     */
    static getOutlinePositions(positions, options) {
      if (!positions || positions.length < 2) {
        return positions
      }
      positions = LngLatArray.toCartesians(positions);
      return attackArrowPWUtil.startCompute(positions, options)
    }
  }

  // 注册下
  register$4("attackArrowPW", AttackArrowPW);

  // 攻击箭头（燕尾）
  class AttackArrowYWUtil extends ArrowParentUtil {
    // 相关参数
    setOptions(opt = {}) {
      this.headHeightFactor = opt.headHeightFactor || 0.18;
      this.headWidthFactor = opt.headWidthFactor || 0.3;
      this.neckHeightFactor = opt.neckHeightFactor || 0.85;
      this.neckWidthFactor = opt.neckWidthFactor || 0.15;
      this.tailWidthFactor = opt.tailWidthFactor || 0.1;
      this.headTailFactor = opt.headTailFactor || 0.8;
      this.swallowTailFactor = opt.swallowTailFactor || 1;
    }

    // 开始计算
    startCompute(positions, opt) {
      if (!positions || positions.length === 0) {
        return positions
      }
      this.positions = positions;

      this.setOptions(opt);

      const pnts = cartesians2mercators(positions);
      const maxHeight = this.getMaxHeight(pnts);

      const _ref = [pnts[0], pnts[1]];
        let tailLeft = _ref[0];
        let tailRight = _ref[1];

      if (this.algorithmUtil.isClockWise(pnts[0], pnts[1], pnts[2])) {
        tailLeft = pnts[1];
        tailRight = pnts[0];
      }
      const midTail = this.algorithmUtil.Mid(tailLeft, tailRight);
      const bonePnts = [midTail].concat(pnts.slice(2));
      const headPnts = this.getArrowHeadPoints(bonePnts, tailLeft, tailRight);
      if (!headPnts || headPnts.length < 4) {
        return positions
      }
      const _ref2 = [headPnts[0], headPnts[4]];
        const neckLeft = _ref2[0];
        const neckRight = _ref2[1];

      const tailWidth = this.algorithmUtil.MathDistance(tailLeft, tailRight);
      const allLen = this.algorithmUtil.getBaseLength(bonePnts);
      const len = allLen * this.tailWidthFactor * this.swallowTailFactor;
      const swallowTailPnt = this.algorithmUtil.getThirdPoint(bonePnts[1], bonePnts[0], 0, len, true);
      const factor = tailWidth / allLen;
      const bodyPnts = this.getArrowBodyPoints(bonePnts, neckLeft, neckRight, factor);
      const count = bodyPnts.length;
      let leftPnts = [tailLeft].concat(bodyPnts.slice(0, count / 2));
      leftPnts.push(neckLeft);
      let rightPnts = [tailRight].concat(bodyPnts.slice(count / 2, count));
      rightPnts.push(neckRight);
      leftPnts = this.algorithmUtil.getQBSplinePoints(leftPnts);
      rightPnts = this.algorithmUtil.getQBSplinePoints(rightPnts);
      const pList = leftPnts.concat(headPnts, rightPnts.reverse(), [swallowTailPnt, leftPnts[0]]);

      const returnArr = mercators2cartesians(pList, maxHeight);
      return returnArr
    }
  }

  // 主要算法
  const attackArrowUtil = new AttackArrowYWUtil();

  /**
   *  攻击箭头（燕尾）  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class AttackArrowYW
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class AttackArrowYW extends PolygonEntity {
    // 是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
    get hasClosure() {
      return false
    }

    getShowPositions(positions) {
      if (!positions || positions.length < 3) {
        return positions
      }
      return attackArrowUtil.startCompute(positions, this.style)
    }

    //= =================静态方法=================


    /**
     * 计算当前军标对象的边界坐标点
     * @static
     * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} positions 坐标位置
     * @param {Object} [options] 控制参数(预留)
     * @return {Cesium.Cartesian3[]} 边界坐标点
     */
    static getOutlinePositions(positions, options) {
      if (!positions || positions.length < 3) {
        return positions
      }
      positions = LngLatArray.toCartesians(positions);
      return attackArrowUtil.startCompute(positions, options)
    }
  }

  // 注册下
  register$4("attackArrowYW", AttackArrowYW);

  // 闭合曲面
  class CloseCurveUtil {
    constructor() {
      this.algorithmUtil = algorithmUtil;
    }
    // //相关参数
    // setOptions(opt = {}) {
    //   //
    // }

    // 开始计算
    startCompute(positions, opt) {
      if (!positions || positions.length === 0) {
        return positions
      }
      this.positions = positions;
      // this.setOptions(opt);

      const pnts = cartesians2mercators(positions);
      const maxHeight = this.getMaxHeight(pnts);
      pnts.push(pnts[0], pnts[1]);

      let normals = [];
      const pList = [];
      for (let i = 0; i < pnts.length - 2; i++) {
        const normalPoints = this.algorithmUtil.getBisectorNormals(0.3, pnts[i], pnts[i + 1], pnts[i + 2]);
        normals = normals.concat(normalPoints);
      }
      const count = normals.length;
      normals = [normals[count - 1]].concat(normals.slice(0, count - 1));
      for (let _i = 0; _i < pnts.length - 2; _i++) {
        const pnt1 = pnts[_i];
        const pnt2 = pnts[_i + 1];
        pList.push(pnt1);
        for (let t = 0; t <= 100; t++) {
          const pnt = this.algorithmUtil.getCubicValue(t / 100, pnt1, normals[_i * 2], normals[_i * 2 + 1], pnt2);
          pList.push(pnt);
        }
        pList.push(pnt2);
      }

      const returnArr = mercators2cartesians(pList, maxHeight);
      return returnArr
    }

    getMaxHeight(pnts) {
      let maxHeight = pnts[0][2] || 0;
      for (let i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }
      return maxHeight
    }
  }

  // 主要算法
  const closeCurveUtil = new CloseCurveUtil();

  /**
   * 闭合曲面(3个点)   Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class CloseVurve
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class CloseVurve extends PolygonEntity {
    getShowPositions(positions) {
      if (!positions || positions.length < 2) {
        return positions
      }
      return closeCurveUtil.startCompute(positions, this.style)
    }

    //= =================静态方法=================

    /**
     * 计算当前军标对象的边界坐标点
     *
     * @static
     * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} positions 坐标位置
     * @param {Object} [options] 控制参数(预留)
     * @return {Cesium.Cartesian3[]} 边界坐标点
     */
    static getOutlinePositions(positions, options) {
      if (!positions || positions.length < 2) {
        return positions
      }
      positions = LngLatArray.toCartesians(positions);
      return closeCurveUtil.startCompute(positions, options)
    }
  }

  // 注册下
  register$4("closeVurve", CloseVurve);

  // 计算钳击箭头坐标
  class DoubleArrowUtil {
    constructor() {
      this.algorithmUtil = algorithmUtil;
    }

    // 相关参数
    setOptions(opt = {}) {
      this.headHeightFactor = opt.headHeightFactor || 0.25;
      this.headWidthFactor = opt.headWidthFactor || 0.3;
      this.neckHeightFactor = opt.neckHeightFactor || 0.85;
      this.neckWidthFactor = opt.neckWidthFactor || 0.15;
    }

    // 开始计算
    startCompute(positions, opt) {
      if (!positions || positions.length < 3) {
        return positions
      }
      this.positions = positions;
      this.setOptions(opt);

      const pnts = cartesians2mercators(positions);
      const maxHeight = this.getMaxHeight(pnts);

      const _ref = [pnts[0], pnts[1], pnts[2]];
      const pnt1 = _ref[0];
      const pnt2 = _ref[1];
      const pnt3 = _ref[2];
      const count = this.positions.length;
      let tempPoint4;
      let connPoint;
      if (count === 3) {
        tempPoint4 = this.getTempPoint4(pnt1, pnt2, pnt3);
        connPoint = this.algorithmUtil.Mid(pnt1, pnt2);
      } else if (count === 4) {
        tempPoint4 = pnts[3];
        connPoint = this.algorithmUtil.Mid(pnt1, pnt2);
      } else {
        const len1 = this.algorithmUtil.MathDistance(pnts[3], pnts[4]); // 最后2个点
        const len2 = this.algorithmUtil.MathDistance(pnts[2], pnts[3]); // 2个箭头间的距离
        if (len1 < len2 * 0.1) {
          tempPoint4 = pnts[3];
          connPoint = this.algorithmUtil.Mid(pnt1, pnt2);
        } else {
          tempPoint4 = pnts[3];
          connPoint = pnts[4];
        }
      }
      let leftArrowPnts,
        rightArrowPnts;

      if (this.algorithmUtil.isClockWise(pnt1, pnt2, pnt3)) {
        leftArrowPnts = this.getArrowPoints(pnt1, connPoint, tempPoint4, false);
        rightArrowPnts = this.getArrowPoints(connPoint, pnt2, pnt3, true);
      } else {
        leftArrowPnts = this.getArrowPoints(pnt2, connPoint, pnt3, false);
        rightArrowPnts = this.getArrowPoints(connPoint, pnt1, tempPoint4, true);
      }
      const m = leftArrowPnts.length;
      const t = (m - 5) / 2;
      const llBodyPnts = leftArrowPnts.slice(0, t);
      const lArrowPnts = leftArrowPnts.slice(t, t + 5);
      let lrBodyPnts = leftArrowPnts.slice(t + 5, m);
      let rlBodyPnts = rightArrowPnts.slice(0, t);
      const rArrowPnts = rightArrowPnts.slice(t, t + 5);
      const rrBodyPnts = rightArrowPnts.slice(t + 5, m);
      rlBodyPnts = this.algorithmUtil.getBezierPoints(rlBodyPnts);
      const bodyPnts = this.algorithmUtil.getBezierPoints(rrBodyPnts.concat(llBodyPnts.slice(1)));
      lrBodyPnts = this.algorithmUtil.getBezierPoints(lrBodyPnts);
      const newPnts = rlBodyPnts.concat(rArrowPnts, bodyPnts, lArrowPnts, lrBodyPnts);

      const returnArr = mercators2cartesians(newPnts, maxHeight);
      return returnArr
    }

    getTempPoint4(linePnt1, linePnt2, point) {
      const midPnt = this.algorithmUtil.Mid(linePnt1, linePnt2);
      const len = this.algorithmUtil.MathDistance(midPnt, point);
      const angle = this.algorithmUtil.getAngleOfThreePoints(linePnt1, midPnt, point);
      let symPnt,
        distance1,
        distance2,
        mid;

      if (angle < Math.PI / 2) {
        distance1 = len * Math.sin(angle);
        distance2 = len * Math.cos(angle);
        mid = this.algorithmUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, false);
        symPnt = this.algorithmUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, true);
      } else if (angle >= Math.PI / 2 && angle < Math.PI) {
        distance1 = len * Math.sin(Math.PI - angle);
        distance2 = len * Math.cos(Math.PI - angle);
        mid = this.algorithmUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, false);
        symPnt = this.algorithmUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, false);
      } else if (angle >= Math.PI && angle < Math.PI * 1.5) {
        distance1 = len * Math.sin(angle - Math.PI);
        distance2 = len * Math.cos(angle - Math.PI);
        mid = this.algorithmUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, true);
        symPnt = this.algorithmUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, true);
      } else {
        distance1 = len * Math.sin(Math.PI * 2 - angle);
        distance2 = len * Math.cos(Math.PI * 2 - angle);
        mid = this.algorithmUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, true);
        symPnt = this.algorithmUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, false);
      }
      return symPnt
    }

    getArrowPoints(pnt1, pnt2, pnt3, clockWise) {
      const midPnt = this.algorithmUtil.Mid(pnt1, pnt2);
      const len = this.algorithmUtil.MathDistance(midPnt, pnt3);
      let midPnt1 = this.algorithmUtil.getThirdPoint(pnt3, midPnt, 0, len * 0.3, true);
      let midPnt2 = this.algorithmUtil.getThirdPoint(pnt3, midPnt, 0, len * 0.5, true);
      midPnt1 = this.algorithmUtil.getThirdPoint(midPnt, midPnt1, Math.PI / 2, len / 5, clockWise);
      midPnt2 = this.algorithmUtil.getThirdPoint(midPnt, midPnt2, Math.PI / 2, len / 4, clockWise);
      const points = [midPnt, midPnt1, midPnt2, pnt3];
      const arrowPnts = this.getArrowHeadPoints(points);
      if (arrowPnts && Array.isArray(arrowPnts) && arrowPnts.length > 3) {
        const _ref2 = [arrowPnts[0], arrowPnts[4]];
          const neckLeftPoint = _ref2[0];
          const neckRightPoint = _ref2[1];

        const tailWidthFactor = this.algorithmUtil.MathDistance(pnt1, pnt2) / this.algorithmUtil.getBaseLength(points) / 2;
        const bodyPnts = this.getArrowBodyPoints(points, neckLeftPoint, neckRightPoint, tailWidthFactor);
        if (bodyPnts) {
          const n = bodyPnts.length;
          let lPoints = bodyPnts.slice(0, n / 2);
          let rPoints = bodyPnts.slice(n / 2, n);
          lPoints.push(neckLeftPoint);
          rPoints.push(neckRightPoint);
          lPoints = lPoints.reverse();
          lPoints.push(pnt2);
          rPoints = rPoints.reverse();
          rPoints.push(pnt1);
          return lPoints.reverse().concat(arrowPnts, rPoints)
        }
      } else {
        console.log("getArrowPoints:插值出错", arrowPnts);
      }
    }

    getArrowHeadPoints(points) {
      if (!points || points.length < 2) {
        return []
      }
      const len = this.algorithmUtil.getBaseLength(points);
      const headHeight = len * this.headHeightFactor;
      const headPnt = points[points.length - 1];
      const headWidth = headHeight * this.headWidthFactor;
      const neckWidth = headHeight * this.neckWidthFactor;
      const neckHeight = headHeight * this.neckHeightFactor;
      const headEndPnt = this.algorithmUtil.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
      const neckEndPnt = this.algorithmUtil.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
      const headLeft = this.algorithmUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, false);
      const headRight = this.algorithmUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, true);
      const neckLeft = this.algorithmUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, false);
      const neckRight = this.algorithmUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, true);
      return [neckLeft, headLeft, headPnt, headRight, neckRight]
    }

    getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
      const allLen = this.algorithmUtil.wholeDistance(points);
      const len = this.algorithmUtil.getBaseLength(points);
      const tailWidth = len * tailWidthFactor;
      const neckWidth = this.algorithmUtil.MathDistance(neckLeft, neckRight);
      const widthDif = (tailWidth - neckWidth) / 2;
      let tempLen = 0;
        const leftBodyPnts = [];
        const rightBodyPnts = [];

      for (let i = 1; i < points.length - 1; i++) {
        const angle = this.algorithmUtil.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
        tempLen += this.algorithmUtil.MathDistance(points[i - 1], points[i]);
        const w = (tailWidth / 2 - (tempLen / allLen) * widthDif) / Math.sin(angle);
        const left = this.algorithmUtil.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
        const right = this.algorithmUtil.getThirdPoint(points[i - 1], points[i], angle, w, false);
        leftBodyPnts.push(left);
        rightBodyPnts.push(right);
      }
      return leftBodyPnts.concat(rightBodyPnts)
    }

    getMaxHeight(pnts) {
      let maxHeight = pnts[0][2] || 0;
      for (let i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }
      return maxHeight
    }
  }

  // 主要算法
  const doubleArrowUtil = new DoubleArrowUtil();

  /**
   *  双箭头（钳击）  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class DoubleArrow
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class DoubleArrow extends PolygonEntity {
    constructor(options = {}) {
      super(options);

      this._minPointNum = 3; // 至少需要点的个数
      this._maxPointNum = 5; // 最多允许点的个数
    }

    getShowPositions(positions) {
      if (!positions || positions.length < this._minPointNum) {
        return positions
      }
      return doubleArrowUtil.startCompute(positions, this.style)
    }

    //= =================静态方法=================

    /**
     * 计算当前军标对象的边界坐标点
     * @static
     * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} positions 坐标位置
     * @param {Object} [options] 控制参数(预留)
     * @return {Cesium.Cartesian3[]} 边界坐标点
     */
    static getOutlinePositions(positions, options) {
      if (!positions || positions.length < 3) {
        return positions
      }
      positions = LngLatArray.toCartesians(positions);
      return doubleArrowUtil.startCompute(positions, options)
    }
  }

  // 注册下
  register$4("doubleArrow", DoubleArrow);

  // 计算粗单尖直箭头坐标
  class FineArrowUtil {
    constructor() {
      this.algorithmUtil = algorithmUtil;
    }

    // 相关参数
    setOptions(opt = {}) {
      this.headAngle = opt.headAngle || Math.PI / 8.5;
      this.neckAngle = opt.neckAngle || Math.PI / 13;
      this.tailWidthFactor = opt.tailWidthFactor || 0.1;
      this.neckWidthFactor = opt.neckWidthFactor || 0.2;
      this.headWidthFactor = opt.headWidthFactor || 0.25;
      this.neckHeightFactor = opt.neckHeightFactor || 0.85;
    }

    // 开始计算
    startCompute(positions, opt) {
      if (!positions || positions.length === 0) {
        return positions
      }
      this.positions = positions;
      this.setOptions(opt);

      const pnts = cartesians2mercators(positions);
      const maxHeight = this.getMaxHeight(pnts);

      const _ref = [pnts[0], pnts[1]];
        const pnt1 = _ref[0];
        const pnt2 = _ref[1];
      const len = this.algorithmUtil.getBaseLength(pnts);
      const tailWidth = len * this.tailWidthFactor;
      const neckWidth = len * this.neckWidthFactor;
      const headWidth = len * this.headWidthFactor;
      const tailLeft = this.algorithmUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, true);
      const tailRight = this.algorithmUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, false);
      const headLeft = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, false);
      const headRight = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, true);
      const neckLeft = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, false);
      const neckRight = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, true);
      const pList = [tailLeft, neckLeft, headLeft, pnt2, headRight, neckRight, tailRight];

      const returnArr = mercators2cartesians(pList, maxHeight);
      return returnArr
    }

    getMaxHeight(pnts) {
      let maxHeight = pnts[0][2] || 0;
      for (let i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }
      return maxHeight
    }
  }

  // 主要算法
  const fineArrowUtil = new FineArrowUtil();

  /**
   * 直箭头(2个点)   Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class FineArrow
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class FineArrow extends PolygonEntity {
    constructor(options = {}) {
      super(options);

      this._minPointNum = 2; // 至少需要点的个数
      this._maxPointNum = 2; // 最多允许点的个数
    }

    getShowPositions(positions) {
      if (!positions || positions.length < 2) {
        return positions
      }
      return fineArrowUtil.startCompute(positions, this.style)
    }

    //= =================静态方法=================

    /**
     * 计算当前军标对象的边界坐标点
     * @static
     * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} positions 坐标位置
     * @param {Object} [options] 控制参数(预留)
     * @return {Cesium.Cartesian3[]} 边界坐标点
     */
    static getOutlinePositions(positions, options) {
      if (!positions || positions.length < 2) {
        return positions
      }
      positions = LngLatArray.toCartesians(positions);
      return fineArrowUtil.startCompute(positions, options)
    }
  }

  // 注册下
  register$4("fineArrow", FineArrow);

  // 计算粗单尖直箭头(带燕尾)坐标
  class FineArrowYWUtil extends ArrowParentUtil {
    // 相关参数
    setOptions(opt = {}) {
      this.headHeightFactor = opt.headHeightFactor || 0.18;
      this.headWidthFactor = opt.headWidthFactor || 0.3;
      this.neckHeightFactor = opt.neckHeightFactor || 0.85;
      this.neckWidthFactor = opt.neckWidthFactor || 0.15;
      this.tailWidthFactor = opt.tailWidthFactor || 0.1;
      this.swallowTailFactor = opt.swallowTailFactor || 1;
    }

    // 开始计算
    startCompute(positions, opt) {
      if (!positions || positions.length === 0) {
        return positions
      }
      this.positions = positions;
      this.setOptions(opt);

      const pnts = cartesians2mercators(positions);
      const maxHeight = this.getMaxHeight(pnts);

      const tailPnts = this.getTailPoints(pnts);
      const headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[2]);
      if (!headPnts || headPnts.length < 4) {
        return positions
      }
      const neckLeft = headPnts[0];
      const neckRight = headPnts[4];
      const bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this.tailWidthFactor);
      const _count = bodyPnts.length;
      let leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, _count / 2));
      leftPnts.push(neckLeft);
      let rightPnts = [tailPnts[2]].concat(bodyPnts.slice(_count / 2, _count));
      rightPnts.push(neckRight);
      leftPnts = this.algorithmUtil.getQBSplinePoints(leftPnts);
      rightPnts = this.algorithmUtil.getQBSplinePoints(rightPnts);
      const pList = leftPnts.concat(headPnts, rightPnts.reverse(), [tailPnts[1], leftPnts[0]]);

      const returnArr = mercators2cartesians(pList, maxHeight);
      return returnArr
    }

    getTailPoints(points) {
      const allLen = this.algorithmUtil.getBaseLength(points);
      const tailWidth = allLen * this.tailWidthFactor;
      const tailLeft = this.algorithmUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, false);
      const tailRight = this.algorithmUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, true);
      const len = tailWidth * this.swallowTailFactor;
      const swallowTailPnt = this.algorithmUtil.getThirdPoint(points[1], points[0], 0, len, true);
      return [tailLeft, swallowTailPnt, tailRight]
    }
  }

  // 主要算法
  const fineArrowYWUtil = new FineArrowYWUtil();

  /**
   * 燕尾直箭头(2个点)   Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class FineArrowYW
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class FineArrowYW extends PolygonEntity {
    constructor(options = {}) {
      super(options);

      this._minPointNum = 2; // 至少需要点的个数
      this._maxPointNum = 2; // 最多允许点的个数
    }

    getShowPositions(positions) {
      if (!positions || positions.length < 2) {
        return positions
      }
      return fineArrowYWUtil.startCompute(positions, this.style)
    }

    //= =================静态方法=================

    /**
     * 计算当前军标对象的边界坐标点
     * @static
     * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} positions 坐标位置
     * @param {Object} [options] 控制参数(预留)
     * @return {Cesium.Cartesian3[]} 边界坐标点
     */
    static getOutlinePositions(positions, options) {
      if (!positions || positions.length < 2) {
        return positions
      }
      positions = LngLatArray.toCartesians(positions);
      return fineArrowYWUtil.startCompute(positions, options)
    }
  }

  // 注册下
  register$4("fineArrowYW", FineArrowYW);

  // 集结地
  class GatheringPlaceUtil {
    constructor() {
      this.algorithmUtil = algorithmUtil;
    }

    // 开始计算
    startCompute(positions, opt) {
      if (!positions || positions.length === 0) {
        return positions
      }
      this.positions = positions;
      // this.setOptions(opt);

      const pnts = cartesians2mercators(positions);
      const maxHeight = this.getMaxHeight(pnts);

      const mid = this.algorithmUtil.Mid(pnts[0], pnts[2]);
      pnts.push(mid, pnts[0], pnts[1]);
      let normals = [];
        let pnt1;
        let pnt2;
        let pnt3;
        const pList = [];
      for (let i = 0; i < pnts.length - 2; i++) {
        pnt1 = pnts[i];
        pnt2 = pnts[i + 1];
        pnt3 = pnts[i + 2];
        const normalPoints = this.algorithmUtil.getBisectorNormals(0.4, pnt1, pnt2, pnt3);
        normals = normals.concat(normalPoints);
      }
      const count = normals.length;
      normals = [normals[count - 1]].concat(normals.slice(0, count - 1));
      for (let _i = 0; _i < pnts.length - 2; _i++) {
        pnt1 = pnts[_i];
        pnt2 = pnts[_i + 1];
        pList.push(pnt1);
        for (let t = 0; t <= 100; t++) {
          const _pnt = this.algorithmUtil.getCubicValue(t / 100, pnt1, normals[_i * 2], normals[_i * 2 + 1], pnt2);
          pList.push(_pnt);
        }
        pList.push(pnt2);
      }

      const returnArr = mercators2cartesians(pList, maxHeight);
      return returnArr
    }

    getMaxHeight(pnts) {
      let maxHeight = pnts[0][2] || 0;
      for (let i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }
      return maxHeight
    }
  }

  // 主要算法
  const gatheringPlaceUtil = new GatheringPlaceUtil();

  /**
   * 集结地(3个点)   Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class GatheringPlace
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class GatheringPlace extends PolygonEntity {
    constructor(options = {}) {
      super(options);

      this._minPointNum = 3; // 至少需要点的个数
      this._maxPointNum = 3; // 最多允许点的个数
    }

    getShowPositions(positions) {
      if (!positions || positions.length < this._minPointNum) {
        return positions
      }
      return gatheringPlaceUtil.startCompute(positions, this.style)
    }

    //= =================静态方法=================

    /**
     * 计算当前军标对象的边界坐标点
     * @static
     * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} positions 坐标位置
     * @param {Object} [options] 控制参数(预留)
     * @return {Cesium.Cartesian3[]} 边界坐标点
     */
    static getOutlinePositions(positions, options) {
      if (!positions || positions.length < 2) {
        return positions
      }
      positions = LngLatArray.toCartesians(positions);
      return gatheringPlaceUtil.startCompute(positions, options)
    }
  }

  // 注册下
  register$4("gatheringPlace", GatheringPlace);

  /**
   * 等腰三角形(3个点)  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class IsosTriangle
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class IsosTriangle extends PolygonEntity {
    constructor(options = {}) {
      super(options);

      this._minPointNum = 3; // 至少需要点的个数
      this._maxPointNum = 3; // 最多允许点的个数
    }

    getShowPositions(positions) {
      if (!positions || positions.length < this._minPointNum) {
        return positions
      }
      return IsosTriangle.getOutlinePositions(positions, this.style)
    }

    //= =================静态方法=================

    /**
     * 计算当前矢量对象的边界坐标点
     * @static
     * @param {Cesium.Cartesian3[]} positions 坐标位置
     * @param {Object} [options] 控制参数(预留)
     * @return {Cesium.Cartesian3[]} 边界坐标点
     */
    static getOutlinePositions(positions, options) {
      if (!positions || positions.length < 3) {
        return positions
      }
      // p1 p2 用于控制腰的高度 p3用于控制夹角
      const p1 = positions[0];
      const p2 = positions[1];
      const p3 = positions[2];

      const midpoint = Cesium__namespace.Cartesian3.midpoint(p1, p2, new Cesium__namespace.Cartesian3());

      const angle1 = getAngle(midpoint, p2);
      const angle2 = getAngle(midpoint, p3);
      const angle = angle1 - angle2 - 90;
      const newPoint2 = getRotateCenterPoint(midpoint, p3, angle);

      return [p1, p2, newPoint2]
    }
  }
  // 注册下
  register$4("isosTriangle", IsosTriangle);

  // 弓形面
  class LuneUtil {
    constructor() {
      this.algorithmUtil = algorithmUtil;
    }

    // 开始计算
    startCompute(positions, opt) {
      if (!positions || positions.length === 0) {
        return positions
      }
      this.positions = positions;
      // this.setOptions(opt);

      let pnts = cartesians2mercators(positions);
      const maxHeight = this.getMaxHeight(pnts);
      const _ref = [pnts[0], pnts[1], pnts[2], undefined, undefined];
        const pnt1 = _ref[0];
        const pnt2 = _ref[1];
        const pnt3 = _ref[2];
        let startAngle = _ref[3];
        let endAngle = _ref[4];

      const center = this.algorithmUtil.getCircleCenterOfThreePoints(pnt1, pnt2, pnt3);
      const radius = this.algorithmUtil.MathDistance(pnt1, center);
      const angle1 = this.algorithmUtil.getAzimuth(pnt1, center);
      const angle2 = this.algorithmUtil.getAzimuth(pnt2, center);
      if (this.algorithmUtil.isClockWise(pnt1, pnt2, pnt3)) {
        startAngle = angle2;
        endAngle = angle1;
      } else {
        startAngle = angle1;
        endAngle = angle2;
      }
      pnts = this.algorithmUtil.getArcPoints(center, radius, startAngle, endAngle);
      pnts.push(pnts[0]);

      const returnArr = mercators2cartesians(pnts, maxHeight);
      return returnArr
    }

    getMaxHeight(pnts) {
      let maxHeight = pnts[0][2] || 0;
      for (let i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }
      return maxHeight
    }
  }

  // 主要算法
  const luneUtil = new LuneUtil();

  /**
   * 弓形面(3个点)   Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class Lune
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class Lune extends PolygonEntity {
    constructor(options = {}) {
      super(options);

      this._minPointNum = 3; // 至少需要点的个数
      this._maxPointNum = 3; // 最多允许点的个数
    }

    getShowPositions(positions) {
      if (!positions || positions.length < this._minPointNum) {
        return positions
      }
      return luneUtil.startCompute(positions, this.style)
    }

    //= =================静态方法=================


    /**
     * 计算当前军标对象的边界坐标点
     * @static
     * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} positions 坐标位置
     * @param {Object} [options] 控制参数(预留)
     * @return {Cesium.Cartesian3[]} 边界坐标点
     */
    static getOutlinePositions(positions, options) {
      if (!positions || positions.length < 3) {
        return positions
      }
      positions = LngLatArray.toCartesians(positions);
      return luneUtil.startCompute(positions, options)
    }
  }

  // 注册下
  register$4("lune", Lune);

  /**
   * Regular对象 标绘处理对应的编辑类
   *
   * @export
   * @class EditRegular
   * @extends {EditPolygon}
   */
  class EditRegular extends EditPolygon {
    bindDraggers() {
      const positions = this.positions;

      // 中心点
      let positionMove = this.updatePositionsHeightByAttr(positions[0]);

      const dragger = this.createDragger({
        position: positionMove,
        type: PointType.MoveAll,
        tooltip: this._map.getLangText("_整体平移"),
        onDrag: (dragger, position) => {
          position = this.updatePositionsHeightByAttr(position);
          dragger.position = position;

          // 记录差值
          const diff = Cesium__namespace.Cartesian3.subtract(position, positionMove, new Cesium__namespace.Cartesian3());
          positionMove = position;

          this.positions.forEach((pos, index, arr) => {
            const newPos = Cesium__namespace.Cartesian3.add(pos, diff, new Cesium__namespace.Cartesian3());
            this.positions[index] = newPos;
          });
          for (let i = 0, len = this.draggers.length; i < len; i++) {
            this.draggers[i].position = Cesium__namespace.Cartesian3.add(this.draggers[i].position, diff, new Cesium__namespace.Cartesian3());
          }
        }
      });
      dragger.index = 0;
      this.draggers.push(dragger);

      // 各顶点
      const startAnglePt = getPositionByDirectionAndLen(positionMove, this.style.startAngle, this.style.radius);
      positions[1] = startAnglePt;
      const dragger1 = this.createDragger({
        position: this.updatePositionsHeightByAttr(startAnglePt),
        onDrag: (dragger, position) => {
          position = this.updatePositionsHeightByAttr(position);
          dragger.position = position;
          this.positions[dragger.index] = position;

          this.style.radius = Cesium__namespace.Cartesian3.distance(positions[0], position);
          this.style.startAngle = formatNum$1(getAngle(positions[0], position), 2);
        },
        onDragStart: (dragger, position) => {
          for (let i = 0, len = this.draggers.length; i < len; i++) {
            this.draggers[i].show = false;
          }
        },
        onDragEnd: (dragger, position) => {
          this.updateDraggers();
        }
      });
      dragger1.index = 1;
      this.draggers.push(dragger1);

      // 创建高度拖拽点
      if (this.entityGraphic.extrudedHeight) {
        this._bindHeightDraggers();
      }
    }

    // 高度处理
    _updateHeight(height) {
      this.entityGraphic.height = height;
      this.style.height = this.formatNum(height, 2);

      const positions = this.positions;
      for (let i = 0, len = positions.length; i < len; i++) {
        positions[i] = setPositionsHeight(positions[i], height);
      }

      // for (let i = 0, len = this.draggers.length; i < len; i++) {
      //   const draggerItem = this.draggers[i]
      //   draggerItem.position = setPositionsHeight(draggerItem.position, height)
      // }

      this.fire(EventType.editStyle);
    }
  }

  /**
   *  正多边形  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息,还包括：
   * @param {Number} [options.style.border=3] 边数量
   * @param {Number} options.style.radius 区域的半径（单位：米）
   * @param {Number} [options.style.startAngle=0] 区域的开始角度(正东方向为0,顺时针到360度)
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class Regular
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class Regular extends PolygonEntity {
    constructor(options = {}) {
      super(options);

      this._minPointNum = 2; // 至少需要点的个数
      this._maxPointNum = 2; // 最多允许点的个数

      this.style.radius = this.style.radius ?? 1000;
      this.style.startAngle = this.style.startAngle ?? 0;

      if (options.position) {
        this.positions = [options.position];
      }
    }

    /**
     * 编辑处理类
     * @type {EditRegular}
     * @readonly
     */
    get EditClass() {
      return EditRegular
    }

    updateAttrForDrawing(isEditing) {
      if (!isEditing && this._positions_draw?.length > 1) {
        const center = this._positions_draw[0];

        this.style.radius = Cesium__namespace.Cartesian3.distance(center, this._positions_draw[1]);
        this.style.startAngle = formatNum$1(getAngle(center, this._positions_draw[1]), 2);
      }
      super.updateAttrForDrawing(isEditing);
    }

    getShowPositions(positions) {
      return Regular.getOutlinePositions(positions, this.style)
    }

    //= =================静态方法=================

    /**
     * 计算当前矢量对象的边界坐标点
     * @static
     * @param {Cesium.Cartesian3[]} positions 坐标位置
     * @param {Object} options 控制参数
     * @param {Number} [options.border=3] 边数量
     * @param {Number} options.radius 区域的半径（单位：米）
     * @param {Number} [options.startAngle=0] 区域的开始角度(正东方向为0,顺时针到360度)
     * @return {Cesium.Cartesian3[]} 边界坐标点
     */
    static getOutlinePositions(positions, options) {
      if (!positions || positions.length < 1) {
        return positions
      }

      const center = positions[0];

      const num = options.border || 3; // 边数量
      const radius = options.radius || 1000;
      const startAngle = options.startAngle || 0;

      const addAngle = 360 / num;

      const arr = [];
      for (let i = 0; i <= num; i++) {
        const thisAngle = startAngle + addAngle * i;
        arr.push(getPositionByDirectionAndLen(center, thisAngle, radius));
      }
      return arr
    }
  }
  // 注册下
  register$4("regular", Regular);

  /**
   * Sector对象 标绘处理对应的编辑类
   *
   * @export
   * @class EditSector
   * @extends {EditPolygon}
   */
  class EditSector extends EditPolygon {
    bindDraggers() {
      const positions = this.positions;

      // 中心点
      let positionMove = this.updatePositionsHeightByAttr(positions[0]);

      const dragger = this.createDragger({
        position: positionMove,
        type: PointType.MoveAll,
        tooltip: this._map.getLangText("_整体平移"),
        onDrag: (dragger, position) => {
          position = this.updatePositionsHeightByAttr(position);
          dragger.position = position;

          // 记录差值
          const diff = Cesium__namespace.Cartesian3.subtract(position, positionMove, new Cesium__namespace.Cartesian3());
          positionMove = position;

          this.positions.forEach((pos, index, arr) => {
            const newPos = Cesium__namespace.Cartesian3.add(pos, diff, new Cesium__namespace.Cartesian3());
            this.positions[index] = newPos;
          });
          for (let i = 0, len = this.draggers.length; i < len; i++) {
            this.draggers[i].position = Cesium__namespace.Cartesian3.add(this.draggers[i].position, diff, new Cesium__namespace.Cartesian3());
          }
        }
      });
      dragger.index = 0;
      this.draggers.push(dragger);

      // 各顶点
      const startAnglePt = getPositionByDirectionAndLen(positionMove, this.style.startAngle, this.style.radius);
      positions[1] = startAnglePt;
      const dragger1 = this.createDragger({
        position: this.updatePositionsHeightByAttr(startAnglePt),
        onDrag: (dragger, position) => {
          position = this.updatePositionsHeightByAttr(position);
          dragger.position = position;
          this.positions[dragger.index] = position;

          this.style.radius = Cesium__namespace.Cartesian3.distance(positions[0], position);
          this.style.startAngle = formatNum$1(getAngle(positions[0], position), 2);

          positions[2] = getPositionByDirectionAndLen(positions[0], this.style.endAngle, this.style.radius);
        },
        onDragStart: (dragger, position) => {
          for (let i = 0, len = this.draggers.length; i < len; i++) {
            this.draggers[i].show = false;
          }
        },
        onDragEnd: (dragger, position) => {
          this.updateDraggers();
        }
      });
      dragger1.index = 1;
      this.draggers.push(dragger1);

      // 各顶点
      const endAnglePt = getPositionByDirectionAndLen(positionMove, this.style.endAngle, this.style.radius);
      positions[2] = endAnglePt;
      const dragger2 = this.createDragger({
        position: this.updatePositionsHeightByAttr(endAnglePt),
        onDrag: (dragger, position) => {
          position = this.updatePositionsHeightByAttr(position);
          dragger.position = position;
          this.positions[dragger.index] = position;

          this.style.radius = Cesium__namespace.Cartesian3.distance(positions[0], position);
          this.style.endAngle = getAngle(positions[0], position);

          positions[1] = getPositionByDirectionAndLen(positions[0], this.style.startAngle, this.style.radius);
        },
        onDragStart: (dragger, position) => {
          for (let i = 0, len = this.draggers.length; i < len; i++) {
            this.draggers[i].show = false;
          }
        },
        onDragEnd: (dragger, position) => {
          this.updateDraggers();
        }
      });
      dragger2.index = 2;
      this.draggers.push(dragger2);

      // 创建高度拖拽点
      if (this.entityGraphic.extrudedHeight) {
        this._bindHeightDraggers();
      }
    }

    // 高度处理
    _updateHeight(height) {
      this.entityGraphic.height = height;
      this.style.height = this.formatNum(height, 2);

      const positions = this.positions;
      for (let i = 0, len = positions.length; i < len; i++) {
        positions[i] = setPositionsHeight(positions[i], height);
      }

      // for (let i = 0, len = this.draggers.length; i < len; i++) {
      //   const draggerItem = this.draggers[i]
      //   draggerItem.position = setPositionsHeight(draggerItem.position, height)
      // }

      this.fire(EventType.editStyle);
    }
  }

  /**
   *  扇形(3个点)  Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息,还包括：
   * @param {Number} options.style.radius 扇形区域的半径（单位：米）
   * @param {Number} options.style.startAngle 扇形区域的开始角度(正东方向为0,顺时针到360度)
   * @param {Number} options.style.endAngle 扇形区域的结束角度(正东方向为0,顺时针到360度)
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class Sector
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class Sector extends PolygonEntity {
    constructor(options = {}) {
      super(options);

      this._minPointNum = 2; // 至少需要点的个数
      this._maxPointNum = 3; // 最多允许点的个数

      this.style.radius = this.style.radius ?? 1000;
      this.style.startAngle = this.style.startAngle ?? 0;
      this.style.endAngle = this.style.endAngle ?? 0;

      if (options.position) {
        this.positions = [options.position];
      }
    }

    /**
     * 编辑处理类
     * @type {EditSector}
     * @readonly
     */
    get EditClass() {
      return EditSector
    }

    updateAttrForDrawing(isEditing) {
      if (!isEditing && this._positions_draw?.length > 1) {
        const center = this._positions_draw[0];

        this.style.radius = Cesium__namespace.Cartesian3.distance(center, this._positions_draw[1]);
        this.style.startAngle = formatNum$1(getAngle(center, this._positions_draw[1]), 2);

        if (this._positions_draw?.length > 2) {
          this.style.endAngle = formatNum$1(getAngle(center, this._positions_draw[2]), 2);
        } else {
          this.style.endAngle = this.style.startAngle;
        }
      }
      super.updateAttrForDrawing(isEditing);
    }

    getShowPositions(positions) {
      return Sector.getOutlinePositions(positions, this.style)
    }

    //= =================静态方法=================

    /**
     * 计算当前矢量对象的边界坐标点
     * @static
     * @param {Cesium.Cartesian3[]} positions 坐标位置
     * @param {Object} options 控制参数
     * @param {Number} options.radius 扇形区域的半径（单位：米）
     * @param {Number} options.startAngle 扇形区域的开始角度(正东方向为0,顺时针到360度)
     * @param {Number} options.endAngle 扇形区域的结束角度(正东方向为0,顺时针到360度)
     * @return {Cesium.Cartesian3[]} 边界坐标点
     */
    static getOutlinePositions(positions, options) {
      if (!positions || positions.length < 1) {
        return positions
      }

      const center = positions[0];
      const radius = options.radius;
      const startAngle = options.startAngle;
      let endAngle = options.endAngle;
      if (endAngle <= startAngle) {
        endAngle += 360;
      }

      const arr = [center];
      for (let i = startAngle; i <= endAngle; i++) {
        arr.push(getPositionByDirectionAndLen(center, i, radius));
      }
      arr.push(center);

      return arr
    }
  }
  // 注册下
  register$4("sector", Sector);

  // 计算粗直箭头坐标
  class StraightArrowUtil {
    constructor() {
      this.algorithmUtil = algorithmUtil;
    }

    // 相关参数
    setOptions(opt = {}) {
      this.tailWidthFactor = opt.tailWidthFactor || 0.05;
      this.neckWidthFactor = opt.neckWidthFactor || 0.1;
      this.headWidthFactor = opt.headWidthFactor || 0.15;
      this.headAngle = Math.PI / 4;
      this.neckAngle = Math.PI * 0.17741;
    }

    // 开始计算
    startCompute(positions, opt) {
      if (!positions || positions.length === 0) {
        return positions
      }
      this.positions = positions;
      this.setOptions(opt);

      const pnts = cartesians2mercators(positions);
      const maxHeight = this.getMaxHeight(pnts);

      const _ref = [pnts[0], pnts[1]];
        const pnt1 = _ref[0];
        const pnt2 = _ref[1];
      const len = this.algorithmUtil.getBaseLength(pnts);
      const tailWidth = len * this.tailWidthFactor;
      const neckWidth = len * this.neckWidthFactor;
      const headWidth = len * this.headWidthFactor;
      const tailLeft = this.algorithmUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, true);
      const tailRight = this.algorithmUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, false);
      const headLeft = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, false);
      const headRight = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, true);
      const neckLeft = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, false);
      const neckRight = this.algorithmUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, true);
      const pList = [tailLeft, neckLeft, headLeft, pnt2, headRight, neckRight, tailRight];

      const returnArr = mercators2cartesians(pList, maxHeight);
      return returnArr
    }

    getMaxHeight(pnts) {
      let maxHeight = pnts[0][2] || 0;
      for (let i = 0; i < pnts.length; i++) {
        if (pnts[2] > maxHeight) {
          maxHeight = pnts[2];
        }
      }
      return maxHeight
    }
  }

  // 主要算法
  const straightArrowUtil = new StraightArrowUtil();

  /**
   * 直箭头(3个点)   Entity矢量数据
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.hasMoveEdit=true] 绘制时，是否可以整体平移
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class StraightArrow
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class StraightArrow extends PolygonEntity {
    constructor(options = {}) {
      super(options);

      this._minPointNum = 2; // 至少需要点的个数
      this._maxPointNum = 2; // 最多允许点的个数
    }

    getShowPositions(positions) {
      if (!positions || positions.length < 2) {
        return positions
      }
      return straightArrowUtil.startCompute(positions, this.style)
    }

    //= =================静态方法=================


    /**
     * 计算当前军标对象的边界坐标点
     * @static
     * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} positions 坐标位置
     * @param {Object} [options] 控制参数(预留)
     * @return {Cesium.Cartesian3[]} 边界坐标点
     */
    static getOutlinePositions(positions, options) {
      if (!positions || positions.length < 2) {
        return positions
      }
      positions = LngLatArray.toCartesians(positions);
      return straightArrowUtil.startCompute(positions, options)
    }
  }

  // 注册下
  register$4("straightArrow", StraightArrow);

  // 测量点的默认样式
  const DEF_STYLE$i = {
    color: "#3388ff",
    pixelSize: 8,
    outlineColor: "#ffffff",
    outlineWidth: 2,
    visibleDepth: false
  };

  /**
   * 坐标量算对象，
   * 非直接调用，由 Measure 类统一创建及管理
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Cesium.PositionProperty|Number[]|String} options.position 坐标位置
   * @param {PointEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class PointMeasure
   * @extends {PointEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PointMeasure extends PointEntity {
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$i,
        ...(options.style || {})
      };

      super(options);
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      super._addedHook(style);

      const map = this._map;

      this.bindPopup((event) => {
        const point = this.point;
        point.format();

        const x2 = degree2dms(point.lng).str;
        const y2 = degree2dms(point.lat).str;

        return `<div class="mars3d-template-titile">${map.getLangText("_位置信息")}</div>
                <div class="mars3d-template-content">
                    <div><label>${map.getLangText("_经度")}</label>${point.lng}&nbsp;&nbsp;${x2}</div>
                    <div><label>${map.getLangText("_纬度")}</label>${point.lat}&nbsp;&nbsp;&nbsp;&nbsp;${y2}</div>
                    <div><label>${map.getLangText("_海拔")}</label>${point.alt}${map.getLangText("_米")}</div>
                </div>`
      });

      // 绘制 事件监听
      this.on(EventType.drawMouseMove, this._drawMouseMoveHandler, this);
      this.once(EventType.drawCreated, this._drawCreatedHandler, this);

      // 编辑 事件监听
      this.on(EventType.editMovePoint, this._editPointHandler, this);
      this.on(EventType.editRemovePoint, this._editPointHandler, this);
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      // 绘制 事件监听
      this.off(EventType.drawMouseMove, this._drawMouseMoveHandler, this);
      this.off(EventType.drawCreated, this._drawCreatedHandler, this);

      // 编辑 事件监听
      this.off(EventType.editMovePoint, this._editPointHandler, this);
      this.off(EventType.editRemovePoint, this._editPointHandler, this);

      super._removedHook();
    }

    // 绘制过程移动中，动态显示长度信息
    _drawMouseMoveHandler(event) {
      this.openPopup();
    }

    _drawCreatedHandler(event) {
      this.openPopup();

      this.fire(
        EventType.end,
        {
          mtype: this.type,
          graphic: this
        },
        true
      );
    }

    // 编辑修改了线
    _editPointHandler(event) {
      this.openPopup();
    }
  }

  // 注册下
  register$4("pointMeasure", PointMeasure);

  // 测量线的默认样式
  const DEF_STYLE$h = {
    materialType: "PolylineGlow",
    glowPower: 0.1,
    color: "#ebe12c",
    width: 9,
    clampToGround: false // 是否贴地
  };

  /**
   * 距离量算对象，
   * 非直接调用，由 Measure 类统一创建及管理
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolylineEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
   * @param {Number} [options.decimal = 2]   显示的 距离值 文本中保留的小数位
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class DistanceMeasure
   * @extends {PolylineEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class DistanceMeasure extends PolylineEntity {
    constructor(options = {}) {
      options.hasMoveEdit = false;
      options.showAddText = options.showAddText ?? true;
      options.decimal = options.decimal ?? 2;

      options.style = {
        ...DEF_STYLE$h,
        ...(options.style || {})
      };

      super(options);

      // 测量结果
      this._measured = {};
    }

    /**
     *  测量结果
     * @type {Object}
     * @readonly
     */
    get measured() {
      return this._measured
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      super._addedHook(style);

      // 初始化lable
      this._arrPartMeasureLable = [];

      // 总长label
      this._measureLable = this._createLabel(this.options.label || this._layer?.options?.label);
      this._measureLable.show = false;

      // 绘制 事件监听
      this.on(EventType.drawAddPoint, this._drawAddPointHandler, this);
      this.on(EventType.drawRemovePoint, this._drawRemovePointHandler, this);
      this.on(EventType.drawMouseMove, this._drawMouseMoveHandler, this);
      this.once(EventType.drawCreated, this._drawCreatedHandler, this);

      // 编辑 事件监听
      this.on(EventType.editMovePoint, this._editPointHandler, this);
      this.on(EventType.editRemovePoint, this._editPointHandler, this);
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      // 绘制 事件监听
      this.off(EventType.drawAddPoint, this._drawAddPointHandler, this);
      this.off(EventType.drawMouseMove, this._drawMouseMoveHandler, this);
      this.off(EventType.drawRemovePoint, this._drawRemovePointHandler, this);
      this.off(EventType.drawCreated, this._drawCreatedHandler, this);

      // 编辑 事件监听
      this.off(EventType.editMovePoint, this._editPointHandler, this);
      this.off(EventType.editRemovePoint, this._editPointHandler, this);

      // 删除所有文本
      if (Cesium__namespace.defined(this._measureLable)) {
        this._removeLabel(this._measureLable);
        delete this._measureLable;
      }
      if (Cesium__namespace.defined(this._arrPartMeasureLable) && this._arrPartMeasureLable.length > 0) {
        const _arrPartMeasureLable = this._arrPartMeasureLable;
        if (_arrPartMeasureLable && _arrPartMeasureLable.length > 0) {
          for (let i = 0, len = _arrPartMeasureLable.length; i < len; i++) {
            this._removeLabel(_arrPartMeasureLable[i]);
          }
        }
        delete this._arrPartMeasureLable;
      }
      super._removedHook();
    }

    /**
     * 更新测量结果的文本
     * @param {String} unit 计量单位,{@link MeasureUtil#formatDistance} 可选值：auto、m、km、mile、zhang 等。auto时根据距离值自动选用k或km
     * @return {void}  无
     */
    updateText(unit) {
      if (unit) {
        this.options.unit = unit;
      }

      const formatOpts = {
        unit: this.options.unit,
        lang: this._map.lang,
        decimal: this.options.decimal
      };

      this._measured.distanceStr = formatDistance(this._measured.distance, formatOpts);

      if (this._measured.distance !== this._measured.distanceLastFd) {
        this._measureLable.text = this._map.getLangText("_总长") + ":" + this._measured.distanceStr;
        if (this.options.showAddText) {
          const lastLenStr = formatDistance(this._measured.distanceLastFd, formatOpts);
          this._measured.distanceLastFdStr = lastLenStr;
          this._measureLable.text += "\n(+" + lastLenStr + ")";
        }
      } else {
        this._measureLable.text = this._map.getLangText("_总长") + ":" + this._measured.distanceStr;
      }

      // 其他各分段label
      if (unit) {
        for (let i = 1, len = this._arrPartMeasureLable.length; i < len; i++) {
          const label = this._arrPartMeasureLable[i];
          if (label.showText) {
            label.showText();
          }
        }
      }
    }

    // 绘制增加一个点后，显示该分段的长度
    _drawAddPointHandler(event) {
      const that = this;
      const positions = this.positionsShow;

      // 创建文本
      const graphicLbl = this._createLabel(this.options.label || this._layer?.options?.label, positions[positions.length - 1]);
      this._arrPartMeasureLable.push(graphicLbl);

      if (positions.length === 1) {
        graphicLbl.text = this._map.getLangText("_起点");
      } else {
        const distance = getSurfaceDistance(positions);
        const lastLen = getSurfaceDistance([positions[positions.length - 2], positions[positions.length - 1]]); // 最后2点间距离

        graphicLbl.attr = {};
        graphicLbl.attr.value = distance;
        graphicLbl.attr.valueFD = lastLen;
        graphicLbl.showText = function () {
          const formatOpts = {
            unit: that.options.unit,
            lang: that._map.lang,
            decimal: that.options.decimal
          };
          const distancestr = formatDistance(this.attr.value, formatOpts);
          if (this.attr.value !== this.attr.valueFD) {
            this.text = distancestr;
            if (that.options.showAddText) {
              const lastLenStr = formatDistance(this.attr.valueFD, formatOpts);
              this.text += "\n(+" + lastLenStr + ")";
            }
          } else {
            this.text = distancestr;
          }
        };
        graphicLbl.showText();

        this._measured.distance = distance;
        this._measured.distanceLastFd = lastLen;
        this._measured.distanceStr = formatDistance(this._measured.distance, {
          unit: this.options.unit,
          lang: this._map.lang,
          decimal: this.options.decimal
        });
      }
    }

    // 绘制中删除了最后一个点
    _drawRemovePointHandler(event) {
      const label = this._arrPartMeasureLable.pop();
      this._removeLabel(label);

      this._drawMouseMoveHandler(event);
      this._measureLable.position = event.cartesian;
    }

    // 绘制过程移动中，动态显示长度信息
    _drawMouseMoveHandler(event) {
      const positions = this.positionsShow;
      if (positions.length < 2) {
        this._measureLable.show = false;
        return
      }

      const distance = getSurfaceDistance(positions);

      // 最后2点间距离
      let lastLen = getSurfaceDistance([positions[positions.length - 2], positions[positions.length - 1]]);
      if (lastLen === 0 && positions.length > 2) {
        lastLen = getSurfaceDistance([positions[positions.length - 3], positions[positions.length - 2]]);
      }

      this._measured.distance = distance;
      this._measured.distanceLastFd = lastLen;

      this.updateText();
      this._measureLable.position = positions[positions.length - 1];
      this._measureLable.show = true;

      this.fire(
        EventType.change,
        {
          mtype: this.type,
          value: this._measured.distance,
          label: this._measured.distanceStr
        },
        true
      );
    }

    _drawCreatedHandler(event, hasEvent = true) {
      const positions = this.positionsShow;
      const count = this._arrPartMeasureLable.length - positions.length;
      if (count >= 0) {
        for (let i = this._arrPartMeasureLable.length - 1; i >= positions.length - 1; i--) {
          this._removeLabel(this._arrPartMeasureLable[i]);
        }
        this._arrPartMeasureLable.splice(positions.length - 1, count + 1);
      }

      this.updateText();
      this._measureLable.position = positions[positions.length - 1];
      this._measureLable.show = true;

      if (hasEvent) {
        this.fire(
          EventType.end,
          {
            mtype: this.type,
            value: this._measured.distance,
            label: this._measured.distanceStr
          },
          true
        );
      }
    }

    // 编辑修改了线
    _editPointHandler(event, hasEvent = true) {
      const that = this;
      const positions = this.positionsShow;

      const _arrPartMeasureLable = this._arrPartMeasureLable;
      if (_arrPartMeasureLable && _arrPartMeasureLable.length > 0) {
        for (let i = 1, len = _arrPartMeasureLable.length; i < len; i++) {
          this._removeLabel(_arrPartMeasureLable[i]);
        }
      }

      // 起点
      const qidian = _arrPartMeasureLable[0];
      qidian.position = positions[0];

      this._arrPartMeasureLable = [qidian];

      let alllen = 0;
      for (let i = 1, len = positions.length - 1; i < len; i++) {
        const lastLen = getSurfaceDistance([positions[i - 1], positions[i]]); // 2点间距离
        alllen += lastLen;

        const graphicLbl = this._createLabel(this.options.label || this._layer?.options?.label, positions[i]);
        this._arrPartMeasureLable.push(graphicLbl);

        graphicLbl.attr = {};
        graphicLbl.attr.value = alllen;
        graphicLbl.attr.valueFD = lastLen;
        graphicLbl.showText = function () {
          const formatOpts = {
            unit: that.options.unit,
            lang: that._map.lang,
            decimal: that.options.decimal
          };
          const distancestr = formatDistance(this.attr.value, formatOpts);
          if (this.attr.value !== this.attr.valueFD) {
            const lastLenStr = formatDistance(this.attr.valueFD, formatOpts);
            this.text = distancestr;
            if (that.options.showAddText) {
              this.text += "\n(+" + lastLenStr + ")";
            }
          } else {
            this.text = distancestr;
          }
        };
        graphicLbl.showText();
      }

      const lastlen = getSurfaceDistance([positions[positions.length - 2], positions[positions.length - 1]]);
      alllen += lastlen;

      this._measured.distance = alllen;
      this._measured.distanceLastFd = lastlen;

      this.updateText();
      this._measureLable.position = positions[positions.length - 1];

      if (hasEvent) {
        this.fire(
          EventType.change,
          {
            mtype: this.type,
            value: this._measured.distance,
            label: this._measured.distanceStr
          },
          true
        );
      }
    }
  }

  // 注册下
  register$4("distanceMeasure", DistanceMeasure);

  /**
   * 贴地距离量算对象
   * 非直接调用，由 Measure 类统一创建及管理
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolylineEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
   * @param {Number} [options.decimal = 2]   显示的 距离值 文本中保留的小数位
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class DistanceSurfaceMeasure
   * @extends {DistanceMeasure}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class DistanceSurfaceMeasure extends DistanceMeasure {
    constructor(options = {}) {
      super(options);

      if (options._promise) {
        this._promise = options._promise;
        delete options._promise;
      }

      options.style.clampToGround = true;
      options.splitNum = options.splitNum ?? 200;

      this.disTerrainScale = 1.2; // 贴地时的概略比例
    }

    _drawCreatedHandler(event) {
      super._drawCreatedHandler(event, false);
      this.updateLengthForTerrain(event);
    }

    // 编辑修改了线
    _editPointHandler(event) {
      super._editPointHandler(event, false);
      this.updateLengthForTerrain(event);
    }

    // 计算贴地线
    updateLengthForTerrain(event) {
      const positions = this.positionsShow;

      this.fire(
        EventType.start,
        {
          mtype: this.type,
          graphic: this
        },
        true
      );

      // 求贴地线长度
      getClampDistance(positions, {
        scene: this._map.scene,
        splitNum: this.options.splitNum,
        has3dtiles: this.options.has3dtiles,
        disTerrainScale: this.disTerrainScale, // 求高度失败，概略估算值
        // 计算每个分段后的回调方法
        endItem: (result) => {
          if (!this._map || !this._measureLable) {
            // 异步结束时，对象已经被释放
            return
          }

          let index = result.index;
          const all_distance = result.all_distance;
          const distance = result.distance;

          index++;
          const thisLabel = this._arrPartMeasureLable[index];
          if (thisLabel) {
            thisLabel.attr.value = all_distance;
            thisLabel.attr.valueFD = distance;
            thisLabel.showText();
          } else if (index === positions.length - 1 && this._measureLable) {
            // 最后一个
            this._measured.distance = all_distance;
            this._measured.distanceLastFd = distance;
            this.updateText();
          }
        },
        // 计算全部完成的回调方法
        end: (all_distance) => {
          if (!this._map || !this._measureLable) {
            // 异步结束时，对象已经被释放
            return
          }
          this._measured.distance = all_distance;

          const result = {
            mtype: this.type,
            graphic: this,
            value: this._measured.distance,
            label: this._measured.distanceStr
          };
          this.fire(EventType.change, result, true);
          this.fire(EventType.end, result, true);

          if (this._promise?.resolve) {
            this._promise.resolve(this);
          }
        }
      });
    }
  }

  // 注册下
  register$4("distanceSurfaceMeasure", DistanceSurfaceMeasure);

  /**
   * 剖面量算对象
   * 非直接调用，由 Measure 类统一创建及管理
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolylineEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
   * @param {Number} [options.decimal = 2]   显示的 距离值 文本中保留的小数位
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Number} [options.addHeight] 在绘制时，在绘制点的基础上增加的高度值
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class SectionMeasure
   * @extends {DistanceMeasure}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class SectionMeasure extends DistanceMeasure {
    constructor(options = {}) {
      super(options);

      if (options._promise) {
        this._promise = options._promise;
        delete options._promise;
      }

      options.style.clampToGround = true;
      options.splitNum = options.splitNum ?? 200;
    }

    _drawCreatedHandler(event) {
      super._drawCreatedHandler(event, false);
      this.updateSectionForTerrain(event);
    }

    // 编辑修改了线
    _editPointHandler(event) {
      super._editPointHandler(event, false);
      this.updateSectionForTerrain(event);
    }

    // 计算剖面
    updateSectionForTerrain(event) {
      const positions = this.positionsShow;
      if (positions.length < 2) {
        return
      }

      this.fire(
        EventType.start,
        {
          mtype: this.type,
          graphic: this
        },
        true
      );

      let all_distance = 0;
      const arrLen = [];
      const arrHB = [];
      const arrLX = [];
      const arrPoint = [];

      computeStepSurfaceLine({
        map: this._map,
        positions: positions,
        splitNum: this.options.splitNum,
        has3dtiles: this.options.has3dtiles,
        // 计算每个分段后的回调方法
        endItem: (raisedPositions, noHeight, index) => {
          if (!this._map || !this._measureLable) {
            // 异步结束时，对象已经被释放
            return
          }
          const h1 = Cesium__namespace.Cartographic.fromCartesian(positions[index])?.height;
          const h2 = Cesium__namespace.Cartographic.fromCartesian(positions[index + 1])?.height;
          const hstep = (h2 - h1) / raisedPositions.length;

          let this_distance = 0;
          for (let i = 0; i < raisedPositions.length; i++) {
            // 长度
            if (i !== 0) {
              const templen = Cesium__namespace.Cartesian3.distance(raisedPositions[i], raisedPositions[i - 1]);
              all_distance += templen;
              this_distance += templen;
            }
            arrLen.push(Number(all_distance.toFixed(1)));

            // 海拔高度
            const point = LngLatPoint.fromCartesian(raisedPositions[i]);
            arrHB.push(point.alt);
            arrPoint.push(point);

            // 路线高度
            const fxgd = Number((h1 + hstep * i).toFixed(1));
            arrLX.push(fxgd);
          }

          index++;
          const thisLabel = this._arrPartMeasureLable[index];
          if (thisLabel) {
            thisLabel.attr.value = all_distance;
            thisLabel.attr.valueFD = this_distance;
            thisLabel.showText();
          } else if (index === positions.length - 1 && this._measureLable) {
            // 最后一个
            this._measured.distance = all_distance;
            this._measured.distanceLastFd = this_distance;
            this.updateText();
          }
        },
        // 计算全部完成的回调方法
        end: () => {
          if (!this._map || !this._measureLable) {
            // 异步结束时，对象已经被释放
            return
          }

          this.updateText();

          this._measured.arrLen = arrLen;
          this._measured.arrLX = arrLX;
          this._measured.arrHB = arrHB;
          this._measured.arrPoint = arrPoint;

          const result = {
            mtype: this.type,
            graphic: this,
            value: all_distance,
            label: this._measured.distanceStr,
            ...this._measured
          };

          this.fire(EventType.change, result, true);
          this.fire(EventType.end, result, true);

          if (this._promise?.resolve) {
            this._promise.resolve(this);
          }
        }
      });
    }
  }

  // 注册下
  register$4("sectionMeasure", SectionMeasure);

  // 测量线的默认样式
  const DEF_STYLE$g = {
    materialType: "PolylineArrow",
    color: "#ebe967",
    width: 9,
    clampToGround: true
  };

  /**
   * 角度量算对象，
   * 非直接调用，由 Measure 类统一创建及管理
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolylineEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
   * @param {Number} [options.angleDecimal = 1]  显示的 角度值 文本中保留的小数位
   * @param {Number} [options.decimal = 2]  显示的 距离值 文本中保留的小数位
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class AngleMeasure
   * @extends {PolylineEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class AngleMeasure extends PolylineEntity {
    constructor(options = {}) {
      options.hasMoveEdit = false;
      options.maxPointNum = 2;

      options.decimal = options.decimal ?? 2;
      options.angleDecimal = options.angleDecimal ?? 1;

      options.style = {
        ...DEF_STYLE$g,
        ...(options.style || {})
      };

      super(options);

      // 测量结果
      this._measured = {};
    }

    /**
     *  测量结果
     * @type {Object}
     * @readonly
     */
    get measured() {
      return this._measured
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      super._addedHook(style);

      // 初始化lable
      this._measureLable = this._createLabel(this.options.label || this._layer?.options?.label);
      this._measureLable.show = false;

      // 绘制 事件监听
      this.on(EventType.drawAddPoint, this._drawAddPointHandler, this);
      this.on(EventType.drawRemovePoint, this._drawRemovePointHandler, this);
      this.on(EventType.drawMouseMove, this._drawMouseMoveHandler, this);
      this.once(EventType.drawCreated, this._drawCreatedHandler, this);

      // 编辑 事件监听
      this.on(EventType.editMovePoint, this._drawMouseMoveHandler, this);
      this.on(EventType.editRemovePoint, this._drawMouseMoveHandler, this);
      this.on(EventType.editMouseMove, this._drawMouseMoveHandler, this); // 编辑中，拖动了点
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      // 绘制 事件监听
      this.off(EventType.drawAddPoint, this._drawAddPointHandler, this);
      this.off(EventType.drawMouseMove, this._drawMouseMoveHandler, this);
      this.off(EventType.drawRemovePoint, this._drawRemovePointHandler, this);
      this.off(EventType.drawCreated, this._drawCreatedHandler, this);

      // 编辑 事件监听
      this.off(EventType.editMovePoint, this._drawMouseMoveHandler, this);
      this.off(EventType.editRemovePoint, this._drawMouseMoveHandler, this);
      this.off(EventType.editMouseMove, this._drawMouseMoveHandler, this); // 编辑中，拖动了点

      // 删除lable
      if (Cesium__namespace.defined(this._measureLable)) {
        this._removeLabel(this._measureLable);
        delete this._measureLable;
      }

      super._removedHook();
    }

    /**
     * 更新测量结果的文本
     * @param {String} unit 计量单位,{@link MeasureUtil#formatDistance} 可选值：auto、m、km、mile、zhang 等。auto时根据距离值自动选用k或km
     * @return {void}  无
     */
    updateText(unit) {
      if (unit) {
        this.options.unit = unit;
      }

      this._measured.angleStr = this._measured.angle.toFixed(this.options.angleDecimal) + "°";
      this._measured.distanceStr = formatDistance(this._measured.distance, {
        unit: this.options.unit,
        lang: this._map.lang,
        decimal: this.options.decimal
      });

      this._measureLable.text =
        this._map.getLangText("_角度") + ":" + this._measured.angleStr + "\n" + this._map.getLangText("_距离") + ":" + this._measured.distanceStr;
    }

    // 绘制增加一个点后，显示该分段的长度
    _drawAddPointHandler(event) {
      this._drawMouseMoveHandler(event); // 兼容手机端
    }

    // 绘制中删除了最后一个点
    _drawRemovePointHandler(event) {
      if (this._measureLable) {
        this._measureLable.show = false;
      }
    }

    // 绘制过程移动中，动态显示长度信息
    _drawMouseMoveHandler(event) {
      const positions = this.positionsShow;
      if (positions.length < 2) {
        this._measureLable.show = false;
        return
      }

      this._measured.distance = Cesium__namespace.Cartesian3.distance(positions[0], positions[1]); // 求长度
      this._measured.angle = getAngle(positions[0], positions[1], true); // 求方位角（正北为0）

      this.updateText();

      this._measureLable.position = positions[1];
      this._measureLable.show = true;

      this.fire(
        EventType.change,
        {
          mtype: this.type,
          value: this._measured.angle,
          label: this._measured.angleStr
        },
        true
      );
    }

    _drawCreatedHandler(event) {
      this.fire(
        EventType.end,
        {
          mtype: this.type,
          value: this._measured.angle,
          label: this._measured.angleStr
        },
        true
      );
    }
  }

  // 注册下
  register$4("angleMeasure", AngleMeasure);

  // 测量线的默认样式
  const DEF_STYLE$f = {
    materialType: "PolylineGlow",
    glowPower: 0.1,
    color: "#ebe12c",
    width: 9
  };

  /**
   * 高度量算对象，
   * 非直接调用，由 Measure 类统一创建及管理
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolylineEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
   * @param {Number} [options.decimal = 2]  显示的 距离和高度值 文本中保留的小数位
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class HeightMeasure
   * @extends {PolylineEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class HeightMeasure extends PolylineEntity {
    constructor(options = {}) {
      options.hasMoveEdit = false;
      options.maxPointNum = 2;
      options.decimal = options.decimal ?? 2;

      options.style = {
        ...DEF_STYLE$f,
        ...(options.style || {})
      };

      super(options);

      // 测量结果
      this._measured = {};
    }

    /**
     *  测量结果
     * @type {Object}
     * @readonly
     */
    get measured() {
      return this._measured
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      super._addedHook(style);

      this._initMeasureLable();

      // 绘制 事件监听
      this.on(EventType.drawAddPoint, this._drawAddPointHandler, this);
      this.on(EventType.drawRemovePoint, this._drawRemovePointHandler, this);
      this.on(EventType.drawMouseMove, this._drawMouseMoveHandler, this);
      this.once(EventType.drawCreated, this._drawCreatedHandler, this);

      // 编辑 事件监听
      this.on(EventType.editMovePoint, this._editPointHandler, this);
      this.on(EventType.editRemovePoint, this._editPointHandler, this);
      this.on(EventType.editMouseMove, this._editPointHandler, this); // 编辑中，拖动了点
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      // 绘制 事件监听
      this.off(EventType.drawAddPoint, this._drawAddPointHandler, this);
      this.off(EventType.drawMouseMove, this._drawMouseMoveHandler, this);
      this.off(EventType.drawRemovePoint, this._drawRemovePointHandler, this);
      this.off(EventType.drawCreated, this._drawCreatedHandler, this);

      // 编辑 事件监听
      this.off(EventType.editMovePoint, this._editPointHandler, this);
      this.off(EventType.editRemovePoint, this._editPointHandler, this);
      this.off(EventType.editMouseMove, this._editPointHandler, this); // 编辑中，拖动了点

      this._removeMeasureLabelAndEx();

      super._removedHook();
    }

    // 初始化lable
    _initMeasureLable() {
      this._measureLable = this._createLabel(this.options.label || this._layer?.options?.label);
      this._measureLable.show = false;
    }

    // 删除lable
    _removeMeasureLabelAndEx() {
      if (Cesium__namespace.defined(this._measureLable)) {
        this._removeLabel(this._measureLable);
        delete this._measureLable;
      }
    }

    /**
     * 更新测量结果的文本
     * @param {String} unit 计量单位,{@link MeasureUtil#formatDistance} 可选值：auto、m、km、mile、zhang 等。auto时根据距离值自动选用k或km
     * @return {void}  无
     */
    updateText(unit) {
      if (unit) {
        this.options.unit = unit;
      }
      this._measured.heightStr = formatDistance(this._measured.height, {
        unit: this.options.unit,
        lang: this._map.lang,
        decimal: this.options.decimal
      });
      this._measureLable.text = this._map.getLangText("_高度差") + ":" + this._measured.heightStr;
    }

    // 绘制增加一个点后，显示该分段的长度
    _drawAddPointHandler(event) {
      this._drawMouseMoveHandler(event); // 兼容手机端
    }

    // 绘制中删除了最后一个点
    _drawRemovePointHandler(event) {
      if (this._measureLable) {
        this._measureLable.show = false;
      }
    }

    // 绘制过程移动中，动态显示长度信息
    _drawMouseMoveHandler(event) {
      const positions = this.positionsShow;
      if (positions.length < 2) {
        this._measureLable.show = false;
        return
      }

      const cartographic = Cesium__namespace.Cartographic.fromCartesian(positions[0]);
      const cartographic1 = Cesium__namespace.Cartographic.fromCartesian(positions[1]);
      this._measured.height = this._map.getRealAlt(Math.abs(cartographic1.height - cartographic.height));

      this.updateText();

      // 位置
      this._measureLable.position = Cesium__namespace.Cartesian3.midpoint(positions[0], positions[1], new Cesium__namespace.Cartesian3());
      this._measureLable.show = true;

      this.fire(
        EventType.change,
        {
          mtype: this.type,
          value: this._measured.height,
          label: this._measured.heightStr
        },
        true
      );
    }

    _drawCreatedHandler(event) {
      this.fire(
        EventType.end,
        {
          mtype: this.type,
          value: this._measured.height,
          label: this._measured.heightStr
        },
        true
      );
    }

    // 编辑修改后
    _editPointHandler(event) {
      this._drawMouseMoveHandler(event);
    }
  }

  // 注册下
  register$4("heightMeasure", HeightMeasure);

  /**
   * 三角高度量算对象，
   * 非直接调用，由 Measure 类统一创建及管理
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolylineEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
   * @param {Number} [options.decimal = 2]  显示的 距离和高度值 文本中保留的小数位
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class HeightTriangleMeasure
   * @extends {HeightMeasure}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class HeightTriangleMeasure extends HeightMeasure {
    // 初始化lable标记
    _initMeasureLable() {
      super._initMeasureLable();

      this._measureDistanceLable = this._createLabel(this.options.label || this._layer?.options?.label);
      this._measureDistanceLable.pixelOffset = new Cesium__namespace.Cartesian2(0, 0);

      this._measureHorLable = this._createLabel(this.options.label || this._layer?.options?.label);
      this._measureHorLable.pixelOffset = new Cesium__namespace.Cartesian2(0, 0);
    }

    _removeMeasureLabelAndEx() {
      super._removeMeasureLabelAndEx();

      if (this._measureDistanceLable != null) {
        this._removeLabel(this._measureDistanceLable);
        delete this._measureDistanceLable;
      }
      if (this._measureHorLable != null) {
        this._removeLabel(this._measureHorLable);
        delete this._measureHorLable;
      }
      if (this._measureExLine != null) {
        this.dataSource.entities.remove(this._measureExLine);
        delete this._measureExLine;
      }
    }

    /**
     * 更新测量结果的文本
     * @param {String} unit 计量单位,{@link MeasureUtil#formatDistance} 可选值：auto、m、km、mile、zhang 等。auto时根据距离值自动选用k或km
     * @return {void}  无
     */
    updateText(unit) {
      super.updateText(unit);

      const formatOpts = {
        unit: this.options.unit,
        lang: this._map.lang,
        decimal: this.options.decimal
      };

      this._measured.distanceStr = formatDistance(this._measured.distance, formatOpts);
      this._measureDistanceLable.text = this._map.getLangText("_空间距离") + ":" + this._measured.distanceStr;

      this._measured.distanceHorStr = formatDistance(this._measured.distanceHor, formatOpts);
      this._measureHorLable.text = this._map.getLangText("_水平距离") + ":" + this._measured.distanceHorStr;
    }

    // 绘制中删除了最后一个点
    _drawRemovePointHandler(event) {
      if (this._measureLable) {
        this._measureLable.show = false;
      }
      if (this._measureHorLable) {
        this._measureHorLable.show = false;
      }
      if (this._measureDistanceLable) {
        this._measureDistanceLable.show = false;
      }
      if (this._measureExLine) {
        this._measureExLine_positions = null;
      }
    }

    // 绘制过程移动中，动态显示长度信息
    _drawMouseMoveHandler(event) {
      const positions = this.positionsShow;
      if (positions.length < 2) {
        this._measureLable.show = false;
        return
      }

      const carto1 = Cesium__namespace.Cartographic.fromCartesian(positions[0]);
      const height1 = carto1.height;
      const carto2 = Cesium__namespace.Cartographic.fromCartesian(positions[1]);
      const height2 = carto2.height;

      let bottomPosition; // 三角底部点
      let zPosition; // 三角底部点 对应的高处的点
      let topPosion; // 三角的顶部点

      if (height1 > height2) {
        zPosition = Cesium__namespace.Cartesian3.fromRadians(carto2.longitude, carto2.latitude, height1);
        topPosion = positions[0];
        bottomPosition = positions[1];
      } else {
        zPosition = Cesium__namespace.Cartesian3.fromRadians(carto1.longitude, carto1.latitude, height2);
        topPosion = positions[1];
        bottomPosition = positions[0];
      }

      // [垂直方向]高度差
      this._measured.height = this._map.getRealAlt(Math.abs(height2 - height1));
      this._measureLable.position = Cesium__namespace.Cartesian3.midpoint(zPosition, bottomPosition, new Cesium__namespace.Cartesian3()); // 位置
      this._measureLable.show = true;

      // 空间距离长度
      this._measured.distance = Cesium__namespace.Cartesian3.distance(topPosion, bottomPosition);
      this._measureDistanceLable.position = Cesium__namespace.Cartesian3.midpoint(topPosion, bottomPosition, new Cesium__namespace.Cartesian3()); // 位置
      this._measureDistanceLable.show = true;

      // [水平方向]水平距离
      this._measured.distanceHor = Cesium__namespace.Cartesian3.distance(zPosition, topPosion);
      this._measureHorLable.position = Cesium__namespace.Cartesian3.midpoint(zPosition, topPosion, new Cesium__namespace.Cartesian3()); // 位置
      this._measureHorLable.show = true;

      this.updateText();

      // 显示三角行 线
      this.updateExLine([bottomPosition, zPosition, topPosion]); // 参考线

      this.fire(
        EventType.change,
        {
          mtype: this.type,
          value: this._measured.height, // 高度差
          label: this._measured.heightStr
        },
        true
      );
    }

    updateExLine(positions) {
      this._measureExLine_positions = positions;

      if (!this._measureExLine) {
        const addattr = {
          id: this.id + "-ex",
          polyline: PolylineStyleConver.toCesiumVal(this.options.style, {}, true)
        };
        addattr.polyline.positions = new Cesium__namespace.CallbackProperty((time) => {
          return this._measureExLine_positions
        }, false);
        this._measureExLine = this._createEntity(addattr);
        this.dataSource.entities.add(this._measureExLine);
        this.bindPickId(this._measureExLine);
      }
    }

    // 编辑修改后
    _editPointHandler(event) {
      this._drawMouseMoveHandler(event);
    }
  }

  // 注册下
  register$4("heightTriangleMeasure", HeightTriangleMeasure);

  // 测量线的默认样式
  const DEF_STYLE$e = {
    color: "#00fff2",
    outline: true,
    outlineColor: "#fafa5a",
    outlineWidth: 1,
    opacity: 0.4,
    clampToGround: false // 贴地
  };

  /**
   * 面积测量对象，
   * 非直接调用，由 Measure 类统一创建及管理
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
   * @param {Number} [options.decimal = 2]  显示的 面积值 文本中保留的小数位
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class AreaMeasure
   * @extends {PolygonEntity}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class AreaMeasure extends PolygonEntity {
    constructor(options = {}) {
      options.hasMoveEdit = false;
      options.decimal = options.decimal ?? 2;

      options.style = {
        ...DEF_STYLE$e,
        ...(options.style || {})
      };

      options.label = {
        horizontalOrigin: Cesium__namespace.HorizontalOrigin.CENTER,
        ...(options.label || {})
      };

      super(options);

      // 测量结果
      this._measured = {};
    }

    /**
     *  测量结果
     * @type {Object}
     * @readonly
     */
    get measured() {
      return this._measured
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      super._addedHook(style);

      // 初始化lable
      this._measureLable = this._createLabel(this.options.label || this._layer?.options?.label);
      this._measureLable.show = false;

      // 绘制 事件监听
      this.on(EventType.drawAddPoint, this._drawAddPointHandler, this);
      this.on(EventType.drawRemovePoint, this._drawRemovePointHandler, this);
      this.on(EventType.drawMouseMove, this._drawMouseMoveHandler, this);
      this.once(EventType.drawCreated, this._drawCreatedHandler, this);

      // 编辑 事件监听
      this.on(EventType.editMovePoint, this._editPointHandler, this);
      this.on(EventType.editRemovePoint, this._editPointHandler, this);
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      // 绘制 事件监听
      this.off(EventType.drawAddPoint, this._drawAddPointHandler, this);
      this.off(EventType.drawMouseMove, this._drawMouseMoveHandler, this);
      this.off(EventType.drawRemovePoint, this._drawRemovePointHandler, this);
      this.off(EventType.drawCreated, this._drawCreatedHandler, this);

      // 编辑 事件监听
      this.off(EventType.editMovePoint, this._editPointHandler, this);
      this.off(EventType.editRemovePoint, this._editPointHandler, this);

      this._removeMeasureLabelAndEx();

      super._removedHook();
    }

    // 删除lable
    _removeMeasureLabelAndEx() {
      if (Cesium__namespace.defined(this._measureLable)) {
        this._removeLabel(this._measureLable);
        delete this._measureLable;
      }
    }

    /**
     * 更新测量结果的文本
     * @param {String} unit 计量单位,{@link MeasureUtil#formatArea} 可选值：计量单位，可选值：auto、m、km、mu、ha 。auto时根据面积值自动选用m或km
     * @return {void}  无
     */
    updateText(unit) {
      if (unit) {
        this.options.unit = unit;
      }

      this._measured.areaStr = formatArea(this._measured.area, {
        unit: this.options.unit,
        lang: this._map.lang,
        decimal: this.options.decimal
      });
      this._measureLable.text = this._map.getLangText("_面积") + ":" + this._measured.areaStr;
    }

    startDraw(layer) {
      super.startDraw(layer);

      this._drawMouseMoveHandler();
      if (this.options.positions?.length > 2) {
        this.stopDraw();
      }
    }

    // 绘制增加一个点后，显示该分段的长度
    _drawAddPointHandler(event) {
      this._drawMouseMoveHandler(event); // 兼容手机端
    }

    // 绘制中删除了最后一个点
    _drawRemovePointHandler(event) {
      const positions = this.positionsShow;
      if (positions?.length < 3) {
        this._measureLable.show = false;
      }
    }

    // 绘制过程移动中，动态显示长度信息
    _drawMouseMoveHandler(event) {
      const positions = this.positionsShow;
      if (positions.length < 3) {
        this._measureLable.show = false;
        return
      }

      this._measured.area = getArea(positions);
      this.updateText();

      // 求中心点
      const ptcenter = centerOfMass(positions);
      this._measureLable.position = ptcenter;
      this._measureLable.show = true;

      this.fire(
        EventType.change,
        {
          mtype: this.type,
          value: this._measured.area,
          label: this._measured.areaStr
        },
        true
      );
    }

    _drawCreatedHandler(event) {
      this.fire(
        EventType.end,
        {
          mtype: this.type,
          value: this._measured.area,
          label: this._measured.areaStr
        },
        true
      );
    }

    // 编辑修改了线
    _editPointHandler(event) {
      const positions = this.positionsShow;

      this._measured.area = getArea(positions);
      this.updateText();

      this._measureLable.position = centerOfMass(positions); // 求中心点

      this.fire(
        EventType.change,
        {
          mtype: this.type,
          value: this._measured.area,
          label: this._measured.areaStr
        },
        true
      );
    }
  }

  // 注册下
  register$4("areaMeasure", AreaMeasure);

  /**
   * 贴地面积量算对象，
   * 非直接调用，由 Measure 类统一创建及管理
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Cesium.PositionProperty|Array} options.positions 坐标位置
   * @param {PolygonEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
   * @param {Number} [options.decimal = 2]  显示的 面积值 文本中保留的小数位
   * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
   * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
   * @param {Cesium.Property} [options.viewFrom] 观察这个物体时建议的初始偏移量。
   * @param {Cesium.Entity} [options.parent] 要与此实体关联的父实体。
   * @param {Function} [options.onBeforeCreate] 在 new Cesium.Entity(addattr) 前的回调方法，可以对addattr做额外个性化处理。
   *
   * @param {Number} [options.minPointNum=2] 绘制时，至少需要点的个数
   * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {Boolean} [options.hasMoveEdit=true] 编辑时，是否可以整体平移
   * @param {Boolean} [options.hasHeightEdit=true] 编辑时，当有diffHeight时，是否可以编辑高度
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class AreaSurfaceMeasure
   * @extends {AreaMeasure}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class AreaSurfaceMeasure extends AreaMeasure {
    constructor(options = {}) {
      super(options);

      if (options._promise) {
        this._promise = options._promise;
        delete options._promise;
      }

      options.style.clampToGround = true;
    }

    _drawCreatedHandler(event) {
      this.updateAreaForTerrain(event);
    }

    // 编辑修改后
    _editPointHandler(event) {
      super._editPointHandler(event);
      this.updateAreaForTerrain(event);
    }

    // 计算贴地面
    updateAreaForTerrain(event) {
      // 更新lable等
      const positions = this.positionsShow;

      this.fire(
        EventType.start,
        {
          mtype: this.type,
          graphic: this
        },
        true
      );

      // 贴地总面积
      getClampArea(positions, {
        scene: this._map.scene,
        splitNum: this.options.splitNum,
        has3dtiles: this.options.has3dtiles,
        exact: true //  求准确的
      }).then((resultInter) => {
        if (!this._map || !this._measureLable) {
          // 异步结束时，对象已经被释放
          return
        }

        const thisCenter = getPositionValue(this._measureLable.position, this._map?.clock.currentTime);
        if (thisCenter && resultInter?.maxHeight) {
          // 更新lable高度
          this._measureLable.position = setPositionsHeight(thisCenter, resultInter.maxHeight);
        }

        this._measured.area = resultInter.area;
        this.updateText();

        const result = {
          ...resultInter,
          mtype: this.type,
          value: this._measured.area,
          label: this._measured.areaStr
        };
        this.fire(EventType.change, result, true);
        this.fire(EventType.end, result, true);

        if (this._promise?.resolve) {
          this._promise.resolve(this);
        }
      });
    }
  }

  // 注册下
  register$4("areaSurfaceMeasure", AreaSurfaceMeasure);

  /**
   * 体积量算对象（方量），
   * 非直接调用，由 Measure 类统一创建及管理。<br />
   *
   * 1. 挖方量: 计算“基准面”到地表之间的凸出部分进行挖掉的体积。<br />
   * 2. 填方量：计算“基准面”与“墙底部”之间的缺少部分进行填平的体积。
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {PolygonEntity.StyleOptions} options.style 基准面样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {PolygonEntity.StyleOptions} [options.polygonWallStyle] 围墙面的样式
   * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
   * @param {Boolean} [options.showFillVolume=true] 是否显示填方体积结果文本
   * @param {String} [options.fillVolumeName='填方体积'] 填方体积结果的名称
   * @param {Boolean} [options.showDigVolume=true] 是否显示挖方体积结果文本
   * @param {String} [options.digVolumeName='挖方体积'] 挖方体积结果的名称
   * @param {Boolean} [options.showArea=true] 是否显示横切面积结果文本
   * @param {String} [options.areaName='横切面积'] 横切面积结果的名称
   *
   * @param {Boolean} [options.heightLabel=true] 是否显示各边界点高度值文本
   * @param {Boolean} [options.offsetLabel=false] 是否显示各边界点高度差文本
   * @param {LabelEntity.StyleOptions} [options.labelHeight] 各边界点高度结果文本的样式
   * @param {Number} [options.decimal = 2]  显示的 数值 文本中保留的小数位
   * @param {Boolean} [options.has3dtiles]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class VolumeMeasure
   * @extends {AreaMeasure}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class VolumeMeasure extends AreaMeasure {
    constructor(options = {}) {
      super(options);

      if (options._promise) {
        this._promise = options._promise;
        delete options._promise;
      }

      // 高度文本样式
      this.labelHeightStyle = {
        ...(this.options.label || {}),
        font_size: 15,
        background: false
      };
      if (Cesium__namespace.defined(options.labelHeight)) {
        this.labelHeightStyle = { ...this.labelHeightStyle, ...options.labelHeight };
      }

      // 围合的墙样式
      this.polygonWallStyle = {
        color: "#00ff00",
        opacity: 0.3,
        closeTop: false,
        closeBottom: true,
        perPositionHeight: false,
        height: new Cesium__namespace.CallbackProperty((time) => {
          return this.minHeight
        }, false),
        extrudedHeight: new Cesium__namespace.CallbackProperty((time) => {
          return this.maxHeight
        }, false)
      };
      if (Cesium__namespace.defined(options.polygonWall)) {
        this.polygonWallStyle = { ...this.polygonWallStyle, ...options.polygonWall };
      }

      this.heightLabel = options.heightLabel ?? true;
      this.offsetLabel = options.offsetLabel ?? false;
      this.showArea = options.showArea ?? true;
      this.showFillVolume = options.showFillVolume ?? true;
      this.showDigVolume = options.showDigVolume ?? true;

      this._hasFX = false;
    }

    // 禁用编辑
    get hasEdit() {
      return false
    }

    /**
     *  面内的最高地表高度
     * @type {Number}
     * @readonly
     */
    get polygonMaxHeight() {
      if (this.interPolygonObj) {
        return this.interPolygonObj.maxHeight
      } else {
        return this.maxHeight
      }
    }

    /**
     * 基准面 高度，
     * 1. 挖方量: 计算“基准面”到地表之间的凸出部分进行挖掉的体积。<br />
     * 2. 填方量：计算“基准面”与“墙底部”之间的缺少部分进行填平的体积。
     * @type {Number}
     */
    get height() {
      return this._jzmHeight
    }

    set height(val) {
      this._jzmHeight = val;
      if (val > this.maxHeight) {
        this.maxHeight = val;
      }
      if (val < this.minHeight) {
        this.minHeight = val;
      }

      if (!this._hasFX) {
        return
      }

      const newFillV = updateVolume(this.interPolygonObj, this.height);
      for (const key in newFillV) {
        this._measured[key] = newFillV[key];
      }
      this.updateText();

      if (this._arrPartMeasureLable) {
        for (let i = 0; i < this._arrPartMeasureLable.length; i++) {
          this._arrPartMeasureLable[i].showText();
        }
      }

      const result = {
        ...newFillV,
        sourceTarget: this,
        mtype: this.type,
        graphic: this
      };
      this.fire(EventType.change, result, true);
    }

    /**
     * 底部高度，
     * 会影响 填方量：计算“基准面高度”与“底部高度”之间的缺少部分进行填平的体积。
     * @type {Number}
     */
    get minHeight() {
      return this._minHeight || 0
    }

    set minHeight(val) {
      this._minHeight = val;

      if (!this._hasFX) {
        return
      }

      if (this.interPolygonObj) {
        this.interPolygonObj.minHeight = val;
        this.interPolygonObj = updateVolumeByMinHeight(this.interPolygonObj);
      }
      const newFillV = updateVolume(this.interPolygonObj, this.height);
      for (const key in newFillV) {
        this._measured[key] = newFillV[key];
      }
      this.updateText();

      const result = {
        ...newFillV,
        sourceTarget: this,
        mtype: this.type,
        graphic: this
      };
      this.fire(EventType.change, result, true);
    }

    /**
     * 最高高度，对应墙的高度，
     * 不影响测量结果，只是显示效果的区别。
     * @type {Number}
     */
    get maxHeight() {
      return this._maxHeight || 0
    }

    set maxHeight(val) {
      this._maxHeight = val;
    }

    _removedHook() {
      if (this._depthTestAgainstTerrain_reset) {
        this._map.scene.globe.depthTestAgainstTerrain = false;
        delete this._depthTestAgainstTerrain_reset;
      }

      super._removedHook();
    }

    // 删除lable
    _removeMeasureLabelAndEx() {
      super._removeMeasureLabelAndEx();

      // 子类的对象
      if (Cesium__namespace.defined(this._arrPartMeasureLable) && this._arrPartMeasureLable.length > 0) {
        const _arrPartMeasureLable = this._arrPartMeasureLable;
        if (_arrPartMeasureLable && _arrPartMeasureLable.length > 0) {
          for (let i = 0, len = _arrPartMeasureLable.length; i < len; i++) {
            this._removeLabel(_arrPartMeasureLable[i]);
          }
        }
        delete this._arrPartMeasureLable;
      }

      if (Cesium__namespace.defined(this._wallEntity)) {
        this.dataSource.entities.remove(this._wallEntity);
        delete this._wallEntity;
      }
    }

    _drawCreatedHandler(event) {
      this._measureLable.text = this._map.getLangText("_正在计算体积") + "…";

      const positions = this.positionsShow;
      setTimeout(() => {
        this.calcVolume(positions);
      }, 100);
    }

    // 编辑修改后
    _editPointHandler(event) {
      this._drawCreatedHandler(event);
    }

    /**
     * 更新测量结果的文本
     * @param {String} unit 计量单位,{@link MeasureUtil#formatArea} 可选值：计量单位，可选值：auto、m、km、mu、ha 。auto时根据面积值自动选用m或km
     * @return {void}  无
     */
    updateText(unit) {
      if (unit) {
        this.options.unit = unit;
      }

      const formatOpts = {
        unit: this.options.unit,
        lang: this._map.lang,
        decimal: this.options.decimal
      };

      let fillText = "";
      if (this.showFillVolume && this._measured.fillVolume > 0) {
        this._measured.fillVolumeStr = formatVolume(this._measured.fillVolume, formatOpts);
        fillText += (this.options.fillVolumeName || this._map.getLangText("_填方体积")) + "：" + this._measured.fillVolumeStr + "\n";
      }
      if (this.showDigVolume && this._measured.digVolume > 0) {
        this._measured.digVolumeStr = formatVolume(this._measured.digVolume, formatOpts);
        fillText += (this.options.digVolumeName || this._map.getLangText("_挖方体积")) + "：" + this._measured.digVolumeStr + "\n";
      }
      if (this.showArea && this._measured.totalArea > 0) {
        this._measured.totalAreaStr = formatArea(this._measured.totalArea, formatOpts);
        fillText += (this.options.areaName || this._map.getLangText("_横切面积")) + "：" + this._measured.totalAreaStr;
      }
      this._measureLable.text = fillText;
    }

    // 计算贴地面
    calcVolume(positions) {
      if (!this._map) {
        return
      }

      this.fire(
        EventType.start,
        {
          mtype: this.type,
          sourceTarget: this,
          positions: positions
        },
        true
      );

      this._hasFX = true;

      // 计算体积
      interPolygon({
        positions: positions,
        scene: this._map.scene,
        exact: true,
        ...this.options
      }).then((result) => {
        if (!this._map || !this._hasFX) {
          return
        }

        if (result.has3dtiles) {
          this._map.scene.globe.depthTestAgainstTerrain = false;
        } else if (!this._map.scene.globe.depthTestAgainstTerrain) {
          this._map.scene.globe.depthTestAgainstTerrain = true;
          this._depthTestAgainstTerrain_reset = true;
        }

        this.showVolume(positions, result);
      });
    }

    showVolume(positions, interPolygonObj) {
      this._jzmHeight = this.options.height ?? interPolygonObj.minHeight;

      // 传入的基准面高度小于最小高度值时
      if (this._jzmHeight < interPolygonObj.minHeight) {
        interPolygonObj.minHeight = this._jzmHeight;
      }

      this.interPolygonObj = updateVolumeByMinHeight(interPolygonObj);
      this._minHeight = this.options.minHeight ?? this.interPolygonObj.minHeight;
      this._maxHeight = this.options.maxHeight ?? this.interPolygonObj.maxHeight;

      const minDiffHeight = Math.floor(0.3 * Cesium__namespace.Math.chordLength(interPolygonObj.granularity, this._map.scene.globe.ellipsoid.maximumRadius));
      if (this._maxHeight - this._minHeight < minDiffHeight) {
        this._maxHeight = this._minHeight + minDiffHeight;
      }

      const fillV = updateVolume(this.interPolygonObj, this.height);
      for (const key in fillV) {
        this._measured[key] = fillV[key];
      }

      // 显示计算结果文本
      this.updateText();
      this._measureLable.position = centerOfMass(positions, this.interPolygonObj.maxHeight); // 求中心点

      // 显示各点的贴地高度文本
      if (this.heightLabel) {
        this.showPointHeightLabel(positions, this.interPolygonObj.minHeight);
      }

      // 显示基准面
      this.entityGraphic.perPositionHeight = false;
      this.entityGraphic.hierarchy = new Cesium__namespace.PolygonHierarchy(positions);
      this.entityGraphic.height = new Cesium__namespace.CallbackProperty((time) => {
        return this.height
      }, false);

      // 显示立体边界
      const entityWallattr = PolygonStyleConver.toCesiumVal(this.polygonWallStyle, {}, true);
      entityWallattr.hierarchy = new Cesium__namespace.PolygonHierarchy(positions);

      this._wallEntity = this.dataSource.entities.add({
        polygon: entityWallattr
      });
      this.bindPickId(this._wallEntity);

      const result = {
        ...fillV,
        sourceTarget: this,
        mtype: this.type,
        graphic: this
      };
      this.fire(EventType.change, result, true);
      this.fire(EventType.end, result, true);

      if (this._promise?.resolve) {
        this._promise.resolve(this);
      }
    }

    // 显示各点的贴地高度文本
    showPointHeightLabel(positions, minHeight) {
      const that = this;

      const arrLable = [];
      for (let i = 0; i < positions.length; i++) {
        const height = Math.max(getHeight(this._map.scene, positions[i]), minHeight);

        const cartographic = Cesium__namespace.Cartographic.fromCartesian(positions[i]);
        const position = Cesium__namespace.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, height);

        // 各点的文本
        const label = this._createLabel(this.labelHeightStyle, position);
        label.attr = { value: height };
        arrLable.push(label);

        label.showText = function () {
          const height = this.attr.value;
          let text = that._map.getLangText("_海拔") + "：" + height.toFixed(2) + that._map.getLangText("_米");

          if (that.offsetLabel) {
            const offset = height - that.height;
            if (offset > 0) {
              text +=
                "\n" +
                that._map.getLangText("_高度") +
                "：" +
                offset.toFixed(2) +
                that._map.getLangText("_米") +
                "(" +
                that._map.getLangText("_面上") +
                ")";
            } else {
              text +=
                "\n" +
                that._map.getLangText("_高度") +
                "：" +
                Math.abs(offset).toFixed(2) +
                that._map.getLangText("_米") +
                "(" +
                that._map.getLangText("_面下") +
                ")";
            }
          }

          this.text = text;
          return text
        };
        label.showText();
      }
      this._arrPartMeasureLable = arrLable;
    }
  }

  // 注册下
  register$4("volumeMeasure", VolumeMeasure);

  /**
   * 图标点 Primitive矢量数据
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {BillboardEntity.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class BillboardPrimitive
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BillboardPrimitive extends BasePointPrimitive {
    /**
     * 当加载primitive数据的内部Cesium容器
     * @type {Cesium.BillboardCollection}
     * @readonly
     */
    get primitiveCollection() {
      return this._layer?.billboardCollection
    }

    /**
     * 图像、URI或Canvas
     * @type {string | HTMLCanvasElement}
     */
    get image() {
      return this.style.image
    }

    set image(val) {
      this.style.image = val;
      if (this._primitive) {
        this._primitive.image = val;
      }
    }

    _showHook(val) {
      // 覆盖父类
      if (val && !this._primitive) {
        super._showHook(val);
      }
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show) {
        return
      }

      this._forPositionProperty(this.options.position); // 对动态属性坐标的支持

      const addattr = BillboardStyleConver.toCesiumVal(style, {
        show: this.show,
        position: this.position
      });
      this._primitive = this.primitiveCollection.add(addattr);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      BillboardStyleConver.toCesiumVal(style, this.primitive);
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return BillboardStyleConver.toJSON(czmStyle, styleJson)
    }

    _updatePositionsHook() {
      if (!this._primitive._billboardCollection) {
        // this._primitive._billboardCollection = this.primitiveCollection
        return
      }

      this._primitive.position = this.position;
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this.style.globalAlpha = value;
      if (this._primitive) {
        this._primitive.color = Cesium__namespace.Color.WHITE.withAlpha(value);
      }
      this._updateLabelOpacity(value);
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return create$4("billboard", options)
    }
  }
  // 注册下
  register$4("billboardP", BillboardPrimitive);

  /**
   * 积云 Primitive矢量数据 支持的样式信息
   *
   * @typedef {Object} CloudPrimitive.StyleOptions
   *
   * @property {Cesium.Cartesian2} scale  积云的比例（以米为单位）。该scale属性会影响广告牌的大小，但不会影响云的实际外观。
   * @property {Cesium.Cartesian3} maximumSize 积云的最大尺寸。这定义了云可以出现的最大椭球体积。这不是保证特定的大小，而是指定了云出现的边界，改变它可以影响云的形状。
   * @property {Number} slice 切片，即为广告牌外观选择的云的特定横截面。给定一个介于 0 和 1 之间的值，切片根据其在 z 方向上的最大尺寸指定与云相交的深度。
   * @property {Number} [brightness = 1.0] 亮度
   *
   * @see Cesium.CumulusCloud
   */

  /**
   * 积云 Primitive矢量数据
   * <br />
   * <div align='center'>
   * <img src='//mars3d.cn/api/cesium/Images/CumulusCloud.png' width='400' height='300' />
   * </div>
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {CloudPrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {Boolean} [options.stopPropagation=false] 当前类中事件是否停止冒泡, false时：事件冒泡到layer中。
   * @export
   * @class CloudPrimitive
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class CloudPrimitive extends BasePointPrimitive {
    /**
     * 当加载primitive数据的内部Cesium容器
     * @type {Cesium.CloudCollection}
     * @readonly
     */
    get primitiveCollection() {
      return this._layer?.cloudCollection
    }

    /**
     * 积云的最大大小。这定义了云可以出现在的最大椭球体体积。这不是保证一个特定的大小，而是指定了云出现的边界，改变它可能会影响云的形状。
     * 改变maximumSize的z值对云的外观有最显著的影响，因为它改变了云的深度，从而改变了云形状纹理采样的位置。
     *
     * <div align='center'>
     * <table border='0' cellpadding='5'>
     * <tr>
     *   <td align='center'>
     *     <code>cloud.maximumSize = new Cesium.Cartesian3(14, 9, 10);</code><br/>
     *     <img src='//mars3d.cn/api/cesium/Images/CumulusCloud.maximumSizex14y9z10.png' width='250' height='158' />
     *   </td>
     *   <td align='center'>
     *     <code>cloud.maximumSize.x = 25;</code><br/>
     *     <img src='//mars3d.cn/api/cesium/Images/CumulusCloud.maximumSizex25.png' width='250' height='158' />
     *   </td>
     * </tr>
     * <tr>
     *   <td align='center'>
     *     <code>cloud.maximumSize.y = 5;</code><br/>
     *     <img src='//mars3d.cn/api/cesium/Images/CumulusCloud.maximumSizey5.png' width='250' height='158' />
     *   </td>
     *   <td align='center'>
     *     <code>cloud.maximumSize.z = 17;</code><br/>
     *     <img src='//mars3d.cn/api/cesium/Images/CumulusCloud.maximumSizez17.png' width='250' height='158' />
     *   </td>
     * </tr>
     * </table>
     * </div>
     *
     * <p>To modify the billboard's actual size, modify the cloud's <code>scale</code> property.</p>
     * @type {Cesium.Cartesian3}
     */
    get maximumSize() {
      return this.style.maximumSize
    }

    set maximumSize(val) {
      this.style.maximumSize = val;
      if (this._primitive) {
        this._primitive.maximumSize = val;
      }
    }

    /**
     * 积云广告牌的规模(以米为单位)。缩放属性会影响广告牌的大小，但不会影响云的实际外观。
     *
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'>
     *   <code>cloud.scale = new Cesium.Cartesian2(12, 8);</code><br/>
     *   <img src='//mars3d.cn/api/cesium/Images/CumulusCloud.scalex12y8.png' width='250' height='158' />
     * </td>
     * <td align='center'>
     *   <code>cloud.scale = new Cesium.Cartesian2(24, 10);</code><br/>
     *   <img src='//mars3d.cn/api/cesium/Images/CumulusCloud.scalex24y10.png' width='250' height='158' />
     * </td>
     * </tr></table>
     * </div>
     *
     * <p>To modify the cloud's appearance, modify its <code>maximumSize</code>
     * and <code>slice</code> properties.</p>
     * @type {Cesium.Cartesian2}
     */
    get scale() {
      return this.style.scale
    }

    set scale(val) {
      this.style.scale = val;
      if (this._primitive) {
        this._primitive.scale = val;
      }
    }

    /**
     * 在广告牌上渲染的云的“切片”，即为广告牌的外观选择的云的特定横截面。给定一个介于0和1之间的值，切片根据它在z方向上的最大大小指定与云相交的深度。
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>cloud.slice = 0.32;</code><br/><img src='//mars3d.cn/api/cesium/Images/CumulusCloud.slice0.32.png' width='250' height='158' /></td>
     * <td align='center'><code>cloud.slice = 0.5;</code><br/><img src='//mars3d.cn/api/cesium/Images/CumulusCloud.slice0.5.png' width='250' height='158' /></td>
     * <td align='center'><code>cloud.slice = 0.6;</code><br/><img src='//mars3d.cn/api/cesium/Images/CumulusCloud.slice0.6.png' width='250' height='158' /></td>
     * </tr></table>
     * </div>
     *
     * <br />
     *
     * 由于计算这个切片的性质，低于0.2的值可能导致横截面太小，从而可以看到椭球体的边缘。同样，大于0.7的值会使云看起来更小。应该完全避免超出范围[0.1,0.9]的值，因为它们不会产生理想的结果。
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>cloud.slice = 0.08;</code><br/><img src='//mars3d.cn/api/cesium/Images/CumulusCloud.slice0.08.png' width='250' height='158' /></td>
     * <td align='center'><code>cloud.slice = 0.8;</code><br/><img src='//mars3d.cn/api/cesium/Images/CumulusCloud.slice0.8.png' width='250' height='158' /></td>
     * </tr></table>
     * </div>
     *
     * 如果slice设置为负数，云将不会渲染一个横截面。相反，它将渲染椭球的外部是可见的。对于具有“maximumSize”小值的云。，这可以产生好看的结果，但对于较大的云，这可能导致云扭曲到不希望的椭球体体积。
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'>
     *  <code>cloud.slice = -1.0;<br/>cloud.maximumSize.z = 18;</code><br/>
     *  <img src='//mars3d.cn/api/cesium/Images/CumulusCloud.slice-1z18.png' width='250' height='158' />
     * </td>
     * <td align='center'>
     *   <code>cloud.slice = -1.0;<br/>cloud.maximumSize.z = 30;</code><br/>
     *   <img src='//mars3d.cn/api/cesium/Images/CumulusCloud.slice-1z30.png' width='250' height='158' /></td>
     * </tr></table>
     * </div>
     *
     * @type {Number}
     * @default -1.0
     */
    get slice() {
      return this.style.slice
    }

    set slice(val) {
      this.style.slice = val;
      if (this._primitive) {
        this._primitive.slice = val;
      }
    }

    /**
     * 云的亮度。这可以用来给云一个更暗、更灰的外观。
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>cloud.brightness = 1.0;</code><br/><img src='//mars3d.cn/api/cesium/Images/CumulusCloud.brightness1.png' width='250' height='158' /></td>
     * <td align='center'><code>cloud.brightness = 0.6;</code><br/><img src='//mars3d.cn/api/cesium/Images/CumulusCloud.brightness0.6.png' width='250' height='158' /></td>
     * <td align='center'><code>cloud.brightness = 0.0;</code><br/><img src='//mars3d.cn/api/cesium/Images/CumulusCloud.brightness0.png' width='250' height='158' /></td>
     * </tr></table>
     * </div>
     * @type {Number}
     * @default 1.0
     */
    get brightness() {
      return this.style.brightness
    }

    set brightness(val) {
      this.style.brightness = val;
      if (this._primitive) {
        this._primitive.brightness = val;
      }
    }

    /**
     * 是否可以调整透明度
     * @type {Boolean}
     * @readonly
     */
    get hasOpacity() {
      return false
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show) {
        return
      }

      this._forPositionProperty(this.options.position); // 对动态属性坐标的支持

      const addattr = CloudStyleConver.toCesiumVal(style, {
        show: this.show,
        position: this.position
      });
      this._primitive = this.primitiveCollection.add(addattr);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      CloudStyleConver.toCesiumVal(style, this.primitive);
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return CloudStyleConver.toJSON(czmStyle, styleJson)
    }

    _updatePositionsHook() {
      this._primitive.position = this.position;
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return this._getDrawPointEntityClass(options, isDraw)
    }
  }
  // 注册下
  register$4("cloud", CloudPrimitive);

  /**
   * 文字 支持的样式信息（与LabelEntity相同）
   *
   * @typedef {Object} LabelPrimitive.StyleOptions
   * @property {LabelEntity.StyleOptions} [所有] 与LabelEntity相同
   *
   * @see LabelEntity.StyleOptions
   * @see Cesium.Label
   */

  /**
   *  文字 Primitive矢量数据
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {LabelPrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class LabelPrimitive
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class LabelPrimitive extends BasePointPrimitive {
    /**
     * 当加载primitive数据的内部Cesium容器
     * @type {Cesium.LabelCollection}
     * @readonly
     */
    get primitiveCollection() {
      return this._layer?.labelCollection
    }

    /**
     * 文本内容
     * @type {String}
     * @readonly
     */
    get text() {
      return this.style.text
    }

    set text(value) {
      this.style.text = value;
      if (this._primitive) {
        this._primitive.text = value;
      }
    }

    _showHook(val) {
      // 覆盖父类
      if (val && !this._primitive) {
        super._showHook(val);
      }
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show) {
        return
      }

      const addattr = LabelStyleConver.toCesiumVal(
        this.style,
        {
          show: this.show,
          position: this.position
        },
        {},
        this.attr
      );
      this._primitive = this.primitiveCollection.add(addattr);
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      LabelStyleConver.toCesiumVal(style, this.primitive, this.attr);
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return LabelStyleConver.toJSON(czmStyle, styleJson)
    }

    _updatePositionsHook() {
      this._primitive.position = this.position;
    }

    // 获取对应标绘时的Entity对象
   _getDrawEntityClass(options, isDraw) {
      return create$4("label", options)
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this.style.globalAlpha = value;
      if (this._primitive && this.show) {
        LabelStyleConver.setOpacity(this._primitive, value);
      }
    }
  }
  // 注册下
  register$4("labelP", LabelPrimitive);

  /**
   * gltf小模型 支持的样式信息
   *
   * @typedef {Object} ModelPrimitive.StyleOptions
   *
   *
   * @property {String| Cesium.Resource} [url] glTF模型的URI的字符串或资源属性。
   * @property {Number} [scale = 1] 整体缩放比例
   *
   * @property {Number} [scaleX = 1] X轴方向缩放比例
   * @property {Number} [scaleY = 1] Y轴方向缩放比例
   * @property {Number} [scaleZ = 1] Z轴方向缩放比例
   *
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   * @property {Boolean} [noPitchRoll] 当addDynamicPosition时，设置为true时，可以设置模型只动态更改方向，内部固定模型的Pitch和Roll方向值为0
   *
   * @property {number} [minimumPixelSize=0.0] 指定模型的近似最小像素大小，而不考虑缩放。
   * @property {number} [maximumScale] 模型的最大比例尺寸。minimumPixelSize的上限。
   *
   * @property {Boolean} [fill = false] 是否填充，指定与模型渲染颜色混合
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {Cesium.ColorBlendMode} [colorBlendMode=ColorBlendMode.HIGHLIGHT] 指定颜色如何与模型混合。
   * @property {number} [colorBlendAmount=0.5] 当colorBlendMode为MIX时指定颜色强度的数字属性。0.0的值表示模型渲染的颜色，1.0的值表示纯色，任何介于两者之间的值表示两者的混合。
   *
   * @property {Boolean} [silhouette = false] 是否轮廓
   * @property {String|Cesium.Color} [silhouetteColor = "#ff0000"] 轮廓颜色
   * @property {Number} [silhouetteSize = 2] 轮廓宽度
   * @property {Number} [silhouetteAlpha = 0.8] 轮廓透明度
   *
   * @property {Boolean|Cesium.DistanceDisplayCondition} [distanceDisplayCondition = false] 是否按视距显示 或 指定此框将显示在与摄像机的多大距离。
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   * @property {Number} [distanceDisplayCondition_far = 100000] 最大距离
   * @property {PointEntity.StyleOptions} [distanceDisplayPoint] 当视角距离超过一定距离后(distanceDisplayCondition_far定义的) 后显示为 像素点 对象的样式，仅在distanceDisplayCondition设置时有效。
   * @property {BillboardEntity.StyleOptions} [distanceDisplayBillboard]  当视角距离超过一定距离后(distanceDisplayCondition_far定义的) 后显示为 图标 对象的样式，仅在distanceDisplayCondition设置时有效。
   *
   * @property {Cesium.CustomShader} [customShader] 自定义shader效果
   *
   * @property {Boolean} [hasShadows = true] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=ShadowMode.ENABLED] 指定模型是投射还是接收来自光源的阴影。
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   *
   * @property {boolean} [incrementallyLoadTextures=true] 确定模型加载后纹理是否会继续流进来。
   * @property {boolean} [runAnimations=true]  指定模型中指定的glTF动画是否应该启动。
   * @property {boolean} [clampAnimations=true]  指定在没有关键帧的情况下，glTF动画是否应该保持最后一个姿势。
   *
   * @property {Cesium.Color} [lightColor]  在为模型着色时指定光的颜色的属性。当undefined场景的浅色被使用代替。
   * @property {Cesium.PropertyBag | Object.<string, Cesium.TranslationRotationScale>} [nodeTransformations] 一个对象，其中键是节点的名称，值是{@link TranslationRotationScale}属性，描述要应用到该节点的转换。该转换是在节点的现有转换之后(如glTF中指定的那样)应用的，并且不会替换节点的现有转换。
   * @property {Cesium.PropertyBag | Object.<string, number>} [articulations] An object, where keys are composed of an articulation name, a single space, and a stage name, and the values are numeric properties.
   * @property {Cesium.ClippingPlaneCollection} [clippingPlanes]  用于裁剪模型的Plane平面集合
   *
   *
   * @property {Boolean} [allowPicking=true] 当true时，每个glTF和Primitive都可以用{@link Cesium.Scene#pick}来拾取。
   * @property {Boolean} [asynchronous=true] 确定模型WebGL资源创建是否将分散在几个帧或块上，直到所有glTF文件加载完成。
   * @property {Boolean} [dequantizeInShader=true] 确定一个{@link https://github.com/google/draco|Draco}编码的模型是否在GPU上被去量化。这减少了编码模型的总内存使用量。
   * @property {Boolean} [backFaceCulling=true] 是否剔除面向背面的几何图形。当为真时，背面剔除是由材料的双面属性决定的;当为false时，禁用背面剔除。如果{@link Model#color}是半透明的，或者{@link Model#silhouette}大于0.0，则背面不会被剔除。
   * @property {Boolean} [debugShowBoundingVolume=false] 仅供调试。查看模型的包围边界球。
   * @property {Boolean} [debugWireframe=false] 仅供调试。查看模型的三角网线框图。
   *
   * //以下是 以下是 模型动画相关
   * @property {Cesium.JulianDate} [startTime] 场景时间开始播放动画。当undefined时，动画从下一帧开始。
   * @property {Number} [delay=0.0] 从startTime开始播放的延迟，以秒为单位。
   * @property {Cesium.JulianDate} [stopTime] 场景时间停止播放动画。当这是undefined，动画播放它的整个持续时间。
   * @property {Boolean} [removeOnStop=false] 当true时，动画在停止播放后被删除。
   * @property {Number} [multiplier=1.0] 大于1.0的值增加动画播放的速度相对于场景时钟的速度;小于1.0会降低速度。
   * @property {Boolean} [reverse=false] 当true时，动画会反向播放。
   * @property {Cesium.ModelAnimationLoop} [loop=Cesium.ModelAnimationLoop.REPEAT] 决定动画是否循环以及如何循环。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {ModelPrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   */

  /**
   *
   * gltf小模型 Primitive图元矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]|Cesium.PositionProperty} options.position 坐标位置
   * @param {Cesium.Property} [options.orientation] 实体方向，仅position是回调属性时有效
   *
   * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
   * @param {ModelPrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Number} [options.frameRate = 1] 当postion为CallbackProperty时，多少帧获取一次数据。用于控制效率，如果卡顿就把该数值调大一些。
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   *
   * @param {Number} [options.maxCacheCount=50] 当使用addDynamicPosition设置为动画轨迹位置时，保留的坐标点数量
   * @param {Boolean} [options.fixedHeading] 当使用addDynamicPosition设置为动画轨迹位置时，是否使用固定的heading角度，而不用路线的自动方向角度。
   * @param {Cesium.ExtrapolationType} [options.forwardExtrapolationType= Cesium.ExtrapolationType.HOLD]  当使用addDynamicPosition设置为动画轨迹位置时，在任何可用坐标之后一次请求值时要执行的推断类型，默认为最后一个坐标位置。
   * @param {Cesium.ExtrapolationType} [options.backwardExtrapolationType= Cesium.ExtrapolationType.HOLD] 当使用addDynamicPosition设置为动画轨迹位置时， 在任何可用坐标之前一次请求值时要执行的推断类型，默认为第一个坐标位置。
   * @param {Boolean} [options.clampToTileset] 当使用addDynamicPosition设置为动画轨迹位置时，是否进行贴模型。
   * @param {Number} [options.frameRateHeight=30] 当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，多少帧计算一次贴模型高度
   * @param {Object[]} [options.objectsToExclude]  当使用addDynamicPosition设置为动画轨迹位置时，并clampToTileset：true时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class ModelPrimitive extends BasePointPrimitive {
    // 内部用，文本等附加对象
    get czmObjectEx() {
      const arr = [];
      if (this._primitive_label) {
        arr.push(this._primitive_label);
      }
      if (this._primitive_point) {
        arr.push(this._primitive_point);
      }
      if (this._primitive_billboard) {
        arr.push(this._primitive_billboard);
      }
      return arr
    }

    /**
     * 模型整体的缩放比例
     * @type {Number}
     */
    get scale() {
      return this.style.scale ?? 1
    }

    set scale(val) {
      this.style.scale = val;
      this._updateStyleHook(this.style, { scale: val });
    }

    /**
     * X轴方向缩放比例
     * @type {Number}
     */
    get scaleX() {
      return this.style.scaleX ?? 1
    }

    set scaleX(val) {
      this.style.scaleX = val;
      this.updateModelMatrix();
    }

    /**
     * Y轴方向缩放比例
     * @type {Number}
     */
    get scaleY() {
      return this.style.scaleY ?? 1
    }

    set scaleY(val) {
      this.style.scaleY = val;
      this.updateModelMatrix();
    }

    /**
     * Z轴方向缩放比例
     * @type {Number}
     */
    get scaleZ() {
      return this.style.scaleZ ?? 1
    }

    set scaleZ(val) {
      this.style.scaleZ = val;
      this.updateModelMatrix();
    }

    /**
     * 获取图层完成解析加载完成的Promise承诺, 等价于load事件(区别在于load事件必须在load完成前绑定才能监听)。
     * @type {Promise<Cesium.Model>}
     * @readonly
     */
    get readyPromise() {
      if (this._primitive) {
        return this._primitive.readyPromise
      } else {
        return null
      }
    }

    _showHook(val) {
      // 覆盖父类
      if (val && !this._primitive) {
        super._showHook(val);
      }
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show || !this._map) {
        return
      }

      this._forPositionProperty(this.options.position); // 对动态属性坐标的支持

      const addattr = ModelStyleConver.toCesiumVal(this.style);

      let model;
      if (this.style.customShader) {
        const modelMatrix = this.modelMatrix;
        if (this.style.scale > 0 && this.style.scale !== 1) {
          Cesium__namespace.Matrix4.multiplyByUniformScale(modelMatrix, this.style.scale, modelMatrix);
        }

        model = Cesium__namespace.ModelExperimental.fromGltf({
          modelMatrix: modelMatrix,
          scene: this._map.scene, // heightReference需要
          gltf: addattr.url,
          ...addattr
        });
      } else {
        model = Cesium__namespace.Model.fromGltf({
          modelMatrix: this.modelMatrix,
          scene: this._map.scene, // heightReference需要
          marsOptions: {
            // marsOptions用于传递给 mars3d-cesium 内部
            occlusion: this.style.marsOcclusion // gltf部分材质的混乱问题控制
          },
          ...addattr
        });
      }

      this._primitive = this.primitiveCollection.add(model);
      this._primitive.readyPromise
        .then((model) => {
          // 加载完成后直接启动所有动画
          if ((this.style.runAnimations ?? true) && model.activeAnimations?.addAll) {
            model.activeAnimations.addAll({
              loop: Cesium__namespace.ModelAnimationLoop.REPEAT,
              ...this.style
            });
          }

          this.fire(
            EventType.load,
            {
              drawtype: this.type,
              model: model,
              graphic: this
            },
            true
          );
        })
        .catch((error) => {
          logError("ModelPrimitive:模型加载出错", error);
        });

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }

      // 当视角距离超过一定距离后(distanceDisplayCondition_far定义的) 后显示的对象处理
      if (this.style.distanceDisplayCondition) {
        if (this.style.distanceDisplayPoint) {
          const addattr = PointStyleConver.toCesiumVal(this.style.distanceDisplayPoint, {
            show: this.show,
            position: this.position
          });
          addattr.distanceDisplayCondition = this._getTargetDistanceDisplayCondition(this.style.distanceDisplayPoint);

          this._primitive_point = this._layer?.pointCollection.add(addattr);
        } else if (this.style.distanceDisplayBillboard) {
          const addattr = BillboardStyleConver.toCesiumVal(this.style.distanceDisplayBillboard, {
            show: this.show,
            position: this.position
          });
          addattr.distanceDisplayCondition = this._getTargetDistanceDisplayCondition(this.style.distanceDisplayBillboard);

          this._primitive_billboard = this._layer?.billboardCollection.add(addattr);
        }
      }
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      super._removedHook();

      if (this._primitive_point) {
        this._layer?.pointCollection.remove(this._primitive_point);
        delete this._primitive_point;
      }
      if (this._primitive_billboard) {
        this._layer?.billboardCollection.remove(this._primitive_billboard);
        delete this._primitive_billboard;
      }
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      ModelStyleConver.toCesiumVal(style, this.primitive);
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return ModelStyleConver.toJSON(czmStyle, styleJson)
    }

    _updatePositionsHook() {
      this._primitive.modelMatrix = this.modelMatrix;

      if (this._primitive_point) {
        this._primitive_point.position = this.position;
      }
      if (this._primitive_billboard) {
        this._primitive_billboard.position = this.position;
      }
    }

    // 当视角距离超过一定距离后(distanceDisplayCondition_far定义的) 后显示的对象处理
    // 获取其对应的distanceDisplayCondition属性
    _getTargetDistanceDisplayCondition(pointAttr) {
      let model_far;
      if (this.style.distanceDisplayCondition instanceof Cesium__namespace.DistanceDisplayCondition) {
        model_far = this.style.distanceDisplayCondition.far;
      } else if (this.style.distanceDisplayCondition_far) {
        model_far = this.style.distanceDisplayCondition_far;
      }

      return new Cesium__namespace.DistanceDisplayCondition(
        pointAttr.distanceDisplayCondition_near ?? model_far,
        pointAttr.distanceDisplayCondition_far ?? Number.MAX_VALUE
      )
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this.style.globalAlpha = value;
      if (this._primitive) {
        ModelStyleConver.setOpacity(this._primitive, value);
      }
      this._updateLabelOpacity(value);
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return create$4("model", options)
    }
  }
  // 注册下
  register$4("modelP", ModelPrimitive);

  /**
   * 圆 支持的样式信息
   *
   * @typedef {Object} CirclePrimitive.StyleOptions
   *
   * @property {Number} [radius = 100] 半径
   *
   * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
   * @property {Number} [diffHeight = 100] 高度差（圆柱本身的高度），与extrudedHeight二选一。
   * @property {number} [extrudedHeight] 指定圆的挤压面相对于椭球面的高度。
   *
   * @property {Number} [stRotation = 0] 椭圆纹理的角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [stRotationDegree = 0] 椭圆纹理的角度（度数值，0-360度），与stRotation二选一
   *
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定椭圆上各点之间的角距离。
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
   * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   * @property {PolylinePrimitive.StyleOptions} [outlineStyle] 边框的样式，会覆盖outlineColor、outlineOpacity
   *
   * @property {Cesium.MaterialAppearance.MaterialSupportType} [materialSupport=Cesium.MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
   *
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
   * @property {Boolean} [classification = false] 是否为ClassificationPrimitive ，分类基元 表示Scene要高亮显示的包围几何的体积
   *
   * //以下是 这是MaterialAppearance的参数
   * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
   * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
   * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
   * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
   * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
   * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
   * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {CirclePrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   */

  /**
   *
   * 圆 Primitive图元矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
   * @param {CirclePrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class CirclePrimitive extends BasePointPrimitive {
    // 距离长度（单位：米）
    get distance() {
      return Math.PI * 2 * this.radius
    }

    // 面积（单位：平方米）
    get area() {
      const radius = this.radius;
      return Math.PI * radius * radius
    }

    /**
     * 圆的半径（单位：米）
     * @type {Number}
     */
    get radius() {
      return this.style.radius
    }

    set radius(val) {
      this.style.radius = val;
      this._updateStyleHook(this.style, { radius: val });
    }

    /**
     * 圆的边线坐标集合（笛卡尔坐标）
     * @type {Cesium.Cartesian3[]}
     * @readonly
     */
    get outlinePositions() {
      return this.getOutlinePositions()
    }

    // 转换style
    _conversionStyle(style) {
      return CircleStyleConver.toCesiumVal(style)
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return CircleStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstance(addattr, outline) {
      addattr.height = addattr.height ?? this.point?.alt ?? 0;
      addattr.center = this.position;

      // 存在extrudedHeight高度设置时
      if (Cesium__namespace.defined(this.style.diffHeight)) {
        addattr.extrudedHeight = addattr.height + this.style.diffHeight;
      }

      const GeometryClass = outline ? Cesium__namespace.CircleOutlineGeometry : Cesium__namespace.CircleGeometry;

      return new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new GeometryClass(addattr),
        attributes: this.options.attributes
      })
    }

    // 边线坐标数组，支持多个线 [线坐标集合]
    _getPolylineOutlinePositions() {
      return [this.getOutlinePositions(false)]
    }

    /**
     *  获取圆的边线坐标集合（经纬度二维数组）
     *
     * @param {Boolean} [closure=true] 是否闭合，true时会添加第0个点进行闭合。
     * @param {Number} [count=90] 象限内点的数量，返回的总数为 count*4
     * @param {Boolean} [noAlt] 是否包含高度值
     * @return  {Array[]} 边线坐标数组（经纬度二维数组）
     */
    getOutlineCoordinates(closure, count, noAlt) {
      return cartesians2lonlats(this.getOutlinePositions(closure, count), noAlt)
    }

    /**
     * 获取圆的边线坐标集合（笛卡尔坐标）
     *
     * @param {Boolean} [closure=true] 是否闭合，true时会添加第0个点进行闭合。
     * @param {Number} [count] 象限内点的数量，返回的总数为 count*4
     * @return  {Cesium.Cartesian3[]} 边线坐标数组
     */
    getOutlinePositions(closure = true, count) {
      const outerPositions = getEllipseOuterPositions({
        position: this.position,
        radius: this.radius,
        granularity: this.style.granularity,
        count: count // 共返回count*4个点
      });

      if (closure && outerPositions) {
        outerPositions.push(outerPositions[0]);
      }
      return outerPositions
    }

    // 定位至数据区域
    flyTo(options = {}) {
      if (!this._map) {
        return Promise.resolve(false)
      }

      options.radius = this.radius * (options.scale || 1.8);
      return this._map.flyToPoint(this.position, options)
    }

    /**
     * 获取数据的矩形边界
     * @param {Boolean} [options] 控制参数
     * @param {Boolean} [options.isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */
    getRectangle(options) {
      const positions = this.getOutlinePositions(false, 1);
      if (!positions || positions.length === 0) {
        return
      }

      const extent = getRectangle(positions, options?.isFormat);
      return extent
    }

    /**
     * 判断点是否在圆内
     *
     * @param {Cesium.Cartesian3|LngLatPoint} position 需要判断的点
     * @return {Boolean} 是否在圆内
     */
    isInPoly(position) {
      position = LngLatPoint.parse(position).toCartesian();

      position = setPositionsHeight(position, this.height);
      const len = Cesium__namespace.Cartesian3.distance(this.position, position);
      return len <= this.radius // 小于半径的说明在圆内
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return create$4("circle", options)
    }
  }
  // 注册下
  register$4("circleP", CirclePrimitive);

  /**
   * 平面 支持的样式信息
   *
   * @typedef {Object} PlanePrimitive.StyleOptions
   *
   * @property {Cesium.Cartesian2} [dimensions] 指定平面的宽度和高度。
   * @property {Number} [dimensions_x = 100] 长度
   * @property {Number} [dimensions_y = 100] 宽度
   *
   *  @property {String|Cesium.Cartesian3} [plane_normal = "z"] 方向 ,可选项：x (解释：X轴),y (解释：Y轴),z (解释：Z轴),
   *
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   *
   * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   * @property {Cesium.MaterialAppearance.MaterialSupportType} [materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * //以下是 这是MaterialAppearance的参数
   * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
   * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
   * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
   * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
   * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
   * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
   * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
   *
   *
   *
   * @property {PlanePrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   */

  /**
   *
   * 平面 Primitive图元矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
   * @param {PlanePrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PlanePrimitive extends BasePointPrimitive {
    /**
     *  用于指定位置的矩阵
     * @type {Cesium.Matrix4}
     * @readonly
     */
    get modelMatrix() {
      if (this.options.modelMatrix) {
        return this.options.modelMatrix
      }
      const modelMatrix = super.modelMatrix;
      if (!this.position) {
        return Cesium__namespace.Matrix4.IDENTITY
      }

      const addattr = PlaneStyleConver.toCesiumVal(this.style);
      const normal = this.style.plane_normal || addattr.plane?.normal;
      const scale = new Cesium__namespace.Cartesian3(addattr.dimensions?.x ?? 1, addattr.dimensions?.y ?? 1, 1);
      if (normal === Cesium__namespace.Cartesian3.UNIT_X || normal === "x") {
        const rotationMatrix = Cesium__namespace.Matrix4.fromRotationTranslation(Cesium__namespace.Matrix3.fromRotationY(Cesium__namespace.Math.toRadians(90.0)));
        Cesium__namespace.Matrix4.multiply(modelMatrix, rotationMatrix, modelMatrix);

        scale.x = addattr.dimensions?.y ?? 1;
        scale.y = addattr.dimensions?.x ?? 1;
        scale.z = 1;

      } else if (normal === Cesium__namespace.Cartesian3.UNIT_Y || normal === "y") {
        const rotationMatrix = Cesium__namespace.Matrix4.fromRotationTranslation(Cesium__namespace.Matrix3.fromRotationX(Cesium__namespace.Math.toRadians(90.0)));
        Cesium__namespace.Matrix4.multiply(modelMatrix, rotationMatrix, modelMatrix);
      }

      // 缩放，必须放在最后面
      const scaleMatrix = Cesium__namespace.Matrix4.fromScale(scale);
      Cesium__namespace.Matrix4.multiply(modelMatrix, scaleMatrix, modelMatrix);

      return modelMatrix
    }

    // 转换style
    _conversionStyle(style) {
      return PlaneStyleConver.toCesiumVal(style)
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PlaneStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstance(addattr, outline) {
      const GeometryClass = outline ? Cesium__namespace.PlaneOutlineGeometry : Cesium__namespace.PlaneGeometry;

      return new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new GeometryClass(addattr),
        modelMatrix: this.modelMatrix,
        attributes: this.options.attributes
      })
    }

    // 获取对应标绘时的Entity对象
   _getDrawEntityClass(options, isDraw) {
      return create$4("plane", options)
    }
  }
  // 注册下
  register$4("planeP", PlanePrimitive);

  /**
   * 盒子 支持的样式信息
   *
   * @typedef {Object} BoxPrimitive.StyleOptions
   *
   * @property {Cesium.Cartesian3} [dimensions] 指定盒子的长度、宽度和高度。
   * @property {Number} [dimensions_x = 100] 盒子长度
   * @property {Number} [dimensions_y = 100] 盒子宽度
   * @property {Number} [dimensions_z = 100] 盒子高度
   *
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
   * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {Cesium.MaterialAppearance.MaterialSupportType} [materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
   *
   * //以下是 这是MaterialAppearance的参数
   * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
   * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
   * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
   * @property {Boolean} [closed=true] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
   * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
   * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
   * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {BoxPrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   */

  /**
   *
   * 盒子 Primitive图元矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
   * @param {BoxPrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class BoxPrimitive
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BoxPrimitive extends BasePointPrimitive {
    constructor(options = {}) {
      super(options);

      this.style.closed = this.style.closed ?? true;
    }

    // 子类需要继承实现
    _conversionStyle(style) {
      return BoxStyleConver.toCesiumVal(style)
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return BoxStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstance(addattr, outline) {
      const GeometryClass = outline ? Cesium__namespace.BoxOutlineGeometry : Cesium__namespace.BoxGeometry;

      return new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: GeometryClass.fromDimensions(addattr),
        modelMatrix: this.modelMatrix,
        // modelMatrix:
        //   this.options.modelMatrix ||
        //   Cesium.Matrix4.multiplyByTranslation(
        //     Cesium.Transforms.eastNorthUpToFixedFrame(this.position),
        //     new Cesium.Cartesian3(0.0, 0.0, dimensions.z * 0.5),
        //     new Cesium.Matrix4()
        //   ),
        attributes: this.options.attributes
      })
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return create$4("box", options)
    }
  }

  // 注册下
  register$4("boxP", BoxPrimitive);

  /**
   * 圆锥 支持的样式信息
   *
   * @typedef {Object} CylinderPrimitive.StyleOptions
   *
   * @property {Number} [topRadius = 0] 顶部半径，指定圆柱体顶部的半径，当为0时即为圆锥。
   * @property {Number} [bottomRadius = 100] 底部半径，指定圆柱体底部半径。
   * @property {Number} [length = 100] 高度，柱面长度。
   * @property {number} [slices=128] 圆柱体周长周围的边数。
   *
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   *
   * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
   * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {Cesium.MaterialAppearance.MaterialSupportType} [materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
   *
   * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
   * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
   * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
   * @property {Boolean} [closed=true] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
   * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
   * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
   * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
   *
   *
   * @property {CylinderPrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   */

  /**
   *
   * 圆锥 Primitive图元矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
   * @param {CylinderPrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class CylinderPrimitive
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class CylinderPrimitive extends BasePointPrimitive {
    constructor(options = {}) {
      super(options);

      this.style.closed = this.style.closed ?? true;
    }

    // 转换style
    _conversionStyle(style) {
      return CylinderStyleConver.toCesiumVal(style)
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return CylinderStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstance(addattr, outline) {
      const GeometryClass = outline ? Cesium__namespace.CylinderOutlineGeometry : Cesium__namespace.CylinderGeometry;

      return new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new GeometryClass(addattr),
        modelMatrix: addattr.modelMatrix || this.modelMatrix,
        attributes: this.options.attributes
      })
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return create$4("cylinder", options)
    }
  }
  // 注册下
  register$4("cylinderP", CylinderPrimitive);

  /**
   * 圆锥追踪体 Primitive图元矢量对象 支持的样式信息
   *
   * @typedef {Object} ConeTrackPrimitive.StyleOptions
   *
   * @property {Number} [angle] 圆锥追踪体张角（角度值，取值范围 0.01-89.99）
   * @property {Number} [bottomRadius = 100] 不指定angle时，也可以直接指定圆锥底部半径（单位：米）
   * @property {Number} [length = 100]  圆锥追踪体长度值（单位：米），没有指定targetPosition时有效
   * @property {number} [slices=128] 圆柱体周长周围的边数。
   *
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度），没有指定targetPosition时有效
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度），没有指定targetPosition时有效
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度），没有指定targetPosition时有效
   *
   * @property {Boolean} [fill = true] 是否填充
   * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {Cesium.MaterialAppearance.MaterialSupportType} [materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
   *
   * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
   * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
   * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
   * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
   * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
   * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
   * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
   *
   * @property {CylinderPrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   *  @see Cesium.CylinderGraphics.ConstructorOptions
   *  @see CylinderPrimitive.StyleOptions
   */

  /**
   * 圆锥追踪体 Primitive图元矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置(不支持动态属性)
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} [options.targetPosition] 追踪的目标位置(不支持动态属性)
   * @param {ConeTrackPrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class ConeTrackPrimitive
   * @extends {CylinderPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class ConeTrackPrimitive extends CylinderPrimitive {
    constructor(options = {}) {
      super(options);

      if (options.targetPosition) {
        this.targetPosition = options.targetPosition;
      }
    }

    // 禁用编辑
    get hasEdit() {
      return false
    }

    /**
     * 追踪的目标位置(确定了方向和距离)
     * @type {Cesium.Cartesian3|LngLatPoint}
     */
    get targetPosition() {
      return this._targetPosition
    }

    set targetPosition(value) {
      this._targetPoint = LngLatPoint.parse(value);
      this._targetPosition = this._targetPoint.toCartesian();

      if (this.czmObject) {
        this._updatePositionsHook();
      }
    }

    /**
     * 追踪的目标位置
     * @type {LngLatPoint}
     * @readonly
     */
    get targetPoint() {
      return this._targetPoint
    }

    /**
     * 夹角，半场角度，取值范围 0.01-89.99
     * @type {Number}
     */
    get angle() {
      return this.style.angle
    }

    set angle(val) {
      this.style.angle = val;
    }

    _createGeometryInstance(addattr, outline) {
      const position = this.position;
      const targetPosition = getPositionValue(this.targetPosition, this._map.clock.currentTime);

      let hpr;
      let cylinderPosition;
      if (targetPosition) {
        addattr.length = Cesium__namespace.Cartesian3.distance(position, targetPosition);
        cylinderPosition = Cesium__namespace.Cartesian3.midpoint(position, targetPosition, new Cesium__namespace.Cartesian3());

        hpr = getHeadingPitchRollForLine(targetPosition, position);
      } else {
        addattr.length = this.style.length;
        hpr = new Cesium__namespace.HeadingPitchRoll(Cesium__namespace.Math.toRadians(this.heading), Cesium__namespace.Math.toRadians(this.pitch), Cesium__namespace.Math.toRadians(this.roll));
        cylinderPosition = getPositionByHprAndLen(position, hpr, addattr.length / 2);
      }
      addattr.modelMatrix = Cesium__namespace.Transforms.headingPitchRollToFixedFrame(cylinderPosition, hpr);

      if (Cesium__namespace.defined(this.style.angle)) {
        addattr.bottomRadius = addattr.length * Math.cos(Cesium__namespace.Math.toRadians(90 - this.angle));
      }
      return super._createGeometryInstance(addattr, outline)
    }
  }

  // 注册下
  register$4("coneTrackP", ConeTrackPrimitive);

  /**
   * 球体 支持的样式信息
   *
   * @typedef {Object} EllipsoidPrimitive.StyleOptions
   *
   * @property {Cesium.Cartesian3} [radii] 指定椭球半径。
   * @property {Number} [radii_x = 100] X半径
   * @property {Number} [radii_y = 100] Y半径
   * @property {Number} [radii_z = 100] Z半径
   * @property {Cesium.Cartesian3} [innerRadii] 指定椭球的内半径。
   * @property {Number} [innerRadii_x = 0] 内部X半径
   * @property {Number} [innerRadii_y = 0] 内部Y半径
   * @property {Number} [innerRadii_z = 0] 内部Z半径
   *
   * @property {Number} [minimumClock = 0] 最小时钟角度（弧度值）
   * @property {Number} [minimumClockDegree = 0] 最小时钟角度（度数值，0-360度），与minimumClock二选一
   * @property {Number} [maximumClock = 360] 最大时钟角度（弧度值）
   * @property {Number} [maximumClockDegree = 360] 最大时钟角度（度数值，0-360度），与maximumClock二选一
   * @property {Number} [minimumCone = 0] 最小锥角（弧度值）
   * @property {Number} [minimumConeDegree = 0] 最小锥角（度数值，0-360度），与minimumCone二选一
   * @property {Number} [maximumCone = 180] 最大圆锥角（弧度值）
   * @property {Number} [maximumConeDegree = 180] 最大圆锥角（度数值，0-360度），与maximumCone二选一
   *
   * @property {number} [stackPartitions=64] 指定竖向划分数量
   * @property {number} [slicePartitions=64] 指定横向划分数量
   *
   * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
   * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   * @property {Cesium.MaterialAppearance.MaterialSupportType} [materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * //以下是 这是MaterialAppearance的参数
   * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
   * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
   * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
   * @property {Boolean} [closed=true] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
   * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
   * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
   * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
   *
   *
   *
   * @property {EllipsoidPrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   *
   */

  /**
   *
   * 球体 Primitive图元矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
   * @param {EllipsoidPrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class EllipsoidPrimitive
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class EllipsoidPrimitive extends BasePointPrimitive {
    constructor(options = {}) {
      super(options);

      this.style.closed = this.style.closed ?? true;
    }

    // 转换style
    _conversionStyle(style) {
      return EllipsoidStyleConver.toCesiumVal(style)
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return EllipsoidStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstance(addattr, outline) {
      const GeometryClass = outline ? Cesium__namespace.EllipsoidOutlineGeometry : Cesium__namespace.EllipsoidGeometry;

      return new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new GeometryClass(addattr),
        modelMatrix: this.modelMatrix,
        // modelMatrix:
        //   this.options.modelMatrix ||
        //   Cesium.Matrix4.multiplyByTranslation(
        //     Cesium.Transforms.eastNorthUpToFixedFrame(this.position),
        //     new Cesium.Cartesian3(0.0, 0.0, this.style.radii.z), //几何的x,y,z空间偏移
        //     new Cesium.Matrix4()
        //   ),
        attributes: this.options.attributes
      })
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return create$4("ellipsoid", options)
    }
  }
  // 注册下
  register$4("ellipsoidP", EllipsoidPrimitive);

  /**
   * 简单线 Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标位置
   * @param {PolylinePrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePolyPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PolylineSimplePrimitive extends BasePolyPrimitive {
    /**
     * 当加载 线primitive 数据的内部Cesium容器
     * @type {Cesium.PolylineCollection}
     * @readonly
     * @ignore
     */
    get primitiveCollection() {
      return this._layer?.polylineCollection
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show || !this.positions || this.positions.length === 0) {
        return
      }

      const addattr = PolylineStyleConver.toCesiumVal(this.style, {
        show: this.show
      });

      if (this.style.closure && this.positions?.length > 0) {
        addattr.positions = this.positions.concat(this.positions[0]);
      } else {
        addattr.positions = this.positions;
      }

      this._primitive = this.primitiveCollection.add(addattr);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} style 完整样式信息
     * @param {Object} newStyle 变动部分的样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleHook(style, newStyle) {
      PolylineStyleConver.toCesiumVal(style, this._primitive);
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PolylineStyleConver.toJSON(czmStyle, styleJson)
    }

    _updatePositionsHook() {
      if (this.style.closure && this.positions?.length > 0) {
        this._primitive.positions = this.positions.concat(this.positions[0]);
      } else {
        this._primitive.positions = this.positions;
      }
    }
  }
  // 注册下
  register$4("polylineSP", PolylineSimplePrimitive);

  /**
   * 墙  Primitive图元 支持的样式信息
   *
   * @typedef {Object} WallPrimitive.StyleOptions
   *
   * @property {Number} [diffHeight = 100] 墙高
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   *
   * @property {Boolean} [closure = false] 是否闭合
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定折线是投射还是接收来自光源的阴影。
   *
   * //以下是 这是MaterialAppearance的参数
   * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
   * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
   * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
   * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
   * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
   * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
   * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
   *
   * @property {WallPrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelPrimitive.StyleOptions|Object} [label] 支持附带文字的显示 ，额外支持：<br />
  //  * @property {String|LngLatPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
  //  * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
   *
   */

  /**
   * 墙 Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标位置
   * @param {WallPrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePolyPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class WallPrimitive extends BasePolyPrimitive {
    // 子类需要继承实现
    _createGeometryInstance(addattr, outline) {
      let positions = this.positions;
      const points = this.points;

      const len = points.length;
      let minimumHeights = new Array(len);
      let maximumHeights = new Array(len);
      for (let i = 0; i < len; i++) {
        const height = points[i].alt;
        minimumHeights[i] = height;
        maximumHeights[i] = height + Number(this.style.diffHeight || 100);
      }

      if (this.style.closure && positions?.length > 0) {
        positions = positions.concat(positions[0]);
        minimumHeights = minimumHeights.concat(minimumHeights[0]);
        maximumHeights = maximumHeights.concat(maximumHeights[0]);
      }

      const GeometryClass = outline ? Cesium__namespace.WallOutlineGeometry : Cesium__namespace.WallGeometry;

      return new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new GeometryClass({
          ...addattr,
          positions: positions,
          maximumHeights: maximumHeights,
          minimumHeights: minimumHeights
        }),
        attributes: this.options.attributes
      })
    }

    //
    _conversionStyle(style) {
      return WallStyleConver.toCesiumVal(style)
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return WallStyleConver.toJSON(czmStyle, styleJson)
    }

    // 获取对应标绘时的Entity对象
   _getDrawEntityClass(options, isDraw) {
      return create$4("wall", options)
    }
  }

  // 注册下
  register$4("wallP", WallPrimitive);

  /**
   * 走廊  Primitive图元 支持的样式信息
   *
   * @typedef {Object} CorridorPrimitive.StyleOptions
   *
   *
   * @property {Number} [width = 100] 走廊宽度，指定走廊边缘之间的距离。
   * @property {String|Cesium.CornerType} [cornerType] 指定边角的样式。
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
   * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
   * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。

   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
   * @property {Boolean} [classification = false] 是否为ClassificationPrimitive ，分类基元 表示Scene要高亮显示的包围几何的体积
   *
   *
   * //以下是 这是MaterialAppearance的参数
   * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
   * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
   * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
   * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
   * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
   * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
   * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示
   *
   */

  /**
   * 走廊  Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标位置
   * @param {CorridorPrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePolyPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class CorridorPrimitive extends BasePolyPrimitive {
    // 子类需要继承实现
    _createGeometryInstance(addattr, outline) {
      addattr.positions = this.positions;

      const GeometryClass = outline ? Cesium__namespace.CorridorOutlineGeometry : Cesium__namespace.CorridorGeometry;

      return new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new GeometryClass(addattr),
        attributes: this.options.attributes
      })
    }

    //
    _conversionStyle(style) {
      return CorridorStyleConver.toCesiumVal(style)
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return CorridorStyleConver.toJSON(czmStyle, styleJson)
    }

    // 获取对应标绘时的Entity对象
   _getDrawEntityClass(options, isDraw) {
      return create$4("corridor", options)
    }
  }
  // 注册下
  register$4("corridorP", CorridorPrimitive);

  /**
   *  管道线 Primitive图元 支持的样式信息
   *
   * @typedef {Object} PolylineVolumePrimitive.StyleOptions
   *
   * @property {String|Array<Cesium.Cartesian2>} [shape = "pipeline"] 形状类型 或 定义要挤压的形状。类型可选项：pipeline (解释：空心管),circle (解释：实心管),star (解释：星状管),
   * @property {Number} [radius = 10] 半径(单位：米)
   * @property {Number} [thicknes = radius/3] 厚度(单位：米)，空心管/星状管 的外层厚度
   * @property {Number} [slices] 边数，比如为4时是矩形管；星状管代表角的个数；
   * @property {Number} [startAngle=0] 开始角度，取值范围0-360
   * @property {Number} [endAngle=360] 结束角度，取值范围0-360，比如endAngle=180的空心管是拱形半圆管道
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
   * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   *
   * @property {Cesium.CornerType} [cornerType=CornerType.ROUNDED] 指定边角的样式。
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE] 指定每个纬度点和经度点之间的角距离。
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
   *
   * //以下是 这是MaterialAppearance的参数
   * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
   * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
   * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
   * @property {Boolean} [closed=true] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
   * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
   * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
   * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
   *
   * @property {Number|Number[]} [setHeight] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
   * @property {Number|Number[]} [addHeight] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
   *
   * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示
   *
   */

  /**
   * 管道线  Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标位置
   * @param {PolylineVolumePrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class PolylineVolumePrimitive
   * @extends {BasePolyPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PolylineVolumePrimitive extends BasePolyPrimitive {
    constructor(options = {}) {
      super(options);

      this.style.closed = this.style.closed ?? true;
    }

    // 子类需要继承实现
    _createGeometryInstance(addattr, outline) {
      const GeometryClass = outline ? Cesium__namespace.PolylineVolumeOutlineGeometry : Cesium__namespace.PolylineVolumeGeometry;

      return new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new GeometryClass({
          ...addattr,
          polylinePositions: this.positions,
          shapePositions: addattr.shape
        }),
        attributes: this.options.attributes
      })
    }

    //
    _conversionStyle(style) {
      return PolylineVolumeStyleConver.toCesiumVal(style)
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PolylineVolumeStyleConver.toJSON(czmStyle, styleJson)
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return create$4("polylineVolume", options)
    }
  }

  // 注册下
  register$4("polylineVolumeP", PolylineVolumePrimitive);

  /**
   * 矩形   Primitive图元 支持的样式信息
   *
   * @typedef {Object} RectanglePrimitive.StyleOptions
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {String} [image] 当为贴图时，贴图的url
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   * @property {PolylinePrimitive.StyleOptions} [outlineStyle] 边框的样式，会覆盖outlineColor、outlineOpacity
   *
   * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
   * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
   * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。
   *
   * @property {Number} [rotation = 0] 旋转角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [rotationDegree = 0] 旋转角度（度数值，0-360度），与rotation二选一
   * @property {Number} [stRotation = 0] 矩形纹理的角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [stRotationDegree = 0] 矩形纹理的角度（度数值，0-360度），与stRotation二选一
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
   * @property {Boolean} [classification = false] 是否为ClassificationPrimitive ，分类基元 表示Scene要高亮显示的包围几何的体积
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示
   *
   */

  /**
   * 矩形  Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} [options.positions] 坐标位置
   * @param {Cesium.Rectangle|Cesium.PositionProperty} [options.rectangle]  矩形范围，与positions二选一。
   * @param {RectanglePrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class RectanglePrimitive
   * @extends {BasePolyPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class RectanglePrimitive extends BasePolyPrimitive {
    constructor(options = {}) {
      super(options);

      if (options.rectangle) {
        this.rectangle = options.rectangle;
      }
    }

    /**
     * 坐标数据对应的矩形边界对象
     * @type {Cesium.Rectangle}
     */
    get rectangle() {
      if (!this._rectangle && this.positions) {
        this._rectangle = Cesium__namespace.Rectangle.fromCartesianArray(this.positions);
      }
      return this._rectangle
    }

    set rectangle(value) {
      this._rectangle = value;
      // if (this._primitive) {
      //   this.geometryInstanceAttributes.rectangle = value
      // }
    }

    get outlinePositions() {
      const arr = getRectangleOuterPositions({
        rectangle: this.rectangle,
        rotation: this.style.rotation,
        height: this.style.height
      });
      return arr
    }

    /**
     * 周长 距离（单位：米）
     * @type {Number}
     * @readonly
     */
    get distance() {
      return getDistance(this.outlinePositions, true)
    }

    // 面积（单位：平方米）
    get area() {
      return getSurfaceArea(this.outlinePositions)
    }

    // 中心点坐标，覆盖父类
    get center() {
      const rectangle = this.rectangle;
      if (!this.rectangle) {
        return null
      }
      const position = Cesium__namespace.Cartographic.toCartesian(Cesium__namespace.Rectangle.center(rectangle));
      return position
    }

    _updatePositionsHook() {
      this.rectangle = Cesium__namespace.Rectangle.fromCartesianArray(this.positions);
      return super._updatePositionsHook()
    }

    // 子类需要继承实现
    _createGeometryInstance(addattr, outline) {
      addattr.rectangle = this.rectangle;

      const GeometryClass = outline ? Cesium__namespace.RectangleOutlineGeometry : Cesium__namespace.RectangleGeometry;

      return new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new GeometryClass(addattr),
        attributes: this.options.attributes
      })
    }

    //
    _conversionStyle(style) {
      return RectangleStyleConver.toCesiumVal(style)
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return RectangleStyleConver.toJSON(czmStyle, styleJson)
    }

    _getGeoJsonGeometry(options) {
      return { type: "Polygon", coordinates: [this.getCoordinates(options?.noAlt)] }
    }

    // 边线坐标数组，支持多个线 [线坐标集合]
    _getPolylineOutlinePositions() {
      return [this.outlinePositions]
    }

    /**
     * 获取数据的矩形边界
     * @param {Boolean} [options] 控制参数
     * @param {Boolean} [options.isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */
    getRectangle(options) {
      const rectangle = this.rectangle;

      if (options?.isFormat) {
        return formatRectangle(rectangle)
      } else {
        return rectangle
      }
    }

    /**
     * 判断点是否在矩形内
     *
     * @param {Cesium.Cartesian3|LngLatPoint} position 需要判断的点
     * @return {Boolean} 是否在矩形内
     */
    isInPoly(position) {
      const isInRectangle = Cesium__namespace.Rectangle.contains(this.rectangle, LngLatPoint.parse(position).toCartographic());
      return isInRectangle
    }

    // 获取对应标绘时的Entity对象
   _getDrawEntityClass(options, isDraw) {
      return create$4("rectangle", options)
    }

    _updateDrawEntityToThis() {
      super._updateDrawEntityToThis();
      this._updatePositionsHook();
    }
  }

  // 注册下
  register$4("rectangleP", RectanglePrimitive);

  const nullColor = new Cesium__namespace.Color(0.0, 0.0, 0.0, 0.01);

  /**
   * 面   Primitive图元 支持的样式信息
   *
   * @typedef {Object} PolygonPrimitive.StyleOptions
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
    * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {Boolean} [randomColor = false] 是否随机颜色
   * @property {String} [image] 当为贴图时，贴图的url
   *
   * @property {Number} [stRotation = 0] 多边形纹理的角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [stRotationDegree = 0] 多边形纹理的角度（度数值，0-360度），与stRotation二选一
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   * @property {PolylinePrimitive.StyleOptions} [outlineStyle] 边框的样式，会覆盖outlineColor、outlineOpacity
   *
   * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
   * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
   * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。
   *
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE]  指定每个纬度点和经度点之间的角距离。
   * @property {Boolean} [closeTop=true]  当为false时，离开一个挤压多边形的顶部打开。
   * @property {Boolean} [closeBottom=true]  当为false时，离开挤压多边形的底部打开。
   * @property {Cesium.ArcType} [arcType=Cesium.ArcType.GEODESIC]  多边形的边缘必须遵循的线条类型。
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
   *
   * @property {Boolean} [classification = false] 是否为ClassificationPrimitive ，分类基元 表示Scene要高亮显示的包围几何的体积
   *
   * //以下是 这是MaterialAppearance的参数
   * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
   * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
   * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
   * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
   * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
   * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
   * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
   *
   * @property {Number} [buffer] 对坐标进行缓冲扩大buffer指定的半径范围，单位：米。如用于单体化建筑物扩大点方便鼠标拾取。
   * @property {Number|Number[]} [setHeight] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
   * @property {Number|Number[]} [addHeight] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
   *
   * @property {PolygonPrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelPrimitive.StyleOptions|Object} [label] 支持附带文字的显示 ，额外支持：<br />
  //  * @property {String|LngLatPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
  //  * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
   *
   */

  /**
   *  面  Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标位置
   * @param {PolygonPrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePolyPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PolygonPrimitive extends BasePolyPrimitive {
    // 中心点坐标，覆盖父类
    get center() {
      return this.centerOfMass
    }

    /**
     * 周长 距离（单位：米）
     * @type {Number}
     * @readonly
     */
    get distance() {
      return getDistance(this._positions, true)
    }

    /**
     * 位置坐标数组 （笛卡尔坐标）, 赋值时可以传入LatLngPoint数组对象
     * @type {Cesium.Cartesian3[]}
     */
    get positions() {
      return this._positions
    }

    set positions(value) {
      if (!value) {
        return
      }

      // 判断是否为存在holes的面
      if (value.length > 0 && Array.isArray(value[0]) && value[0].length > 0) {
        const firstItem = value[0][0];
        if (Array.isArray(firstItem) && isNumber(firstItem[0])) {
          this._hierarchy = getPolygonHierarchy(value, this.style.height || this.style.setHeight || this.style.addHeight);
          value = this._hierarchy.positions;
        } else if (firstItem instanceof Cesium__namespace.Cartesian3) {
          this._hierarchy = getPolygonHierarchy2(value);
          value = this._hierarchy.positions;
        }
      }

      super.positions = value;

      if (this._hierarchy && this._positions) {
        this._hierarchy.positions = this._positions;
      }
    }

    // get defaultVertexFormat() {
    //   return Cesium.VertexFormat.DEFAULT
    // }

    _createGeometryInstance(addattr, outline) {
      if (this._hierarchy) {
        addattr.polygonHierarchy = this._hierarchy;
      } else {
        addattr.polygonHierarchy = new Cesium__namespace.PolygonHierarchy(this.positions);
      }

      // 存在diffHeight高度设置时
      if (Cesium__namespace.defined(this.style.diffHeight) && !Cesium__namespace.defined(addattr.extrudedHeight)) {
        let height = 0;
        if (Cesium__namespace.defined(this.style.height)) {
          height = this.style.height;
        } else {
          height = getMaxHeight(this.positions);
        }
        addattr.extrudedHeight = height + this.style.diffHeight;
      }

      const GeometryClass = outline ? Cesium__namespace.PolygonOutlineGeometry : Cesium__namespace.PolygonGeometry;

      return new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new GeometryClass(addattr),
        attributes: this.options.attributes
      })
    }

    //
    _conversionStyle(style) {
      let addattr = PolygonStyleConver.toCesiumVal(style);
      addattr = this._bindExType(addattr);
      return addattr
    }

    // 是特殊的面类型的处理
    _bindExType(addattr) {
      // 是建筑物时
      const buildings = this.options.buildings || this._layer.options.buildings;
      if (buildings) {
        if (buildings.bottomHeight) {
          const bottomHeight = Number(this.attr[buildings.bottomHeight] || 0); // 底部高度
          addattr.height = bottomHeight;
        }

        const floor = Number(this.attr[buildings.cloumn] || 1); // 层数
        let height; // 层高
        if (isNumber(buildings.height)) {
          height = buildings.height;
        } else if (isString(buildings.height)) {
          height = this.attr[buildings.height] || height;
        } else {
          height = 3.5; // 默认值
        }
        const bottomHeight = addattr.height || 0;
        addattr.extrudedHeight = bottomHeight + floor * height; // 顶部高度
      }

      // 是建筑物单体化时(兼容v3.0)
      const dthCfg = this.options.dth || this._layer.options.dth;
      if (dthCfg) {
        const color = this._getColorByColorMaterial(addattr, false);
        if (!Cesium__namespace.defined(color)) {
          addattr.color = nullColor;
        }
        addattr.classification = true;
        if (!Cesium__namespace.defined(this.style.height)) {
          addattr.perPositionHeight = false;
        }
        addattr.zIndex = 99;
      }

      return addattr
    }

    // 更新高度
    updateHeight(height) {
      const eRadis = 6378137;
      for (let i = 0, len = this.primitiveCollection.length; i < len; i++) {
        const primitive = this.primitiveCollection.get(i);

        const n = (eRadis + height) / (eRadis + this.style.height);
        const modelMatrix = Cesium__namespace.Matrix4.fromScale(new Cesium__namespace.Cartesian3(n, n, n));
        primitive.modelMatrix = modelMatrix;
      }
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PolygonStyleConver.toJSON(czmStyle, styleJson)
    }

    _getGeoJsonGeometry(options) {
      return { type: "Polygon", coordinates: [this.getCoordinates(options?.noAlt)] }
    }

    // 边线坐标数组，支持多个线 [线坐标集合]
    _getPolylineOutlinePositions() {
      if (this._hierarchy) {
        return getHierarchyVal(this._hierarchy)
      } else {
        return [this.positions]
      }
    }

    // 获取对应标绘时的Entity对象
   _getDrawEntityClass(options, isDraw) {
      return create$4("polygon", options)
    }

    _startEditingHook(graphic) {
      if (this._hierarchy) {
        graphic._hierarchy = this._hierarchy;
      }
    }
  }

  // 注册下
  register$4("polygonP", PolygonPrimitive);

  /**
   * 四棱锥体 支持的样式信息
   *
   * @typedef {Object} FrustumPrimitive.StyleOptions
   *
   * @property {Number} [angle] 四棱锥体张角（角度值，取值范围 0.01-89.99）
   * @property {Number} [angle2=angle] 四棱锥体张角2，（角度值，取值范围 0.01-89.99）
   *
   * @property {Number} [length = 100]   长度值（单位：米），没有指定targetPosition时有效
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度），没有指定targetPosition时有效
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度），没有指定targetPosition时有效
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度），没有指定targetPosition时有效
   *
   * @property {String} [materialType = "Color"] 填充材质类型 ,可选项：{@link MaterialType}
   * @property {Object} [materialOptions] materialType对应的{@link MaterialType}中材质参数
   * @property {Cesium.Material} [material] 指定用于填充的材质，指定material后`materialType`和`materialOptions`将被覆盖。
   *
   * @property {String|Cesium.Color} [color = "#00FF00"] 颜色
   * @property {Number} [opacity = 1.0] 透明度, 取值范围：0.0-1.0
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {Cesium.MaterialAppearance.MaterialSupportType} [materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] 将被支持的材质类型。
   *
   * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
   * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
   * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
   * @property {Boolean} [closed=true] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
   * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
   * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
   * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
   *
   *
   * @property {FrustumPrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelEntity.StyleOptions} [label] 支持附带文字的显示
   */

  /**
   * 四棱锥体  Primitive图元矢量对象
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   *  @param {LngLatPoint|Cesium.Cartesian3|Number[]} [options.targetPosition] 追踪的目标位置
   * @param {FrustumPrimitive.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class FrustumPrimitive
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class FrustumPrimitive extends BasePointPrimitive {
    constructor(options = {}) {
      super(options);

      this.style.closed = this.style.closed ?? true;

      if (options.targetPosition) {
        this.targetPosition = options.targetPosition;
      }
    }

    /**
     * 圆锥追踪的目标(确定了方向和距离)
     * @type {Cesium.Cartesian3|LngLatPoint}
     */
    get targetPosition() {
      return this._targetPosition
    }

    set targetPosition(value) {
      this._targetPoint = LngLatPoint.parse(value);
      this._targetPosition = this._targetPoint.toCartesian();

      if (this.isAdded && this.show) {
        this._removedHook();
        this._addedHook(this.style);
      }
    }

    /**
     * 圆锥追踪的目标位置坐标
     * @type {LngLatPoint}
     * @readonly
     */
    get targetPoint() {
      return this._targetPoint
    }

    /**
     * 夹角，半场角度，取值范围 0.01-89.99
     * @type {Number}
     */
    get angle() {
      return this.style.angle
    }

    set angle(val) {
      this.style.angle = val;
    }

    /**
     * 夹角2，半场角度，取值范围 0.01-89.99
     * @type {Number}
     */
    get angle2() {
      return this.style.angle2 ?? this.style.angle
    }

    set angle2(val) {
      this.style.angle2 = val;
    }

    /**
     * 求当前位置射线与地球相交点
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get groundPosition() {
      return getRayEarthPosition(this.position, this._orientation)
    }

    get defaultVertexFormat() {
      return Cesium__namespace.VertexFormat.POSITION_ONLY
    }

    updateModelMatrix() {} // 覆盖父类

    // 转换style
    _conversionStyle(style) {
      return CylinderStyleConver.toCesiumVal(style)
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return CylinderStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstance(addattr, outline) {
      this._update();

      const GeometryClass = outline ? Cesium__namespace.FrustumOutlineGeometry : Cesium__namespace.FrustumGeometry;

      return new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new GeometryClass({
          ...addattr,
          origin: this.position,
          orientation: this._orientation,
          frustum: this._frustum
        }),
        attributes: this.options.attributes
      })
    }

    _update(time) {
      const position = getPositionValue(this.position, time);
      if (!position) {
        this._cylinderPosition = undefined;
        return
      }
      const targetPosition = getPositionValue(this.targetPosition, time);
      if (targetPosition) {
        this._frustumFar = Cesium__namespace.Cartesian3.distance(position, targetPosition);
        const hpr = getHeadingPitchRollForLine(position, targetPosition);
        this.heading = Cesium__namespace.Math.toDegrees(hpr.heading);
        this.pitch = Cesium__namespace.Math.toDegrees(hpr.pitch);
        this.roll = Cesium__namespace.Math.toDegrees(hpr.roll);
        this._orientation = Cesium__namespace.Transforms.headingPitchRollQuaternion(position, hpr);
      } else {
        this._frustumFar = -this.style.length;

        const hpr = new Cesium__namespace.HeadingPitchRoll(
          Cesium__namespace.Math.toRadians(this.heading),
          Cesium__namespace.Math.toRadians(this.pitch),
          Cesium__namespace.Math.toRadians(this.roll)
        );
        this._orientation = Cesium__namespace.Transforms.headingPitchRollQuaternion(position, hpr);
      }

      this._frustum = new Cesium__namespace.PerspectiveFrustum({
        fov: Cesium__namespace.Math.toRadians(this.angle * 2 || 0.01), // 视场角
        aspectRatio: this.angle2 / this.angle, // 视锥的宽度与高度的纵横比。
        near: 0.01, // 近平面的距离。
        far: this._frustumFar // 远平面的距离。
      });
    }

    /**
     * 获取射线向地面与地球的4个交点坐标
     *
     * @param {Cesium.JulianDate} [time=Cesium.JulianDate.now()] 指定的时间值
     * @return {Cesium.Cartesian3[]} 坐标数组
     */
    getRayEarthPositions(time) {
      const position = getPositionValue(this.position, time);

      const heading = Cesium__namespace.Math.toRadians(this.heading);
      const pitch1 = Cesium__namespace.Math.toRadians(this.pitch + this.angle2);
      const pitch2 = Cesium__namespace.Math.toRadians(this.pitch - this.angle2);
      const roll1 = Cesium__namespace.Math.toRadians(this.roll + this.angle);
      const roll2 = Cesium__namespace.Math.toRadians(this.roll - this.angle);

      const pt1 = getRayEarthPosition(position, new Cesium__namespace.HeadingPitchRoll(heading, pitch1, roll1), true);
      const pt2 = getRayEarthPosition(position, new Cesium__namespace.HeadingPitchRoll(heading, pitch1, roll2), true);
      const pt3 = getRayEarthPosition(position, new Cesium__namespace.HeadingPitchRoll(heading, pitch2, roll2), true);
      const pt4 = getRayEarthPosition(position, new Cesium__namespace.HeadingPitchRoll(heading, pitch2, roll1), true);
      return [pt1, pt2, pt3, pt4]
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return this._getDrawPointEntityClass(options, isDraw)
    }
  }

  // 注册下
  register$4("frustum", FrustumPrimitive);

  var ConeGlowCircleOuterMaterial = "uniform vec4 u_color;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float time = fract(czm_frameNumber / 90.);\n  vec2 new_st = fract(st - vec2(time, time));\n  vec4 color = texture2D(image, new_st);\n\n  vec3 diffuse = color.rgb;\n  float alpha = color.a;\n  diffuse *= u_color.rgb;\n  alpha *= u_color.a;\n  alpha *= u_color.a;\n  material.diffuse = diffuse;\n  material.alpha = alpha * pow(1. - st.t, u_color.a) * globalAlpha;\n  return material;\n}\n"; // eslint-disable-line

  var ConeGlowCylinderGaussMaterial = "uniform vec4 u_color;\nuniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float powerRatio = 1. / (fract(czm_frameNumber / 30.0) + 1.);\n  float alpha = pow(1. - st.t, powerRatio);\n  vec4 color = vec4(u_color.rgb, alpha * u_color.a);\n  material.diffuse = color.rgb;\n  material.alpha = color.a * globalAlpha;\n  return material;\n}\n"; // eslint-disable-line

  var ConeGlowGradientMaterial = "uniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec4 tColor = u_color;\n  vec2 st = materialInput.st;\n  vec2 center = st - vec2(0.5, 0.5);\n  float length = length(center) / 0.5;\n  float time = 1. - abs(czm_frameNumber / 360. - 0.5);\n\n  float param = 1. - step(length, 0.6);//大于0.6模糊，rate = 0.6\n  float scale = param * length;// 0.6< length 返回0，反之返回1.\n  float alpha = param * (1.0 - abs(scale - 0.8) / 0.2);// 0.8 < length 返回0，反之返回1.\n\n  float param1 = step(length, 0.7);//小于0.5模糊\n  float scale1 = param1 * length;// 0.6< length 返回0，反之返回1.\n  alpha += param1 * (1.0 - abs(scale1 - 0.35) / 0.35);// 0.8 < length 返回0，反之返回1.\n\n  material.diffuse = u_color.rgb * vec3(u_color.a);\n  material.alpha = pow(alpha, 4.0) * globalAlpha;\n  return material;\n}\n"; // eslint-disable-line

  var ConeGlowRingScanMaterial = "uniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  vec2 center = st - vec2(0.5, 0.5);\n  float time = -czm_frameNumber * 3.1415926 / 180.;//扫描速度1度\n  float sin_t = sin(time);\n  float cos_t = cos(time);\n  vec2 center_rotate = vec2(center.s * cos_t - center.t * sin_t + 0.5, center.s * sin_t + center.t * cos_t + 0.5);\n  vec4 color = texture2D(image, center_rotate);\n  vec3 tColor = color.rgb * u_color.rgb;\n  tColor *= u_color.a;\n  material.diffuse = tColor;\n  float length = 2. - length(center) / 0.5;\n  material.alpha = color.a * pow(length, 0.5) * globalAlpha;//color.r = 0 或1\n  return material;\n}\n"; // eslint-disable-line

  const DEF_STYLE$d = {
    height: 1000,
    radius: 100,
    color: "#00ffff"
  };

  // 粒子图对象
  const particleImage = new Image();
  particleImage.src =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAEACAYAAADSoXR2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjExQTg0NDEyMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjExQTg0NDEzMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTFBODQ0MTAwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MTFBODQ0MTEwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz41vRwAAAAE90lEQVR42uydyW4UMRCG3T2dgYSAEGs4sp44cCJBcGUJbwCvALwWPAI8ABwAiUVwgLBdkEikJEiAGMhkZqhfU1aa1sy0g+yaJPyWSupOpPjz0uVyucrJer2eG2fJ3ZgLAQhAgC0PgN8XIlkqgGLE75oih0WmRVZEvop0rHog18rnRe6IzInsthyCXFt+TuSKyGmRXZZDgK5eFrkv8l7kiUhrxN/JSo3pigSvcNmI1bCh3b5LK2+NqHyvyEF9x3z5HgqRRViOAXhW5JrCoNdei/y20gMYxhmRSyIXRY6JTMT4DENLW+SdyD19x/NajDmwmYIW79Hnn+MA4GJEAAIQgABJbMJB+n5Sl9zWZvR9DABUfkJkVt8fi3zUldAEoKl24Y2S1fPZEmBdZFHkkb4vxTLRQ5djbyUf0ncYrD/UADUB8MZno2Q19yx7gIqIAAQgAAEIQIAtYZT+85LvRnjQCoPKR3rQUgN4Y3ZeK30g8qps0qeeAzDn4TWD9+ySG+BBS90DaGnVg9a2tgnR4il9/jkOACoiAhCAAASIZpAAFl6yulO0JACo/IDrn6CedP1zxOciv6wAYNnAP3RVBeWtJQCWzG8iL/X9g4vkqNzMctzUXtintt2KM/aS+bmQaY90rb8CF6tSKiICEIAABCAAAQiwbfcFIWVCbUcc9bZDLKiYAKj4uOv7Bb+ILLj+8W7PCgC7Jhzv44Qdh9yrru8V61jPgd645gD2io+15RiC5ZA5ENNPmGmDmtrta9YAVEQE2FlrQUM/J6efU8cSAD87ojodBaccS6kgiiErGiq/qe93XT+3oGU5BJnbyKrIUs6BQZoQUEcrQ7CYagiGqeKiMgnXLXsg5uJUm/RQJKy8fGS7PMw6SgVQPrJFGZr0kCfUL/7IFjIzrLGpemBQ0kPbehL6I9vMjUh6oEVEAAIQgAAEIAABdpyj0qcK71YrqGUJANNrv+sHOcAiRpDDM1cTY1BEHk7kqyP/2Ac5vLEEQEG8aDnIoTb5ObZRWg5ywG5o1dX4ClNYxT7IISgJPsXGpLut9MCWU0S5bqkmdAa3LQEwcZDAfkZ3tthQfkwNkVeeD6kiuaUabcp6DpS9YyalrAdQ8bT1EFQVUabarND9fNuyB2gREYAABCAAAQhAAAIQoM770UgBXARCIr/koDogVlzgrWuxemBKd0m4JnBed0+5ZQ9gn3BK5LK+P4y5ewoB8DFiKO91COLFfwVuTCZV1hSoYw1APZCsFIkbN1Haaa87wwiKQe6eT27AEX6esPVVd8/kOOdAz/oz9FE0p+uGIKUeqE5C8xgSKiICEIAABCAAAQhAAAIQgAAEIAABCECA6AA+sbkREyDUUYlKD6ggZwzRkr8tewBhusisv+0in5qE/hFchoZTE0TL4p8sTbtIpyahQ4Ag5fKpSVBmfdDECvQTZjoM0U9N6KgkwH9xY7PXpPiCmq5yuaLVldHIO7jgNi5XfOEhCqNh9udHV/RnC5YAUDTftdV4/ivvwEoRVS9XXPWa1FIT5ird8jpSB+BDN3rO8AaGMnGy0I0QRYTvdk6NkOsucuhGCMAgI8Q0isaHbmAevNMhiD4P6iZhstANGiQE2PEGCRo2NcgAsQDwKnxWFdlT17/duWU1BJmuHz6A5bwbEsCScgh+qAHit3Jr1oooOPExdRBLbeJjSpuwuy30AAH+CDAAPH5ltESNYl4AAAAASUVORK5CYII=";
  particleImage.onload = function () {
    // console.log('加载particleImage成功')
  };

  /**
   * 光锥体 支持的样式信息
   *
   * @typedef {Object} LightCone.StyleOptions
   *
   * @property {String|Cesium.Color} [color = '#00ffff'] 颜色
   * @property {Number} [radius = 100] 锥体底部半径。(单位：米)
   * @property {Number} [height = 1000] 锥体高度，相对于椭球面的高度。(单位：米)
   *
   */

  /**
   * 光锥体
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {LightCone.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class LightCone
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class LightCone extends BasePointPrimitive {
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$d,
        ...(options.style || {})
      };
      super(options);

      this._primitive1 = null; // 外圈
      this._primitive2 = null; // 内圈
      this._primitive3 = null; // 底部圆
      this._primitive4 = null; // 底部放大圆环
    }

    //= ========= 对外属性 ==========
    get czmObject() {
      return this._primitive1
    }

    // 文本等附加对象
    get czmObjectEx() {
      if (this._primitive2) {
        return [this._primitive2, this._primitive3, this._primitive4]
      } else {
        return []
      }
    }

    /**
     * 颜色
     * @type {Cesium.Color}
     */
    get color() {
      return this._color
    }

    set color(val) {
      this.style.color = val;
    }

    //= ========= 方法 ==========

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show || !this.position) {
        return
      }

      const radius = style.radius;

      // 计算其他参数
      this.topRadius = radius / 100.0;
      this.topRadius = this.topRadius > 1.0 ? 1.0 : this.topRadius;
      this.inner_controlPoints = getCirclePosition(this.position, radius * 0.7);
      this.outer_controlPoints = getCirclePosition(this.position, radius); // 计算底部外圈
      this.circular_clone_topPoints = getCirclePosition(this.position, this.topRadius); // 计算顶部
      this.circlePoints_2 = getCirclePosition(this.position, radius * 2); // 计算顶部

      this.ringCanvas = this.drawRingCanvas();
      this.gradientCircleCanvas = this.cirdrawGradientCircleCanvas();
      this.image = this.drawCanvas(particleImage);

      this._color = getColorByStyle(style);

      this.addInner(style); // 内圈
      this.addOuter(style); // 外圈
      this.addCircle(style); // 底部圆
      this.addRing(style); // 底部放大钰圆环
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this._primitive1) {
        this.primitiveCollection.remove(this._primitive1);
        delete this._primitive1;
      }
      if (this._primitive2) {
        this.primitiveCollection.remove(this._primitive2);
        delete this._primitive2;
      }
      if (this._primitive3) {
        this.primitiveCollection.remove(this._primitive3);
        delete this._primitive3;
      }
      if (this._primitive4) {
        this.primitiveCollection.remove(this._primitive4);
        delete this._primitive4;
      }
    }

    // 添加绘制内圈圆柱闪烁效果
    addInner(style) {
      const side_instances = createCylinderInstance(this.inner_controlPoints, this.circular_clone_topPoints, {
        height: style.height,
        color: this.color,
        distanceDisplayCondition: style.distanceDisplayCondition
      });
      const a = new Cesium__namespace.EllipsoidSurfaceAppearance({
        material: new Cesium__namespace.Material({
          fabric: {
            uniforms: {
              u_color: this._color,
              globalAlpha: 1.0
            },
            source: ConeGlowCylinderGaussMaterial
          },
          translucent: function (material) {
            return material.uniforms.u_color.alpha < 1.0
          }
        })
      });
      this._primitive1 = new Cesium__namespace.Primitive({
        geometryInstances: side_instances,
        appearance: a,
        asynchronous: false,
        show: this.show
      });
      this.primitiveCollection.add(this._primitive1);
    }

    // 添加绘制外圈粒子效果
    addOuter(style) {
      const side_instances = createCylinderInstance(this.outer_controlPoints, this.circular_clone_topPoints, {
        height: style.height,
        distanceDisplayCondition: style.distanceDisplayCondition,
        color: new Cesium__namespace.Color(0.5, 0.8, 1.0, 2)
      });
      this._primitive2 = new Cesium__namespace.Primitive({
        geometryInstances: side_instances,
        appearance: new Cesium__namespace.EllipsoidSurfaceAppearance({
          material: new Cesium__namespace.Material({
            fabric: {
              uniforms: {
                u_color: this._color,
                image: this.image,
                globalAlpha: 1.0
              },
              source: ConeGlowCircleOuterMaterial
            },
            translucent: true
          })
        }),
        asynchronous: false,
        show: this.show
      });
      this.primitiveCollection.add(this._primitive2);
    }

    // 绘制底部圆
    addCircle(style) {
      const carto = Cesium__namespace.Cartographic.fromCartesian(this.position);
      const instance = createCircleInstance(this.circlePoints_2, {
        perPositionHeight: carto.height >= 1,
        distanceDisplayCondition: style.distanceDisplayCondition
      });
      this._primitive3 = new Cesium__namespace.Primitive({
        geometryInstances: instance,
        appearance: new Cesium__namespace.EllipsoidSurfaceAppearance({
          material: new Cesium__namespace.Material({
            fabric: {
              uniforms: {
                u_color: this._color,
                image: this.gradientCircleCanvas,
                globalAlpha: 1.0
              },
              source: ConeGlowGradientMaterial
            },
            translucent: true
          })
        }),
        asynchronous: false,
        show: this.show
      });
      this.primitiveCollection.add(this._primitive3);
    }

    // 添加绘制底部扩散圆环
    addRing(style) {
      const instance = createCircleInstance(this.circlePoints_2, {
        perPositionHeight: this.point.alt >= 1,
        distanceDisplayCondition: style.distanceDisplayCondition
      });
      this._primitive4 = new Cesium__namespace.Primitive({
        geometryInstances: instance,
        appearance: new Cesium__namespace.EllipsoidSurfaceAppearance({
          material: new Cesium__namespace.Material({
            fabric: {
              uniforms: {
                u_color: this._color,
                image: this.ringCanvas,
                globalAlpha: 1.0
              },
              source: ConeGlowRingScanMaterial
            },
            translucent: true
          })
        }),
        asynchronous: false,
        show: this.show
      });
      this.primitiveCollection.add(this._primitive4);
    }

    //= ===============材质贴图Canvas ====================
    // 画粒子图
    getParticleImage(callback) {
      const image = new Image();
      image.src =
        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAEACAYAAADSoXR2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjExQTg0NDEyMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjExQTg0NDEzMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTFBODQ0MTAwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MTFBODQ0MTEwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz41vRwAAAAE90lEQVR42uydyW4UMRCG3T2dgYSAEGs4sp44cCJBcGUJbwCvALwWPAI8ABwAiUVwgLBdkEikJEiAGMhkZqhfU1aa1sy0g+yaJPyWSupOpPjz0uVyucrJer2eG2fJ3ZgLAQhAgC0PgN8XIlkqgGLE75oih0WmRVZEvop0rHog18rnRe6IzInsthyCXFt+TuSKyGmRXZZDgK5eFrkv8l7kiUhrxN/JSo3pigSvcNmI1bCh3b5LK2+NqHyvyEF9x3z5HgqRRViOAXhW5JrCoNdei/y20gMYxhmRSyIXRY6JTMT4DENLW+SdyD19x/NajDmwmYIW79Hnn+MA4GJEAAIQgABJbMJB+n5Sl9zWZvR9DABUfkJkVt8fi3zUldAEoKl24Y2S1fPZEmBdZFHkkb4vxTLRQ5djbyUf0ncYrD/UADUB8MZno2Q19yx7gIqIAAQgAAEIQIAtYZT+85LvRnjQCoPKR3rQUgN4Y3ZeK30g8qps0qeeAzDn4TWD9+ySG+BBS90DaGnVg9a2tgnR4il9/jkOACoiAhCAAASIZpAAFl6yulO0JACo/IDrn6CedP1zxOciv6wAYNnAP3RVBeWtJQCWzG8iL/X9g4vkqNzMctzUXtintt2KM/aS+bmQaY90rb8CF6tSKiICEIAABCAAAQiwbfcFIWVCbUcc9bZDLKiYAKj4uOv7Bb+ILLj+8W7PCgC7Jhzv44Qdh9yrru8V61jPgd645gD2io+15RiC5ZA5ENNPmGmDmtrta9YAVEQE2FlrQUM/J6efU8cSAD87ojodBaccS6kgiiErGiq/qe93XT+3oGU5BJnbyKrIUs6BQZoQUEcrQ7CYagiGqeKiMgnXLXsg5uJUm/RQJKy8fGS7PMw6SgVQPrJFGZr0kCfUL/7IFjIzrLGpemBQ0kPbehL6I9vMjUh6oEVEAAIQgAAEIAABdpyj0qcK71YrqGUJANNrv+sHOcAiRpDDM1cTY1BEHk7kqyP/2Ac5vLEEQEG8aDnIoTb5ObZRWg5ywG5o1dX4ClNYxT7IISgJPsXGpLut9MCWU0S5bqkmdAa3LQEwcZDAfkZ3tthQfkwNkVeeD6kiuaUabcp6DpS9YyalrAdQ8bT1EFQVUabarND9fNuyB2gREYAABCAAAQhAAAIQoM770UgBXARCIr/koDogVlzgrWuxemBKd0m4JnBed0+5ZQ9gn3BK5LK+P4y5ewoB8DFiKO91COLFfwVuTCZV1hSoYw1APZCsFIkbN1Haaa87wwiKQe6eT27AEX6esPVVd8/kOOdAz/oz9FE0p+uGIKUeqE5C8xgSKiICEIAABCAAAQhAAAIQgAAEIAABCECA6AA+sbkREyDUUYlKD6ggZwzRkr8tewBhusisv+0in5qE/hFchoZTE0TL4p8sTbtIpyahQ4Ag5fKpSVBmfdDECvQTZjoM0U9N6KgkwH9xY7PXpPiCmq5yuaLVldHIO7jgNi5XfOEhCqNh9udHV/RnC5YAUDTftdV4/ivvwEoRVS9XXPWa1FIT5ird8jpSB+BDN3rO8AaGMnGy0I0QRYTvdk6NkOsucuhGCMAgI8Q0isaHbmAevNMhiD4P6iZhstANGiQE2PEGCRo2NcgAsQDwKnxWFdlT17/duWU1BJmuHz6A5bwbEsCScgh+qAHit3Jr1oooOPExdRBLbeJjSpuwuy30AAH+CDAAPH5ltESNYl4AAAAASUVORK5CYII=";
      image.onload = function () {
        if (callback) {
          callback();
        }
      };
    }

    drawCanvas(image) {
      const canvas = document.createElement("canvas");
      canvas.width = 64;
      canvas.height = 256;
      const ctx = canvas.getContext("2d");

      ctx.clearRect(0, 0, 64, 256);
      ctx.drawImage(image, 0, 0);
      ctx.drawImage(image, 33, 0);
      return canvas
    }

    // 画圆环图
    drawRingCanvas() {
      const canvas = document.createElement("canvas");
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext("2d");

      // ctx.clearRect(0,0,512,512);
      ctx.fillStyle = "rgba(255,255,255,0)";
      ctx.strokeStyle = "rgba(255, 255, 255,255)";
      ctx.setLineDash([50, 50]);
      ctx.lineWidth = 30;
      ctx.beginPath();
      ctx.arc(256, 256, 150, 0, Math.PI * 2, true);
      ctx.stroke();
      ctx.restore();
      return canvas
    }

    // 画渐变圆
    cirdrawGradientCircleCanvas() {
      const canvas = document.createElement("canvas");
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext("2d");

      const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
      gradient.addColorStop(0.1, "rgba(255, 255, 255, 1.0)");
      gradient.addColorStop(0.2, "rgba(255, 255, 255, 0.0)");
      gradient.addColorStop(0.3, "rgba(255, 255, 255, 0.9)");
      gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.0)");
      gradient.addColorStop(0.9, "rgba(255, 255, 255, 0.2)");
      gradient.addColorStop(1.0, "rgba(255, 255, 255, 1.0)");

      ctx.clearRect(0, 0, 512, 512);
      ctx.beginPath();
      ctx.arc(256, 256, 256, 0, Math.PI * 2, true);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.restore();

      return canvas
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this.style.globalAlpha = value;
      if (this._primitive1) {
        this._primitive1.appearance.material.uniforms.globalAlpha = value; // 外圈
        this._primitive2.appearance.material.uniforms.globalAlpha = value; // 内圈
        this._primitive3.appearance.material.uniforms.globalAlpha = value; // 底部圆
        this._primitive4.appearance.material.uniforms.globalAlpha = value; // 底部放大圆环
      }
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return this._getDrawPointEntityClass(options, isDraw)
    }
  }
  // 注册下
  register$4("lightCone", LightCone);

  // 创建 圆 效果
  function createCircleInstance(pos, options) {
    const polygon = new Cesium__namespace.PolygonGeometry({
      polygonHierarchy: new Cesium__namespace.PolygonHierarchy(pos),
      perPositionHeight: options.perPositionHeight
    });
    return new Cesium__namespace.GeometryInstance({
      geometry: polygon,
      attributes: {
        distanceDisplayCondition: options.distanceDisplayCondition || new Cesium__namespace.DistanceDisplayConditionGeometryInstanceAttribute()
      }
    })
  }

  // 创建 圆锥柱体 效果
  function createCylinderInstance(pts, topPts, options) {
    const height = options.height;
    const color = options.color;

    const newpts = pts.slice();

    const length = pts.length;
    const len_2 = 2 * length;
    const sts = [];
    const st_interval = 1.0 / (length - 1);
    const define_indices = [];

    const ep = [];
    for (let i = 0; i < length; i++) {
      ep.push(addPositionsHeight(topPts[i], height));
      sts.push(i * st_interval);
      sts.push(0);

      const i_1 = i + 1;
      const i_11 = (i + 1) % length;
      const len_2_i_1 = len_2 - i_1;
      define_indices.push(...[len_2_i_1 - 1, len_2_i_1, i]); // 用materialAppearance贴纹理正确
      define_indices.push(...[i, i_11, len_2_i_1 - 1]);
    }

    for (let i = 0; i < ep.length; i++) {
      newpts.push(ep[length - i - 1]);

      sts.push(1 - i * st_interval);
      sts.push(1);
    }

    let polygon = new Cesium__namespace.PolygonGeometry({
      polygonHierarchy: new Cesium__namespace.PolygonHierarchy(newpts),
      perPositionHeight: true
    });
    polygon = Cesium__namespace.PolygonGeometry.createGeometry(polygon);
    polygon.indices = define_indices;
    polygon.attributes.st.values = sts;

    return new Cesium__namespace.GeometryInstance({
      geometry: polygon,
      attributes: {
        color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
        distanceDisplayCondition: options.distanceDisplayCondition || new Cesium__namespace.DistanceDisplayConditionGeometryInstanceAttribute()
      }
    })
  }

  // 计算圆坐标
  function getCirclePosition(center, radius, length = 120) {
    const res = [];
    const mm = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(center);

    const interval = (2 * Math.PI) / length;
    const startPos = (2 * Math.PI * 270) / 360;

    for (let i = 0; i < length; i++) {
      const a = startPos - interval * i;
      const p = new Cesium__namespace.Cartesian3(Math.sin(a) * radius, Math.cos(a) * radius, 0);
      res.push(Cesium__namespace.Matrix4.multiplyByPoint(mm, p, new Cesium__namespace.Cartesian3()));
    }
    res.push(res[0]);

    return res
  }

  var WaterFS = "varying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main() {\n  czm_materialInput materialInput;\n  vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n    #ifdef FACE_FORWARD\n  normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n  materialInput.s = v_st.s;\n  materialInput.st = v_st;\n  materialInput.str = vec3(v_st, 0.0);\n  materialInput.normalEC = normalEC;\n  materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\n  vec3 positionToEyeEC = -v_positionEC;\n  materialInput.positionToEyeEC = positionToEyeEC;\n  czm_material material = czm_getMaterial(materialInput);\n\n    #ifdef FLAT\n  gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n    #else\n  gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n    #endif\n}\n"; // eslint-disable-line

  /**
   * 水面   Primitive图元 支持的样式信息
   * @typedef {Object} Water.StyleOptions
   *
   * @property {String}  [baseWaterColor="#123e59"] 基础颜色
   * @property {String}  [blendColor="#123e59"] 从水中混合到非水域时使用的rgba颜色对象。
   * @property {String}  [specularMap] 单一通道纹理用来指示水域的面积。
   * @property {String}  [normalMap] 水正常扰动的法线图。
   * @property {Number}  [frequency=8000] 控制波数的数字。
   * @property {Number}  [animationSpeed=0.03] 控制水的动画速度的数字。
   * @property {Number}  [amplitude=5.0] 控制水波振幅的数字。
   * @property {Number}  [specularIntensity=0.8] 控制镜面反射强度的数字。
   * @property {Number}  [fadeFactor=1.0] fadeFactor
   * @property {Number} [opacity = 0.8] 透明度，取值范围：0.0-1.0
   * @property {Boolean} [clampToGround = false] 是否贴地
   *
   * @property {Number} [stRotation = 0] 多边形纹理的角度（弧度值），正北为0，逆时针旋转
   * @property {Number} [stRotationDegree = 0] 多边形纹理的角度（度数值，0-360度），与stRotation二选一
   *
   * @property {Boolean} [outline = false] 是否边框
   * @property {String|Cesium.Color} [outlineColor  = "#ffffff"] 边框颜色
   * @property {Number} [outlineOpacity = 0.6] 边框透明度
   *
   * @property {Number} [height = 0] 高程，圆相对于椭球面的高度。
   * @property {Number} [diffHeight = 100] 高度差（走廊本身的高度），与extrudedHeight二选一。
   * @property {number} [extrudedHeight] 指定走廊挤压面相对于椭球面的高度。
   *
   * @property {number} [granularity=Cesium.Math.RADIANS_PER_DEGREE]  指定每个纬度点和经度点之间的角距离。
   * @property {Boolean} [closeTop=true]  当为false时，离开一个挤压多边形的顶部打开。
   * @property {Boolean} [closeBottom=true]  当为false时，离开挤压多边形的底部打开。
   * @property {Cesium.ArcType} [arcType=Cesium.ArcType.GEODESIC]  多边形的边缘必须遵循的线条类型。
   *
   * @property {Boolean} [hasShadows = false] 是否阴影
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
   * @property {Cesium.ClassificationType} [classificationType=Cesium.ClassificationType.BOTH] 指定贴地时的覆盖类型，是只对地形、3dtiles 或 两者同时。
   *
   *
   * //以下是 这是MaterialAppearance的参数
   * @property {Boolean} [flat=false] 当true时，在片段着色器中使用平面着色，不考虑光照。
   * @property {Boolean} [faceForward=!closed] 当true时，片段着色器根据需要翻转表面的法线，以确保法线面向查看器以避免黑点。
   * @property {Boolean} [translucent=true] 当true时，几何图形将显示为半透明，因此{@link Cesium.PerInstanceColorAppearance#renderState}将启用alpha混合。
   * @property {Boolean} [closed=false] 当true时，几何图形将被关闭，因此{@link Cesium.PerInstanceColorAppearance#renderState}启用了背面剔除。
   * @property {String} [vertexShaderSource] 可选的GLSL顶点着色器源，覆盖默认的顶点着色器。
   * @property {String} [fragmentShaderSource] 可选的GLSL片段着色器源覆盖默认的片段着色器。
   * @property {Object} [renderState] 可选渲染状态，以覆盖默认渲染状态。
   *
   * @property {Number|Number[]} [setHeight] 指定坐标高度值，或数组指定每个点的高度（常用于图层中配置）
   * @property {Number|Number[]} [addHeight] 在现有坐标基础上增加的高度值，或数组指定每个点增加的高度（常用于图层中配置）
   *
   * @property {PolygonPrimitive.StyleOptions} [highlight] 鼠标移入或单击(type:'click')后的对应高亮的部分样式，创建Graphic后也可以openHighlight、closeHighlight方法来手动调用
   * @property {LabelPrimitive.StyleOptions|Object} [label] 支持附带文字的显示 ，额外支持：<br />
  //  * @property {String|LngLatPoint} [label.position] 文字所在位置，默认是矢量对象本身的center属性值。支持配置 'center'：围合面的内部中心点坐标，'{xxxx}'配置属性字段, 或者直接指定坐标值。
  //  * @property {Boolean} [label.showAll] MultiPolygon和MultiLineString时，是否显示所有注记，默认只在最大坐标数的面或线上显示。
   *
   * @see PolygonPrimitive.StyleOptions
   */

  /**
   * 水域面 Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标位置
   * @param {Water.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class Water
   * @extends {PolygonPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class Water extends PolygonPrimitive {
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show || !this.positions || this.positions.length === 0) {
        return
      }

      const addattr = this._conversionStyle(style);

      style.opacity = style.opacity ?? 0.8;
      const alpha = style.opacity * (style.globalAlpha ?? 1.0);

      const primitiveOpts = {
        geometryInstances: this._createGeometryInstance(addattr),
        appearance: new Cesium__namespace.EllipsoidSurfaceAppearance({
          aboveGround: false,
          material: new Cesium__namespace.Material({
            fabric: {
              type: "Water",
              uniforms: {
                specularMap: addattr.specularMap || Cesium__namespace.Material.DefaultImageId,
                normalMap: addattr.normalMap || Cesium__namespace.Material.DefaultImageId, // 水正常扰动的法线图。
                frequency: addattr.frequency || 8000.0, // 控制波数的数字。
                animationSpeed: addattr.animationSpeed || 0.03, // 控制水的动画速度的数字。
                amplitude: addattr.amplitude || 5.0, // 控制水波振幅的数字。
                specularIntensity: style.specularIntensity || 0.8, // 控制镜面反射强度的数字。
                baseWaterColor: getCesiumColor(style.baseWaterColor || "#123e59").withAlpha(style.opacity), // rgba颜色对象基础颜色的水。#00ffff,#00baff,#006ab4
                blendColor: getCesiumColor(style.blendColor || "#123e59").withAlpha(style.opacity) // 从水中混合到非水域时使用的rgba颜色对象。
              }
            }
          }),
          fragmentShaderSource: WaterFS,
          translucent: alpha !== 1.0
        }),
        show: this.show
      };

      if (style.clampToGround) {
        primitiveOpts.classificationType = style.classificationType ?? Cesium__namespace.ClassificationType.TERRAIN;
        this._primitive = this.primitiveCollection.add(new Cesium__namespace.GroundPrimitive(primitiveOpts));
      } else {
        this._primitive = this.primitiveCollection.add(new Cesium__namespace.Primitive(primitiveOpts));
      }

      // 同时加文字
      if (style.label) {
        this._addLabel();
      }
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      options.style.materialType = "Water";
      return create$4("polygon", options)
    }
  }
  // 注册下
  register$4("water", Water);

  var DiffuseWallGlowVS = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\nattribute float batchId;\nvarying vec2 v_st;\nvarying vec3 v_normalEC;\nvarying vec3 v_positionEC;\n\nvoid main() {\n  vec4 p = czm_translateRelativeToEye(position3DHigh, position3DLow);\n  v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n  v_normalEC = czm_normal * normal;\n  v_st = st;\n  gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"; // eslint-disable-line

  var DiffuseWallGlowFS = "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main() {\n  gl_FragColor = xh_getMaterial(v_st);\n}\n"; // eslint-disable-line

  const DEF_STYLE$c = {
    diffHeight: 1000,
    speed: 10,
    maxScale: 1
  };

  /**
   *  立体面(或圆)散射效果  支持的样式信息
   *
   * @typedef {Object} DiffuseWall.StyleOptions
   *
   * @property {Number} [diffHeight = 100] 墙高
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   * @property {Number} [speed = 10] 扩散的速度，值越大越快
   * @property {Number} [maxScale=1] 扩散的最大比例
   *
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
   *
   */

  /**
   * 立体面(或圆)散射效果 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} [options.positions] 坐标位置数组（多边形时）
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} [options.position] 坐标位置数组（圆形时），与positions二选一
   * @param {DiffuseWall.StyleOptions} [options.style] 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class DiffuseWall
   * @extends {BasePolyPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class DiffuseWall extends BasePolyPrimitive {
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$c,
        ...(options.style || {})
      };
      super(options);

      if (options.positions) {
        // 多边形时
        this.center = this.centerOfMass;
      } else if (options.position) {
        // 圆形时
        this.position = options.position;
        this._isCircle = true;
      }

      // 内部变量
      this._mScale = Cesium__namespace.Matrix4.fromUniformScale(1.0);
      this._maxScale = options.style.maxScale || 1;
    }

    //= ========= 对外属性 ==========
    get czmObject() {
      return this._primitive
    }

    // 中心点坐标，覆盖父类
    get center() {
      return this._center
    }

    set center(value) {
      this._center = value;
    }

    /**
     * 圆形时，位置坐标 （笛卡尔坐标）, 赋值时可以传入LatLngPoint对象
     * @type {Cesium.Cartesian3|LngLatPoint}
     */
    get position() {
      return this._center
    }

    set position(value) {
      this._center = LngLatPoint.parse(value).toCartesian();
      this._updatePositionsByCircleCenter();
    }

    /**
     *  圆形时，半径（单位：米）
     * @type {Number}
     */
    get radius() {
      return this.style.radius
    }

    set radius(val) {
      this.style.radius = val;
      this._updatePositionsByCircleCenter();
    }

    //= ========= 方法 ==========

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      const cps = this.positions;
      if (!this.show || !cps || cps.length === 0) {
        return
      }

      const up = addPositionsHeight(this.positions, style.diffHeight);

      this.center = this.centerOfMass;

      // 计算位置
      const pos = []; // 坐标
      const sts = []; // 纹理
      const indices = []; // 索引
      const normal = []; // 法向量
      for (let i = 0, count = cps.length; i < count; i++) {
        const ni = (i + 1) % count;
        pos.push(...[cps[i].x, cps[i].y, cps[i].z]);
        pos.push(...[cps[ni].x, cps[ni].y, cps[ni].z]);
        pos.push(...[up[ni].x, up[ni].y, up[ni].z]);
        pos.push(...[up[i].x, up[i].y, up[i].z]);

        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);

        sts.push(...[0, 0, 1, 0, 1, 1, 0, 1]); // 四个点的纹理一次存入

        const ii = i * 4;
        const i1 = ii + 1;
        const i2 = ii + 2;
        const i3 = ii + 3;
        indices.push(...[i2, i3, ii, ii, i1, i2]);
      }

      const positions = new Float64Array(pos);
      const gi = new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new Cesium__namespace.Geometry({
          attributes: {
            position: new Cesium__namespace.GeometryAttribute({
              // 使用double类型的position进行计算
              componentDatatype: Cesium__namespace.ComponentDatatype.DOUBLE,
              // componentDatatype: Cesium.ComponentDatatype.FLOAT,
              componentsPerAttribute: 3,
              values: positions
            }),
            normal: new Cesium__namespace.GeometryAttribute({
              componentDatatype: Cesium__namespace.ComponentDatatype.FLOAT,
              componentsPerAttribute: 3,
              values: new Float32Array(normal)
            }),
            st: new Cesium__namespace.GeometryAttribute({
              componentDatatype: Cesium__namespace.ComponentDatatype.FLOAT,
              componentsPerAttribute: 2,
              values: new Float32Array(sts)
            })
          },
          indices: new Uint16Array(indices),
          primitiveType: Cesium__namespace.PrimitiveType.TRIANGLES,
          boundingSphere: Cesium__namespace.BoundingSphere.fromVertices(positions)
        })
      });

      const color = getColorByStyle(style);

      this._primitive = new Cesium__namespace.Primitive({
        geometryInstances: gi,
        appearance: new Cesium__namespace.MaterialAppearance({
          material: new Cesium__namespace.Material({
            translucent: true,
            fabric: {
              uniforms: {
                color: color,
                globalAlpha: 1.0
              },
              source: `
              uniform vec4 color;
              uniform float globalAlpha;

              vec4 xh_getMaterial(vec2 st){
                float alpha = pow(1. - st.t, 1.5);
                vec4 colorNew = vec4(color.rgb * color.a, alpha*globalAlpha);
                return colorNew;
              }`
            }
          }),
          vertexShaderSource: DiffuseWallGlowVS,
          fragmentShaderSource: DiffuseWallGlowFS
        }),
        asynchronous: false,
        shadows: this.style.shadows,
        show: this.show
      });
      this.primitiveCollection.add(this._primitive);

      this.bindUpdateEvent();
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
        delete this._primitive;
      }
    }

    update(frameState) {
      if (this._primitive && this._show) {
        const time = (frameState.frameNumber / 1000.0) * this.style.speed;
        let tt = time - Math.floor(time);

        tt = tt < 0.01 ? 0.01 : tt;
        this._mScale[0] = this._mScale[5] = tt * this._maxScale;
        this._mScale[10] = 1.1 - tt;
        this._primitive.modelMatrix = scaleXYZ(this.center, this._mScale);
      }
    }

    _updatePositionsByCircleCenter() {
      this.positions = getEllipseOuterPositions({
        position: this._center,
        radius: this.style.radius ?? 100, // 半径
        count: this.style.count ?? 50 // 共返回(count*4)个点
      });
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      if (this._isCircle) {
        return create$4("circle", options)
      } else {
        options.style.closure = true;
        return create$4("wall", options)
      }
    }

    // 编辑中修改了半径等样式
    _updateStyleByEdit(newStyle) {
      if (this._isCircle && Cesium__namespace.defined(newStyle.radius)) {
        this.radius = newStyle.radius;
      }
      if (Cesium__namespace.defined(newStyle.diffHeight)) {
        this.style.diffHeight = newStyle.diffHeight;
      }
    }
  }
  // 注册下
  register$4("diffuseWall", DiffuseWall);

  function scaleXYZ(point, scale) {
    const m = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(point);
    const inverse = Cesium__namespace.Matrix4.inverse(m, new Cesium__namespace.Matrix4());

    const tt = Cesium__namespace.Matrix4.multiply(scale, inverse, new Cesium__namespace.Matrix4());
    return Cesium__namespace.Matrix4.multiply(m, tt, new Cesium__namespace.Matrix4())
  }

  var ScrollWallGlowVS = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\nattribute float batchId;\nvarying vec2 v_st;\nvarying vec3 v_normalEC;\nvarying vec3 v_positionEC;\n\nvoid main() {\n  vec4 p = czm_translateRelativeToEye(position3DHigh, position3DLow);\n  v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n  v_normalEC = czm_normal * normal;\n  v_st = st;\n  gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"; // eslint-disable-line

  var ScrollWallGlowFS = "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main() {\n  vec3 positionToEyeEC = -v_positionEC;\n  vec3 normalEC = normalize(v_normalEC);\n    #ifdef FACE_FORWARD\n  normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n\n  czm_materialInput materialInput;\n  materialInput.normalEC = normalEC;\n  materialInput.positionToEyeEC = positionToEyeEC;\n  materialInput.st = v_st;\n\n  czm_material material = czm_getMaterial(materialInput);\n  gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n}\n"; // eslint-disable-line

  var ScrollWallGlowMaterial = "uniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput cmi) {\n  czm_material material = czm_getDefaultMaterial(cmi);\n  vec2 st = cmi.st;\n  float t = fract(speed * czm_frameNumber / 1000.0) * direction;\n  vec2 st1 = vec2(st.s, fract(st.t - t));\n  vec4 color = vec4(0., 0., 0., 0.);\n  float tt = 0.5 - abs(0.5 - st1.t);\n  float ss = st1.s;\n  float alpha = tt * 2.;\n  color = vec4(u_color.rgb * u_color.a, alpha * 1.2);\n  material.diffuse = color.rgb;\n  material.alpha = color.a * globalAlpha;\n  return material;\n}\n"; // eslint-disable-line

  var ScrollWallGlowMaterial2 = "uniform float globalAlpha;\n\nczm_material czm_getMaterial(czm_materialInput cmi) {\n  czm_material material = czm_getDefaultMaterial(cmi);\n  vec2 st = cmi.st;\n  float t = fract(speed * czm_frameNumber / 1000.0) * direction;\n  vec2 st1 = vec2(fract(st.s - t), st.t);\n  vec4 color = vec4(0., 0., 0., 0.);\n  float alpha = 1. - st.t;\n  float value = fract(st1.s / 0.25);\n  alpha *= sin(value * 3.1415926);\n  color = vec4(u_color.rgb * u_color.a, alpha * 1.2);\n  material.diffuse = color.rgb;\n  material.alpha = color.a * globalAlpha;\n  return material;\n}\n"; // eslint-disable-line

  const DEF_STYLE$b = {
    diffHeight: 100,
    speed: 10,
    style: 1
  };

  /**
   *  走马灯围墙效果 支持的样式信息
   *
   * @typedef {Object} ScrollWall.StyleOptions
   *
   * @property {Number} [diffHeight = 100] 墙高
   * @property {String|Cesium.Color} [color = "#3388ff"] 颜色
   * @property {Number} [opacity = 1.0] 透明度，取值范围：0.0-1.0
   *
   * @property {Number} [speed = 10] 速度，值越大越快
   * @property {Boolean} [reverse = false] 方向：true往上、false往下
   * @property {Number} [style = 1] 样式，可选值：1、2
   *
   * @property {Cesium.ShadowMode} [shadows=Cesium.ShadowMode.DISABLED] 指定对象是投射还是接收来自光源的阴影。
   *
   */

  /**
   *  走马灯围墙效果 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标位置
   * @param {ScrollWall.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class ScrollWall
   * @extends {BasePolyPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class ScrollWall extends BasePolyPrimitive {
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$b,
        ...(options.style || {})
      };
      super(options);
    }

    get czmObject() {
      return this._primitive
    }

    //= ========= 方法 ==========
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      const cps = this.positions;
      if (!this.show || !cps || cps.length === 0) {
        return
      }

      const up = addPositionsHeight(cps, style.diffHeight);

      // 计算位置
      const pos = []; // 坐标
      const sts = []; // 纹理
      const indices = []; // 索引
      const normal = []; // 法向量

      for (let i = 0, len = cps.length; i < len; i++) {
        let ni = i + 1;
        if (ni === len) {
          ni = 0;
        }

        pos.push(...[cps[i].x, cps[i].y, cps[i].z]);
        pos.push(...[cps[ni].x, cps[ni].y, cps[ni].z]);
        pos.push(...[up[ni].x, up[ni].y, up[ni].z]);
        pos.push(...[up[i].x, up[i].y, up[i].z]);

        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);

        sts.push(...[0, 0, 1, 0, 1, 1, 0, 1]); // 四个点的纹理一次存入

        const ii = i * 4;
        const i1 = ii + 1;
        const i2 = ii + 2;
        const i3 = ii + 3;
        indices.push(...[ii, i1, i2, i2, i3, ii]);
      }

      const positions = new Float64Array(pos);
      const gi = new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: new Cesium__namespace.Geometry({
          attributes: {
            position: new Cesium__namespace.GeometryAttribute({
              // 使用double类型的position进行计算
              componentDatatype: Cesium__namespace.ComponentDatatype.DOUBLE,
              // componentDatatype: Cesium.ComponentDatatype.FLOAT,
              componentsPerAttribute: 3,
              values: positions
            }),
            normal: new Cesium__namespace.GeometryAttribute({
              componentDatatype: Cesium__namespace.ComponentDatatype.FLOAT,
              componentsPerAttribute: 3,
              values: new Float32Array(normal)
            }),
            st: new Cesium__namespace.GeometryAttribute({
              componentDatatype: Cesium__namespace.ComponentDatatype.FLOAT,
              componentsPerAttribute: 2,
              values: new Float32Array(sts)
            })
          },
          indices: new Uint16Array(indices),
          primitiveType: Cesium__namespace.PrimitiveType.TRIANGLES,
          boundingSphere: Cesium__namespace.BoundingSphere.fromVertices(positions)
        })
      });
      const color = getColorByStyle(style);
      const translucent = true; // color.alpha < 1 //透明时打开透明度

      this._primitive = new Cesium__namespace.Primitive({
        geometryInstances: gi,
        appearance: new Cesium__namespace.MaterialAppearance({
          material: new Cesium__namespace.Material({
            translucent: translucent,
            fabric: {
              uniforms: {
                u_color: color,
                speed: style.speed,
                direction: style.reverse ? 1 : -1,
                globalAlpha: 1.0
              },
              source: this.createShader()
            }
          }),
          vertexShaderSource: ScrollWallGlowVS,
          fragmentShaderSource: ScrollWallGlowFS
        }),
        asynchronous: false,
        shadows: style.shadows,
        show: this.show
      });

      this.primitiveCollection.add(this._primitive);
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
        delete this._primitive;
      }
    }

    createShader() {
      if (this.style.style === 1) {
        return ScrollWallGlowMaterial
      } else {
        return ScrollWallGlowMaterial2
      }
    }

    // 获取对应标绘时的Entity对象
   _getDrawEntityClass(options, isDraw) {
      options.style.closure = true;
      return create$4("wall", options)
    }
  }
  // 注册下
  register$4("scrollWall", ScrollWall);

  var DynamicRiverFS = "varying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main() {\n  czm_materialInput materialInput;\n\n  vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n    #ifdef FACE_FORWARD\n  normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n\n  materialInput.s = v_st.s;\n  materialInput.st = v_st;\n  materialInput.str = vec3(v_st, 0.0);\n\n    // Convert tangent space material normal to eye space\n  materialInput.normalEC = normalEC;\n  materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\n    // Convert view vector to world space\n  vec3 positionToEyeEC = -v_positionEC;\n  materialInput.positionToEyeEC = positionToEyeEC;\n\n  czm_material material = czm_getMaterial(materialInput);\n\n    #ifdef FLAT\n  gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n    #else\n  gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n    #endif\n}\n"; // eslint-disable-line

  var DynamicRiverVS = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main() {\n  vec4 p = czm_computePosition();\n\n  v_positionMC = position3DHigh + position3DLow;           // position in model coordinates\n  v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates\n  v_st = st;\n\n  gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"; // eslint-disable-line

  var DynamicRiverMaterial = "uniform float globalAlpha;\nuniform float opacity;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  if(move) {\n    float r = sqrt((st.x - 0.8) * (st.x - 0.8) + (st.y - 0.8) * (st.y - 0.8));\n    float r2 = sqrt((st.x - 0.2) * (st.x - 0.2) + (st.y - 0.2) * (st.y - 0.2));\n    float z = cos(moveVar.x * r + czm_frameNumber / 100.0 * moveVar.y) / moveVar.z;\n    float z2 = cos(moveVar.x * r2 + czm_frameNumber / 100.0 * moveVar.y) / moveVar.z;\n    st += sqrt(z * z + z2 * z2);\n    st.s += direction * czm_frameNumber / 1000.0 * speed;\n    st.s = mod(st.s, 1.0);\n  }\n  if(axisY) {\n    st = vec2(st.t, st.s);\n  }\n  vec4 colorImage = texture2D(image, st);\n  material.alpha = opacity * globalAlpha;\n  material.diffuse = colorImage.rgb;\n  return material;\n}\n"; // eslint-disable-line

  const DEF_STYLE$a = {
    opacity: 0.5, // 透明度
    width: 10.0, // 宽度(单位：米)
    height: 0.0, // 海拔高数值(单位：米)
    speed: 10.0, // 流动速度

    axisY: false, // uv交换（图片横竖切换）
    move: true, // 是否开启流动效果
    direction: true, // 设置流动方向
    moveVar: new Cesium__namespace.Cartesian3(50, 1, 100) // 流动动画参数，不建议调整该参数
  };

  /**
   * 动态河流 支持的样式信息
   *
   * @typedef {Object} DynamicRiver.StyleOptions
   *
   * @property {String} image 图片材质URL
   * @property {Number} [opacity = 0.5] 透明度，取值范围：0.0-1.0
   * @property {Number} [width = 20] 河流宽度。(单位：米)
   * @property {Number} [height = 0] 海拔高度，相对于椭球面的高度。(单位：米)
   * @property {Number} [speed = 10] 流动速度，值越大越快
   *
   * @property {Boolean} [axisY = false] 是否uv交换（图片横竖切换）
   * @property {Boolean} [move = true] 是否开启流动效果
   * @property {Boolean} [direction = true] 设置流动方向
   *
   */

  /**
   * 动态河流 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标位置
   * @param {DynamicRiver.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class DynamicRiver
   * @extends {BasePolyPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class DynamicRiver extends BasePolyPrimitive {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$a,
        ...(options.style || {})
      };
      super(options);
    }

    //= ========= 对外属性 ==========
    get czmObject() {
      return this._primitive
    }

    /**
     * 图片材质URL
     * @type {String}
     */
    get image() {
      return this.style.image
    }

    set image(str) {
      this.style.image = str;
      this._material.uniforms.image = str;
    }

    /**
     * 宽度 (单位：米)
     * @type {Number}
     */
    get width() {
      return this.style.width
    }

    set width(val) {
      val = Number(val) || 1;
      this.style.width = val;
      this.redraw(this.style);
    }

    /**
     * 海拔高度，相对于椭球面的高度。(单位：米)
     * @type {Number}
     */
    get height() {
      return this.style.height
    }

    set height(val) {
      this.style.height = val;
      this.redraw(this.style);
    }

    /**
     * 透明度 0.0-1.0
     * @type {Number}
     */
    get opacity() {
      return this.style.opacity
    }

    set opacity(val) {
      this.style.opacity = Number(val);
      this._material.uniforms.opacity = val;
    }

    /**
     * 设置流动方向
     * @type {Boolean}
     */
    get direction() {
      return this.style.direction
    }

    set direction(val) {
      val = Boolean(val);
      this.style.direction = val;
      this._material.uniforms.direction = val ? -1 : 1;
    }

    /**
     * 流动速度
     * @type {Number}
     */
    get speed() {
      return this.style.speed
    }

    set speed(val) {
      val = Number(val) || 1;
      this.style.speed = val;
      this._material.uniforms.speed = val;
    }

    /**
     * 是否开启流动效果
     * @type {Boolean}
     */
    get move() {
      return this.style.move
    }

    set move(val) {
      val = Boolean(val);
      this.style.move = val;
      this._material.uniforms.move = val;
    }

    /**
     * 是否uv交换（图片横竖切换）
     * @type {Boolean}
     */
    get axisY() {
      return this.style.axisY
    }

    set axisY(val) {
      val = Boolean(val);
      this.style.axisY = val;
      this._material.uniforms.axisY = val;
    }

    // 流动动画参数，不建议调整该参数
    get moveVar() {
      return this.style.moveVar
    }

    set moveVar(val) {
      this.style.moveVar = val;
      this._material.uniforms.moveVar = val;
    }

    //= ========= 方法 ==========

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show || !this.positions || this.positions.length === 0) {
        return
      }

      this._sideRes = Lines2Plane(this.positions, this.width, this.height);
      if (!this._sideRes) {
        return
      }

      this._primitive = this.createPrimitive();
      this.primitiveCollection.add(this._primitive);
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this.dhEvent) {
        this._map.off(EventType.clockTick, this.dhEvent, this);
        delete this.dhEvent;
      }

      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
        delete this._primitive;
      }

      if (this._material) {
        this._material.destroy();
        delete this._material;
      }
    }

    _updateStyleHook(style, newStyle) {
      let hasReDraw = false;

      for (const key in newStyle) {
        switch (key) {
          case "image":
          case "opacity":
          case "moveVar":
          case "direction":
          case "speed":
          case "axisY":
          case "globalAlpha":
            this._material.uniforms[key] = newStyle[key];
            break
          default:
            hasReDraw = true;
            break
        }
      }

      if (hasReDraw) {
        this.redraw(style);
      }
    }

    createPrimitive() {
      // 创建图元
      const sides = this._sideRes;
      const positions = new Float64Array(sides.vertexs);
      const attributes = new Cesium__namespace.GeometryAttributes();
      attributes.position = new Cesium__namespace.GeometryAttribute({
        componentDatatype: Cesium__namespace.ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: positions
      });
      attributes.st = new Cesium__namespace.GeometryAttribute({
        componentDatatype: Cesium__namespace.ComponentDatatype.FLOAT,
        componentsPerAttribute: 2,
        values: sides.uvs
      });
      const geometry = new Cesium__namespace.Geometry({
        attributes: attributes,
        indices: sides.indexs,
        primitiveType: Cesium__namespace.PrimitiveType.TRIANGLES,
        boundingSphere: Cesium__namespace.BoundingSphere.fromVertices(positions)
      });

      const instance = new Cesium__namespace.GeometryInstance({
        id: this.id,
        geometry: geometry
      });
      const renderState = new Cesium__namespace.RenderState();
      renderState.depthTest.enabled = true;

      this._material = createMaterial(MaterialType, {
        image: this.image,
        opacity: this.opacity,
        moveVar: this.moveVar,
        direction: this.direction ? -1 : 1,
        speed: this.speed,
        move: this.move,
        axisY: this.axisY,
        globalAlpha: 1.0
      });

      const primitive = new Cesium__namespace.Primitive({
        geometryInstances: instance,
        appearance: new Cesium__namespace.Appearance({
          material: this._material,
          renderState: renderState,
          vertexShaderSource: DynamicRiverVS,
          fragmentShaderSource: DynamicRiverFS // czm_lightDirectionEC在cesium1.66开始加入的
        })
      });
      return primitive
    }

    /**
     * 执行升高或降低高度的动画效果
     *
     * @param {Number} height 升高或降低的相对高度（单位：米），负数代表降低
     * @param {Number} time  动画时长（单位：秒）
     * @return {void}  无
     */
    offsetHeight(height, time) {
      if (!height || !time || !this._primitive) {
        return
      }

      let currH = 0;
      const avgF = 20; // 平均每帧20毫秒，即每秒50帧；
      const avgH = height / (time * avgF);

      const selfV = this._sideRes.self;
      const totalN = new Cesium__namespace.Cartesian3();
      for (let i = 0, len = selfV.length; i < len; i++) {
        // 求平均的法线
        const currN = Cesium__namespace.Cartesian3.normalize(selfV[i], new Cesium__namespace.Cartesian3());
        Cesium__namespace.Cartesian3.add(totalN, currN, totalN);
      }
      Cesium__namespace.Cartesian3.normalize(totalN, totalN);

      const initM = Cesium__namespace.clone(this._primitive.modelMatrix);

      this.dhEvent = function () {
        if (!this._primitive || !this._map) {
          return
        }
        if (Math.abs(currH) <= Math.abs(height)) {
          // 可以升高，可以降低，height可以为负值
          const currNor = Cesium__namespace.Cartesian3.multiplyByScalar(totalN, currH, new Cesium__namespace.Cartesian3());
          this._primitive.modelMatrix = Cesium__namespace.Matrix4.multiplyByTranslation(initM, currNor, new Cesium__namespace.Matrix4());
        } else {
          if (this.dhEvent) {
            this._map.off(EventType.clockTick, this.dhEvent, this);
            delete this.dhEvent;
          }
        }
        currH += avgH;
      };
      this._map.on(EventType.clockTick, this.dhEvent, this);
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this.style.globalAlpha = value;
      if (this._material) {
        this._material.uniforms.globalAlpha = value;
      }
    }

    // 获取对应标绘时的Entity对象
   _getDrawEntityClass(options, isDraw) {
      options.style.width = 5;
      return create$4("polyline", options)
    }
  }
  // 注册下
  register$4("dynamicRiver", DynamicRiver);

  const MaterialType = "DynamicRiver";
  register$3(MaterialType, {
    fabric: {
      uniforms: {
        image: Cesium__namespace.Material.DefaultImageId,
        opacity: 1,
        moveVar: new Cesium__namespace.Cartesian3(50, 1, 100),
        direction: 1,
        speed: 1,
        move: true,
        axisY: false,
        globalAlpha: 1.0
      },
      source: DynamicRiverMaterial
    },
    translucent: true
  });

  function Lines2Plane(lineArr, width, height) {
    if (!lineArr || lineArr.length <= 1 || !width || width === 0) {
      logError("请确认参数符合规则：数组长度大于1，宽高不能为0！", lineArr);
      return
    }
    const len = lineArr.length;
    const leftPots = [];
    const rightPots = [];
    const halfW = width / 2.0;
    for (let i = 0; i < len; i++) {
      let prevP;
      let currP;
      let nextP;
      let leftPot;
      let rightPot;
      if (i === 0) {
        prevP = lineArr[i];
        currP = lineArr[i];
        nextP = lineArr[i + 1];
      } else if (i === len - 1) {
        prevP = lineArr[i - 1];
        currP = lineArr[i];
        nextP = lineArr[i - 1];
      } else {
        prevP = lineArr[i - 1];
        currP = lineArr[i];
        nextP = lineArr[i + 1];
      }

      if (height !== 0) {
        prevP = RaisePoint(prevP, height);
        currP = RaisePoint(currP, height);
        nextP = RaisePoint(nextP, height);
      }

      if (prevP && currP && nextP) {
        const sides = GetSide2(prevP, currP, nextP, halfW);
        leftPot = sides.left;
        rightPot = sides.right;

        leftPots.push(rightPot);
        rightPots.push(leftPot);
      }
    }

    const leftPotsRes = leftPots;
    const rightPotsRes = rightPots;
    const uvs = [];
    const vertexs = [];
    const vertexsH = [];
    const vertexsL = [];
    const indexs = [];

    // 先记录右边点，后记录左边点、记录2遍为了分离UV
    for (let i = 0; i < len; i++) {
      const encodeRes = Cesium__namespace.EncodedCartesian3.fromCartesian(rightPotsRes[i]);
      vertexs.push(rightPotsRes[i].x);
      vertexs.push(rightPotsRes[i].y);
      vertexs.push(rightPotsRes[i].z);

      vertexsH.push(encodeRes.high.x);
      vertexsH.push(encodeRes.high.y);
      vertexsH.push(encodeRes.high.z);

      vertexsL.push(encodeRes.low.x);
      vertexsL.push(encodeRes.low.y);
      vertexsL.push(encodeRes.low.z);

      uvs.push(1, 1);

      // 记录索引以及UV
      if (i < len - 1) {
        indexs.push(i + len * 2);
        indexs.push(i + 1);
        indexs.push(i + 1 + len);

        indexs.push(i + len * 2);
        indexs.push(i + 1 + len);
        indexs.push(len + i + len * 2);
      }
    }
    for (let i = 0; i < len; i++) {
      const encodeRes = Cesium__namespace.EncodedCartesian3.fromCartesian(leftPotsRes[i]);
      vertexs.push(leftPotsRes[i].x);
      vertexs.push(leftPotsRes[i].y);
      vertexs.push(leftPotsRes[i].z);

      vertexsH.push(encodeRes.high.x);
      vertexsH.push(encodeRes.high.y);
      vertexsH.push(encodeRes.high.z);

      vertexsL.push(encodeRes.low.x);
      vertexsL.push(encodeRes.low.y);
      vertexsL.push(encodeRes.low.z);

      uvs.push(1, 0);
    }

    for (let i = 0; i < len; i++) {
      const encodeRes = Cesium__namespace.EncodedCartesian3.fromCartesian(rightPotsRes[i]);
      vertexs.push(rightPotsRes[i].x);
      vertexs.push(rightPotsRes[i].y);
      vertexs.push(rightPotsRes[i].z);

      vertexsH.push(encodeRes.high.x);
      vertexsH.push(encodeRes.high.y);
      vertexsH.push(encodeRes.high.z);

      vertexsL.push(encodeRes.low.x);
      vertexsL.push(encodeRes.low.y);
      vertexsL.push(encodeRes.low.z);

      uvs.push(0, 1);
    }
    for (let i = 0; i < len; i++) {
      const encodeRes = Cesium__namespace.EncodedCartesian3.fromCartesian(leftPotsRes[i]);
      vertexs.push(leftPotsRes[i].x);
      vertexs.push(leftPotsRes[i].y);
      vertexs.push(leftPotsRes[i].z);

      vertexsH.push(encodeRes.high.x);
      vertexsH.push(encodeRes.high.y);
      vertexsH.push(encodeRes.high.z);

      vertexsL.push(encodeRes.low.x);
      vertexsL.push(encodeRes.low.y);
      vertexsL.push(encodeRes.low.z);

      uvs.push(0, 0);
    }

    return {
      left: leftPotsRes,
      right: rightPotsRes,
      self: lineArr,
      vertexs: new Float32Array(vertexs),
      vertexsH: new Float32Array(vertexsH),
      vertexsL: new Float32Array(vertexsL),
      indexs: new Uint16Array(indexs),
      uvs: new Float32Array(uvs)
    }
  }

  function RaisePoint(pot, height) {
    if (!(pot instanceof Cesium__namespace.Cartesian3)) {
      logError("请确认点是Cartesian3类型！");
      return
    }
    if (!height || height === 0) {
      logError("请确认高度是非零数值！");
      return
    }
    const dir = Cesium__namespace.Cartesian3.normalize(pot, new Cesium__namespace.Cartesian3());
    const ray = new Cesium__namespace.Ray(pot, dir);
    return Cesium__namespace.Ray.getPoint(ray, height)
  }

  function GetSide2(prevP, currP, nextP, halfW) {
    let leftPot, rightPot;
    if (Cesium__namespace.Cartesian3.equals(prevP, currP)) {
      const dir = Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(nextP, currP, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3());
      const nor = Cesium__namespace.Cartesian3.normalize(currP, new Cesium__namespace.Cartesian3());
      const leftDir = Cesium__namespace.Cartesian3.cross(nor, dir, new Cesium__namespace.Cartesian3());
      const rightDir = Cesium__namespace.Cartesian3.cross(dir, nor, new Cesium__namespace.Cartesian3());
      const leftray = new Cesium__namespace.Ray(currP, leftDir);
      const rightray = new Cesium__namespace.Ray(currP, rightDir);
      leftPot = Cesium__namespace.Ray.getPoint(leftray, halfW);
      rightPot = Cesium__namespace.Ray.getPoint(rightray, halfW);
    } else if (Cesium__namespace.Cartesian3.equals(nextP, currP)) {
      const dir = Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(currP, prevP, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3());
      const nor = Cesium__namespace.Cartesian3.normalize(currP, new Cesium__namespace.Cartesian3());
      const leftDir = Cesium__namespace.Cartesian3.cross(nor, dir, new Cesium__namespace.Cartesian3());
      const rightDir = Cesium__namespace.Cartesian3.cross(dir, nor, new Cesium__namespace.Cartesian3());
      const leftray = new Cesium__namespace.Ray(currP, leftDir);
      const rightray = new Cesium__namespace.Ray(currP, rightDir);
      leftPot = Cesium__namespace.Ray.getPoint(leftray, halfW);
      rightPot = Cesium__namespace.Ray.getPoint(rightray, halfW);
    } else {
      const prevDir = Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(currP, prevP, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3());
      const nextDir = Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(nextP, currP, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3());
      const avgDir = Cesium__namespace.Cartesian3.add(prevDir, nextDir, new Cesium__namespace.Cartesian3());
      if (Cesium__namespace.Cartesian3.equals(avgDir, new Cesium__namespace.Cartesian3())) {
        const dir = Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(currP, prevP, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3());
        const nor = Cesium__namespace.Cartesian3.normalize(currP, new Cesium__namespace.Cartesian3());
        const leftDir = Cesium__namespace.Cartesian3.cross(nor, dir, new Cesium__namespace.Cartesian3());
        const rightDir = Cesium__namespace.Cartesian3.cross(dir, nor, new Cesium__namespace.Cartesian3());
        const leftray = new Cesium__namespace.Ray(currP, leftDir);
        const rightray = new Cesium__namespace.Ray(currP, rightDir);
        leftPot = Cesium__namespace.Ray.getPoint(leftray, halfW);
        rightPot = Cesium__namespace.Ray.getPoint(rightray, halfW);
      } else {
        const avgDir_nor = Cesium__namespace.Cartesian3.normalize(avgDir, new Cesium__namespace.Cartesian3());
        const nor = Cesium__namespace.Cartesian3.normalize(currP, new Cesium__namespace.Cartesian3());
        const leftDir = Cesium__namespace.Cartesian3.cross(nor, avgDir_nor, new Cesium__namespace.Cartesian3());
        const rightDir = Cesium__namespace.Cartesian3.cross(avgDir_nor, nor, new Cesium__namespace.Cartesian3());
        const leftray = new Cesium__namespace.Ray(currP, leftDir);
        const rightray = new Cesium__namespace.Ray(currP, rightDir);

        const dirAng_dot = Cesium__namespace.Cartesian3.dot(prevDir, nextDir);
        const mo_prev = Cesium__namespace.Cartesian3.magnitude(prevDir);
        const mo_next = Cesium__namespace.Cartesian3.magnitude(nextDir);
        const dirAng_cos = dirAng_dot / mo_prev / mo_next;
        const dirAng_deg = Cesium__namespace.Math.toDegrees(Math.acos(dirAng_cos));
        const halfAng_deg = dirAng_deg / 2;
        // console.log(dirAng_deg)
        const halfAng_cos = Math.cos(Cesium__namespace.Math.toRadians(halfAng_deg));
        const disMid = (halfW * 2.0) / halfAng_cos;
        leftPot = Cesium__namespace.Ray.getPoint(leftray, disMid / 2);
        rightPot = Cesium__namespace.Ray.getPoint(rightray, disMid / 2);
      }
    }

    return {
      left: leftPot,
      right: rightPot
    }
  }

  const DEF_STYLE$9 = {
    opacity: 1, // 透明度
    move: false, // 是否开启流动效果
    axisY: true // uv交换（图片横竖切换）
  };

  /**
   * 道路 支持的样式信息
   *
   * @typedef {Object} Road.StyleOptions
   *
   * @property {String} image 图片材质URL
   * @property {Number} [width = 20] 道路 宽度。(单位：米)
   * @property {Number} [height = 0] 道路 高度，相对于椭球面的高度。(单位：米)
   *
   * @property {Boolean} [axisY = true] 是否uv交换（图片横竖切换）
   *
   */

  /**
   * 道路  矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标位置
   * @param {Road.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class Road
   * @extends {DynamicRiver}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class Road extends DynamicRiver {
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$9,
        ...(options.style || {})
      };
      super(options);
    }
  }

  // 注册下
  register$4("road", Road);

  class PitWallGeometry {
    constructor(options = {}) {
      const min = options.minimumArr;
      const max = options.maximumArr;
      Cesium__namespace.Check.defined("dingmian", max);
      Cesium__namespace.Check.defined("dimianmian", min);

      Cesium__namespace.Check.typeOf.number.greaterThanOrEquals("dingmian.length", max.length, 3);
      Cesium__namespace.Check.typeOf.number.greaterThanOrEquals("dimian.length", min.length, 3);

      const vertexFormat = new Cesium__namespace.VertexFormat({
        st: true,
        position: true,
        bitangent: false,
        normal: false,
        color: false,
        tangent: false
      });

      this._minimumArr = Cesium__namespace.clone(min);
      this._maximumArr = Cesium__namespace.clone(max);
      this._vertexFormat = vertexFormat;
      this._workerName = "";
    }

    createGeometry(PitWallGeometry, topHeights, bottomHeight, maxHeight = 0) {
      const min = PitWallGeometry._minimumArr;
      const max = PitWallGeometry._maximumArr;
      const vertexFormat = PitWallGeometry._vertexFormat;

      const attributes = new Cesium__namespace.GeometryAttributes();
      let indices;
      let positions;
      let min_pos, max_pos;
      if (Cesium__namespace.defined(vertexFormat.position) && Cesium__namespace.defined(vertexFormat.st)) {
        if (Cesium__namespace.defined(vertexFormat.position)) {
          // 8 corner points.  Duplicated 3 times each for each incident edge/face.
          positions = new Float64Array(max.length * 4 * 3);

          for (let i = 0; i < max.length; i++) {
            if (i === max.length - 1) {
              positions[i * 12 + 0] = max[i].x;
              positions[i * 12 + 1] = max[i].y;
              positions[i * 12 + 2] = max[i].z;

              positions[i * 12 + 3] = min[i].x;
              positions[i * 12 + 4] = min[i].y;
              positions[i * 12 + 5] = min[i].z;

              positions[i * 12 + 9] = min[0].x;
              positions[i * 12 + 10] = min[0].y;
              positions[i * 12 + 11] = min[0].z;

              positions[i * 12 + 6] = max[0].x;
              positions[i * 12 + 7] = max[0].y;
              positions[i * 12 + 8] = max[0].z;
            } else {
              positions[i * 12 + 0] = max[i].x;
              positions[i * 12 + 1] = max[i].y;
              positions[i * 12 + 2] = max[i].z;

              positions[i * 12 + 3] = min[i].x;
              positions[i * 12 + 4] = min[i].y;
              positions[i * 12 + 5] = min[i].z;

              positions[i * 12 + 9] = min[i + 1].x;
              positions[i * 12 + 10] = min[i + 1].y;
              positions[i * 12 + 11] = min[i + 1].z;

              positions[i * 12 + 6] = max[i + 1].x;
              positions[i * 12 + 7] = max[i + 1].y;
              positions[i * 12 + 8] = max[i + 1].z;
            }
          }

          attributes.position = new Cesium__namespace.GeometryAttribute({
            componentDatatype: Cesium__namespace.ComponentDatatype.DOUBLE,
            componentsPerAttribute: 3,
            values: positions
          });
        }

        if (Cesium__namespace.defined(vertexFormat.st)) {
          const texCoords = new Float32Array(max.length * 4 * 2);
          const maxLen = max.length;
          for (let i = 0; i < max.length; i++) {
            const currX = i / maxLen;
            const currMaxHeight = (topHeights && topHeights[i]) || 0;
            const currY = (currMaxHeight - bottomHeight) / (maxHeight - bottomHeight);
            const nextIndex = i + 1;

            const nextMaxHeight = (topHeights && topHeights[nextIndex]) || 0;
            const nextX = nextIndex / maxLen;
            const nextY = (nextMaxHeight - bottomHeight) / (maxHeight - bottomHeight);

            texCoords[i * 8 + 0] = currX;
            texCoords[i * 8 + 1] = currY - 0.0;
            texCoords[i * 8 + 2] = currX;
            texCoords[i * 8 + 3] = currY - currY;
            texCoords[i * 8 + 4] = nextX;
            texCoords[i * 8 + 5] = nextY - 0.0;
            texCoords[i * 8 + 6] = nextX;
            texCoords[i * 8 + 7] = nextY - nextY;
          }

          attributes.st = new Cesium__namespace.GeometryAttribute({
            componentDatatype: Cesium__namespace.ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: texCoords
          });
        }

        // 12 triangles:  6 faces, 2 triangles each.
        indices = new Uint16Array(max.length * 2 * 3);
        min_pos = new Cesium__namespace.Cartesian3(9999999999999, 9999999999999, 9999999999999);
        max_pos = new Cesium__namespace.Cartesian3(-9999999999999, -9999999999999, -9999999999999);
        for (let i = 0; i < max.length; i++) {
          indices[i * 6 + 0] = 4 * i + 0;
          indices[i * 6 + 1] = 4 * i + 1;
          indices[i * 6 + 2] = 4 * i + 2;
          indices[i * 6 + 3] = 4 * i + 1;
          indices[i * 6 + 4] = 4 * i + 2;
          indices[i * 6 + 5] = 4 * i + 3;

          if (max[i].x >= max_pos.x && max[i].y >= max_pos.y && max[i].z >= max_pos.z) {
            max_pos = max[i];
          }
          if (min[i].x <= min_pos.x && min[i].y <= min_pos.y && min[i].z <= min_pos.z) {
            min_pos = min[i];
          }
        }
      }

      const diff = Cesium__namespace.Cartesian3.subtract(max_pos, min_pos, new Cesium__namespace.Cartesian3());
      const radius = Cesium__namespace.Cartesian3.magnitude(diff) * 0.5;

      return new Cesium__namespace.Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: Cesium__namespace.PrimitiveType.TRIANGLES,
        boundingSphere: new Cesium__namespace.BoundingSphere(Cesium__namespace.Cartesian3.ZERO, radius)
      })
    }
  }

  /**
   * 井  支持的样式信息，
   *
   * @typedef {Object} Pit.StyleOptions
   *
   * @property {String} image   井墙面贴图URL
   * @property {String} imageBottom   井底面贴图URL
   * @property {Number} diffHeight  井下深度（单位：米）
   * @property {Number} [splitNum = 50] 井墙面每两点之间插值个数
   *
   * @property {LabelPrimitive.StyleOptions} [label] 支持附带文字的显示
   */

  /**
   * 井 矢量对象
   * 用于显示地形开挖后的开挖效果。
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.positions 坐标位置
   * @param {Pit.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class Pit
   * @extends {BasePolyPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class Pit extends BasePolyPrimitive {
    constructor(options = {}) {
      super(options);

      this.style.diffHeight = this.style.diffHeight ?? 10; // 挖掘深度
      this.style.splitNum = this.style.splitNum ?? 50; // 每两点之间插值个数
    }

    // 内部用，文本等附加对象
    get czmObjectEx() {
      const arr = [];
      if (this._bottomPrimitive) {
        arr.push(this._bottomPrimitive);
      }
      if (this._primitive_label) {
        arr.push(this._primitive_label);
      }
      return arr
    }

    // 中心点坐标，覆盖父类
    get center() {
      return this.centerOfMass
    }

    /**
     * 井下深度（单位：米）
     * @type {Number}
     */
    get diffHeight() {
      return this.style.diffHeight
    }

    set diffHeight(val) {
      this.style.diffHeight = val;

      const bottomPositions = [];
      const bottomHeight = this._minHeight - val; // 墙底部的高度
      const cartoList = this.wellData.cartoList;
      for (let i = 0, len = cartoList.length; i < len; i++) {
        const carto = cartoList[i];
        bottomPositions.push(Cesium__namespace.Cartesian3.fromRadians(carto.longitude, carto.latitude, bottomHeight));
      }
      // 墙底部的坐标数组
      this.wellData.bottomPositions = bottomPositions;

      this._removePit();
      this._createPit(this.wellData);
    }

    _getWellData() {
      if (this.positions.length === 0) {
        return
      }

      // 墙顶部的高度（也是绘制的坐标的最低点高度）
      this._minHeight = getMinHeight(this.positions);

      // 墙底部的高度
      const bottomHeight = this._minHeight - this.diffHeight;

      const wallTopPositions = [];
      const bottomPositions = [];
      const cartoList = [];

      const positionsNew = interPolyline({
        scene: this._map.scene,
        positions: this.positions.concat(this.positions[0]),
        splitNum: this.style.splitNum
      });

      for (let i = 0, len = positionsNew.length; i < len; i++) {
        const point = Cesium__namespace.Cartographic.fromCartesian(positionsNew[i]);
        cartoList.push(new Cesium__namespace.Cartographic(point.longitude, point.latitude));

        bottomPositions.push(Cesium__namespace.Cartesian3.fromRadians(point.longitude, point.latitude, bottomHeight));
        wallTopPositions.push(Cesium__namespace.Cartesian3.fromRadians(point.longitude, point.latitude, 0)); // 无地形时直接使用这个0
      }
      return {
        cartoList: cartoList,
        bottomPositions: bottomPositions,
        wallTopPositions: wallTopPositions
      }
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show || !this.positions || this.positions.length === 0) {
        return
      }

      const wellData = this._getWellData();
      this.wellData = wellData;

      this._createPit(wellData);

      // 同时加文字
      if (this.style.label) {
        this._addLabel();
      }
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      super._removedHook();
      this._removePit();
    }

    _removePit() {
      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
        delete this._primitive;
      }

      if (this._bottomPrimitive) {
        this.primitiveCollection.remove(this._bottomPrimitive);
        delete this._bottomPrimitive;
      }
    }

    _createPit(wellData) {
      this._createBottomSurface(wellData.bottomPositions);

      if (this._map.hasTerrain) {
        Cesium__namespace.sampleTerrainMostDetailed(this._map.terrainProvider, wellData.cartoList).then((updatedPositions) => {
          if (!this.isAdded) {
            return
          }

          const _topHeights = [];
          let _maxHeight = -9999;

          const wallTopPositions = []; // 墙顶部的坐标数组
          for (let k = 0, len = updatedPositions.length; k < len; k++) {
            const carto = updatedPositions[k];

            _topHeights.push(carto.height);
            _maxHeight = Math.max(carto.height, _maxHeight);

            wallTopPositions.push(Cesium__namespace.Cartesian3.fromRadians(carto.longitude, carto.latitude, carto.height));
          }
          this._maxHeight = _maxHeight; // PitWallGeometry 使用
          this._topHeights = _topHeights; // PitWallGeometry 使用

          this._createWellWall(wellData.bottomPositions, wallTopPositions);
        });
      } else {
        this._createWellWall(wellData.bottomPositions, wellData.wallTopPositions);
      }
    }

    // 创建井壁
    _createWellWall(bottom, top) {
      // logInfo('井高度', this._minHeight, this._maxHeight, this._topHeights)

      // 墙底部的高度
      const bottomHeight = this._minHeight - this.diffHeight;
      const opacity = this.style.opacity ?? 1.0;

      let geo = new PitWallGeometry({
        minimumArr: bottom,
        maximumArr: top
      });
      geo = geo.createGeometry(geo, this._topHeights, bottomHeight, this._maxHeight);

      if (this._primitive) {
        this.primitiveCollection.remove(this._primitive);
      }
      this._primitive = new Cesium__namespace.Primitive({
        geometryInstances: new Cesium__namespace.GeometryInstance({
          id: this.id,
          geometry: geo
        }),
        appearance: new Cesium__namespace.MaterialAppearance({
          material: Cesium__namespace.Material.fromType(Cesium__namespace.Material.ImageType, {
            image: this.style.image,
            color: Cesium__namespace.Color.WHITE.withAlpha(opacity)
          }),
          translucent: opacity !== 1,
          faceForward: true,
          flat: true
        })
      });
      this.primitiveCollection.add(this._primitive);

      this.bindPickId(this._primitive);
    }

    // 创建井底
    _createBottomSurface(bottomPositions) {
      if (!bottomPositions.length) {
        return
      }

      const opacity = this.style.opacity ?? 1.0;

      if (this._bottomPrimitive) {
        this.primitiveCollection.remove(this._bottomPrimitive);
      }
      this._bottomPrimitive = new Cesium__namespace.Primitive({
        geometryInstances: new Cesium__namespace.GeometryInstance({
          id: this.id,
          geometry: Cesium__namespace.PolygonGeometry.fromPositions({
            vertexFormat: Cesium__namespace.VertexFormat.ALL,
            positions: bottomPositions,
            perPositionHeight: true
          })
        }),
        appearance: new Cesium__namespace.MaterialAppearance({
          material: Cesium__namespace.Material.fromType(Cesium__namespace.Material.ImageType, {
            image: this.style.imageBottom,
            color: Cesium__namespace.Color.WHITE.withAlpha(opacity)
          }),
          translucent: opacity !== 1,
          faceForward: true,
          flat: true
        })
      });

      this.primitiveCollection.add(this._bottomPrimitive);
      this.bindPickId(this._bottomPrimitive);
    }

    _updateExOpacity(value) {
      this._updatePrimitiveOpacity(this._bottomPrimitive, value);
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      options.style.image = options.style.imageBottom;
      delete options.style.diffHeight;
      return create$4("polygon", options)
    }
  }

  // 注册下
  register$4("pit", Pit);

  /**
   * 大数据合并渲染Primitive对象基类
   *
   * @export
   * @class BaseCombine
   * @extends {BasePrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BaseCombine extends BasePrimitive {
    /**
     * 数据集合数组，同类的构造参数
     * @type {Object[]}
     */
    get instances() {
      return this.options.instances || []
    }

    set instances(val) {
      this.options.instances = val;
      this._rectangle = null;
      this.redraw();
    }

    /**
     * 根据 pickId 获取对应绑定的数据据对象
     *
     * @param {String} pickId 单个对象的pickid
     * @return {Object} 对应绑定的数据对象
     */
    getPickedObject(pickId) {
      const arr = pickId.split("#");
      if (arr.length !== 2) {
        return null
      }

      const index = Number(arr[1]);
      return this.instances[index]
    }

    createPickId(id) {
      return this.id + "#" + id
    }

    _createGeometryInstance(globeAttr, outline) {
      if (this.options.geometryInstances) {
        return this.options.geometryInstances
      }

      const instances = [];
      const arr = this.instances;
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        item.id = this.createPickId(i);
        instances.push(item);
      }
      return instances
    }

    /**
     * 获取数据的矩形边界
     * @param {Boolean} [options] 控制参数
     * @param {Boolean} [options.isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */
    getRectangle(options) {
      if (!this._rectangle) {
        const arr = this.options.instances || [];
        for (let i = 0; i < arr.length; i++) {
          const item = arr[i];

          // 转换规范坐标数据
          if (item.position) {
            item.position = LngLatPoint.parse(item.position).toCartesian();
            this._unionRectangle([item.position]);
          }
          if (item.positions) {
            item.positions = LngLatArray.toCartesians(item.positions);
            this._unionRectangle(item.positions);
          }
        }
      }

      if (options?.isFormat) {
        return formatRectangle(this._rectangle)
      } else {
        return this._rectangle
      }
    }

    _unionRectangle(positions) {
      const rectangle = Cesium__namespace.Rectangle.fromCartesianArray(positions);
      if (!Cesium__namespace.defined(rectangle)) {
        return
      }

      if (Cesium__namespace.defined(this._rectangle)) {
        this._rectangle = Cesium__namespace.Rectangle.union(rectangle, this._rectangle);
      } else {
        this._rectangle = rectangle;
      }
    }

    /**
     * 将矢量数据的坐标、样式及属性等信息导出为对象，可以用于存储。
     * @return {Object} 导出的坐标、样式及属性等信息
     */
    toJSON() {
      const json = {
        ...getAttrVal(this.options, { onlySimpleType: true }),
        type: this.type
      };

      if (this.options.style) {
        json.style = this._style2JsonBase(this.options.style, false);
      }

      const instances = [];
      for (let i = 0; i < this.instances.length; i++) {
        const item = this.instances[i];

        const jsonItem = {
          attr: item.attr,
          style: this._style2JsonBase(item.style, false)
        };
        if (item.position) {
          jsonItem.position = LngLatPoint.toArray(item.position);
        } else if (item.positions) {
          jsonItem.positions = LngLatArray.toArray(item.positions);
        }

        instances.push(jsonItem);
      }
      json.instances = instances;

      if (this._toJSON_Ex) {
        this._toJSON_Ex(json);
      }

      return json
    }

    /**
     * 将矢量数据导出为GeoJSON格式规范对象。[因为geojson格式规范，是拆分为多个Feature，如果不满足需求，也可以用toJSON方法]
     * @param {Object} [options] 参数对象:
     * @param {Boolean} [options.noAlt] 不导出高度值
     * @return {Object} GeoJSON格式规范对象
     */
    toGeoJSON(options) {
      const features = [];
      for (let i = 0; i < this.instances.length; i++) {
        const item = this.instances[i];
        const geojson = {
          type: "Feature",
          properties: {
            ...item.attr,
            type: this.type,
            style: this._style2JsonBase(item.style, true)
          }
        };
        if (this._getGeoJsonGeometry) {
          geojson.geometry = this._getGeoJsonGeometry(item, options);
        } else if (item.position) {
          geojson.geometry = { type: "Point", coordinates: LngLatPoint.toArray(item.position, options?.noAlt) };
        } else if (item.positions) {
          geojson.geometry = { type: "LineString", coordinates: LngLatArray.toArray(item.positions, options?.noAlt) };
        }
        features.push(geojson);
      }
      return features
    }

    // 飞行定位至图层数据所在的视角
    flyTo(options) {
      const rectangle = this.getRectangle();
      if (this._map && rectangle) {
        return this._map.flyToExtent(rectangle, options)
      } else {
        return Promise.resolve(false)
      }
    }

    /**
     * 更新颜色
     *
     * @param {Object} style 样式信息
     * @param {String|Cesium.Color} [style.color = "#3388ff"] 颜色
     * @param {Number} [style.opacity = 1.0] 透明度，取值范围：0.0-1.0
     * @param {Number|undefined} [index] 更新的instances对象index值，为空时更新所有对象。
     * @return {void} 空
     */
    setColorStyle(style, index) {
      if (Cesium__namespace.defined(index)) {
        this._setColorStyleItem(index, style);
      } else {
        for (let i = 0; i < this.options.instances.length; i++) {
          this._setColorStyleItem(i, style);
        }
      }
    }

    _setColorStyleItem(index, style) {
      const attributes = this._primitive.getGeometryInstanceAttributes(this.createPickId(index));
      if (attributes) {
        const item = this.options.instances[index];
        const color = getColorByStyle({ ...this.style, ...(item.style || {}), ...style });
        attributes.color = Cesium__namespace.ColorGeometryInstanceAttribute.toValue(color);
      }
    }
  }
  // 对类是否为大数据的判断,GraphicUtil内用到
  BaseCombine.isCombine = true;

  var FlatBillboardFS = "#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D mars_image;\nuniform vec2 mars_distanceDisplayCondition;\nuniform vec3 mars_positionWC;\nvarying vec3 v_worldPos;\nvarying vec2 v_st;\nuniform float globalAlpha;\n\nvoid main() {\n  float dis = distance(mars_positionWC, v_worldPos);\n  if(dis < mars_distanceDisplayCondition.x || dis > mars_distanceDisplayCondition.y) {\n    discard;\n  } else {\n    gl_FragColor = texture2D(mars_image, v_st);\n    gl_FragColor.a *= globalAlpha;\n  }\n}\n"; // eslint-disable-line

  var FlatBillboardVS = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 color;\nattribute vec2 st;\nattribute float batchId;\n\nuniform mat4 mars_orthographicMatrix;\nuniform mat4 mars_viewMatrix;\nuniform vec2 mars_resolution;\nuniform float mars_pointSize;\nvarying vec2 v_st;\nvarying vec3 v_worldPos;\n\nvec4 transform(mat4 m, mat4 v, vec3 coord) {\n  return m * v * vec4(coord, 1.0);\n}\nvec2 project(vec4 device) {\n  vec3 device_normal = device.xyz / device.w;\n  vec2 clip_pos = (device_normal * 0.5 + 0.5).xy;\n  return clip_pos * mars_resolution;\n}\nvec4 unproject(vec2 screen, float z, float w) {\n  vec2 clip_pos = screen / mars_resolution;\n  vec2 device_normal = clip_pos * 2.0 - 1.0;\n  return vec4(device_normal * w, z, w);\n}\n\nvoid main() {\n  v_st = st;\n  vec3 currP = position3DHigh.xyz + position3DLow.xyz;\n  v_worldPos = currP;\n  vec4 eyeCurrP = transform(mars_orthographicMatrix, mars_viewMatrix, currP);\n  vec2 winCurrP = project(eyeCurrP);\n  vec3 dirEye = czm_viewRotation * color;\n  dirEye = normalize(dirEye);\n\n  vec2 newWinCurrP = winCurrP + dirEye.xy * mars_pointSize;\n  gl_Position = unproject(newWinCurrP, eyeCurrP.z, eyeCurrP.w);\n  gl_PointSize = mars_pointSize;\n}\n"; // eslint-disable-line

  const DEF_STYLE$8 = {
    angle: 0,
    width: 50
  };

  /**
   * 平放的图标 单个数据对象的样式
   *
   * @typedef {Object} FlatBillboard.StyleOptions
   *
   * @property {String} image 图标URL
   * @property {Number} [angle=0] 图标的角度（角度值，0-360）
   * @property {Number} [width = 50] 图标宽度
   * @property {Number} [height] 图标高度，默认值等于宽度
   *
   */

  /**
   * 平放的图标 数据集合 (多个图标一起合并渲染)
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 数组，单个对象包括：
   * @param {LngLatPoint|Cesium.Cartesian3|Array|Object} options.instances.position 坐标位置
   * @param {FlatBillboard.StyleOptions} options.instances.style 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   *
   * @param {FlatBillboard.StyleOptions} [options.style] 所有图标的公共样式信息
   * @param {Number} [options.scale3d=0.8] 二维和三维模式切换后图标的缩放比例。因为二三维模式使用不同渲染方式，可能存在大小偏差，可以该参数调优。
   * @param {Cesium.DistanceDisplayCondition} [options.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(0, 5000000)] 指定数据将显示在与摄像机的多大距离
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class FlatBillboard
   * @extends {BaseCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class FlatBillboard extends BaseCombine {
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$8,
        ...(options.style || {})
      };
      super(options);

      this.distanceDisplayCondition = options.distanceDisplayCondition ?? new Cesium__namespace.DistanceDisplayCondition(0, 5000000);
      this._pointSize = (options.scale3d ?? 0.8) * 100;
      this._globalAlpha = 1.0;
    }

    //= ========= 对外属性 ==========

    get billboardCollection() {
      return this._layer?.billboardCollection
    }

    /**
     * 指定数据将显示在与摄像机的多大距离
     * @type {Cesium.DistanceDisplayCondition}
     */
    get distanceDisplayCondition() {
      return this._distanceDisplayCondition
    }

    set distanceDisplayCondition(val) {
      this._distanceDisplayCondition = val;
      this._distanceDisplayConditionCartesian2 = new Cesium__namespace.Cartesian2(val.near, val.far);
    }

    //= ========= 方法 ==========

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show) {
        return
      }

      this.textures = {};
      this.textureDef = new Cesium__namespace.Texture({
        context: this._map.scene.context,
        width: 500,
        height: 500
      });

      this._pickCommands = [];

      if (this.options.instances) {
        this.redraw();
      }

      // 切换场景后事件
      this._map.on(EventType.morphComplete, this._onMorphComplete, this);

      this.primitiveCollection.add(this);
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      // 切换场景后事件
      this._map.off(EventType.morphComplete, this._onMorphComplete, this);

      this.clear();
      this.textureDef.destroy();

      this._noDestroy = true;
      this.primitiveCollection.remove(this);
      this._noDestroy = false;
    }

    /**
     * 清除数据
     * @return {void}  无
     */
    clear() {
      if (this.billboardCollection) {
        this.billboardCollection.removeAll();
      }
      this._removeCollectionBy3D();
    }

    // 渲染数据
    redraw() {
      if (!this._map) {
        return
      }
      this.clear();

      const arrdata = this.instances;
      if (arrdata) {
        for (let i = 0, len = arrdata.length; i < len; i++) {
          const item = arrdata[i];
          item.position = LngLatPoint.toCartesian(item.position);
        }
      }

      if (this._map.scene.mode === Cesium__namespace.SceneMode.SCENE3D) {
        this._initCollectionBy3D();
      } else {
        this._initCollectionBy2D();
      }
    }

    _onMorphComplete(e) {
      this.redraw();
    }

    update(frameState) {
      if (!this._map) {
        return
      }

      if (!this.show) {
        if (this.billboardCollection) {
          this.billboardCollection.removeAll();
        }
        return
      }

      // 三维模式下
      if (frameState.mode === Cesium__namespace.SceneMode.SCENE3D) {
        // 添加到渲染序列中
        if (frameState.passes.render) {
          if (this._drawCommands) {
            frameState.commandList.push(...this._drawCommands);
          }
        } else {
          if (this._pickCommands) {
            frameState.commandList.push(...this._pickCommands);
          }
        }
      } else {
        if (!this.billboardCollection) {
          this._initCollectionBy2D();
        }
      }
    }

    // 二维模式下的处理
    _initCollectionBy2D() {
      const arrdata = this.instances;
      if (!arrdata) {
        return
      }

      for (let i = 0, len = arrdata.length; i < len; i++) {
        const item = arrdata[i];

        const style = { ...this.options.style, ...item.style };

        const billboard = this.billboardCollection.add({
          position: item.position,
          image: style.image,
          scale: 1,
          rotation: Cesium__namespace.Math.toRadians(style.angle || 0),
          width: style.width,
          height: style.height || style.width
        });
        this.bindPickId(billboard);
      }
    }

    // 三维模式下的处理
    _initCollectionBy3D() {
      const arrdata = this.instances;
      if (!arrdata) {
        return
      }

      // 按图片分组
      const imaObj = {};
      for (let i = 0, len = arrdata.length; i < len; i++) {
        const item = arrdata[i];
        item.index = i;

        const key = item.style?.image;
        if (!key) {
          continue
        }

        if (!imaObj[key]) {
          imaObj[key] = [];
        }

        imaObj[key].push(item);
      }

      const commands = [];
      for (const key in imaObj) {
        const arr = imaObj[key];
        const image = key;

        // 加载图片
        this.prepareTexture(image);

        // 生成Command
        for (const point of arr) {
          const command = this.createDrawCommand(image, point);
          commands.push(command);
        }
      }
      this._drawCommands = commands;
    }

    _removeCollectionBy3D() {
      if (this._drawCommands) {
        delete this._drawCommands;
      }
      if (this._pickCommands) {
        this._pickCommands = [];
      }

      for (const key in this.textures) {
        if (this.textures[key]) {
          this.textures[key].destroy();
        }
      }
      this.textures = {};
    }

    prepareTexture(imgUrl) {
      const image = new Image();
      image.onload = (e) => {
        const texture = new Cesium__namespace.Texture({
          context: this._map.scene.context,
          source: image
        });
        this.textures[imgUrl] = texture;
      };
      image.src = imgUrl;
    }

    prepareVAO(points) {
      const vertexs_H = [];
      const vertexs_L = [];
      const indexs = [];
      const uvs = [];
      const colors = [];

      for (let i = 0, len = points.length; i < len; i++) {
        const item = points[i];
        const position = item.position;
        const style = { ...this.options.style, ...item.style };

        indexs.push(i * 4 + 0);
        indexs.push(i * 4 + 2);
        indexs.push(i * 4 + 1);
        indexs.push(i * 4 + 0);
        indexs.push(i * 4 + 3);
        indexs.push(i * 4 + 2);

        // 伪造双精度数据
        const currDF = new Float32Array(6);
        currDF[0] = position.x;
        currDF[1] = position.x - currDF[0];
        currDF[2] = position.y;
        currDF[3] = position.y - currDF[2];
        currDF[4] = position.z;
        currDF[5] = position.z - currDF[4];

        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);

        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);

        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);

        vertexs_H.push(currDF[0]);
        vertexs_H.push(currDF[2]);
        vertexs_H.push(currDF[4]);
        vertexs_L.push(currDF[1]);
        vertexs_L.push(currDF[3]);
        vertexs_L.push(currDF[5]);

        uvs.push(0, 0);
        uvs.push(0, 1);
        uvs.push(1, 1);
        uvs.push(1, 0);

        const trans = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(position);
        const angle = style.angle || 0;
        const mz = Cesium__namespace.Matrix3.fromRotationZ(Cesium__namespace.Math.toRadians(angle));
        const rotationZ = Cesium__namespace.Matrix4.fromRotationTranslation(mz);
        const currMat = Cesium__namespace.Matrix4.multiply(trans, rotationZ, new Cesium__namespace.Matrix4());

        const width = 1;
        const height = (style.height || style.width) / style.width;

        const zxj = new Cesium__namespace.Cartesian3(-width, -height, 0);
        Cesium__namespace.Matrix4.multiplyByPointAsVector(currMat, zxj, zxj);
        Cesium__namespace.Cartesian3.normalize(zxj, zxj);
        colors.push(zxj.x, zxj.y, zxj.z);

        const zsj = new Cesium__namespace.Cartesian3(-width, height, 0);
        Cesium__namespace.Matrix4.multiplyByPointAsVector(currMat, zsj, zsj);
        Cesium__namespace.Cartesian3.normalize(zsj, zsj);
        colors.push(zsj.x, zsj.y, zsj.z);

        const ysj = new Cesium__namespace.Cartesian3(width, height, 0);
        Cesium__namespace.Matrix4.multiplyByPointAsVector(currMat, ysj, ysj);
        Cesium__namespace.Cartesian3.normalize(ysj, ysj);
        colors.push(ysj.x, ysj.y, ysj.z);

        const yxj = new Cesium__namespace.Cartesian3(width, -height, 0);
        Cesium__namespace.Matrix4.multiplyByPointAsVector(currMat, yxj, yxj);
        Cesium__namespace.Cartesian3.normalize(yxj, yxj);
        colors.push(yxj.x, yxj.y, yxj.z);
      }

      return {
        index: new Uint16Array(indexs),
        vertex_H: {
          values: new Float32Array(vertexs_H),
          componentDatatype: "DOUBLE",
          componentsPerAttribute: 3
        },
        vertex_L: {
          values: new Float32Array(vertexs_L),
          componentDatatype: "DOUBLE",
          componentsPerAttribute: 3
        },
        uv: {
          values: new Float32Array(uvs),
          componentDatatype: "FLOAT",
          componentsPerAttribute: 2
        },
        color: {
          values: new Float32Array(colors),
          componentDatatype: "FLOAT",
          componentsPerAttribute: 3
        }
      }
    }

    createDrawCommand(imgUrl, item) {
      const context = this._map.scene.context;

      // renderState
      const renderState = Cesium__namespace.RenderState.fromCache();

      // shaderProgram
      const attributeLocations = {
        position3DHigh: 0,
        position3DLow: 1,
        color: 2,
        st: 3
      };
      const shaderProgram = Cesium__namespace.ShaderProgram.fromCache({
        context: context,
        vertexShaderSource: FlatBillboardVS,
        fragmentShaderSource: FlatBillboardFS,
        attributeLocations: attributeLocations
      });

      // vertexArray
      const VAO = this.prepareVAO([item]);
      const indexBuffer = Cesium__namespace.Buffer.createIndexBuffer({
        context: context,
        typedArray: VAO.index,
        usage: Cesium__namespace.BufferUsage.STATIC_DRAW,
        indexDatatype: Cesium__namespace.IndexDatatype.UNSIGNED_SHORT
      });
      const vertexArray = new Cesium__namespace.VertexArray({
        context: context,
        attributes: [
          {
            index: 0,
            vertexBuffer: Cesium__namespace.Buffer.createVertexBuffer({
              context: context,
              typedArray: VAO.vertex_H.values,
              usage: Cesium__namespace.BufferUsage.STATIC_DRAW
            }),
            componentsPerAttribute: 3
          },
          {
            index: 1,
            vertexBuffer: Cesium__namespace.Buffer.createVertexBuffer({
              context: context,
              typedArray: VAO.vertex_L.values,
              usage: Cesium__namespace.BufferUsage.STATIC_DRAW
            }),
            componentsPerAttribute: 3
          },
          {
            index: 2,
            vertexBuffer: Cesium__namespace.Buffer.createVertexBuffer({
              context: context,
              typedArray: VAO.color.values,
              usage: Cesium__namespace.BufferUsage.STATIC_DRAW
            }),
            componentsPerAttribute: 3
          },
          {
            index: 3,
            vertexBuffer: Cesium__namespace.Buffer.createVertexBuffer({
              context: context,
              typedArray: VAO.uv.values,
              usage: Cesium__namespace.BufferUsage.STATIC_DRAW
            }),
            componentsPerAttribute: 2
          }
        ],
        indexBuffer: indexBuffer
      });

      // uniformMap
      const camera = this._map.scene.camera;
      const width = context.drawingBufferWidth;
      const height = context.drawingBufferHeight;
      const resolution = new Cesium__namespace.Cartesian2(width, height);

      const boundingVolume = Cesium__namespace.BoundingSphere.fromVertices(VAO.vertex_H.values);
      boundingVolume.radius = 10000;

      const command = new Cesium__namespace.DrawCommand({
        primitiveType: Cesium__namespace.PrimitiveType.TRIANGLES,
        shaderProgram: shaderProgram,
        vertexArray: vertexArray,
        modelMatrix: Cesium__namespace.Matrix4.IDENTITY,
        renderState: renderState,
        boundingVolume: boundingVolume,
        uniformMap: {
          mars_orthographicMatrix: () => {
            if (camera.frustum._offCenterFrustum) {
              return camera.frustum._offCenterFrustum?._perspectiveMatrix
            } else {
              return camera.frustum._orthographicMatrix
            }
          },
          mars_viewMatrix: () => {
            return camera._viewMatrix
          },
          mars_resolution: () => {
            return resolution
          },
          mars_pointSize: () => {
            return this._pointSize
          },
          mars_image: () => {
            return this.textures[imgUrl] || this.textureDef
          },
          mars_distanceDisplayCondition: () => {
            return this._distanceDisplayConditionCartesian2
          },
          mars_positionWC: () => {
            return camera.positionWC
          },
          globalAlpha: () => {
            return this._globalAlpha
          }
        },
        castShadows: false,
        receiveShadows: false,
        pass: Cesium__namespace.Pass.TRANSLUCENT,
        pickOnly: true,
        pickCommand: new Cesium__namespace.DrawCommand({
          owner: this,
          pickOnly: true
        })
      });
      this.bindPickId(command);

      command.pickId = context.createPickId({
        primitive: command,
        id: this.createPickId(item.index)
      });

      const pickCommand = new Cesium__namespace.DrawCommand({
        owner: command,
        primitiveType: Cesium__namespace.PrimitiveType.TRIANGLES,
        pickOnly: true
      });
      pickCommand.vertexArray = vertexArray;
      pickCommand.renderState = renderState;
      const sp1 = Cesium__namespace.ShaderProgram.fromCache({
        context: context,
        vertexShaderSource: FlatBillboardVS,
        fragmentShaderSource: Cesium__namespace.ShaderSource.createPickFragmentShaderSource(FlatBillboardFS, "uniform"),
        attributeLocations: attributeLocations
      });
      pickCommand.shaderProgram = sp1;
      pickCommand.uniformMap = command.uniformMap;
      pickCommand.uniformMap.czm_pickColor = () => {
        return command.pickId.color
      };
      pickCommand.pass = Cesium__namespace.Pass.TRANSLUCENT;
      pickCommand.boundingVolume = boundingVolume;
      pickCommand.modelMatrix = Cesium__namespace.Matrix4.IDENTITY;

      this._pickCommands.push(pickCommand);

      return command
    }

    /**
     * 设置透明度
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this._globalAlpha = value;
    }
  }

  // 对类是否为点状数据的判断,GraphicUtil内用到
  FlatBillboard.isPoint = true;

  // 注册下
  register$4("flatBillboard", FlatBillboard);

  /**
   * 大数据 gltf小模型集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Cesium.Resource|String} [options.url] glTF模型的URI的字符串或资源属性。
   * @param {Object[]} [options.instances] 集合信息数组，单个对象包括：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.instances.position 坐标位置
   * @param {ModelPrimitive.StyleOptions} [options.instances.style] 样式信息(目前仅支持方向和比例参数)
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {*} [options.batchTable] 实例化的3D贴图的Cesium.Cesium3DTileBatchTable批处理表。
   * @param {Object} [options.requestType] 请求类型，用于确定请求的优先级
   * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] 一个glTF JSON对象，或者一个二进制的glTF缓冲区。
   * @param {Cesium.Resource|String} [options.basePath=''] glTF JSON中路径相对的基本路径。
   * @param {Boolean} [options.dynamic=false] 提示实例模型矩阵是否会频繁更新。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个glTF和Primitive都可以用{@link Cesium.Scene#pick}来拾取。
   * @param {Boolean} [options.asynchronous=true]  确定模型WebGL资源创建是否将分散在几个帧或块上，直到所有glTF文件加载完成。
   * @param {Boolean} [options.incrementallyLoadTextures=true] 确定模型加载后纹理是否会继续流进来。
   * @param {Cesium.ShadowMode} [options.shadows=ShadowMode.ENABLED] 指定模型是投射还是接收来自光源的阴影。
   * @param {Cesium.Cartesian2} [options.imageBasedLightingFactor=new Cartesian2(1.0, 1.0)] 指定来自基于图像的漫反射和镜面照明的贡献。
   * @param {Cesium.Cartesian3} [options.lightColor] 光的颜色当遮光模型。当undefined场景的浅色被使用代替。
   * @param {Boolean} [options.backFaceCulling=true] 是否剔除面向背面的几何图形。当为真时，背面剔除由glTF材质的双面属性决定;当为false时，禁用背面剔除。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。查看模型的包围边界球。
   * @param {Boolean} [options.debugWireframe=false] 仅供调试。查看模型的三角网线框图。
   *
   * //以下是 模型动画相关
   * @param {Cesium.JulianDate} [options.startTime] 场景时间开始播放动画。当undefined时，动画从下一帧开始。
   * @param {Number} [options.delay=0.0] 从startTime开始播放的延迟，以秒为单位。
   * @param {Cesium.JulianDate} [options.stopTime] 场景时间停止播放动画。当这是undefined，动画播放它的整个持续时间。
   * @param {Boolean} [options.removeOnStop=false] 当true时，动画在停止播放后被删除。
   * @param {Number} [options.multiplier=1.0] 大于1.0的值增加动画播放的速度相对于场景时钟的速度;小于1.0会降低速度。
   * @param {Boolean} [options.reverse=false] 当true时，动画会反向播放。
   * @param {Cesium.ModelAnimationLoop} [options.loop=Cesium.ModelAnimationLoop.REPEAT] 决定动画是否循环以及如何循环。
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class ModelCombine
   * @extends {BaseCombine}
   *
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class ModelCombine extends BaseCombine {
    /**
     * 是否可以调整透明度
     * @type {Boolean}
     * @readonly
     */
    get hasOpacity() {
      return false
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show) {
        return
      }

      const arr = this.instances;
      if (!arr || arr.length === 0) {
        return
      }

      const instances = [];
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        item.position = LngLatPoint.parse(item.position).toCartesian();

        const modelMatrix = this.getModelMatrix(item.position, item.style);

        instances.push({
          batchId: this.createPickId(i),
          modelMatrix: modelMatrix
        });
      }

      this._primitive = this.primitiveCollection.add(
        new Cesium__namespace.ModelInstanceCollection({
          ...this.options,
          url: this.options.url || arr[0]?.style?.url,
          instances: instances
        })
      );

      this._primitive.readyPromise
        .then((collection) => {
          collection.activeAnimations.addAll({
            loop: Cesium__namespace.ModelAnimationLoop.REPEAT,
            ...style
          });

          this.loadOk = true;

          this.fire(
            EventType.load,
            {
              drawtype: this.type,
              model: collection,
              graphic: this
            },
            true
          );
        })
        .catch((error) => {
          logError("ModelCombine:模型加载出错", error);
        });
    }

    // 转换style为可以导出的json
    _style2JsonBase(style, isGeoJSON) {
      const styleJson = getAttrVal(style, { onlySimpleType: true });
      if (isGeoJSON) {
        styleJson.url = this.options.url;
      }
      return styleJson
    }

    getModelMatrix(position, style) {
      const heading = Cesium__namespace.Math.toRadians(style.heading || 0);
      const pitch = Cesium__namespace.Math.toRadians(style.pitch || 0);
      const roll = Cesium__namespace.Math.toRadians(style.roll || 0);

      const modelMatrix = Cesium__namespace.Transforms.headingPitchRollToFixedFrame(position, new Cesium__namespace.HeadingPitchRoll(heading, pitch, roll));

      const scaleX = style.scaleX || style.scale || 1;
      const scaleY = style.scaleY || style.scale || 1;
      const scaleZ = style.scaleZ || style.scale || 1;
      Cesium__namespace.Matrix4.multiplyByScale(modelMatrix, new Cesium__namespace.Cartesian3(scaleX, scaleY, scaleZ), modelMatrix);

      return modelMatrix
    }
  }

  // 对类是否为点状数据的判断,GraphicUtil内用到
  ModelCombine.isPoint = true;

  // 注册下
  register$4("modelCombine", ModelCombine); // 兼容 v3.1 及之前版本
  register$4("modelC", ModelCombine);

  /**
   * 大数据线面集合 (合并渲染) Primitive图元 矢量对象基类
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 线面信息数组，单个对象包括：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.instances.positions 坐标位置
   * @param {Object} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {Object} [options.style] 所有面的公共样式信息
   * @param {Object} [options.highlight] 鼠标移入或单击后的对应高亮的部分样式
   * @param {String} [options.highlight.type] 触发高亮的方式，默认鼠标移入，可以指定为type:'click'为单击后高亮
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   *
   * @class BasePolyCombine
   * @extends {BaseCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BasePolyCombine extends BaseCombine {
    /**
     * 样式信息
     * @type {Object}
     * @readonly
     */
    get style() {
      if (this.options.instances?.length > 0 && this.options.instances[0].style) {
        return {
          ...(this.options.style || {}),
          ...this.options.instances[0].style
        }
      }
      return this.options.style
    }

    set style(style) {
      this.setStyle(style);
    }

    _createGeometryInstance(globeAttr, outline) {
      this._rectangle = null;
      this.translucent = false;

      const arr = this.instances;
      const instances = [];
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];

        if (item instanceof Cesium__namespace.GeometryInstance) {
          item.id = this.createPickId(i);
          instances.push(item);
        } else {
          const instance = this._createGeometryInstanceItem(globeAttr, outline, item);
          if (instance) {
            instance.id = this.createPickId(i);
            instances.push(instance);
          }
        }
      }
      return instances
    }

    // 子类覆盖
    _createGeometryInstanceItem(globeAttr, outline, item) {}

    // 边线坐标数组，支持多个线 [线坐标集合]
    _getPolylineOutlinePositions(item) {
      if (item.positions) {
        return [LngLatArray.toCartesians(item.positions)]
      } else {
        return null
      }
    }

    // 创建Polyline的outline对象
    _createPolylineOutline(globOutlineStyle) {
      const arr = this.instances;

      const arrInstance = [];
      let polylineStyle;
      for (let i = 0; i < arr.length; i++) {
        const polylineOptions = arr[i];

        // 属性
        if (
          Cesium__namespace.defined(polylineOptions.outline) ||
          Cesium__namespace.defined(polylineOptions.outlineStyle) ||
          Cesium__namespace.defined(polylineOptions.outlineColor) ||
          Cesium__namespace.defined(polylineOptions.outlineOpacity) ||
          Cesium__namespace.defined(polylineOptions.outlineWidth)
        ) {
          const itemOutlineStyle = this._getOutlineStyle(polylineOptions.style);
          if (!itemOutlineStyle.show) {
            continue
          }
          polylineStyle = { ...globOutlineStyle, ...itemOutlineStyle };
        } else {
          polylineStyle = globOutlineStyle;
        }
        const polyline = PolylineStyleConver.toCesiumVal(polylineStyle);
        if (!polyline.material) {
          polyline.vertexFormat = Cesium__namespace.PolylineColorAppearance.VERTEX_FORMAT;
        }

        const GeometryClass = polylineStyle.clampToGround ? Cesium__namespace.GroundPolylineGeometry : Cesium__namespace.PolylineGeometry;
        const color = polyline.color ?? Cesium__namespace.Color.YELLOW.withAlpha(0.5);

        // 坐标
        const arrline = this._getPolylineOutlinePositions(polylineOptions);
        if (!arrline) {
          return
        }

        for (let i = 0, len = arrline.length; i < len; i++) {
          let positions = arrline[i];
          if (Cesium__namespace.defined(polylineOptions.style.height)) {
            positions = setPositionsHeight(positions, polylineOptions.style.height);
          }
          if (positions.length > 0) {
            positions = positions.concat(positions[0]);
          }
          const instance = new Cesium__namespace.GeometryInstance({
            geometry: new GeometryClass({ ...polyline, positions: positions }),
            attributes: {
              color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
              distanceDisplayCondition: polyline.distanceDisplayCondition
            }
          });
          arrInstance.push(instance);
        }
      }

      const primitiveOpts = {
        ...this.options,
        geometryInstances: arrInstance,
        show: this.show
      };
      delete primitiveOpts.style;
      delete primitiveOpts.attr;

      // 存在材质时
      if (polylineStyle.material) {
        primitiveOpts.appearance = new Cesium__namespace.PolylineMaterialAppearance({
          ...polylineStyle
        });
      } else {
        primitiveOpts.appearance = new Cesium__namespace.PolylineColorAppearance({
          ...polylineStyle
        });
      }

      let primitive;
      if (polylineStyle.clampToGround) {
        primitive = this.primitiveCollection.add(new Cesium__namespace.GroundPolylinePrimitive(primitiveOpts));
      } else {
        primitive = this.primitiveCollection.add(new Cesium__namespace.Primitive(primitiveOpts));
      }
      this.bindPickId(primitive);
      return primitive
    }

    // 移入
    _highlight_mouseEventHandler(event) {
      this._map.closeHighlight(); // 需要关闭下

      const pickedObject = event.pickedObject;
      if (pickedObject) {
        this._last_pickedObject = pickedObject;
        this._map.openHighlight(this, this._highlightOptions, event);
      }
    }

    /**
     * 高亮对象。
     * @param {Object} [highlightStyle] 高亮的样式，具体见各{@link GraphicType}矢量数据的style参数。
     * @param {Boolean} [closeLast=true] 是否清除地图上上一次的高亮对象
     * @param {Object} [pickedObject] 指定需要高亮的子对象, 如果是mars3d的相关事件内时，可以取 event.pickedObject
     * @return {void}  无
     */
    openHighlight(highlightStyle, closeLast = true, pickedObject) {
      if (closeLast) {
        this._map.closeHighlight();
        this._map.last_highlighGraphic = this;
      }

      if (pickedObject) {
        this._last_pickedObject = pickedObject;
      }

      const style = highlightStyle || this._highlightOptions;
      if (this._last_pickedObject && style) {
        const addattr = PolygonStyleConver.toCesiumVal({ ...this._last_pickedObject.data.style, ...style });
        const color = this._getColorByColorMaterial(addattr, false);
        if (color) {
          const attributes = this._primitive.getGeometryInstanceAttributes(this._last_pickedObject.id);
          attributes.color = Cesium__namespace.ColorGeometryInstanceAttribute.toValue(color);

          this.fire(EventType.highlightOpen, {}, true);
        }
      }
    }

    /**
     * 清除已选中的高亮，原有style的配置项需要与highlightStyle配置有一一对应关系，否则无法清除
     * @return {void}  无
     */
    closeHighlight() {
      if (this._last_pickedObject && this._primitive) {
        const addattr = PolygonStyleConver.toCesiumVal(this._last_pickedObject.data.style);
        const color = this._getColorByColorMaterial(addattr, false);
        if (color) {
          const attributes = this._primitive.getGeometryInstanceAttributes(this._last_pickedObject.id);
          if (attributes) {
            attributes.color = Cesium__namespace.ColorGeometryInstanceAttribute.toValue(color);
            this.fire(EventType.highlightClose, {}, true);
          }
        }
        delete this._last_pickedObject;
      }

      if (this._map?.last_highlighGraphic === this) {
        this._map._clearLastHighlight();
      }
    }
  }

  /**
   * 大数据点状数据基类 集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 面信息数组，单个对象包括：
   * @param {LngLatPoint|Cesium.Cartesian3|Array|Object} options.instances.position 坐标位置
   * @param {Object} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {Object} [options.style] 所有面的公共样式信息
   * @param {Object} [options.highlight] 鼠标移入或单击后的对应高亮的部分样式
   * @param {String} [options.highlight.type] 触发高亮的方式，默认鼠标移入，可以指定为type:'click'为单击后高亮
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class BasePointCombine
   * @extends {BasePolyCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BasePointCombine extends BasePolyCombine {
    _getModelMatrix(item, addattr) {
      if (item.modelMatrix) {
        return item.modelMatrix
      }

      const position = LngLatPoint.toCartesian(item.position);

      const heading = Cesium__namespace.Math.toRadians(addattr.heading || 0);
      const pitch = Cesium__namespace.Math.toRadians(addattr.pitch || 0);
      const roll = Cesium__namespace.Math.toRadians(addattr.roll || 0);
      const modelMatrix = Cesium__namespace.Transforms.headingPitchRollToFixedFrame(position, new Cesium__namespace.HeadingPitchRoll(heading, pitch, roll));

      return modelMatrix
    }
  }

  // 对类是否为点状数据的判断,GraphicUtil内用到
  BasePointCombine.isPoint = true;

  /**
   * 大数据 平面 集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 面信息数组，单个对象包括：
   * @param {LngLatPoint|Cesium.Cartesian3|Array|Object} options.instances.position 坐标位置
   * @param {PlanePrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {PlanePrimitive.StyleOptions} [options.style] 所有面的公共样式信息
   * @param {PlanePrimitive.StyleOptions} [options.highlight] 鼠标移入或单击后的对应高亮的部分样式
   * @param {String} [options.highlight.type] 触发高亮的方式，默认鼠标移入，可以指定为type:'click'为单击后高亮
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePointCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PlaneCombine extends BasePointCombine {
    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PlaneStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstanceItem(globeAttr, outline, item) {
      // style样式信息的处理
      const addattr = PlaneStyleConver.toCesiumVal({
        ...this.options.style,
        ...(item.style || {})
      });
      addattr.vertexFormat = addattr.vertexFormat || globeAttr.vertexFormat;

      // 颜色的处理
      let color = this._getColorByColorMaterial(addattr);
      if (outline && addattr.outlineColor) {
        color = addattr.outlineColor;
      }
      if (color.alpha !== 1) {
        this.translucent = true;
      }

      // 坐标或位置的处理
      const modelMatrix = this._getModelMatrix(item, addattr);

      // geometry的处理
      const GeometryClass = outline ? Cesium__namespace.PlaneOutlineGeometry : Cesium__namespace.PlaneGeometry;

      const instance = new Cesium__namespace.GeometryInstance({
        geometry: new GeometryClass(addattr),
        modelMatrix: modelMatrix,
        attributes: {
          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
          distanceDisplayCondition: addattr.distanceDisplayCondition
        }
      });
      return instance
    }

    _getModelMatrix(item, addattr) {
      if (item.modelMatrix) {
        return item.modelMatrix
      }

      const modelMatrix = super._getModelMatrix(item, addattr);

      if (addattr.plane_normal === Cesium__namespace.Cartesian3.UNIT_X) {
        const rotationXMatrix = Cesium__namespace.Matrix4.fromRotationTranslation(Cesium__namespace.Matrix3.fromRotationX(Cesium__namespace.Math.toRadians(90.0)));
        Cesium__namespace.Matrix4.multiply(modelMatrix, rotationXMatrix, modelMatrix);
      } else if (addattr.plane_normal === Cesium__namespace.Cartesian3.UNIT_Y) {
        const rotationYMatrix = Cesium__namespace.Matrix4.fromRotationTranslation(Cesium__namespace.Matrix3.fromRotationY(Cesium__namespace.Math.toRadians(90.0)));
        Cesium__namespace.Matrix4.multiply(modelMatrix, rotationYMatrix, modelMatrix);
      }

      // 缩放，必须放在最后面
      const scaleMatrix = Cesium__namespace.Matrix4.fromScale(new Cesium__namespace.Cartesian3(addattr.dimensions?.x ?? 1, addattr.dimensions?.y ?? 1, 1));
      Cesium__namespace.Matrix4.multiply(modelMatrix, scaleMatrix, modelMatrix);

      return modelMatrix
    }
  }

  // 注册下
  register$4("planeC", PlaneCombine);

  /**
   * 大数据 盒子 集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 面信息数组，单个对象包括：
   * @param {LngLatPoint|Cesium.Cartesian3|Array|Object} options.instances.position 坐标位置
   * @param {BoxPrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {BoxPrimitive.StyleOptions} [options.style] 所有面的公共样式信息
   * @param {BoxPrimitive.StyleOptions} [options.highlight] 鼠标移入或单击后的对应高亮的部分样式
   * @param {String} [options.highlight.type] 触发高亮的方式，默认鼠标移入，可以指定为type:'click'为单击后高亮
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePointCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class BoxCombine extends BasePointCombine {
    _conversionStyle(style) {
      style.closed = style.closed ?? true;
      return style
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return BoxStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstanceItem(globeAttr, outline, item) {
      // style样式信息的处理
      const addattr = BoxStyleConver.toCesiumVal({
        ...this.options.style,
        ...(item.style || {})
      });
      addattr.vertexFormat = addattr.vertexFormat || globeAttr.vertexFormat;

      // 颜色的处理
      let color = this._getColorByColorMaterial(addattr);
      if (outline && addattr.outlineColor) {
        color = addattr.outlineColor;
      }
      if (color.alpha !== 1) {
        this.translucent = true;
      }

      // 坐标或位置的处理
      const modelMatrix = this._getModelMatrix(item, addattr);

      // geometry的处理
      const GeometryClass = outline ? Cesium__namespace.BoxOutlineGeometry : Cesium__namespace.BoxGeometry;

      const instance = new Cesium__namespace.GeometryInstance({
        geometry: GeometryClass.fromDimensions(addattr),
        modelMatrix: modelMatrix,
        attributes: {
          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
          distanceDisplayCondition: addattr.distanceDisplayCondition
        }
      });
      return instance
    }
  }

  // 注册下
  register$4("boxC", BoxCombine);

  /**
   * 大数据圆集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 面信息数组，单个对象包括：
   * @param {LngLatPoint|Cesium.Cartesian3|Array|Object} options.instances.position 坐标位置
   * @param {CirclePrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {CirclePrimitive.StyleOptions} [options.style] 所有面的公共样式信息
   * @param {CirclePrimitive.StyleOptions} [options.highlight] 鼠标移入或单击后的对应高亮的部分样式
   * @param {String} [options.highlight.type] 触发高亮的方式，默认鼠标移入，可以指定为type:'click'为单击后高亮
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePointCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class CircleCombine extends BasePointCombine {
    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return CircleStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstanceItem(globeAttr, outline, item) {
      // style样式信息的处理
      const addattr = CircleStyleConver.toCesiumVal({
        ...this.options.style,
        ...(item.style || {})
      });
      addattr.vertexFormat = addattr.vertexFormat || globeAttr.vertexFormat;

      // 颜色的处理
      let color = this._getColorByColorMaterial(addattr);
      if (outline && addattr.outlineColor) {
        color = addattr.outlineColor;
      }
      if (color.alpha !== 1) {
        this.translucent = true;
      }

      // 坐标或位置的处理
      item.position = LngLatPoint.parse(item.position).toCartesian();
      addattr.center = item.position;

      // geometry的处理
      const GeometryClass = outline ? Cesium__namespace.CircleOutlineGeometry : Cesium__namespace.CircleGeometry;

      const instance = new Cesium__namespace.GeometryInstance({
        geometry: new GeometryClass(addattr),
        attributes: {
          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
          distanceDisplayCondition: addattr.distanceDisplayCondition
        }
      });
      return instance
    }

    // 边线坐标数组，支持多个线 [线坐标集合]
    _getPolylineOutlinePositions(item) {
      const outerPositions = getEllipseOuterPositions({
        position: item.position,
        radius: item.style.radius,
        granularity: item.style.granularity
      });
      return [outerPositions]
    }
  }

  // 注册下
  register$4("circleC", CircleCombine);

  /**
   * 大数据圆锥、圆柱集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 面信息数组，单个对象包括：
   * @param {LngLatPoint|Cesium.Cartesian3|Array|Object} options.instances.position 坐标位置
   * @param {CylinderPrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {CylinderPrimitive.StyleOptions} [options.style] 所有面的公共样式信息
   * @param {CylinderPrimitive.StyleOptions} [options.highlight] 鼠标移入或单击后的对应高亮的部分样式
   * @param {String} [options.highlight.type] 触发高亮的方式，默认鼠标移入，可以指定为type:'click'为单击后高亮
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePointCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class CylinderCombine extends BasePointCombine {
    _conversionStyle(style) {
      style.closed = style.closed ?? true;
      return style
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return CylinderStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstanceItem(globeAttr, outline, item) {
      // style样式信息的处理
      const addattr = CylinderStyleConver.toCesiumVal({
        ...this.options.style,
        ...(item.style || {})
      });
      addattr.vertexFormat = addattr.vertexFormat || globeAttr.vertexFormat;

      // 颜色的处理
      let color = this._getColorByColorMaterial(addattr);
      if (outline && addattr.outlineColor) {
        color = addattr.outlineColor;
      }
      if (color.alpha !== 1) {
        this.translucent = true;
      }

      // 坐标或位置的处理
      const modelMatrix = this._getModelMatrix(item, addattr);

      // geometry的处理
      const GeometryClass = outline ? Cesium__namespace.CylinderOutlineGeometry : Cesium__namespace.CylinderGeometry;

      const instance = new Cesium__namespace.GeometryInstance({
        geometry: new GeometryClass(addattr),
        modelMatrix: modelMatrix,
        attributes: {
          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
          distanceDisplayCondition: addattr.distanceDisplayCondition
        }
      });
      return instance
    }
  }

  // 注册下
  register$4("cylinderC", CylinderCombine);

  /**
   * 大数据 四棱锥体 集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 面信息数组，单个对象包括：
   * @param {LngLatPoint|Cesium.Cartesian3|Array|Object} options.instances.position 坐标位置
   * @param {FrustumPrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {FrustumPrimitive.StyleOptions} [options.style] 所有面的公共样式信息
   * @param {FrustumPrimitive.StyleOptions} [options.highlight] 鼠标移入或单击后的对应高亮的部分样式
   * @param {String} [options.highlight.type] 触发高亮的方式，默认鼠标移入，可以指定为type:'click'为单击后高亮
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePointCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class FrustumCombine extends BasePointCombine {
    _conversionStyle(style) {
      style.closed = style.closed ?? true;
      return style
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return CylinderStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstanceItem(globeAttr, outline, item) {
      // style样式信息的处理
      const addattr = CylinderStyleConver.toCesiumVal({
        ...this.options.style,
        ...(item.style || {})
      });
      addattr.vertexFormat = addattr.vertexFormat || globeAttr.vertexFormat;

      // 颜色的处理
      let color = this._getColorByColorMaterial(addattr);
      if (outline && addattr.outlineColor) {
        color = addattr.outlineColor;
      }
      if (color.alpha !== 1) {
        this.translucent = true;
      }

      // 坐标或位置的处理
      const position = (item.position = LngLatPoint.parse(item.position).toCartesian());
      let _frustumFar, _orientation;
      if (item.targetPositio) {
        const targetPosition = LngLatPoint.parse(item.targetPosition).toCartesian();
        _frustumFar = Cesium__namespace.Cartesian3.distance(position, targetPosition);
        const hpr = getHeadingPitchRollForLine(position, targetPosition);
        _orientation = Cesium__namespace.Transforms.headingPitchRollQuaternion(position, hpr);
      } else {
        _frustumFar = -addattr.length;

        const hpr = new Cesium__namespace.HeadingPitchRoll(
          Cesium__namespace.Math.toRadians(addattr.heading || 0),
          Cesium__namespace.Math.toRadians(addattr.pitch || 0),
          Cesium__namespace.Math.toRadians(addattr.roll || 0)
        );
        _orientation = Cesium__namespace.Transforms.headingPitchRollQuaternion(position, hpr);
      }

      const _frustum = new Cesium__namespace.PerspectiveFrustum({
        fov: Cesium__namespace.Math.toRadians(addattr.angle * 2 || 0.01), // 视场角
        aspectRatio: addattr.angle2 / addattr.angle, // 视锥的宽度与高度的纵横比。
        near: 0.01, // 近平面的距离。
        far: _frustumFar // 远平面的距离。
      });

      // geometry的处理
      const GeometryClass = outline ? Cesium__namespace.FrustumOutlineGeometry : Cesium__namespace.FrustumGeometry;

      const instance = new Cesium__namespace.GeometryInstance({
        geometry: new GeometryClass({
          ...addattr,
          origin: position,
          orientation: _orientation,
          frustum: _frustum
        }),
        attributes: {
          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
          distanceDisplayCondition: addattr.distanceDisplayCondition
        }
      });
      return instance
    }
  }

  // 注册下
  register$4("frustumC", FrustumCombine);

  /**
   * 大数据 球体 集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 面信息数组，单个对象包括：
   * @param {LngLatPoint|Cesium.Cartesian3|Array|Object} options.instances.position 坐标位置
   * @param {EllipsoidPrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {EllipsoidPrimitive.StyleOptions} [options.style] 所有面的公共样式信息
   * @param {EllipsoidPrimitive.StyleOptions} [options.highlight] 鼠标移入或单击后的对应高亮的部分样式
   * @param {String} [options.highlight.type] 触发高亮的方式，默认鼠标移入，可以指定为type:'click'为单击后高亮
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePointCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class EllipsoidCombine extends BasePointCombine {
    _conversionStyle(style) {
      style.closed = style.closed ?? true;
      return style
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return EllipsoidStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstanceItem(globeAttr, outline, item) {
      // style样式信息的处理
      const addattr = EllipsoidStyleConver.toCesiumVal({
        ...this.options.style,
        ...(item.style || {})
      });
      addattr.vertexFormat = addattr.vertexFormat || globeAttr.vertexFormat;

      // 颜色的处理
      let color = this._getColorByColorMaterial(addattr);
      if (outline && addattr.outlineColor) {
        color = addattr.outlineColor;
      }
      if (color.alpha !== 1) {
        this.translucent = true;
      }

      // 坐标或位置的处理
      const modelMatrix = this._getModelMatrix(item, addattr);

      // geometry的处理
      const GeometryClass = outline ? Cesium__namespace.EllipsoidOutlineGeometry : Cesium__namespace.EllipsoidGeometry;

      const instance = new Cesium__namespace.GeometryInstance({
        geometry: new GeometryClass(addattr),
        modelMatrix: modelMatrix,
        attributes: {
          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
          distanceDisplayCondition: addattr.distanceDisplayCondition
        }
      });
      return instance
    }
  }

  // 注册下
  register$4("ellipsoidC", EllipsoidCombine);

  /**
   * 大数据线集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 线信息 数组，单个对象包括：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.instances.positions 坐标位置
   * @param {PolylinePrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {PolylinePrimitive.StyleOptions} [options.style] 所有线的公共样式信息
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取*
   * @extends {BasePolyCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PolylineCombine extends BasePolyCombine {
    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PolylineStyleConver.toJSON(czmStyle, styleJson)
    }

    _conversionStyle(style) {
      return PolylineStyleConver.toCesiumVal(style)
    }

    _createGeometryInstanceItem(globeAttr, outline, item) {
      // style样式信息的处理
      const addattr = PolylineStyleConver.toCesiumVal({
        ...this.options.style,
        ...(item.style || {})
      });
      if (globeAttr._isColorMaterial) {
        addattr.vertexFormat = Cesium__namespace.PolylineColorAppearance.VERTEX_FORMAT;
      }

      // 颜色的处理
      const color = this._getColorByColorMaterial(addattr);

      // 坐标或位置的处理
      const positions = (item.positions = LngLatArray.toCartesians(item.positions));
      addattr.positions = positions;

      // geometry的处理
      const GeometryClass = addattr.clampToGround ? Cesium__namespace.GroundPolylineGeometry : Cesium__namespace.PolylineGeometry;

      const instance = new Cesium__namespace.GeometryInstance({
        geometry: new GeometryClass(addattr),
        attributes: {
          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
          distanceDisplayCondition: addattr.distanceDisplayCondition
        }
      });
      return instance
    }

    _createAppearance(addattr, primitiveOpts) {
      if (addattr._isColorMaterial) {
        // 纯色时
        return new Cesium__namespace.PolylineColorAppearance({
          ...addattr
        })
      } else {
        // 存在材质时
        return new Cesium__namespace.PolylineMaterialAppearance({
          ...addattr
        })
      }
    }
  }

  // 注册下
  register$4("polylineCombine", PolylineCombine); // 兼容 v3.1 及之前版本
  register$4("polylineC", PolylineCombine);

  /**
   * 大数据线集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 线信息 数组，单个对象包括：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.instances.positions 坐标位置
   * @param {PolylineVolumePrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {PolylineVolumePrimitive.StyleOptions} [options.style] 所有线的公共样式信息
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取*
   * @extends {BasePolyCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PolylineVolumeCombine extends BasePolyCombine {
    _conversionStyle(style) {
      style.closed = style.closed ?? true;
      return style
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PolylineVolumeStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstanceItem(globeAttr, outline, item) {
      // style样式信息的处理
      const addattr = PolylineVolumeStyleConver.toCesiumVal({
        ...this.options.style,
        ...(item.style || {})
      });
      addattr.vertexFormat = addattr.vertexFormat || globeAttr.vertexFormat;

      // 颜色的处理
      let color = this._getColorByColorMaterial(addattr);
      if (outline && addattr.outlineColor) {
        color = addattr.outlineColor;
      }
      if (color.alpha !== 1) {
        this.translucent = true;
      }

      // 坐标或位置的处理
      const positions = (item.positions = LngLatArray.toCartesians(item.positions));

      // geometry的处理
      const GeometryClass = outline ? Cesium__namespace.PolylineVolumeOutlineGeometry : Cesium__namespace.PolylineVolumeGeometry;

      const instance = new Cesium__namespace.GeometryInstance({
        geometry: new GeometryClass({
          ...addattr,
          polylinePositions: positions,
          shapePositions: addattr.shape
        }),
        attributes: {
          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
          distanceDisplayCondition: addattr.distanceDisplayCondition
        }
      });
      return instance
    }
  }

  // 注册下
  register$4("polylineVolumeC", PolylineVolumeCombine);

  /**
   * 大数据 走廊 集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 线信息 数组，单个对象包括：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.instances.positions 坐标位置
   * @param {CorridorPrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {CorridorPrimitive.StyleOptions} [options.style] 所有线的公共样式信息
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取*
   * @extends {BasePolyCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class CorridorCombine extends BasePolyCombine {
    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return CorridorStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstanceItem(globeAttr, outline, item) {
      // style样式信息的处理
      const addattr = CorridorStyleConver.toCesiumVal({
        ...this.options.style,
        ...(item.style || {})
      });
      addattr.vertexFormat = addattr.vertexFormat || globeAttr.vertexFormat;

      // 颜色的处理
      let color = this._getColorByColorMaterial(addattr);
      if (outline && addattr.outlineColor) {
        color = addattr.outlineColor;
      }
      if (color.alpha !== 1) {
        this.translucent = true;
      }

      // 坐标或位置的处理
      item.positions = LngLatArray.toCartesians(item.positions);
      addattr.positions = item.positions;

      // geometry的处理
      const GeometryClass = outline ? Cesium__namespace.CorridorOutlineGeometry : Cesium__namespace.CorridorGeometry;

      const instance = new Cesium__namespace.GeometryInstance({
        geometry: new GeometryClass(addattr),
        attributes: {
          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
          distanceDisplayCondition: addattr.distanceDisplayCondition
        }
      });
      return instance
    }
  }

  // 注册下
  register$4("corridorC", CorridorCombine);

  /**
   * 大数据 墙 集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 线信息 数组，单个对象包括：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.instances.positions 坐标位置
   * @param {WallPrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {WallPrimitive.StyleOptions} [options.style] 所有线的公共样式信息
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取*
   * @extends {BasePolyCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class WallCombine extends BasePolyCombine {
    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return WallStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstanceItem(globeAttr, outline, item) {
      // style样式信息的处理
      const addattr = WallStyleConver.toCesiumVal({
        ...this.options.style,
        ...(item.style || {})
      });
      addattr.vertexFormat = addattr.vertexFormat || globeAttr.vertexFormat;

      // 颜色的处理
      let color = this._getColorByColorMaterial(addattr);
      if (outline && addattr.outlineColor) {
        color = addattr.outlineColor;
      }
      if (color.alpha !== 1) {
        this.translucent = true;
      }

      // 坐标或位置的处理
      const points = [];
      let positions = [];

      const len = item.positions;
      let minimumHeights = new Array(len);
      let maximumHeights = new Array(len);

      item.positions.forEach(function (item, i) {
        const _point = LngLatPoint.parse(item);
        if (!_point || !_point.valid()) {
          return
        }
        points.push(_point);
        positions.push(_point.toCartesian());

        const height = points[i].alt;
        minimumHeights[i] = height;
        maximumHeights[i] = height + Number(addattr.diffHeight || 100);
      });

      if (addattr.closure && positions?.length > 0) {
        positions = positions.concat(positions[0]);
        minimumHeights = minimumHeights.concat(minimumHeights[0]);
        maximumHeights = maximumHeights.concat(maximumHeights[0]);
      }

      // geometry的处理
      const GeometryClass = outline ? Cesium__namespace.WallOutlineGeometry : Cesium__namespace.WallGeometry;

      const instance = new Cesium__namespace.GeometryInstance({
        geometry: new GeometryClass({
          ...addattr,
          positions: positions,
          maximumHeights: maximumHeights,
          minimumHeights: minimumHeights
        }),
        attributes: {
          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
          distanceDisplayCondition: addattr.distanceDisplayCondition
        }
      });
      return instance
    }
  }

  // 注册下
  register$4("wallC", WallCombine);

  /**
   * 大数据面集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 面信息数组，单个对象包括：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.instances.positions 坐标位置
   * @param {PolygonPrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {PolygonPrimitive.StyleOptions} [options.style] 所有面的公共样式信息
   * @param {PolygonPrimitive.StyleOptions} [options.highlight] 鼠标移入或单击后的对应高亮的部分样式
  //  * @param {String} [options.highlight.type] 触发高亮的方式，默认鼠标移入，可以指定为type:'click'为单击后高亮
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @extends {BasePolyCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class PolygonCombine extends BasePolyCombine {
    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return PolygonStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstanceItem(globeAttr, outline, item) {
      // style样式信息的处理
      const addattr = PolygonStyleConver.toCesiumVal({
        ...this.options.style,
        ...(item.style || {})
      });
      addattr.vertexFormat = addattr.vertexFormat || globeAttr.vertexFormat;

      // 颜色的处理
      let color = this._getColorByColorMaterial(addattr);
      if (outline && addattr.outlineColor) {
        color = addattr.outlineColor;
      }
      if (color.alpha !== 1) {
        this.translucent = true;
      }

      // 坐标或位置的处理
      let _hierarchy;
      let positions;
      if (
        item.positions.length > 0 &&
        Array.isArray(item.positions[0]) &&
        item.positions[0].length > 0 &&
        Array.isArray(item.positions[0][0]) &&
        isNumber(item.positions[0][0][0])
      ) {
        _hierarchy = getPolygonHierarchy(item.positions);
        positions = _hierarchy.positions;
      } else {
        positions = item.positions = LngLatArray.toCartesians(item.positions);
        _hierarchy = new Cesium__namespace.PolygonHierarchy(positions);
      }
      item._hierarchy = _hierarchy; // outline需要使用
      addattr.polygonHierarchy = _hierarchy;

      // geometry的处理
      const GeometryClass = outline ? Cesium__namespace.PolygonOutlineGeometry : Cesium__namespace.PolygonGeometry;

      const instance = new Cesium__namespace.GeometryInstance({
        geometry: new GeometryClass(addattr),
        attributes: {
          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
          distanceDisplayCondition: addattr.distanceDisplayCondition
        }
      });
      return instance
    }

    // 边线坐标数组，支持多个线 [线坐标集合]
    _getPolylineOutlinePositions(item) {
      if (item._hierarchy) {
        return getHierarchyVal(item._hierarchy)
      } else if (item.positions) {
        return getHierarchyVal(LngLatArray.toCartesians(item.positions))
      }
    }

    // 动态更新面的高度
    updateHeight(height) {
      const eRadis = 6378137;
      const styleHeight = this.style?.height || 0;

      for (let i = 0, len = this.primitiveCollection.length; i < len; i++) {
        const primitive = this.primitiveCollection.get(i);

        const n = (eRadis + height) / (eRadis + styleHeight);
        const modelMatrix = Cesium__namespace.Matrix4.fromScale(new Cesium__namespace.Cartesian3(n, n, n));
        primitive.modelMatrix = modelMatrix;
      }
    }

    _getGeoJsonGeometry(item, options) {
      return { type: "Polygon", coordinates: [LngLatArray.toArray(item.positions, options?.noAlt)] }
    }
  }

  // 注册下
  register$4("polygonCombine", PolygonCombine); // 兼容 v3.1 及之前版本
  register$4("polygonC", PolygonCombine);

  /**
   * 大数据 水面集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 面信息数组，单个对象包括：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.instances.positions 坐标位置
   * @param {PolygonPrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {PolygonPrimitive.StyleOptions} [options.style] 所有面的公共样式信息
   * @param {PolygonPrimitive.StyleOptions} [options.highlight] 鼠标移入或单击后的对应高亮的部分样式
   * @param {String} [options.highlight.type] 触发高亮的方式，默认鼠标移入，可以指定为type:'click'为单击后高亮
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取*
   * @extends {PolygonCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class WaterCombine extends PolygonCombine {
    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show) {
        return
      }
      const addattr = this._conversionStyle(style);

      style.opacity = style.opacity ?? 0.8;

      const primitiveOpts = {
        geometryInstances: this._createGeometryInstance(addattr),
        appearance: new Cesium__namespace.EllipsoidSurfaceAppearance({
          aboveGround: false,
          material: new Cesium__namespace.Material({
            fabric: {
              type: "Water",
              uniforms: {
                specularMap: addattr.specularMap || Cesium__namespace.Material.DefaultImageId,
                normalMap: addattr.normalMap || Cesium__namespace.Material.DefaultImageId, // 水正常扰动的法线图。
                frequency: addattr.frequency || 8000.0, // 控制波数的数字。
                animationSpeed: addattr.animationSpeed || 0.03, // 控制水的动画速度的数字。
                amplitude: addattr.amplitude || 5.0, // 控制水波振幅的数字。
                specularIntensity: style.specularIntensity || 0.8, // 控制镜面反射强度的数字。
                baseWaterColor: getCesiumColor(style.baseWaterColor || "#123e59").withAlpha(style.opacity), // rgba颜色对象基础颜色的水。#00ffff,#00baff,#006ab4
                blendColor: getCesiumColor(style.blendColor || "#123e59").withAlpha(style.opacity) // 从水中混合到非水域时使用的rgba颜色对象。
              }
            }
          }),

          fragmentShaderSource: WaterFS,
          translucent: style.opacity !== 1.0
        }),
        show: this.show
      };

      if (style.clampToGround) {
        primitiveOpts.classificationType = style.classificationType ?? Cesium__namespace.ClassificationType.TERRAIN;
        this._primitive = this.primitiveCollection.add(new Cesium__namespace.GroundPrimitive(primitiveOpts));
      } else {
        this._primitive = this.primitiveCollection.add(new Cesium__namespace.Primitive(primitiveOpts));
      }
    }
  }

  // 注册下
  register$4("waterCombine", WaterCombine); // 兼容 v3.1 及之前版本
  register$4("waterC", WaterCombine);

  /**
   * 大数据矩形集合 (合并渲染) Primitive图元 矢量对象
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object[]} [options.instances] 面信息数组，单个对象包括：
   * @param {LngLatPoint[]|Cesium.Cartesian3[]|Array} options.instances.positions 坐标位置
   * @param {RectanglePrimitive.StyleOptions} [options.instances.style] 样式信息
   * @param {Object} [options.instances.attr] 矢量数据的 属性信息，可以任意附加属性。
   * @param {RectanglePrimitive.StyleOptions} [options.style] 所有面的公共样式信息
   * @param {RectanglePrimitive.StyleOptions} [options.highlight] 鼠标移入或单击后的对应高亮的部分样式
   * @param {String} [options.highlight.type] 触发高亮的方式，默认鼠标移入，可以指定为type:'click'为单击后高亮
   *
   * @param {Cesium.Appearance} [options.appearance] [cesium原生]用于渲染图元的外观。
   * @param {Cesium.Appearance} [options.attributes] [cesium原生]每个实例的属性。
   * @param {Cesium.Appearance} [options.depthFailAppearance] 当深度测试失败时，用于为该图元着色的外观。
   * @param {Boolean} [options.vertexCacheOptimize=false] 当true，几何顶点优化前和后顶点着色缓存。
   * @param {Boolean} [options.interleave=false] 当true时，几何顶点属性被交叉，这可以略微提高渲染性能，但会增加加载时间。
   * @param {Boolean} [options.compressVertices=true] 当true时，几何顶点被压缩，这将节省内存。提升效率。
   * @param {Boolean} [options.releaseGeometryInstances=true] 当true时，图元不保留对输入geometryInstances的引用以节省内存。
   * @param {Boolean} [options.allowPicking=true] 当true时，每个几何图形实例只能通过{@link Scene#pick}进行挑选。当false时，保存GPU内存。
   * @param {Boolean} [options.cull=true] 当true时，渲染器会根据图元的边界体积来剔除它们的截锥和地平线。设置为false，如果你手动剔除图元，可以获得较小的性能提升。
   * @param {Boolean} [options.asynchronous=true] 确定该图元是异步创建还是阻塞创建，直到就绪。
   * @param {Boolean} [options.debugShowBoundingVolume=false] 仅供调试。确定该图元命令的边界球是否显示。
   * @param {Boolean} [options.debugShowShadowVolume=false] 仅供调试。贴地时，确定是否绘制了图元中每个几何图形的阴影体积。必须是true创建卷之前要释放几何图形或选项。releaseGeometryInstance必须是false。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @extends {BasePolyCombine}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class RectangleCombine extends BasePolyCombine {
    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return RectangleStyleConver.toJSON(czmStyle, styleJson)
    }

    _createGeometryInstanceItem(globeAttr, outline, item) {
      // style样式信息的处理
      const addattr = RectangleStyleConver.toCesiumVal({
        ...this.options.style,
        ...(item.style || {})
      });
      addattr.vertexFormat = addattr.vertexFormat || globeAttr.vertexFormat;

      // 颜色的处理
      let color = this._getColorByColorMaterial(addattr);
      if (outline && addattr.outlineColor) {
        color = addattr.outlineColor;
      }
      if (color.alpha !== 1) {
        this.translucent = true;
      }

      // 坐标或位置的处理
      const positions = (item.positions = LngLatArray.toCartesians(item.positions));
      addattr.rectangle = Cesium__namespace.Rectangle.fromCartesianArray(positions);
      if (Cesium__namespace.defined(addattr.rectangle)) {
        if (Cesium__namespace.defined(this._rectangle)) {
          this._rectangle = Cesium__namespace.Rectangle.union(addattr.rectangle, this._rectangle);
        } else {
          this._rectangle = addattr.rectangle;
        }
      }

      // geometry的处理
      const GeometryClass = outline ? Cesium__namespace.RectangleOutlineGeometry : Cesium__namespace.RectangleGeometry;

      const instance = new Cesium__namespace.GeometryInstance({
        geometry: new GeometryClass(addattr),
        attributes: {
          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(color),
          distanceDisplayCondition: addattr.distanceDisplayCondition
        }
      });
      return instance
    }
  }

  // 注册下
  register$4("rectangleC", RectangleCombine);

  /**
   * DivGraphic对象，标绘处理对应的编辑类
   *
   * @export
   * @class EditDivGraphic
   * @extends {EditBase}
   */
  class EditDivGraphic extends EditBase {
    /**
     * 对应的DOM元素
     * @type {Element}
     * @readonly
     */
    get container() {
      return this._graphic._container
    }

    // 激活绘制
    activate() {
      if (this._enabled) {
        return this
      }
      this._enabled = true;

      this.container.addEventListener("mousemove", this._onMouseMove.bind(this)); // 鼠标移动
      this.container.addEventListener("mouseout", this._onMouseOut.bind(this)); // 鼠标移出
      this.container.addEventListener("mousedown", this._onMarkerDragStart.bind(this)); // 开始拖动事件

      addClass(this.container, this._graphic.style.editClassName || "mars3d-divGraphic-edit");

      this._graphic._draw_tooltip = this._map.getLangText("_拖动对象后") + "<br/>" + this._map.getLangText("_修改位置");

      this.fire(EventType.editStart);
      return this
    }

    // 释放绘制
    disable() {
      if (!this._enabled) {
        return this
      }
      this._enabled = false;

      delete this._graphic._draw_tooltip;

      this.container.removeEventListener("mousemove", this._onMouseMove); // 鼠标移动
      this.container.removeEventListener("mouseout", this._onMouseOut); // 鼠标移出
      this.container.removeEventListener("mousedown", this._onMarkerDragStart); // 开始拖动事件

      this.unbindEvent();
      removeClass(this.container, this._graphic.style.editClassName || "mars3d-divGraphic-edit");

      this.fire(EventType.editStop);
      return this
    }

    unbindEvent() {
      if (this._mouseMoveHandle) {
        document.removeEventListener("mousemove", this._mouseMoveHandle, false);
      }
      if (this._mouseUpHandle) {
        document.removeEventListener("mouseup", this._mouseUpHandle, false);
      }
      this._map.setCursor(false);
    }

    _onMouseMove(event) {
      if (this._graphic._draw_tooltip) {
        this._map.openSmallTooltip({ x: event.layerX, y: event.layerY }, this._graphic._draw_tooltip);
      }
    }

    _onMouseOut(event) {
      this._map.closeSmallTooltip();
    }

    _onMarkerDragStart(event) {
      if (!this._enabled || event.which !== 1) {
        return
      }
      event.preventDefault();

      this._map.setCursor(true);

      this.fire(EventType.editMouseDown, { mouseEvent: event });

      this.unbindEvent();

      if (!this._mouseMoveHandle) {
        this._mouseMoveHandle = (e) => {
          this._onMarkerDrag(e);
        };
        this._mouseUpHandle = (e) => {
          this._onMarkerDragEnd(e);
        };
      }

      document.addEventListener("mousemove", this._mouseMoveHandle, false);
      document.addEventListener("mouseup", this._mouseUpHandle, false);
    }

    _onMarkerDrag(event) {
      if (!this._enabled) {
        return
      }
      event.preventDefault();

      const windowPosition = new Cesium__namespace.Cartesian2(event.layerX, event.layerY);
      const cartesian = getCurrentMousePosition(this._map.scene, windowPosition);
      if (!cartesian) {
        return
      }

      this._graphic.position = cartesian;
      this._map.openSmallTooltip(windowPosition, this._map.getLangText("_释放后完成修改"));

      this.fire(EventType.editMouseMove, { mouseEvent: event, cartesian: cartesian, windowPosition: windowPosition });
    }

    _onMarkerDragEnd(event) {
      if (!this._enabled) {
        return
      }
      event.preventDefault();

      this.unbindEvent();
      this._map.closeSmallTooltip();

      const windowPosition = new Cesium__namespace.Cartesian2(event.layerX, event.layerY);
      const cartesian = getCurrentMousePosition(this._map.scene, windowPosition);
      if (cartesian) {
        this._graphic.position = cartesian;
      }

      this.fire(EventType.editMovePoint, { mouseEvent: event, cartesian: cartesian, windowPosition: windowPosition });
    }
  }

  /**
   * DIV点 支持的样式信息
   *
   * @typedef {Object} DivGraphic.StyleOptions
   *
   * @property {String|HTMLDivElement|Function} html Html文本
   *
   * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
   * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
   *
   * @property {Number} [offsetX] 用于非规则div时，横向偏移的px像素值
   * @property {Number} [offsetY] 用于非规则div时，垂直方向偏移的px像素值
   *
   * @property {String} [className]  自定义的样式名
   * @property {String} [editClassName="mars3d-divGraphic-edit"]  编辑状态下的的样式名
   *
   * @property {Boolean} [scaleByDistance = false] 是否按视距缩放
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   * @property {Boolean} [distanceDisplayCondition = false] 是否按视距显示
   * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   * @property {String} [css_transform_origin = 'left bottom 0'] DIV的 transform-origin css值
   * @property {Boolean} [timeRender] 是否实时刷新全部HTML，此时需要绑定html需传入回调方法。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   */


  /**
   * DIV点
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {DivGraphic.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {PointEntity.StyleOptions} [options.testPoint] 测试点 的对应样式 ，可以进行用于比较测试div的位置，方便调试CSS。
   * @param {Boolean} [options.pointerEvents=true] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
   * @param {Boolean} [options.hasZIndex=false] 是否自动调整DIV的层级顺序。
   * @param {Number|String} [options.zIndex="auto"] 指定固定的zIndex层级属性(当hasZIndex为true时无效)
   * @param {Boolean} [options.depthTest=true] 是否打开深度判断（true时判断是否在球背面）
   * @param {Boolean} [options.hasCache=true] 是否启用缓存机制，如为true，在视角未变化时不重新渲染。
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为当前图层所在的DOM layer.container
   *
   * @param {Number} [options.frameRate = 1] 多少帧获取更新一次DIV像素位置。用于控制效率，如果卡顿就把该数值调大一些。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @export
   * @class DivGraphic
   * @extends {BaseGraphic}
   *
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class DivGraphic extends BaseGraphic {
    constructor(options = {}) {
      super(options);

      options.styleType = options.styleType ?? "div";

      this._hasEdit = this.options.hasEdit ?? true; // 是否允许编辑
      this._depthTest = options.depthTest ?? true;
      this._hasCache = options.hasCache ?? true;
      this._hasZIndex = options.hasZIndex ?? false;
      this._css_transform_origin = this.style.css_transform_origin ?? "left bottom 0";

      this.options.frameRate = this.options.frameRate ?? 1;

      this.options.testPoint = merge(
        {
          name: "用于与DIV点进行对比测试位置的点",
          color: "#ff0000",
          pixelSize: 8,
          distanceDisplayCondition: this.style.distanceDisplayCondition,
          scaleByDistance: this.style.scaleByDistance,
          clampToGround: this.style.clampToGround,
          heightReference: this.style.heightReference
        },
        this.options.testPoint
      );

      // 坐标位置
      if (options.position) {
        this.position = options.position;
      }
    }

    //= ========= 对外属性 ==========
    /**
     * 位置坐标 （笛卡尔坐标）, 赋值时可以传入LatLngPoint对象
     * @type {Cesium.Cartesian3|LngLatPoint}
     */
    get position() {
      return this._position
    }

    set position(value) {
      this._point = LngLatPoint.parse(value);

      // 按配置调整高度值
      if (this._point) {
        let setHeight = this.style.setHeight;
        if (Cesium__namespace.defined(setHeight)) {
          if (isString(setHeight)) {
            setHeight = Number(template(setHeight, this.attr, true));
            if (isNaN(setHeight)) {
              setHeight = 0;
            }
          }
          this._point.alt = setHeight;
        }
        const addHeight = this.getAddHeight();
        if (addHeight !== 0) {
          this._point.alt = this._point.alt + addHeight;
        }
      }

      this._position = this._point?.toCartesian();

      if (this.debuggerPointEntity) {
        this.debuggerPointEntity.position = this._position;
      }

      this._updateDivPosition();

      this.fire(EventType.updatePosition, { position: this._position });
    }

    /**
     * 位置坐标 （笛卡尔坐标）
     * @type {LngLatPoint}
     * @readonly
     */
    get point() {
      return this._point
    }

    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @type {Array}
     * @readonly
     */
    get coordinate() {
      return this.getCoordinate()
    }

    // 中心点坐标，覆盖父类
    get center() {
      return this._position
    }

    /**
     * 当前实时位置坐标（笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get positionShow() {
      return this._position_show
    }

    /**
     * 是否显示测试点，可以进行用于比较测试div的位置，方便调试CSS。
     * @type {Boolean}
     */
    get testPoint() {
      return this.debuggerPointEntity != null
    }

    set testPoint(value) {
      if (this.debuggerPointEntity) {
        this._layer.dataSource.entities.remove(this.debuggerPointEntity);
        delete this.debuggerPointEntity;
      }
      // 添加实体
      if (value) {
        this.debuggerPointEntity = this._layer.dataSource.entities.add({
          name: this.options.testPoint.name,
          position: this.position,
          point: PointStyleConver.toCesiumVal(this.options.testPoint)
        });
      }
    }

    /**
     *  DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
     * @type {Boolean}
     */
    get pointerEvents() {
      return this.options.pointerEvents
    }

    set pointerEvents(value) {
      this.options.pointerEvents = value;
      this._updatePointerEvents(value);
    }

    /**
     * 是否正在编辑状态
     * @type {Boolean}
     * @readonly
     */
    get isEditing() {
      return this._enabledEdit
    }

    /**
     * 编辑处理类
     * @type {EditDivGraphic}
     * @readonly
     */
    get EditClass() {
      return EditDivGraphic
    }

    /**
     * 是否打开深度判断（true时判断是否在球背面）
     * @type {Boolean}
     */
    get depthTest() {
      return this._depthTest
    }

    set depthTest(value) {
      this._depthTest = value;
      this._camera_cache = null;
    }

    /**
     * 是否贴地
     * @type {Boolean}
     */
    get clampToGround() {
      return this.style.clampToGround
    }

    set clampToGround(value) {
      this.style.clampToGround = value;
      this._calculateAsynSurfacePosition();
    }

    /**
     *  父容器DOM对象
     * @type {HTMLElement}
     * @readonly
     */
    get parentContainer() {
      if (this.options.parentContainer) {
        return this.options.parentContainer
      }
      return this._layer.container
    }

    /**
     *  父容器DOM对象的ID
     * @type {String}
     * @readonly
     */
    get parentContainerId() {
      return this.parentContainer?.id
    }

    /**
     * 对应的DOM元素
     * @type {HTMLDivElement}
     * @readonly
     */
    get container() {
      return this._container
    }

    /**
     * 对应的DOM元素的id
     * @type {String}
     * @readonly
     */
    get containerId() {
      return this._container.id
    }

    /**
     * 设置或获取当前对象对应的Html
     * @type {String|HTMLDivElement}
     */
    get html() {
      return this._container.innerHTML
    }

    set html(content) {
      this.style.html = content;
      if (!this._container || !content) {
        return
      }

      if (typeof content === "function") {
        content = content(this.eventTarget);
      }
      if (content instanceof Promise) {
        content.then((inhtml) => {
          this._camera_cache = null;
          this.html = inhtml;
        });
        return
      }

      if (isString(content)) {
        if (this.style.template) {
          this._container.innerHTML = this.style.template.replace("{content}", content);
        } else {
          this._container.innerHTML = content;
        }
      } else if (content instanceof Element) {
        empty(this._container);

        if (content.style.display !== "block") {
          content.style.display = "block";
        }
        this._container.appendChild(content);
      }

      if (this.style.className) {
        if (this._container.children?.length > 0) {
          for (let i = 0, len = this._container.children.length; i < len; i++) {
            const child = this._container.children[i];
            addClass(child, this.style.className);
          }
        } else {
          addClass(this._container, this.style.className);
        }
      }

      if (this._appendHtmlHook) {
        this._appendHtmlHook();
      }
      this._camera_cache = null;
    }

    get divWidth() {
      return this._container?.offsetWidth
    }

    get divHeight() {
      return this._container?.offsetHeight
    }

    // 事件对象
    get eventTarget() {
      return this
    }

    //= ========= 方法 ==========
    _showHook(val) {
      if (!this._container) {
        return
      }
      if (val) {
        this._camera_cache = null;
        this._container.style.display = "block";
      } else {
        this.hide();
      }
      if (this.debuggerPointEntity) {
        this.debuggerPointEntity.show = val;
      }
    }

    _updatePointerEvents(value) {
      if (this._container) {
        if (value) {
          this._container.style["pointer-events"] = "all";
        } else {
          /* 加上这个css后鼠标可以穿透，但是无法触发单击等鼠标事件 */
          this._container.style["pointer-events"] = "none";
        }
      }
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this.style.globalAlpha = value;

      if (this._container) {
        this._container.style.opacity = value;
      }
    }

    // 对象是否存在鼠标事件相关绑定
    hasBindEvent() {
      // 判断本身是否绑定
      if (this.listens(EventType.click)) {
        return true
      }
      if (this.listens(EventType.mouseOver)) {
        return true
      }
      if (this.listens(EventType.mouseOut)) {
        return true
      }
      if (this.hasPopup(false)) {
        return true
      }
      if (this.hasTooltip(false)) {
        return true
      }

      // 如果有设置，直接取默认设置后的
      if (Cesium__namespace.defined(this.options.pointerEvents)) {
        return this.options.pointerEvents
      }

      // 判断图层是否绑定
      if (this._layer?.listens(EventType.click)) {
        return true
      }
      if (this._layer?.listens(EventType.mouseOver)) {
        return true
      }
      if (this._layer?.listens(EventType.mouseOut)) {
        return true
      }
      if (this.hasPopup(true)) {
        return true
      }
      if (this.hasTooltip(true)) {
        return true
      }

      return false
    }

    _onEventHook() {
      this._updatePointerEvents(this.hasBindEvent());
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      DivGraphicStyleConver.toCesiumVal(this.style, this);

      this._container = create$3("div", "mars3d-divGraphic ", this.parentContainer);
      this._container.id = this.id;
      this._container.style.opacity = this.style.globalAlpha;

      // 添加html
      if (this.style.html) {
        this.html = this.style.html;
      }

      this._updatePointerEvents(this.hasBindEvent());
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      this._layer.container.appendChild(this._container);
      this.hide();

      // 绑定事件
      this._container.addEventListener("click", this._container_onClickHandler.bind(this)); // 单击事件
      this._container.addEventListener("mousedown", this._container_onMousedownHandler.bind(this)); // 右击事件
      this._container.addEventListener("mousemove", this._container_onMouseMoveHandler.bind(this)); // 鼠标移入
      this._container.addEventListener("mouseout", this._container_onMouseoutHandler.bind(this)); // 鼠标移出

      this._calculateAsynSurfacePosition();

      // this._map.on(EventType.postRender, this._onPostRenderHandler, this)
      // this._onPostRenderHandler()
      this.bindUpdateEvent();
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.off(EventType.terrainChange, this._onTerrainChangeHandler, this);
      // this._map.off(EventType.postRender, this._onPostRenderHandler, this)

      this.testPoint = false;

      // 绑定事件
      this._container.removeEventListener("click", this._container_onClickHandler); // 单击事件
      this._container.removeEventListener("mousedown", this._container_onMousedownHandler); // 右击事件
      this._container.removeEventListener("mousemove", this._container_onMouseMoveHandler); // 鼠标移入
      this._container.removeEventListener("mouseout", this._container_onMouseoutHandler); // 鼠标移出

      remove(this._container);
    }

    // 异步处理贴地坐标
    _calculateAsynSurfacePosition() {
      this._camera_cache = null;
      this._hasAsynSurfacePosition = false;

      const position = this.position;
      if (
        position instanceof Cesium__namespace.Cartesian3 &&
        (this.style.clampToGround ||
          this.style.heightReference === Cesium__namespace.HeightReference.CLAMP_TO_GROUND ||
          this.style.heightReference === Cesium__namespace.HeightReference.RELATIVE_TO_GROUND)
      ) {
        getSurfaceHeight(this._map.scene, position, {
          has3dtiles: this.options.has3dtiles
        }).then((result) => {
          if (this.style.heightReference === Cesium__namespace.HeightReference.RELATIVE_TO_GROUND) {
            result.point.alt += result.height_original;
          }
          this.position = result.point;
          this._hasAsynSurfacePosition = true;
        });

        this._map.on(EventType.terrainChange, this._onTerrainChangeHandler, this);
        this._map.on(EventType.terrainChange, this._onTerrainChangeHandler, this);
      }
    }

    _onTerrainChangeHandler(event) {
      if (this._map) {
        this._calculateAsynSurfacePosition();
      }
    }

    /**
     * 设置 样式信息 的钩子方法
     *
     * @param {Object} newStyle 本次更新的部分样式信息
     * @return {void}  无
     * @private
     */
    _updateStyleBaseHook(newStyle) {
      if (newStyle.html) {
        this.html = newStyle.html;
      }
      DivGraphicStyleConver.toCesiumVal(this.style, this);
      this._camera_cache = null;
      this._updateDivPosition();
      return this
    }

    /**
     * 更新刷新下DIV的位置，可以外部主动驱动来更新。
     * @return {DivGraphic} 当前对象本身，可以链式调用
     */
    updateDivPosition() {
      this._camera_cache = null;
      this._updateDivPosition();
      return this
    }

    update(frameState) {
      if (!this._map) {
        return
      }

      if (this.style.timeRender && this.style.html) {
        this.html = this.style.html;
      }
      this._updateDivPosition();

      this.fire(EventType.postRender, { container: this.container }, false);
      this.fireTarget && this.fireTarget(EventType.postRender, { container: this.container }, false);
    }

    // 图层中的postRender事件中来调用
    _updateDivPosition() {
      if (!this.show || !this._map) {
        return false
      }

      const scene = this._map.scene;
      const camera = this._map.camera;

      let _position = getPositionValue(this.position, this._map?.clock.currentTime);

      if (!Cesium__namespace.defined(_position)) {
        this.hide();
        return false
      }

      // 如果视角和位置都没有变化，直接返回
      if (this._hasCache) {
        const _thiscache = {
          x: _position.x,
          y: _position.y,
          z: _position.z,
          p1: this._map.container.clientWidth,
          p2: this._map.container.clientHeight,
          p3: camera.positionWC.x,
          p4: camera.positionWC.y,
          p5: camera.positionWC.z,
          p6: camera.heading,
          p7: camera.pitch,
          p8: camera.roll
        };
        if (
          this._camera_cache &&
          _thiscache.x === this._camera_cache.x &&
          _thiscache.x === this._camera_cache.x &&
          _thiscache.y === this._camera_cache.y &&
          _thiscache.z === this._camera_cache.z &&
          _thiscache.p1 === this._camera_cache.p1 &&
          _thiscache.p2 === this._camera_cache.p2 &&
          _thiscache.p3 === this._camera_cache.p3 &&
          _thiscache.p4 === this._camera_cache.p4 &&
          _thiscache.p5 === this._camera_cache.p5 &&
          _thiscache.p6 === this._camera_cache.p6 &&
          _thiscache.p7 === this._camera_cache.p7 &&
          _thiscache.p8 === this._camera_cache.p8
        ) {
          return true
        }
        this._camera_cache = _thiscache;
      }
      // 如果视角和位置都没有变化，直接返回

      if (!this._hasAsynSurfacePosition) {
        // 贴地计算影响性能！！
        if (this.style.clampToGround || this.style.heightReference === Cesium__namespace.HeightReference.CLAMP_TO_GROUND) {
          _position = getSurfacePosition(this._map.scene, _position);
        } else if (this.style.heightReference === Cesium__namespace.HeightReference.RELATIVE_TO_GROUND) {
          _position = getSurfacePosition(this._map.scene, _position, { relativeHeight: true });
        }
      }

      this._position_show = _position;

      const windowPosition = Cesium__namespace.SceneTransforms.wgs84ToWindowCoordinates(scene, _position);
      const distanceDisplayCondition = this.distanceDisplayCondition; // 是DivGraphicStyleConver.toCesiumVal(this.style, this)绑定的
      const scaleByDistance = this.scaleByDistance; // 是DivGraphicStyleConver.toCesiumVal(this.style, this)绑定的

      let camera_distance = camera.positionCartographic.height;
      if (this._hasZIndex || distanceDisplayCondition || scaleByDistance) {
        if (scene.mode === Cesium__namespace.SceneMode.SCENE3D) {
          camera_distance = Cesium__namespace.Cartesian3.distance(_position, camera.positionWC);
        }
      }

      if (
        !windowPosition ||
        (distanceDisplayCondition && (distanceDisplayCondition.near > camera_distance || distanceDisplayCondition.far < camera_distance))
      ) {
        if (this._container.style.display === "block") {
          // 如果node是显示则隐藏
          this.hide();
        }
        return false
      }

      // 判断是否在球的背面
      if (this.depthTest && scene.mode === Cesium__namespace.SceneMode.SCENE3D) {
        // 三维模式下
        const occluder = new Cesium__namespace.EllipsoidalOccluder(scene.globe.ellipsoid, scene.camera.positionWC);
        const show = occluder.isPointVisible(_position); // 地球椭球体背面判断处理
        // visible为true说明点在球的正面，否则点在球的背面。
        // 需要注意的是不能用这种方法判断点的可见性，如果球放的比较大，点跑到屏幕外面，它返回的依然为true
        if (!show) {
          if (this._container.style.display === "block") {
            // 如果node是显示则隐藏
            this.hide();
          }
          return false
        }
      }
      // 判断是否在球的背面

      if (this._container.style.display !== "block") {
        // 如果node是隐藏的则显示node元素
        this._camera_cache = null;
        this._container.style.display = "block";
      }

      // 求xy位置
      const height = this.divHeight; // 需要是显示状态，才有值
      const width = this.divWidth;

      let x;
      let y;

      switch (this.horizontalOrigin) {
        case "CENTER":
        case Cesium__namespace.HorizontalOrigin.CENTER:
          x = windowPosition.x - width / 2;
          break
        case "RIGHT":
        case Cesium__namespace.HorizontalOrigin.RIGHT:
          x = windowPosition.x - width;
          break
        case "LEFT":
        case Cesium__namespace.HorizontalOrigin.LEFT:
        default:
          x = windowPosition.x;
          break
      }
      switch (this.verticalOrigin) {
        case "TOP":
        case Cesium__namespace.VerticalOrigin.TOP:
          y = windowPosition.y;
          break
        case "CENTER":
        case Cesium__namespace.VerticalOrigin.CENTER:
          y = windowPosition.y - height / 2;
          break
        case "BOTTOM":
        case Cesium__namespace.VerticalOrigin.BOTTOM:
        default:
          y = windowPosition.y - height;
          break
      }

      if (this.style.anchor) {
        x += this.style.anchor[0];
        y += this.style.anchor[1];
      } else {
        if (this.style.offsetX) {
          x += this.style.offsetX;
        }
        if (this.style.offsetY) {
          y += this.style.offsetY;
        }
      }

      // 求缩放比例
      let scale = 1;
      if (scaleByDistance) {
        if (camera_distance <= scaleByDistance.near) {
          scale = scaleByDistance.nearValue;
        } else if (camera_distance > scaleByDistance.near && camera_distance < scaleByDistance.far) {
          scale =
            scaleByDistance.nearValue +
            ((scaleByDistance.farValue - scaleByDistance.nearValue) * (camera_distance - scaleByDistance.near)) /
              (scaleByDistance.far - scaleByDistance.near);
        } else {
          scale = scaleByDistance.farValue;
        }
      }

      const css_transform = "matrix(" + scale + ",0,0," + scale + "," + x + "," + y + ")";
      const css_transform_origin = this._css_transform_origin;

      let zIndex = this.options.zIndex || "auto";
      if (this._hasZIndex) {
        zIndex = Math.round(9999999 - camera_distance);
        if (zIndex <= 0) {
          zIndex = 9999999;
        }
      }

      merge(this._container.style, {
        transform: css_transform,
        "transform-origin": css_transform_origin,
        "-ms-transform": css_transform /* IE 9 */,
        "-ms-transform-origin": css_transform_origin,
        "-webkit-transform": css_transform /* Safari 和 Chrome */,
        "-webkit-transform-origin": css_transform_origin,
        "-moz-transform": css_transform /* Firefox */,
        "-moz-transform-origin": css_transform_origin,
        "-o-transform": css_transform /* Opera */,
        "-o-transform-origin": css_transform_origin,
        "z-index": zIndex
      });

      this.fire(
        EventType.change,
        {
          position: _position,
          windowPosition: windowPosition,
          distance: camera_distance,
          x: x,
          y: y,
          height: height,
          width: width,
          scale: scale
        },
        true
      );
    }

    /**
     * 隐藏当前对象
     * @return {void}  无
     */
    hide() {
      this._container.style.display = "none";
      this._camera_cache = null;
    }

    _getGeoJsonGeometry(options) {
      return { type: "Point", coordinates: this.getCoordinate(options?.noAlt) }
    }

    /**
     * 设置并添加动画轨迹位置，按“指定时间”运动到达“指定位置”。
     *
     * @param {LngLatPoint|Cesium.Cartesian3|Number[]} point 指定位置坐标
     * @param {Cesium.JulianDate|Date|String|Number} [currTime] 指定时间, 默认为当前时间。当为String时，可以传入'2021-01-01 12:13:00'; 当为Number时，可以传入当前时间延迟的秒数。
     * @return {DivGraphic} 当前对象本身，可以链式调用
     */
    addDynamicPosition(point, currTime) {
      if (!this.property) {
        const property = new Cesium__namespace.SampledPositionProperty();
        property.forwardExtrapolationType = this.options.forwardExtrapolationType ?? Cesium__namespace.ExtrapolationType.HOLD;
        property.backwardExtrapolationType = this.options.backwardExtrapolationType ?? Cesium__namespace.ExtrapolationType.HOLD;

        if (!this.options.orientation) {
          this.options.orientation = new Cesium__namespace.VelocityOrientationProperty(property);
          if (this._entity) {
            this._entity.orientation = this.getOrientation();
          }
        }
        this.property = property;
        this.position = property;

        this._maxCacheCount = this.options.maxCacheCount ?? 50; // 保留的坐标点数量
      } else if (this.property !== this.position) {
        this.position = this.property;
      }

      this._removeDynamicPosition();

      if (!currTime) {
        currTime = this._map?.clock?.currentTime || Cesium__namespace.JulianDate.now();
      } else if (isNumber(currTime)) {
        const now = this._map?.clock?.currentTime || Cesium__namespace.JulianDate.now();
        currTime = Cesium__namespace.JulianDate.addSeconds(now, currTime, new Cesium__namespace.JulianDate());
      } else if (isString(currTime)) {
        if (currTime.indexOf("Z") === -1) {
          currTime = Cesium__namespace.JulianDate.fromDate(new Date(currTime));
        } else {
          currTime = Cesium__namespace.JulianDate.fromIso8601(currTime);
        }
      } else if (currTime instanceof Date) {
        currTime = Cesium__namespace.JulianDate.fromDate(currTime);
      }

      const pt = LngLatPoint.parse(point).toCartesian();
      this.position.addSample(currTime, pt);

      return this
    }

    _removeDynamicPosition() {
      if (this._maxCacheCount < 1) {
        return
      }

      const times = this.property?._property?._times;
      if (!times || times.length === 0) {
        return
      }

      const removeCount = times.length - this._maxCacheCount - 1;

      if (removeCount > 0) {
        this.property.removeSamples(
          new Cesium__namespace.TimeInterval({
            start: times[0],
            stop: times[removeCount]
          })
        );
      }
    }

    /**
     * 位置坐标(数组对象)，示例[113.123456,31.123456,30.1]
     * @param {Boolean} noAlt true时不导出高度值
     * @return {Array} 位置坐标(数组对象)
     */
    getCoordinate(noAlt) {
      if (this.point) {
        return this.point.toArray(noAlt)
      } else {
        return []
      }
    }

    /**
     * 高亮对象。
     * @param {Object} [highlightStyle] 高亮的样式，具体见各{@link GraphicType}矢量数据的style参数。
     * @param {Boolean} [closeLast=true] 是否清除地图上上一次的高亮对象
     * @return {void}  无
     */
    openHighlight(highlightStyle, closeLast = true) {
      if (closeLast) {
        this._map.closeHighlight();
        this._map.last_highlighGraphic = this;
      }

      const style = highlightStyle || this._highlightOptions || this._layer?._highlightOptions;
      if (style && style.className) {
        for (let i = 0, len = this._container.children.length; i < len; i++) {
          const child = this._container.children[i];
          addClass(child, style.className);
        }
        this._highlightOptions = style;
        this.fire(EventType.highlightOpen, {}, true);
      }
    }

    /**
     * 清除已选中的高亮，原有style的配置项需要与highlightStyle配置有一一对应关系，否则无法清除
     * @return {void}  无
     */
    closeHighlight() {
      if (this._state !== State.ADDED || this._map?.last_highlighGraphic !== this) {
        return
      }

      this._map._clearLastHighlight();

      const style = this._highlightOptions;
      if (style && style.className) {
        for (let i = 0, len = this._container.children.length; i < len; i++) {
          const child = this._container.children[i];
          removeClass(child, style.className);
        }
        this.fire(EventType.highlightClose, {}, true);
      }
    }

    //= =================事件相关=================

    _getEventTarget(event) {
      if (event.stopPropagation) {
        event.stopPropagation();
      }

      const windowPosition = new Cesium__namespace.Cartesian2(event.layerX, event.layerY);

      const result = {
        mouseEvent: event,
        cartesian: this.position,
        windowPosition: windowPosition,
        sourceTarget: this,
        graphic: this,
        layer: this._layer
      };

      if (this._layer && (this._layer._graphic_drawing || (this._layer._hasEdit && this.hasEdit))) {
        result.cartesian = getCurrentMousePosition(this._map.scene, windowPosition);
      }

      return result
    }

    // 单击事件
    _container_onClickHandler(event) {
      const result = this._getEventTarget(event);
      result.position = result.windowPosition;

      this.fire(EventType.click, result, true);
    }

    // 右击事件
    _container_onMousedownHandler(event) {
      if (event.button !== 2) {
        return // 非右击时 跳出
      }

      const result = this._getEventTarget(event);
      result.position = result.windowPosition;

      this.fire(EventType.rightClick, result, true);
    }

    // 鼠标移动
    _container_onMouseMoveHandler(event) {
      this._map.mouseEvent.clearMoveTargetDelay();

      const result = this._getEventTarget(event);
      result.endPosition = result.windowPosition;

      // map上抛出事件
      this._map.fire(EventType.mouseMove, result);
      this._map.fire(EventType.mouseMoveTarget, result);

      // 移入事件
      if (!this._hasMouseOver) {
        this.fire(EventType.mouseOver, result, true);
      }
      this._hasMouseOver = true;
    }

    // 鼠标移出
    _container_onMouseoutHandler(event) {
      this._hasMouseOver = false;

      const result = this._getEventTarget(event);
      this.fire(EventType.mouseOut, result, true);
    }

    /**
     * 异步计算更新坐标高度进行贴地(或贴模型)，内部自动调用{@link PointUtil#getSurfaceHeight}方法处理。
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @return {Promise<Object>} 异步计算完成的Promise
     */
    autoSurfaceHeight(options = {}) {
      return getSurfaceHeight(this._map.scene, this.position, options).then((result) => {
        if (result.position) {
          this.position = result.position;
        }
      })
    }

    // 转换style为可以导出的json
    _style2Json(czmStyle, styleJson) {
      return DivGraphicStyleConver.toJSON(czmStyle, styleJson, true)
    }

    /**
     * 获取数据的矩形边界
     * @param {Boolean} [options] 控制参数
     * @param {Boolean} [options.isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */
    getRectangle(options) {
      const position = this.positionShow;
      if (!position) {
        return
      }

      const extent = getRectangle([position], options?.isFormat);
      return extent
    }

    //= =================Draw绘制相关=================

    /**
     * 开始绘制创建矢量数据，绘制的数据会加载在layer图层。
     *
     * @param {GraphicLayer} layer 图层
     * @return {void}  无
     */
    startDraw(layer) {
      if (this._enabledDraw) {
        return this
      }
      this._enabledDraw = true;

      if (layer) {
        this.addTo(layer);
      }
      if (!this._map) {
        throw new Error("绘制时_map不能为空,请将对象添加到图层，并且图层已添加到Map")
      }

      this._map._setEditCursor(true);
      this.enableControl(false);

      this._startDrawHook();

      this.fire(
        EventType.drawStart,
        {
          drawtype: this.type,
          graphic: this
        },
        true
      );
    }

    /**
     * 停止绘制，如有未完成的绘制会自动删除
     * @return {void}  无
     */
    stopDraw() {
      if (!this._enabledDraw) {
        return this
      }

      this._stopDrawHook();

      this._map._setEditCursor(false);
      this.enableControl(true);
      this._map.closeSmallTooltip();

      this._enabledDraw = false;

      this.fire(
        EventType.drawCreated,
        {
          drawtype: this.type,
          graphic: this
        },
        true
      );

      if (this.options?.success) {
        this.options.success(this);
      }
      if (this.options?._promise?.resolve) {
        this.options._promise.resolve(this);
      }
    }

    _startDrawHook() {
      this._updatePointerEvents(false);

      this._map.on(EventType.mouseMove, this._onMouseMoveHandler_point, this);
      this._map.on(EventType.click, this._onClickHandler_point, this);
    }

    _stopDrawHook() {
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler_point, this);
      this._map.off(EventType.click, this._onClickHandler_point, this);

      this._updatePointerEvents(this.hasBindEvent());
    }

    _onMouseMoveHandler_point(event) {
      const point = event.cartesian;
      if (point) {
        this.position = point;
      }
      this._map.openSmallTooltip(event.endPosition, this._draw_tooltip || this._map.getLangText("_单击完成绘制"));

      this.fire(
        EventType.drawMouseMove,
        {
          ...event,
          drawtype: this.type,
          graphic: this
        },
        true
      );
    }

    _onClickHandler_point(event) {
      const point = event.cartesian;
      if (point) {
        this.position = point;
      }
      this.stopDraw();
    }

    _setPositionsToCallback() {}
    _cancelPositionsCallback() {}

    /**
     * 完成绘制和编辑，如有未完成的绘制会自动完成。
     * 在移动端需要调用此方法来类似PC端双击结束。
     * @return {void}  无
     */
    endDraw() {
      if (!this._enabledDraw) {
        return this
      }
      // 点数不够
      if (this._positions_draw.length < this._minPointNum) {
        return
      }

      this.updateAttrForDrawing(false);
      this.stopDraw();
    }

    updateAttrForDrawing(isEditing) {}

    /**
     * 启用或禁用popup、tooltip、contextmenu内部控件，
     * 主要用于标绘时来关闭避免交互冲突。
     * @param {Boolean} value 是否启用
     * @return {void}  无
     */
    enableControl(value) {
      this._map.mouseEvent.enabledMoveTarget = value;
      if (this._map.popup) {
        this._map.popup.enabled = value;
      }
      if (this._map.tooltip) {
        this._map.tooltip.enabled = value;
      }
    }

    //= =================Draw编辑相关=================
    /**
     * 开始编辑对象
     * @return {void}  无
     */
    startEditing() {
      if (this._enabledEdit) {
        return this
      }
      this._enabledEdit = true;

      if (!this._map) {
        throw new Error("编辑时_map不能为空,请将对象添加到图层，并且图层已添加到Map")
      }

      this._draw_tooltip = this._map.getLangText("_释放后完成修改");

      this.enableControl(false);

      // 绑定事件
      this._container.removeEventListener("click", this._container_onClickHandler); // 单击事件
      // this._container.removeEventListener("mousedown", this._container_onMousedownHandler); //右击事件
      this._container.removeEventListener("mousemove", this._container_onMouseMoveHandler); // 鼠标移入
      this._container.removeEventListener("mouseout", this._container_onMouseoutHandler); // 鼠标移出

      if (!this.editing) {
        this.editing = new this.EditClass(this);
      }

      if (this.editing.activate) {
        this.editing.activate();
      }
    }

    /**
     * 停止编辑，释放正在编辑的对象。
     * @return {void}  无
     */
    stopEditing() {
      if (!this._enabledEdit) {
        return this
      }

      if (this.editing?.disable) {
        this.editing.disable();
      }

      this.enableControl(true);
      this._map.closeSmallTooltip();

      // 绑定事件
      this._container.addEventListener("click", this._container_onClickHandler.bind(this)); // 单击事件
      // this._container.addEventListener("mousedown", this._container_onMousedownHandler.bind(this)); //右击事件
      this._container.addEventListener("mousemove", this._container_onMouseMoveHandler.bind(this)); // 鼠标移入
      this._container.addEventListener("mouseout", this._container_onMouseoutHandler.bind(this)); // 鼠标移出

      this._enabledEdit = false;
    }
  }
  // 对类是否为点状数据的判断,GraphicUtil内用到
  DivGraphic.isPoint = true;

  // 注册下
  register$4("div", DivGraphic);

  /**
   * 动态边框文本 支持的样式信息
   *
   * @typedef {Object} DivBoderLabel.StyleOptions
   *
   * @property {String} text 文本内容
   * @property {Number} [font_size = 15] 字体大小
   * @property {String} [font_family = "楷体"] 字体 ,可选项：微软雅黑,宋体,楷体,隶书,黑体 等
   * @property {String} [color = "#ccc"] 文本CSS颜色
   * @property {String} [boderColor = "rgb(21, 209, 242)"] 边框CSS颜色
   * @property {Number} [width] 面板宽度（px像素值），默认根据文本内容和字体大小自动计算
   * @property {Number} [height] 面板高度（px像素值），默认根据文本内容和字体大小自动计算
   *
   * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
   * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
   *
   * @property {Number} [offsetX] 用于非规则div时，横向偏移的px像素值
   * @property {Number} [offsetY] 用于非规则div时，垂直方向偏移的px像素值
   *
   * @property {Boolean} [scaleByDistance = false] 是否按视距缩放
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   * @property {Boolean} [distanceDisplayCondition = false] 是否按视距显示
   * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   * @property {String} [css_transform_origin = 'left bottom 0'] DIV的 transform-origin css值
   * @property {Boolean} [timeRender] 是否实时刷新全部HTML，此时需要绑定html需传入回调方法。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   */

  const DEF_STYLE$7 = {
    font_size: 15,
    font_family: "楷体",
    color: "#ccc",
    boderColor: "rgb(21, 209, 242)",
    horizontalOrigin: Cesium__namespace.HorizontalOrigin.CENTER,
    verticalOrigin: Cesium__namespace.VerticalOrigin.CENTER
  };

  /**
   * 动态边框文本 DIV点
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {DivBoderLabel.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {PointEntity.StyleOptions} [options.testPoint] 测试点 的对应样式 ，可以进行用于比较测试div的位置，方便调试CSS。
   * @param {Boolean} [options.pointerEvents=true] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
   * @param {Boolean} [options.hasZIndex=false] 是否自动调整DIV的层级顺序。
   * @param {Number|String} [options.zIndex="auto"] 指定固定的zIndex层级属性(当hasZIndex为true时无效)
   * @param {Boolean} [options.depthTest=true] 是否打开深度判断（true时判断是否在球背面）
   * @param {Boolean} [options.hasCache=true] 是否启用缓存机制，如为true，在视角未变化时不重新渲染。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @export
   * @class DivBoderLabel
   * @extends {DivGraphic}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class DivBoderLabel extends DivGraphic {
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$7,
        ...(options.style || {})
      };

      const color = options.style.color;
      const boderColor = options.style.boderColor;
      const shadowColor = Cesium__namespace.Color.fromCssColorString(boderColor).withAlpha(0.56).toCssColorString();

      const font_size = options.style.font_size;
      const width = options.style.width || getStrLength(options.style.text) * font_size * 0.6;
      const height = options.style.height || font_size * 2;

      options.style.html = `
     <div class="mars3d-divBoderLabel" style="
     --text-font-size: ${font_size}px;
     --boder-width: ${width}px;
     --clip-width-1: ${width + font_size}px;
     --clip-width-2: ${width + font_size - 2}px;
     --boder-height: ${height}px;
     --clip-height-1: ${height + 10}px;
     --clip-height-2: ${height + 8}px;
     --text-color: ${color};
     --border-color: ${boderColor};
     --box-shadow-color: ${shadowColor};">
        <div class="mars3d-divBoderLabel-boder">
          <span class="mars3d-divBoderLabel-text" style="font-family:${options.style.font_family};">${options.style.text}</span>
        </div>
     </div> `;
      super(options);

      this._divWidth = width;
      this._divHeight = height;
    }

    get divWidth() {
      return this._divWidth
    }

    get divHeight() {
      return this._divHeight
    }

  }

  // 注册下
  register$4("divBoderLabel", DivBoderLabel);

  /**
   * 动画的扩散div点 支持的样式信息
   *
   * @typedef {Object} DivLightPoint.StyleOptions
   *
   * @property {String} [color='#f33349'] 点的颜色
   * @property {Number} [size=10] 高宽大小，单位:像素
   * @property {Object} [label] 文本
   * @property {String} [label.text] 文本内容
   * @property {String} [label.color] 文本颜色
   *
   * @property {Number} [offsetX] 用于非规则div时，横向偏移的px像素值
   * @property {Number} [offsetY] 用于非规则div时，垂直方向偏移的px像素值
   *
   * @property {Boolean} [scaleByDistance = false] 是否按视距缩放
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   * @property {Boolean} [distanceDisplayCondition = false] 是否按视距显示
   * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   * @property {String} [css_transform_origin = 'left bottom 0'] DIV的 transform-origin css值
   * @property {Boolean} [timeRender] 是否实时刷新全部HTML，此时需要绑定html需传入回调方法。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   */

  const DEF_STYLE$6 = {
    color: "#f33349",
    horizontalOrigin: Cesium__namespace.HorizontalOrigin.CENTER,
    verticalOrigin: Cesium__namespace.VerticalOrigin.CENTER
  };

  /**
   * 动画的扩散div点
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {DivLightPoint.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {PointEntity.StyleOptions} [options.testPoint] 测试点 的对应样式 ，可以进行用于比较测试div的位置，方便调试CSS。
   * @param {Boolean} [options.pointerEvents=true] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
   * @param {Boolean} [options.hasZIndex=false] 是否自动调整DIV的层级顺序。
   * @param {Number|String} [options.zIndex="auto"] 指定固定的zIndex层级属性(当hasZIndex为true时无效)
   * @param {Boolean} [options.depthTest=true] 是否打开深度判断（true时判断是否在球背面）
   * @param {Boolean} [options.hasCache=true] 是否启用缓存机制，如为true，在视角未变化时不重新渲染。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @export
   * @class DivLightPoint
   * @extends {DivGraphic}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class DivLightPoint extends DivGraphic {
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$6,
        ...(options.style || {})
      };

      const style = options.style;

      options.style.html = `
    <div class="mars3d-animation-point" style="color:${style.color};width: ${style.size}px;height: ${style.size}px;">
      <p></p>
      ${style.label ? `<div class="mars3d-animation-point-lbl" style="color:${style.label.color || style.color};">${style.label.text}</div>` : ""}
    </div>`;

      super(options);
    }
  }

  // 注册下
  register$4("divLightPoint", DivLightPoint);

  /**
   * 竖立的文本 支持的样式信息
   *
   * @typedef {Object} DivUpLabel.StyleOptions
   *
   * @property {String} text 文本内容
   * @property {String} [color = "white"] 文本CSS颜色
   * @property {Number} [font_size = 15] 字体大小
   * @property {String} [font_family = "楷体"] 字体 ,可选项：微软雅黑,宋体,楷体,隶书,黑体 等
   * @property {Number} [lineHeight = 100] 底部线的高度值（单位：px像素）
   * @property {Number} [circleSize = 10] 底部圆圈的大小（单位：px像素）
   *
   * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
   * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
   *
   * @property {Number} [offsetX] 用于非规则div时，横向偏移的px像素值
   * @property {Number} [offsetY] 用于非规则div时，垂直方向偏移的px像素值
   *
   * @property {Boolean} [scaleByDistance = false] 是否按视距缩放
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   * @property {Boolean} [distanceDisplayCondition = false] 是否按视距显示
   * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {Cesium.HeightReference} [heightReference=Cesium.HeightReference.NONE] 指定高度相对于什么的属性。
   * @property {String} [css_transform_origin = 'left bottom 0'] DIV的 transform-origin css值
   * @property {Boolean} [timeRender] 是否实时刷新全部HTML，此时需要绑定html需传入回调方法。
   *
   * @property {Number|String} [setHeight] 指定坐标高度值（常用于图层中配置）,也支持字符串模版配置
   * @property {Number|String} [addHeight] 在现有坐标基础上增加的高度值（常用于图层中配置）,也支持字符串模版配置
   *
   */

  const DEF_STYLE$5 = {
    color: "white",
    font_family: "楷体",
    font_size: 15,
    lineHeight: 100,
    circleSize: 10,
    horizontalOrigin: Cesium__namespace.HorizontalOrigin.CENTER,
    verticalOrigin: Cesium__namespace.VerticalOrigin.BOTTOM
  };

  /**
   * 竖立的文本 DIV点
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {DivUpLabel.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑
   * @param {PointEntity.StyleOptions} [options.testPoint] 测试点 的对应样式 ，可以进行用于比较测试div的位置，方便调试CSS。
   * @param {Boolean} [options.pointerEvents=true] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
   * @param {Boolean} [options.hasZIndex=false] 是否自动调整DIV的层级顺序。
   * @param {Number|String} [options.zIndex="auto"] 指定固定的zIndex层级属性(当hasZIndex为true时无效)
   * @param {Boolean} [options.depthTest=true] 是否打开深度判断（true时判断是否在球背面）
   * @param {Boolean} [options.hasCache=true] 是否启用缓存机制，如为true，在视角未变化时不重新渲染。
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @export
   * @class DivUpLabel
   * @extends {DivGraphic}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class DivUpLabel extends DivGraphic {
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$5,
        ...(options.style || {})
      };

      const color = options.style.color;
      const circleSize = options.style.circleSize;

      options.style.html = `
    <div class="mars3d-divUpLabel" style="color: ${color};">
      <div class="mars3d-divUpLabel-text" style="font-family:${options.style.font_family};font-size: ${options.style.font_size}px;">${
      options.style.text
    }</div>
      <div class="mars3d-divUpLabel-line"  style="
          height: ${options.style.lineHeight}px;
          background-color: ${color};"></div>
      <div style="border-radius: 50%;
          width: ${circleSize}px;
          height: ${circleSize}px;
          margin-left: calc(50% - ${circleSize / 2}px);
          background-color: ${color};"></div>
    </div> `;
      super(options);
    }


  }

  // 注册下
  register$4("divUpLabel", DivUpLabel);

  /**
   * Popup对象 支持的配置信息
   *
   * @typedef {Object} Popup.StyleOptions
   *
   * @property {String} [html] Html文本({content}部分，整体展示的DOM由template和html属性共同组成)
   * @property {String} [template]  公共部分外框部分html内容，需要加2处：
   * (1)用于填充html的地方写上{content}标识；
   * (2)关闭按钮加class样式：closeButton。
   * 传空字符串或false时，不用内置模版。
   *
   *
   * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
   * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
   *
   * @property {Number} [offsetX] 用于非规则div时，横向偏移的px像素值
   * @property {Number} [offsetY] 用于非规则div时，垂直方向偏移的px像素值
   *
   * @property {String} [className]  自定义的样式名
   *
   * @property {Boolean} [scaleByDistance = false] 是否按视距缩放
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   * @property {Boolean} [distanceDisplayCondition = false] 是否按视距显示
   * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {String} [css_transform_origin = 'left bottom 0'] DIV的 transform-origin css值
   * @property {Boolean} [timeRender] 是否实时刷新全部HTML，此时需要绑定html需传入回调方法。
   * @property {Boolean} [autoCenter] 当气泡窗口有部分在地图之外时是否自动进行居中 （目前仅俯视时准确定位）
   * @property {Number} [maxWidth=700] 弹窗的最大宽度，单位为像素
   * @property {Number} [minWidth=50] 弹窗的最小宽度，单位为像素
   * @property {Number} [maxHeight=550] 如果设置，如果内容超过此高度时，则在弹出窗口中显示滚动条。
   *
   * //以下是构造参数，但也兼容style中传入
   * @property {Boolean} [closeOnClick=true] 是否在单击Map地图时，自动关闭当前弹窗
   * @property {Boolean} [autoClose=true] 在打开弹窗时，是否自动关闭之前的弹窗
   * @property {Boolean} [animation=true] 是否执行打开时的动画效果
   * @property {PointEntity.StyleOptions} [testPoint] 测试点 的对应样式 ，可以进行用于比较测试div的位置，方便调试CSS。
   * @property {Boolean} [pointerEvents=true] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
   * @property {Boolean} [hasZIndex=false] 是否自动调整DIV的层级顺序。
   * @property {Number|String} [zIndex="10000000"] 指定固定的zIndex层级属性(当hasZIndex为true时无效)
   * @property {Boolean} [depthTest=true] 是否打开深度判断（true时判断是否在球背面）
   * @property {Boolean} [hasCache=true] 是否启用缓存机制，如为true，在视角未变化时不重新渲染。
   */

  /**
   * Popup对象div点
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {Popup.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {Boolean} [options.closeOnClick=true] 是否在单击Map地图时，自动关闭当前弹窗
   * @param {Boolean} [options.autoClose=true] 在打开弹窗时，是否自动关闭之前的弹窗
   * @param {Boolean} [options.animation=true] 是否执行打开时的动画效果
   * @param {PointEntity.StyleOptions} [options.testPoint] 测试点 的对应样式 ，可以进行用于比较测试div的位置，方便调试CSS。
   * @param {Boolean} [options.pointerEvents=true] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
   * @param {Boolean} [options.hasZIndex=false] 是否自动调整DIV的层级顺序。
   * @param {Number|String} [options.zIndex="10000000"] 指定固定的zIndex层级属性(当hasZIndex为true时无效)
   * @param {Boolean} [options.depthTest=true] 是否打开深度判断（true时判断是否在球背面）
   * @param {Boolean} [options.hasCache=true] 是否启用缓存机制，如为true，在视角未变化时不重新渲染。
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @export
   * @class Popup
   * @extends {DivGraphic}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class Popup extends DivGraphic {
    constructor(options = {}) {
      options.eventParent = options.eventParent ?? false;
      options.hasEdit = options.hasEdit ?? false;
      options.animation = options.animation ?? true;
      options.zIndex = options.zIndex ?? 10000000;

      options.style = options.style || {};
      options.style.direction = options.style.direction ?? "top";

      const newStyle = {};
      switch (options.style.direction) {
        case "top":
          newStyle.offsetY = -8;
          newStyle.horizontalOrigin = Cesium__namespace.HorizontalOrigin.CENTER;
          newStyle.verticalOrigin = Cesium__namespace.VerticalOrigin.BOTTOM;
          break
        case "bottom":
          newStyle.offsetY = 8;
          newStyle.horizontalOrigin = Cesium__namespace.HorizontalOrigin.CENTER;
          newStyle.verticalOrigin = Cesium__namespace.VerticalOrigin.TOP;
          break
        case "center":
          newStyle.horizontalOrigin = Cesium__namespace.HorizontalOrigin.CENTER;
          newStyle.verticalOrigin = Cesium__namespace.VerticalOrigin.CENTER;
          break
        case "right":
          newStyle.offsetX = 8;
          newStyle.horizontalOrigin = Cesium__namespace.HorizontalOrigin.LEFT;
          newStyle.verticalOrigin = Cesium__namespace.VerticalOrigin.CENTER;
          break
        case "left":
          newStyle.offsetX = -8;
          newStyle.horizontalOrigin = Cesium__namespace.HorizontalOrigin.RIGHT;
          newStyle.verticalOrigin = Cesium__namespace.VerticalOrigin.CENTER;
          break
      }
      options.style = {
        ...newStyle,
        ...options.style
      };
      super(options);

      if (!Cesium__namespace.defined(this.style.template) && this.style.template !== false) {
        this.style.template = this._getDefaultTemplate();
      }
    }

    /**
     * 关联的触发对象
     * @type {BaseGraphic|BaseLayer|Map}
     * @readonly
     */
    get target() {
      return this.options?.target
    }

    // 事件对象
    get eventTarget() {
      if (this.options?.event) {
        return this.options.event
      }
      if (this.options?.target) {
        return this.options.target
      } else {
        return this
      }
    }

    _getDefaultTemplate() {
      let closeHtml;
      if (this.style.closeButton ?? true) {
        closeHtml = `<span  class="mars3d-popup-close-button mars3d-popup-color closeButton" >×</span>`;
      } else {
        closeHtml = "";
      }

      let style = "";
      if (this.style.maxWidth) {
        style += `max-width: ${this.style.maxWidth}px;`;
      }
      if (this.style.minWidth) {
        style += `min-width: ${this.style.minWidth}px;`;
      }
      if (this.style.maxHeight) {
        style += `max-height: ${this.style.maxHeight}px;`;
      }

      return `
      <div class="mars3d-popup ${!this.style.timeRender && this.options.animation ? "mars3d-popup-animation" : ""}">
        ${closeHtml}
        <div class="mars3d-popup-content-wrapper mars3d-popup-background">
          <div id="popup-${this.id}"  class="mars3d-popup-content mars3d-popup-color" style="${style}">{content}</div>
        </div>
        <div class="mars3d-popup-tip-container">
          <div class="mars3d-popup-tip mars3d-popup-background"></div>
        </div>
      </div>`
    }

    _appendHtmlHook() {
      const closeBtn = this._container.querySelector(".closeButton");
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          if (this.target && this.target.closeHighlight) {
            this.target.closeHighlight();
          }
          this.remove(true);
        });
      }
    }

    fireTarget(type, data = {}, propagate = true) {
      const target = this.target || this._map;
      if (target) {
        if (this.options.event) {
          for (const key in this.options.event) {
            if (key === "options" || key === "content") {
              continue
            }
            data[key] = this.options.event[key];
          }
        }
        data.sourceTarget = target;
        data.attr = this.attr;
        data.container = this.container;

        this._fireBindDataEx(data);

        target.fire(type, data, propagate);
      }
    }

    _fireBindDataEx(data) {
      data.popup = this;
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      super._addedHook(style);
      this._fireTarget_open();

      this.once(EventType.change, (event) => {
        if (this.options.autoCenter && this._map) {
          if (
            event.y < 0 ||
            event.x < 0 ||
            event.x > this._map.scene.canvas.clientWidth - event.width ||
            event.y > this._map.scene.canvas.clientHeight - event.height
          ) {
            const newX = event.width / 2 + event.x;
            const newY = event.height / 2 + event.y;

            // 屏幕坐标 转换为 笛卡尔空间直角坐标
            const windowPosition = new Cesium__namespace.Cartesian2(newX, newY);

            const ray = this._map.scene.camera.getPickRay(windowPosition);
            let target = this._map.scene.globe.pick(ray, this._map.scene);
            if (!target) {
              target = this._map.scene.camera.pickEllipsoid(windowPosition);
            }
            this._map.flyToPoint(target);
          }
        }
      });

      if (this.target) {
        this.target.on(EventType.updatePosition, this._graphic_updatePosition, this);
      }
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this.target) {
        this.target.off(EventType.updatePosition, this._graphic_updatePosition, this);
      }

      this._fireTarget_close();
      super._removedHook();
    }

    _graphic_updatePosition(event) {
      // 当graphic坐标被改变时，自动更新坐标
      if (event.graphic?._getPopupPosition) {
        this.position = event.graphic._getPopupPosition();
      }
    }

    _fireTarget_open() {
      this.fireTarget(EventType.popupOpen);
    }

    _fireTarget_close() {
      this.fireTarget(EventType.popupClose);
    }

    // 不能删除，覆盖父类方法
    _closeAllControl() {}
    _container_onClickHandler() {}
    _container_onMousedownHandler() {}
    _container_onMouseMoveHandler() {}
    _container_onMouseoutHandler() {}

    // 对象是否存在鼠标事件相关绑定
    hasBindEvent() {
      return this.options.pointerEvents ?? true
    }
  }

  // 注册下
  register$4("popup", Popup);

  /**
   * Tooltip对象 支持的配置信息
   *
   * @typedef {Object} Tooltip.StyleOptions
   *
   * @property {String} [html] Html文本({content}部分，整体展示的DOM由template和html属性共同组成)
   * @property {String|Boolean} [template]  公共部分外框部分html内容，需要加：用于填充html的地方写上{content}标识。 传空字符串或false时，不用内置模版。
   *
   * @property {String} [direction = "top"] 显示的方向，可选值： top、bottom、center、right、left
   * @property {Cesium.HorizontalOrigin} [horizontalOrigin] 横向方向的定位
   * @property {Cesium.VerticalOrigin} [verticalOrigin] 垂直方向的定位
   *
   * @property {Number} [offsetX] 用于非规则div时，横向偏移的px像素值
   * @property {Number} [offsetY] 用于非规则div时，垂直方向偏移的px像素值
   *
   * @property {String} [className]  自定义的样式名
   *
   * @property {Boolean} [scaleByDistance = false] 是否按视距缩放
   * @property {Number} [scaleByDistance_far = 1000000] 上限
   * @property {Number} [scaleByDistance_farValue = 0.1] 比例值
   * @property {Number} [scaleByDistance_near = 1000] 下限
   * @property {Number} [scaleByDistance_nearValue = 1] 比例值
   * @property {Boolean} [distanceDisplayCondition = false] 是否按视距显示
   * @property {Number} [distanceDisplayCondition_far = 10000] 最大距离
   * @property {Number} [distanceDisplayCondition_near = 0] 最小距离
   * @property {Boolean} [clampToGround = false] 是否贴地
   * @property {String} [css_transform_origin = 'left bottom 0'] DIV的 transform-origin css值
   * @property {Boolean} [timeRender] 是否实时刷新全部HTML，此时需要绑定html需传入回调方法。
   *
   * //以下是构造参数，但也兼容style中传入
   * @property {PointEntity.StyleOptions} [testPoint] 测试点 的对应样式 ，可以进行用于比较测试div的位置，方便调试CSS。
   * @property {Boolean} [pointerEvents=true] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
   * @property {Boolean} [hasZIndex=false] 是否自动调整DIV的层级顺序。
   * @property {Number|String} [zIndex="10000000"] 指定固定的zIndex层级属性(当hasZIndex为true时无效)
   * @property {Boolean} [depthTest=true] 是否打开深度判断（true时判断是否在球背面）
   * @property {Boolean} [hasCache=true] 是否启用缓存机制，如为true，在视角未变化时不重新渲染。
   */

  /**
   * Tooltip对象div点
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {Tooltip.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {PointEntity.StyleOptions} [options.testPoint] 测试点 的对应样式 ，可以进行用于比较测试div的位置，方便调试CSS。
   * @param {Boolean} [options.pointerEvents=false] DIV是否可以鼠标交互，为false时可以穿透操作及缩放地图，但无法进行鼠标交互及触发相关事件。
   * @param {Boolean} [options.hasZIndex=false] 是否自动调整DIV的层级顺序。
   * @param {Number|String} [options.zIndex="10000000"] 指定固定的zIndex层级属性(当hasZIndex为true时无效)
   * @param {Boolean} [options.depthTest=true] 是否打开深度判断（true时判断是否在球背面）
   * @param {Boolean} [options.hasCache=true] 是否启用缓存机制，如为true，在视角未变化时不重新渲染。
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @export
   * @class Tooltip
   * @extends {Popup}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class Tooltip extends Popup {
    _getDefaultTemplate() {
      return `<div id="tooltip-${this.id}"  class="mars3d-tooltip mars3d-tooltip-${this.style.direction}">{content}</div>`
    }

    _fireBindDataEx(data) {
      data.tooltip = this;
    }

    _fireTarget_open() {
      this.fireTarget(EventType.tooltipOpen);
    }

    _fireTarget_close() {
      this.fireTarget(EventType.tooltipClose);
    }

    // 对象是否存在鼠标事件相关绑定
    hasBindEvent() {
      return this.options.pointerEvents ?? false
    }
  }

  // 注册下
  register$4("tooltip", Tooltip);

  const DEF_STYLE$4 = {
    startColor: Cesium__namespace.Color.LIGHTCYAN.withAlpha(0.3),
    endColor: Cesium__namespace.Color.WHITE.withAlpha(0.0),
    startScale: 2.0,
    endScale: 4.0,
    minimumParticleLife: 3,
    maximumParticleLife: 6,
    minimumSpeed: 1.0,
    maximumSpeed: 2.0,
    emissionRate: 100
  };

  /**
   * 粒子效果 支持的样式信息
   * @typedef {Object} ParticleSystem.StyleOptions
   *
   * @property {String} [image] 粒子的图片URL
   * @property {Cesium.ParticleEmitter} [emitter=new Cesium.CircleEmitter(1.0)]  粒子发射器
   * @property {Number} [emissionRate=100] 发射速率 （单位：次/秒）
   *
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   * @property {Number} [gravity] 重力因子，会修改速度矢量以改变方向或速度（基于物理的效果）
   * @property {Number} [transX=0] 粒子在X轴方向上的偏离距离（单位：米）
   * @property {Number} [transY=0] 粒子在Y轴方向上的偏离距离（单位：米）
   * @property {Number} [transZ=0] 粒子离地高度（单位：米），粒子在Z轴方向上的偏离距离
   *
   * @property {Number} [particleSize=25] 粒子大小(px)，粒子图片的Size大小（单位：像素）
   * @property {Cesium.Cartesian2} [imageSize] 粒子图片的Size大小,可以设置高宽不同（单位：像素），与particleSize二选一
   * @property {Cesium.Cartesian2} [minimumImageSize] 最小大小，设置最小边界，宽度和高度，在此之上随机缩放粒子图像的像素尺寸
   * @property {Cesium.Cartesian2} [maximumImageSize] 最大大小，设置最大边界，宽度和高度，在其以下随机缩放粒子图像的像素尺寸
   * @property {Number} [scale] 比例，设置在粒子生命周期内应用于粒子图像的比例
   * @property {Number} [startScale=2.0] 开始比例，粒子在出生时的比例（单位：相对于imageSize大小的倍数）
   * @property {Number} [endScale=4.0] 结束比例，粒子在死亡时的比例（单位：相对于imageSize大小的倍数）
   * @property {Cesium.Color} [color=Color.WHITE] 颜色，设置一个粒子在其生命周期内的颜色
   * @property {Cesium.Color} [startColor] 开始颜色，粒子出生时的颜色
   * @property {Cesium.Color} [endColor] 结束颜色，当粒子死亡时的颜色
   * @property {Number} [speed] 速度(米/秒)， 如果设置，则使用此值覆盖最小速度和最大速度输入
   * @property {Number} [minimumSpeed=1.0] 最小速度，设定以每秒米为单位的最小范围，超过这个范围粒子的实际速度将被随机选择
   * @property {Number} [maximumSpeed=2.0] 最大速度(米/秒)，设定以每秒米为单位的最大范围，低于这个范围粒子的实际速度将被随机选择
   * @property {Number} [particleLife=5.0]  寿命时间(秒), 如果设置了这个值，将覆盖minimumParticleLife和maximumParticleLife输入
   * @property {Number} [minimumParticleLife=3] 最小寿命时间, 设定一个粒子生命可能持续时间的最小界限(以秒为单位)，在此之上一个粒子的实际生命将被随机选择
   * @property {Number} [maximumParticleLife=6] 最大寿命时间, 设置一个粒子生命可能持续时间的最大界限(以秒为单位)，低于这个时间的粒子的实际生命将被随机选择
   * @property {Number} [mass=1.0] 质量(千克)，设定粒子的最小和最大质量
   * @property {Number} [minimumMass] 最小质量，设定粒子质量的最小边界，一个粒子的实际质量将被选为高于这个值的随机数量
   * @property {Number} [maximumMass] 最大质量，设置粒子的最大质量，一个粒子的实际质量将被选为低于这个值的随机数量
   *
   * @property {Boolean} [loop=true] 粒子系统完成后是否应该循环爆发
   * @property {Cesium.ParticleBurst[]} [bursts] 周期性发射粒子爆发数组
   * @property {Boolean} [sizeInMeters] 大小模式，设置粒子的大小是米还是像素。true以米为单位设置粒子的大小;否则，大小以像素为单位。
   * @property {Number} [lifetime=Number.MAX_VALUE] 释放粒子的时间(秒)
   * @property {Number} [maxHeight] 最大视角高度（单位：米），超出该高度不显示粒子
   */

  /**
   * 粒子效果 对象，该对象暂不支持鼠标交互和拾取
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {Cesium.Matrix4|Function} [options.modelMatrix] 粒子系统模型矩阵, 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
   * @param {Cesium.Matrix4|Function} [options.emitterModelMatrix] 发射器矩阵, 用于在粒子系统本地坐标系中转换粒子系统发射器
   * @param {Function} [options.updateCallback] 每一帧调用一个回调函数来更新一个粒子。
   * @param {ParticleSystem.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @export
   * @class ParticleSystem
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class ParticleSystem extends BasePointPrimitive {
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$4,
        emitter: new Cesium__namespace.CircleEmitter(1.0), // 此系统的粒子发射器(指定方向)，  共有 圆形、锥体、球体、长方体 ( BoxEmitter,CircleEmitter,ConeEmitter,SphereEmitter ) 几类
        ...(options.style || {})
      };
      super(options);

      // 内部数据
      this.emitterModelMatrix = new Cesium__namespace.Matrix4();
      this.translation = new Cesium__namespace.Cartesian3();
      this.rotation = new Cesium__namespace.Quaternion();
      this.hpr = new Cesium__namespace.HeadingPitchRoll();
      this.trs = new Cesium__namespace.TranslationRotationScale();
    }

    //= ========= 对外属性 ==========
    get czmObject() {
      return this._primitive
    }

    /**
     * 最大视角高度（单位：米），超出该高度不显示粒子效果
     * @type {Number}
     */
    get maxHeight() {
      return this.style.maxHeight
    }

    set maxHeight(val) {
      this.style.maxHeight = val;
    }

    /**
     * 重力因子，会修改速度矢量以改变方向或速度（基于物理的效果）
     * @type {Number}
     */
    get gravity() {
      return this.style.gravity || 0
    }

    set gravity(val) {
      this.style.gravity = val;
    }

    /**
     * X轴方向上的偏离距离（单位：米）
     * @type {Number}
     */
    get transX() {
      return this.style.transX || 0
    }

    set transX(val) {
      this.style.transX = val;
    }

    /**
     * Y轴方向上的偏离距离（单位：米）
     * @type {Number}
     */
    get transY() {
      return this.style.transY || 0
    }

    set transY(val) {
      this.style.transY = val;
    }

    /**
     * 离地高度，Z轴方向上的偏离距离（单位：米）
     * @type {Number}
     */
    get transZ() {
      return this.style.transZ || 0
    }

    set transZ(val) {
      this.style.transZ = val;
    }

    /**
     *  粒子图片的Size大小（单位：像素）
     * @type {Number}
     */
    get particleSize() {
      return this.style.particleSize || 25
    }

    set particleSize(val) {
      this.style.particleSize = val;

      if (this._primitive) {
        this._primitive.minimumImageSize.x = val;
        this._primitive.minimumImageSize.y = val;
        this._primitive.maximumImageSize.x = val;
        this._primitive.maximumImageSize.y = val;
      }
    }

    /**
     * 是否可以调整透明度
     * @type {Boolean}
     * @readonly
     */
    get hasOpacity() {
      return false
    }

    //= ========= 方法 ==========

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show) {
        return
      }
      const currentTime = this._map.clock.currentTime;
      // 默认值
      const psOptions = {
        imageSize: new Cesium__namespace.Cartesian2(this.particleSize, this.particleSize), // 粒子图片的Size大小（单位：像素）
        modelMatrix: this._computeModelMatrix(currentTime), // 可将粒子系统从模型转换为世界坐标
        emitterModelMatrix: this._computeEmitterModelMatrix(currentTime), // 用于在粒子系统本地坐标系中转换粒子系统发射器
        ...this.style,
        show: this.show
      };

      // 构造粒子对象
      this._primitive = new Cesium__namespace.ParticleSystem(psOptions);
      this.primitiveCollection.add(this._primitive);

      if (this.options.position) {
        if (this.options.position instanceof Cesium__namespace.CallbackProperty || this.options.position instanceof Cesium__namespace.SampledPositionProperty) {
          this._orientation = this.options.orientation || new Cesium__namespace.VelocityOrientationProperty(this.options.position);
          this.property = this.options.position;
        }
      }

      this._bindUpdateCallback();
      this._hasUpdate_modelMatrix = isFunction(this.options.modelMatrix) || this.property;
      this._hasUpdate_emitterModelMatrix =
        isFunction(this.options.emitterModelMatrix) || this.heading || this.pitch || this.roll || this.transX || this.transY || this.transZ;

      // 劫持更新函数
      const primitive_update_old = this._primitive.update;
      const that = this;
      this._primitive.update = function (frameState) {
        that._update(frameState);
        primitive_update_old.bind(this)(frameState);
      };
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (!this._map) {
        return
      }
      this.primitiveCollection.remove(this._primitive);
    }

    _update(frameState) {
      if (!this.show || !this._primitive || !this._map) {
        return
      }

      if (this.property) {
        this._position = getPositionValue(this.property, frameState.time);
      }

      if (this._hasUpdate_modelMatrix) {
        this._primitive.modelMatrix = this._computeModelMatrix(frameState.time);
      }

      if (this._hasUpdate_emitterModelMatrix) {
        this._primitive.emitterModelMatrix = this._computeEmitterModelMatrix(frameState.time);
      }

      // 加控制，只在相机高度低于一定高度时才开启本效果
      if (Cesium__namespace.defined(this.maxHeight) && frameState.frameNumber % 10 === 0) {
        if (this._map.camera.positionCartographic.height < this.maxHeight) {
          if (this._primitive.show !== this.show) {
            this._primitive.show = this.show;
          }
        } else {
          if (this._primitive.show) {
            this._primitive.show = false;
          }
        }
      }
    }

    _computeModelMatrix(time) {
      if (this.options.modelMatrix) {
        if (isFunction(this.options.modelMatrix)) {
          return this.options.modelMatrix(time)
        } else {
          return this.options.modelMatrix
        }
      }

      if (this._position) {
        return Cesium__namespace.Transforms.eastNorthUpToFixedFrame(this._position)
      }

      return new Cesium__namespace.Matrix4()
    }

    _computeEmitterModelMatrix(time) {
      if (this.options.emitterModelMatrix) {
        if (isFunction(this.options.emitterModelMatrix)) {
          return this.options.emitterModelMatrix(time)
        } else {
          return this.options.emitterModelMatrix
        }
      }

      const heading = this.style.heading || 0;
      const pitch = this.style.pitch || 0;
      const roll = this.style.roll || 0;

      this.hpr = Cesium__namespace.HeadingPitchRoll.fromDegrees(heading, pitch, roll, this.hpr);
      this.trs.translation = Cesium__namespace.Cartesian3.fromElements(this.transX, this.transY, this.transZ, this.translation);
      this.trs.rotation = Cesium__namespace.Quaternion.fromHeadingPitchRoll(this.hpr, this.rotation);

      Cesium__namespace.Matrix4.fromTranslationRotationScale(this.trs, this.emitterModelMatrix);
      return this.emitterModelMatrix
    }

    _bindUpdateCallback() {
      if (this.options.updateCallback) {
        this._primitive.updateCallback = this.options.updateCallback;
        return
      }

      if (this.gravity === 0) {
        this._primitive.updateCallback = undefined;
      } else if (!this._primitive.updateCallback) {
        const that = this;
        const gravityScratch = new Cesium__namespace.Cartesian3();

        // 回调函数，参数是(particle,dt)，分别是单个粒子的属性和两次发射之间的时间间隔(单位:s)
        this._primitive.updateCallback = function (particle, dt) {
          if (that.options.updateCallback) {
            return that.options.updateCallback(particle, dt)
          }
          const position = particle.position;
          Cesium__namespace.Cartesian3.normalize(position, gravityScratch);

          Cesium__namespace.Cartesian3.multiplyByScalar(gravityScratch, that.gravity * dt, gravityScratch);
          particle.velocity = Cesium__namespace.Cartesian3.add(particle.velocity, gravityScratch, particle.velocity);
        };
      }
    }

    _updateStyleHook(style, newStyle) {
      if (this._primitive) {
        for (const key in newStyle) {
          this._primitive[key] = newStyle[key];
        }

        if (newStyle.particleSize) {
          this.particleSize = newStyle.particleSize;
        }
        if (newStyle.gravity) {
          this._bindUpdateCallback();
        }
      }

      this._hasUpdate_emitterModelMatrix =
        isFunction(this.options.emitterModelMatrix) || this.heading || this.pitch || this.roll || this.transX || this.transY || this.transZ;
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return this._getDrawPointEntityClass(options, isDraw)
    }
  }
  // 注册下
  register$4("particleSystem", ParticleSystem);

  var ArcFrustumFS = "uniform vec4 color;\n\nvoid main() {\n  gl_FragColor = color;\n}\n"; // eslint-disable-line

  var ArcFrustumVS = "attribute vec4 aPosition;\n\nvoid main() {\n  gl_Position = czm_modelViewProjection * vec4(aPosition.xyz, 1.0);\n}\n"; // eslint-disable-line

  const DEF_STYLE$3 = {
    color: Cesium__namespace.Color.WHITE
  };

  /**
   * 弧形平截头体 支持的样式信息
   *
   * @typedef {Object} ArcFrustum.StyleOptions
   *
   * @property {Number} [angle] 四棱锥体张角（角度值，取值范围 0.01-89.99）
   * @property {Number} [angle2=angle] 四棱锥体张角2，（角度值，取值范围 0.01-89.99）
   * @property {Number} distance 投射距离，单位：米
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   * @property {Cesium.Color} [color=Cesium.Color.WHITE] 颜色
   */

  /**
   * 弧形截头体,
   * 目前用于视频投射、可视域分析中
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
   * @param {ArcFrustum.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性。
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @class ArcFrustum
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class ArcFrustum extends BasePointPrimitive {
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$3,
        ...(options.style || {})
      };
      super(options);

      this._boundingSphere = new Cesium__namespace.BoundingSphere();
      this._color = getCesiumColor(this.style.color);
    }

    get czmObject() {
      return this
    }

    /**
     * 颜色
     * @type {Cesium.Color}
     */
    get color() {
      return this._color
    }

    set color(val) {
      this._color = val;
    }

    /**
     * 夹角，半场角度，取值范围 0.01-89.99
     * @type {Number}
     */
    get angle() {
      return this.style.angle
    }

    set angle(val) {
      this.style.angle = val;
      this.destroyCommands();
    }

    /**
     * 夹角2，半场角度，取值范围 0.01-89.99
     * @type {Number}
     */
    get angle2() {
      return this.style.angle2 ?? this.style.angle
    }

    set angle2(val) {
      this.style.angle2 = val;
      this.destroyCommands();
    }

    /**
     * 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵。
     * @type {Cesium.Matrix4}
     * @readonly
     */
    get modelMatrix() {
      if (this.options.modelMatrix) {
        return this.options.modelMatrix
      }

      // createCamera
      const cameraPosition = this.position;
      const hpr = new Cesium__namespace.HeadingPitchRoll(Cesium__namespace.Math.toRadians(this.heading), Cesium__namespace.Math.toRadians(this.pitch), Cesium__namespace.Math.toRadians(this.roll));

      const _camera = new Cesium__namespace.Camera(this._map.scene);
      _camera.position = cameraPosition;
      _camera.frustum.fov = Cesium__namespace.Math.toRadians(this.angle * 2);
      _camera.frustum.aspectRatio = this.angle / this.angle2;
      _camera.frustum.near = 0.01;
      _camera.frustum.far = this.style.distance;
      _camera.setView({
        destination: cameraPosition,
        orientation: {
          heading: hpr.heading,
          pitch: hpr.pitch,
          roll: hpr.roll
        }
      });
      return _camera.inverseViewMatrix
    }

    // 调整heading、pitch触发
    updateModelMatrix() {
      this.destroyCommands();
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show) {
        return
      }
      this.primitiveCollection.add(this);
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this.primitiveCollection.contains(this)) {
        this._noDestroy = true;
        this.primitiveCollection.remove(this);
        this._noDestroy = false;
      }
    }

    update(frameState) {
      if (!this.show) {
        return
      }
      if (!Cesium__namespace.defined(this._command)) {
        this._command = this.createCommand(frameState.context);
      }

      if (frameState.passes.render) {
        if (Cesium__namespace.defined(this._command)) {
          frameState.commandList.push(this._command);
        }
      }
    }

    destroyCommands() {
      if (Cesium__namespace.defined(this._command)) {
        this._command.shaderProgram = this._command.shaderProgram && this._command.shaderProgram.destroy();
        this._command.vertexArray = this._command.vertexArray && this._command.vertexArray.destroy();
        delete this._command;
      }
    }

    // 创建自定义视锥线绘制命令
    createCommand(context) {
      this.destroyCommands();

      const vecIdx = this.createVertices(); // 组织视锥线顶点和索引

      // 方法将通用顶点索引绑定到属性变量。
      const attributeLocations = {
        aPosition: 0
      };

      // 创建顶点缓冲区
      const verBuffer = Cesium__namespace.Buffer.createVertexBuffer({
        context: context,
        typedArray: vecIdx.vertices,
        usage: Cesium__namespace.BufferUsage.STATIC_DRAW
      });
      // 将顶点缓对区对象添加几何体属性中（geometry.attributes)
      const attributes = [
        {
          index: attributeLocations.aPosition,
          vertexBuffer: verBuffer,
          componentsPerAttribute: 3,
          componentDatatype: Cesium__namespace.ComponentDatatype.FLOAT,
          offsetInBytes: 0,
          strideInBytes: 12,
          normalize: false
        }
      ];
      const indexBuffer = Cesium__namespace.Buffer.createIndexBuffer({
        context: context,
        typedArray: vecIdx.indices,
        usage: Cesium__namespace.BufferUsage.STATIC_DRAW,
        indexDatatype: Cesium__namespace.IndexDatatype.UNSIGNED_SHORT
      });
      const vertexArray = new Cesium__namespace.VertexArray({
        context: context,
        attributes: attributes, // 顶点对象
        indexBuffer: indexBuffer // 索引对象
      });

      const modelMatrix = this.modelMatrix;

      // 更新包围球
      this._boundingSphere.radius = this.style.distance;
      if (this.position) {
        this._boundingSphere.position = this.position;
      } else {
        Cesium__namespace.Cartesian3.clone(Cesium__namespace.Cartesian3.ZERO, this._boundingSphere.center);
        Cesium__namespace.BoundingSphere.transform(this._boundingSphere, modelMatrix, this._boundingSphere); // 设置投射包围球的位置
      }

      // 创建command
      const command = new Cesium__namespace.DrawCommand({
        primitiveType: Cesium__namespace.PrimitiveType.LINES,
        shaderProgram: Cesium__namespace.ShaderProgram.fromCache({
          context: context,
          vertexShaderSource: ArcFrustumVS, // 顶点着色器
          fragmentShaderSource: ArcFrustumFS, // 片元着色器
          attributeLocations: attributeLocations
        }),
        vertexArray: vertexArray,
        modelMatrix: modelMatrix,
        boundingVolume: this._boundingSphere,
        uniformMap: {
          color: () => {
            return this.color
          }
        },
        pass: Cesium__namespace.Pass.OPAQUE, // 渲染层次（优先级）
        owner: this,
        cull: true, // 开启剔除
        renderState: Cesium__namespace.RenderState.fromCache({
          cull: {
            enabled: true
          },
          depthTest: {
            enabled: true
          }
        })
      });

      this.bindPickId(command);

      return command
    }

    // 组织视锥线顶点和索引
    createVertices() {
      const distance = this.style.distance;
      const segment = 20; // 分割数 this.style.segment

      const vexLength = (segment + 1) * (segment + 1) + 1;

      // 创建与组件数据类型对应的类型化数组
      const vertices = Cesium__namespace.ComponentDatatype.createTypedArray(Cesium__namespace.ComponentDatatype.FLOAT, 3 * vexLength);
      // 视锥原点为0，从第3位开始计算锥体坐标
      let vIdx = 3;
      const xhalf = Cesium__namespace.Math.toRadians(this.angle * 2);
      const yhalf = Cesium__namespace.Math.toRadians(this.angle2 * 2);
      // centerX = Math.tan(0.5 * xhalf),
      const centerY = Math.tan(0.5 * yhalf);
      // width = distance * centerX,
      const height = distance * centerY;
      const startAngle = Math.PI - 0.5 * xhalf;
      let xAngle = 0;
      let yAngle = 0;
      const stepAngle = xhalf / segment;

      // 计算顶点集合（局部坐标）
      for (let i = 0; i < segment + 1; i++) {
        xAngle = startAngle + i * stepAngle;
        const F = height / (distance / Math.cos(xAngle));
        const B = Math.atan(F);
        const Y = -B;
        const k = (2 * B) / segment;
        for (let j = 0; j < segment + 1; j++) {
          yAngle = Y + j * k;
          vertices[vIdx++] = distance * Math.cos(yAngle) * Math.sin(xAngle); // x
          vertices[vIdx++] = distance * Math.sin(yAngle); // y
          vertices[vIdx++] = distance * Math.cos(yAngle) * Math.cos(xAngle); // z
        }
      }

      // 组织outLine的索引数组
      const lineLength = 2 * (4 + 5 * segment + 2 * segment * 3);
      const indicesLine = Cesium__namespace.ComponentDatatype.createTypedArray(Cesium__namespace.ComponentDatatype.UNSIGNED_SHORT, lineLength);
      let _index = 0;
      // 原点到球面的四条线
      // 右上
      indicesLine[_index++] = 0;
      indicesLine[_index++] = 1;
      // 右下
      indicesLine[_index++] = 0;
      indicesLine[_index++] = segment + 1;
      // 左上
      indicesLine[_index++] = 0;
      indicesLine[_index++] = segment * (segment + 1) + 1;
      // 左下
      indicesLine[_index++] = 0;
      indicesLine[_index++] = (segment + 1) * (segment + 1);
      // 组织纵向线段索引
      for (let i = 0; i < 5; i++) {
        for (let j = 0; j < segment; j++) {
          indicesLine[_index++] = 1 + j + 5 * (segment + 1) * i;
          indicesLine[_index++] = 1 + (j + 1) + 5 * (segment + 1) * i;
        }
      }
      // 组织横向线段索引
      for (let i = 0; i < 5; i++) {
        for (let j = 0; j < segment; j++) {
          indicesLine[_index++] = 1 + (segment + 1) * j + 5 * i;
          indicesLine[_index++] = 1 + (segment + 1) * (j + 1) + 5 * i;
        }
      }
      // 组织顶点索引集合
      const colorLength = segment * segment * 3 * 2 + 3 * segment * 4;
      const indicesColor = Cesium__namespace.ComponentDatatype.createTypedArray(Cesium__namespace.ComponentDatatype.SHORT, colorLength);

      const W = 1;
      for (let i = 0; i < segment; i++) {
        for (let j = 0; j < segment; j++) {
          indicesColor[_index++] = W + i + j * (segment + 1);
          indicesColor[_index++] = W + i + 1 + j * (segment + 1);
          indicesColor[_index++] = W + i + (j + 1) * (segment + 1);
          indicesColor[_index++] = W + i + 1 + j * (segment + 1);
          indicesColor[_index++] = W + i + 1 + (j + 1) * (segment + 1);
          indicesColor[_index++] = W + i + (j + 1) * (segment + 1);
        }
      }
      for (let i = 0; i < segment; i++) {
        indicesColor[_index++] = i + 1 + W;
        indicesColor[_index++] = i + W;
        indicesColor[_index++] = 0;
        indicesColor[_index++] = 0;
        indicesColor[_index++] = i + segment * (segment + 1) + W;
        indicesColor[_index++] = i + 1 + segment * (segment + 1) + W;
      }
      for (let i = 0; i < segment; i++) {
        indicesColor[_index++] = 0;
        indicesColor[_index++] = i * (segment + 1) + W;
        indicesColor[_index++] = (i + 1) * (segment + 1) + W;
        indicesColor[_index++] = segment + (i + 1) * (segment + 1) + W;
        indicesColor[_index++] = segment + i * (segment + 1) + W;
        indicesColor[_index++] = 0;
      }
      return {
        vertices: vertices,
        indices: indicesLine
      }
    }
  }

  // 注册下
  register$4("arcFrustum", ArcFrustum);

  var TetrahedronFS = "varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\nuniform vec4 color;\nuniform float globalAlpha;\n\nvoid main() {\n  vec3 positionToEyeEC = -v_positionEC;\n  vec3 normalEC = normalize(v_normalEC);\n  #ifdef FACE_FORWARD\n  normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n  #endif\n  czm_materialInput materialInput;\n  materialInput.normalEC = normalEC;\n  materialInput.positionToEyeEC = positionToEyeEC;\n  materialInput.st = v_st;\n\n  vec2 st = materialInput.st;\n  czm_material material = czm_getDefaultMaterial(materialInput);\n\n  material.alpha = (mix(0.1, 1.0, clamp((1.0 - st.t) * color.a, 0.0, 1.0)) + (1.0 - sign(st.t - czm_frameNumber * 0.001)) * 0.2 + 0.4) * globalAlpha;\n  material.diffuse = color.rgb;\n\n  #ifdef FLAT\n  gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n  #else\n  gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n  #endif\n}\n"; // eslint-disable-line

  var TetrahedronVS = "attribute vec3 position;\nattribute vec3 normal;\nattribute vec2 st;\nattribute float batchId;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main() {\n  v_positionEC = (czm_modelView * vec4(position, 1.0)).xyz;       // position in eye coordinates\n  v_normalEC = czm_normal * normal;                               // normal in eye coordinates\n  v_st = st;\n  gl_Position = czm_modelViewProjection * vec4(position, 1.0);\n}\n"; // eslint-disable-line

  const DEF_STYLE$2 = {
    width: 20,
    height: 30,
    color: new Cesium__namespace.Color(0.8, 0.8, 0, 0.8),

    animation: true,
    moveHeight: 30,
    moveDuration: 2,
    rotationAngle: 1
  };

  /**
   * 四面体（顶部正方形+倒立的三角椎体） 支持的样式信息
   *
   * @typedef {Object} Tetrahedron.StyleOptions
   *
   * @property {Number} [width=20] 顶部大小，顶部正方形长宽，单位：米
   * @property {Number} [height=30] 椎体高度，倒立的三角椎体部分高度，单位：米
   * @property {String|Cesium.Color} [color = new Cesium.Color(0.8, 0.8, 0, 0.8)] 颜色
   *
   * @property {Boolean} [animation = true] 是否动画
   * @property {Number} [moveHeight = 30] 动画时，上下移动的单程总高度，单位：米
   * @property {Number} [moveDuration = 2] 动画时，上下移动的单程总时长，单位：秒
   * @property {Number} [rotationAngle = 1] 动画时，每帧旋转的角度值，单位：度
   */

  /**
   * 四面体（顶部正方形+倒立的三角椎体）
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 坐标位置
   * @param {Cesium.Matrix4} [options.modelMatrix] 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵,可以替代position。
   * @param {Tetrahedron.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性。
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @export
   * @class Tetrahedron
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class Tetrahedron extends BasePointPrimitive {
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE$2,
        ...(options.style || {})
      };
      super(options);

      this._globalAlpha = 1.0;
    }

    get czmObject() {
      return this
    }

    /**
     * 颜色
     * @type {Cesium.Color}
     */
    get color() {
      return this._color
    }

    set color(val) {
      this._color = getCesiumColor(val);
    }

    /**
     * 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵。
     * @type {Cesium.Matrix4}
     * @readonly
     */
    get modelMatrix() {
      if (this.options.modelMatrix) {
        return this.options.modelMatrix
      }
      if (!this.position) {
        return Cesium__namespace.Matrix4.IDENTITY
      }

      const enuMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(this.position);
      const scaleMatrix = Cesium__namespace.Matrix4.fromScale(new Cesium__namespace.Cartesian3(this.style.width, this.style.width, this.style.height));
      const modelMatrix = Cesium__namespace.Matrix4.multiply(enuMatrix, scaleMatrix, new Cesium__namespace.Matrix4());
      return modelMatrix
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show || !this.position) {
        return
      }

      this._updateStyleHook(style, style);

      this.primitiveCollection.add(this);
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this.primitiveCollection && this.primitiveCollection.contains(this)) {
        this._noDestroy = true;
        this.primitiveCollection.remove(this);
        this._noDestroy = false;
      }
      delete this._modelMatrix;
    }

    _updatePositionsHook() {
      this._modelMatrix = this.modelMatrix;
      this._clearDrawCommand();
    }

    _updateStyleHook(style, newStyle) {
      if (newStyle.width || newStyle.height) {
        this._updatePositionsHook();
      }

      this.color = style.color;
      this._rotationAngle = Cesium__namespace.Math.toRadians(style.rotationAngle);

      this._moveMaxHeight = style.moveHeight / this.style.height;
      if (this._moveMaxHeight !== 0) {
        this._moveDistanceStep = this._moveMaxHeight / (style.moveDuration * 60);
        this._moveDistanceSum = 0;
      }
    }

    update(frameState) {
      if (!this.show) {
        return
      }

      // 执行动画
      if (this.style.animation) {
        // 移动动画
        if (this._moveMaxHeight !== 0) {
          this._moveDistanceSum += this._moveDistanceStep;
          if (this._moveDistanceSum >= this._moveMaxHeight || this._moveDistanceSum <= 0) {
            this._moveDistanceStep = -this._moveDistanceStep;
          }
          const translation = new Cesium__namespace.Cartesian3(0, 0, this._moveDistanceStep);
          Cesium__namespace.Matrix4.multiplyByTranslation(this._modelMatrix, translation, this._modelMatrix);
        }

        // 旋转动画
        if (this._rotationAngle !== 0) {
          const rotationZ = Cesium__namespace.Matrix4.fromRotationTranslation(Cesium__namespace.Matrix3.fromRotationZ(this._rotationAngle));
          Cesium__namespace.Matrix4.multiply(this._modelMatrix, rotationZ, this._modelMatrix);
        }
      }

      // 如果没有创建过 DrawCommand ，将重新创建
      if (!Cesium__namespace.defined(this._drawCommand)) {
        this._drawCommand = this.createDrawCommand(frameState.context);
      }

      // 添加到渲染序列中
      if (frameState.passes.render) {
        if (Cesium__namespace.defined(this._drawCommand)) {
          frameState.commandList.push(this._drawCommand);
        }
      } else {
        if (Cesium__namespace.defined(this._pickCommand)) {
          frameState.commandList.push(this._pickCommand);
        }
      }
    }

    // 销毁 DrawCommand,在update方法中会自动重建DrawCommand
    _clearDrawCommand() {
      if (Cesium__namespace.defined(this._drawCommand)) {
        if (this._drawCommand.vertexArray) {
          this._drawCommand.vertexArray.destroy();
        }
        delete this._drawCommand;
      }

      if (Cesium__namespace.defined(this._pickCommand)) {
        if (this._pickCommand.vertexArray) {
          this._pickCommand.vertexArray.destroy();
        }
        delete this._pickCommand;
      }
    }

    // 创建command
    createDrawCommand(context) {
      const translucent = false;
      const closed = true;

      // 借用一下Appearance.getDefaultRenderState
      const rawRenderState = Cesium__namespace.Appearance.getDefaultRenderState(translucent, closed, undefined);
      const renderState = Cesium__namespace.RenderState.fromCache(rawRenderState);

      const attributeLocations = {
        position: 0,
        textureCoordinates: 1
      };
      const shaderProgram = Cesium__namespace.ShaderProgram.fromCache({
        context: context,
        vertexShaderSource: TetrahedronVS,
        fragmentShaderSource: TetrahedronFS,
        attributeLocations: attributeLocations
      });
      const vertexArray = this.createVertexArray(context);
      const boundingVolume = new Cesium__namespace.BoundingSphere(this.position, Math.max(this.style.width, this.style.height));

      // 创建command
      const command = new Cesium__namespace.DrawCommand({
        primitiveType: Cesium__namespace.PrimitiveType.TRIANGLES,
        shaderProgram: shaderProgram,
        vertexArray: vertexArray,
        modelMatrix: this._modelMatrix,
        renderState: renderState,
        boundingVolume: boundingVolume,
        uniformMap: {
          color: () => {
            return this.color
          },
          globalAlpha: () => {
            return this._globalAlpha
          }
        },
        castShadows: false,
        receiveShadows: false,
        pass: Cesium__namespace.Pass.TRANSLUCENT,
        owner: this,
        pickOnly: true,
        pickCommand: new Cesium__namespace.DrawCommand({
          owner: this,
          pickOnly: true
        })
      });
      this.bindPickId(command);

      command.pickId = context.createPickId({
        primitive: command,
        id: this.id
      });

      // 交互的pick处理
      const pickCommand = new Cesium__namespace.DrawCommand({
        owner: command,
        primitiveType: Cesium__namespace.PrimitiveType.TRIANGLES,
        pickOnly: true
      });
      pickCommand.vertexArray = vertexArray;
      pickCommand.renderState = renderState;
      const sp1 = Cesium__namespace.ShaderProgram.fromCache({
        context: context,
        vertexShaderSource: TetrahedronVS,
        fragmentShaderSource: Cesium__namespace.ShaderSource.createPickFragmentShaderSource(TetrahedronFS, "uniform"),
        attributeLocations: attributeLocations
      });
      pickCommand.shaderProgram = sp1;
      pickCommand.uniformMap = command.uniformMap;
      pickCommand.uniformMap.czm_pickColor = () => {
        return command.pickId.color
      };
      pickCommand.pass = Cesium__namespace.Pass.TRANSLUCENT;
      pickCommand.boundingVolume = boundingVolume;
      pickCommand.modelMatrix = this._modelMatrix;

      this._pickCommand = pickCommand;

      return command
    }

    // 创建vertexArray
    createVertexArray(context) {
      const attributeLocations = {
        position: 0,
        textureCoordinates: 1
      };
      const positionsAndIndice = this.cereatePositionsAndIndice();
      const geometry = new Cesium__namespace.Geometry({
        attributes: {
          position: new Cesium__namespace.GeometryAttribute({
            // 使用double类型的position进行计算
            // componentDatatype : Cesium.ComponentDatatype.DOUBLE,
            componentDatatype: Cesium__namespace.ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: positionsAndIndice.positions
          }),
          textureCoordinates: new Cesium__namespace.GeometryAttribute({
            componentDatatype: Cesium__namespace.ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: positionsAndIndice.sts
          })
        },
        // Workaround Internet Explorer 11.0.8 lack of TRIANGLE_FAN
        indices: positionsAndIndice.indices,
        primitiveType: Cesium__namespace.PrimitiveType.TRIANGLES,
        boundingSphere: Cesium__namespace.BoundingSphere.fromVertices(positionsAndIndice.positions)
      });
      // 计算geometry的法向量
      const geometryNormal = Cesium__namespace.GeometryPipeline.computeNormal(geometry);
      const vertexArray = Cesium__namespace.VertexArray.fromGeometry({
        context: context,
        geometry: geometryNormal,
        attributeLocations: attributeLocations,
        bufferUsage: Cesium__namespace.BufferUsage.STATIC_DRAW
      });
      return vertexArray
    }

    // 创建顶点数组与索引
    cereatePositionsAndIndice() {
      const positions = new Float64Array(5 * 3);
      // position 0
      positions[0] = 0.0;
      positions[1] = 1.0;
      positions[2] = 0.0;

      // position 1
      positions[3] = -1.0;
      positions[4] = 0.0;
      positions[5] = 0.0;

      // position 2
      positions[6] = 0.0;
      positions[7] = -1.0;
      positions[8] = 0.0;

      // position 3
      positions[9] = 1.0;
      positions[10] = 0.0;
      positions[11] = 0.0;

      // position 4
      positions[12] = 0.0;
      positions[13] = 0.0;
      positions[14] = -1.0;
      const indices = new Uint16Array(6 * 3);
      // back triangle
      indices[0] = 4;
      indices[1] = 2;
      indices[2] = 3;

      // left triangle
      indices[3] = 4;
      indices[4] = 3;
      indices[5] = 0;

      // right triangle
      indices[6] = 4;
      indices[7] = 0;
      indices[8] = 1;

      // bottom triangle
      indices[9] = 4;
      indices[10] = 1;
      indices[11] = 2;
      // bottom triangle
      indices[12] = 1;
      indices[13] = 2;
      indices[14] = 3;

      // bottom triangle
      indices[15] = 1;
      indices[16] = 3;
      indices[17] = 0;

      // 1.3 定义纹理数组
      const sts = new Float32Array([0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.5, 0.5]);
      return {
        indices: indices,
        positions: positions,
        sts: sts
      }
    }

    /**
     * 设置透明度
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this._globalAlpha = value;
    }

    // 获取对应标绘时的Entity对象
    _getDrawEntityClass(options, isDraw) {
      return this._getDrawPointEntityClass(options, isDraw)
    }
  }

  // 注册下
  register$4("tetrahedron", Tetrahedron);

  var ViewShedFS = "uniform float mars3d_xAngle;\nuniform float mars3d_yAngle;\nuniform float mars3d_distance;\nuniform float mars3d_opacity;\n\nuniform vec3 mars3d_visibleAreaColor;\nuniform vec3 mars3d_hiddenAreaColor;\n\nuniform sampler2D shadowMap_texture;\nuniform mat4 shadowMap_matrix;\nuniform vec4 shadowMap_lightPositionEC;\nuniform vec4 shadowMap_lightDirectionEC;\nuniform vec3 shadowMap_lightUp;\nuniform vec3 shadowMap_lightDir;\nuniform vec3 shadowMap_lightRight;\nuniform vec4 shadowMap_texelSizeDepthBias;\nuniform vec4 shadowMap_normalOffsetScale;\n\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\n\nvec4 toEye(in vec2 uv, in float depth) {\n  vec2 xy = vec2((uv.x * 2.0 - 1.0), (uv.y * 2.0 - 1.0));\n  vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0);\n  posInCamera = posInCamera / posInCamera.w;\n  return posInCamera;\n}\n\nfloat getDepth(in vec4 depth) {\n  float z_window = czm_unpackDepth(depth);\n  z_window = czm_reverseLogDepth(z_window);\n  float n_range = czm_depthRange.near;\n  float f_range = czm_depthRange.far;\n  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv) {\n  return texture2D(shadowMap, uv).r;\n}\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth) {\n  return step(depth, _czm_sampleShadowMap(shadowMap, uv));\n}\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters) {\n  float depthBias = shadowParameters.depthBias;\n  float depth = shadowParameters.depth;\n  float nDotL = shadowParameters.nDotL;\n  float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n  float darkness = shadowParameters.darkness;\n  vec2 uv = shadowParameters.texCoords;\n  depth -= depthBias;\n  vec2 texelStepSize = shadowParameters.texelStepSize;\n  float radius = 1.0;\n  float dx0 = -texelStepSize.x * radius;\n  float dy0 = -texelStepSize.y * radius;\n  float dx1 = texelStepSize.x * radius;\n  float dy1 = texelStepSize.y * radius;\n  float visibility = (_czm_shadowDepthCompare(shadowMap, uv, depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)) * (1.0 / 9.0);\n  return visibility;\n}\n\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point) {\n  vec3 v01 = point - planeOrigin;\n  float d = dot(planeNormal, v01);\n  return (point - planeNormal * d);\n}\nfloat ptm(vec3 pt) {\n  return sqrt(pt.x * pt.x + pt.y * pt.y + pt.z * pt.z);\n}\n\nvoid main() {\n  const float PI = 3.141592653589793;\n  vec4 color = texture2D(colorTexture, v_textureCoordinates);\n  vec4 currD = texture2D(depthTexture, v_textureCoordinates);\n  if(currD.r >= 1.0) {\n    gl_FragColor = color;\n    return;\n  }\n  float depth = getDepth(currD);\n  vec4 positionEC = toEye(v_textureCoordinates, depth);\n  vec3 normalEC = vec3(1.0);\n  czm_shadowParameters shadowParameters;\n  shadowParameters.texelStepSize = shadowMap_texelSizeDepthBias.xy;\n  shadowParameters.depthBias = shadowMap_texelSizeDepthBias.z;\n  shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBias.w;\n  shadowParameters.darkness = shadowMap_normalOffsetScale.w;\n  shadowParameters.depthBias *= max(depth * 0.01, 1.0);\n\n  vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);\n  float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0);\n  vec4 shadowPosition = shadowMap_matrix * positionEC;\n  shadowPosition /= shadowPosition.w;\n  if(any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) {\n    gl_FragColor = color;\n    return;\n  }\n\n  //坐标与视点位置距离，大于最大距离则舍弃阴影效果\n  vec4 lw = czm_inverseView * vec4(shadowMap_lightPositionEC.xyz, 1.0);\n  vec4 vw = czm_inverseView * vec4(positionEC.xyz, 1.0);\n  if(distance(lw.xyz, vw.xyz) > mars3d_distance) {\n    gl_FragColor = color;\n    return;\n  }\n\n  //水平夹角限制\n  vec3 ptOnSP = pointProjectOnPlane(shadowMap_lightUp, lw.xyz, vw.xyz);\n  directionEC = ptOnSP - lw.xyz;\n  float directionECMO = ptm(directionEC.xyz);\n  float shadowMap_lightDirMO = ptm(shadowMap_lightDir.xyz);\n  float cosJJ = dot(directionEC, shadowMap_lightDir) / (directionECMO * shadowMap_lightDirMO);\n  float degJJ = abs(acos(cosJJ) * (180.0 / PI));\n  if(degJJ > mars3d_xAngle) {\n    gl_FragColor = color;\n    return;\n  }\n\n  //垂直夹角限制\n  vec3 ptOnCZ = pointProjectOnPlane(shadowMap_lightRight, lw.xyz, vw.xyz);\n  vec3 dirOnCZ = ptOnCZ - lw.xyz;\n  float dirOnCZMO = ptm(dirOnCZ);\n  float cosJJCZ = dot(dirOnCZ, shadowMap_lightDir) / (dirOnCZMO * shadowMap_lightDirMO);\n  float degJJCZ = abs(acos(cosJJCZ) * (180.0 / PI));\n  if(degJJCZ > mars3d_yAngle) {\n    gl_FragColor = color;\n    return;\n  }\n\n  shadowParameters.texCoords = shadowPosition.xy;\n  shadowParameters.depth = shadowPosition.z;\n  shadowParameters.nDotL = nDotL;\n  float visibility = _czm_shadowVisibility(shadowMap_texture, shadowParameters);\n\n  //可视域\n  if(visibility == 1.0) {\n    gl_FragColor = mix(color, vec4(mars3d_visibleAreaColor, 1.0), mars3d_opacity);\n  } else {\n    gl_FragColor = mix(color, vec4(mars3d_hiddenAreaColor, 1.0), mars3d_opacity);\n  }\n}\n"; // eslint-disable-line

  const DEF_STYLE$1 = {
    angle: 60,
    angle2: 45,
    distance: 1000,
    opacity: 0.6, // 透明度
    addHeight: 0,
    showFrustum: false
  };

  /**
   * 可视域矢量对象 支持的样式信息
   *
   * @typedef {Object} ViewShed.StyleOptions
   *
   * @property {Number} [angle=60]  水平张角(度数)，取值范围 0-60
   * @property {Number} [angle2=45]  垂直张角(度数)，取值范围 0-45
   * @property {Number} [distance] 投射最远距离，单位：米
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   * @property {Number} [opacity=0.6] 透明度 0.0 - 1.0
   * @property {Cesium.Color|String} [visibleAreaColor = new Cesium.Color(0, 1, 0)] 可视区域颜色
   * @property {Cesium.Color|String} [hiddenAreaColor =  new Cesium.Color(1, 0, 0)] 不可视区域颜色
   * @property {Number} [addHeight] 在坐标点增加的高度值，规避遮挡，效果更友好
   * @property {Boolean} [showFrustum=false] 是否显示视椎体框线
   *
   */

  /**
   * 可视域 矢量对象，该对象暂不支持鼠标交互和拾取
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 相机位置
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} [options.targetPosition] 目标视点位置,可以替代style中的相机heading\pitch\roll方向和distance距离参数
   * @param {ViewShed.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   * @param {Boolean} [options.terrain = true] 是否启用地形的阴影效果，在平原地区或无地形时可以关闭
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @export
   * @class ViewShed
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class ViewShed extends BasePointPrimitive {
    //= ========= 构造方法 ==========
    constructor(options = {}, mergeDefStyle = true) {
      if (mergeDefStyle) {
        options.style = {
          ...DEF_STYLE$1,
          ...(options.style || {})
        };
      }
      super(options);

      this._visibleAreaColor = getCesiumColor(this.style.visibleAreaColor, new Cesium__namespace.Color(0, 1, 0)); // 可视颜色
      this._hiddenAreaColor = getCesiumColor(this.style.hiddenAreaColor, new Cesium__namespace.Color(1, 0, 0)); // 不可视颜色
      this._hasTerrainShadows = this.options.terrain ?? true;
      this._maximumDistance = this.style.maximumDistance ?? 5000;
    }

    //= ========= 对外属性 ==========
    get czmObject() {
      return this._postProcessStage
    }

    /**
     * 水平张角，半场角度
     * @type {Number}
     */
    get angle() {
      return this.style.angle
    }

    set angle(val) {
      this.style.angle = val;
      this._updateDraw();
    }

    /**
     * 垂直张角，半场角度
     * @type {Number}
     */
    get angle2() {
      return this.style.angle2 ?? this.style.angle
    }

    set angle2(val) {
      this.style.angle2 = val;
      this._updateDraw();
    }

    /**
     *  可视区域颜色
     * @type {Cesium.Color}
     */
    get visibleAreaColor() {
      return this._visibleAreaColor
    }

    set visibleAreaColor(val) {
      this._visibleAreaColor = getCesiumColor(val);
    }

    /**
     *  不可视区域颜色
     * @type {Cesium.Color}
     */
    get hiddenAreaColor() {
      return this._hiddenAreaColor
    }

    set hiddenAreaColor(val) {
      this._hiddenAreaColor = getCesiumColor(val);
    }

    /**
     * 混合系数0-1
     * @type {Number}
     */
    get opacity() {
      return this.style.opacity
    }

    set opacity(val) {
      this.style.opacity = val;
    }

    /**
     * 是否显示视椎体框线
     * @type {Boolean}
     */
    get showFrustum() {
      return this.style.showFrustum
    }

    set showFrustum(val) {
      this.style.showFrustum = val;
      this._frustumPrimitive.show = val;
    }

    /**
     * 距离，单位：米
     * @type {Number}
     */
    get distance() {
      return this.style.distance
    }

    set distance(val) {
      this.style.distance = val;
      this._updateDraw();
    }

    /**
     * 相机对象
     * @type {Cesium.Camera}
     * @readonly
     */
    get camera() {
      return this._shadowMap?._lightCamera
    }

    /**
     * 目标点位置(笛卡尔坐标)
     * @type {Cesium.Cartesian3|LngLatPoint}
     */
    get targetPosition() {
      return this.options.targetPosition
    }

    set targetPosition(value) {
      this.options.targetPosition = value;
      if (!this._map) {
        return
      }

      const cameraPosition = this.position;
      if (!cameraPosition) {
        return
      }
      const targetPosition = LngLatPoint.toCartesian(value, this._map?.currentTime);
      this.distance = Cesium__namespace.Cartesian3.distance(cameraPosition, targetPosition);

      const direction = Cesium__namespace.Cartesian3.normalize(
        Cesium__namespace.Cartesian3.subtract(targetPosition, cameraPosition, new Cesium__namespace.Cartesian3()),
        new Cesium__namespace.Cartesian3()
      );
      const up = Cesium__namespace.Cartesian3.normalize(cameraPosition, new Cesium__namespace.Cartesian3());
      const camera = new Cesium__namespace.Camera(this._map.scene);
      camera.position = cameraPosition;
      camera.direction = direction;
      camera.up = up;
      this.style.heading = Cesium__namespace.Math.toDegrees(camera.heading);
      this.style.pitch = Cesium__namespace.Math.toDegrees(camera.pitch);
      // this.style.roll = Cesium.Math.toDegrees(camera.roll);

      this._updateDraw();
    }

    //= ========= 方法 ==========

    _showHook() {
      if (this.show) {
        this._updateDraw();
      } else {
        this._clearDraw();
      }
    }

    _updatePositionsHook() {
      this._updateDraw();
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      // targetPosition的处理
      if (this.options.targetPosition) {
        this.targetPosition = this.options.targetPosition;
      }

      // 默认材质
      this._defaultColorTexture = new Cesium__namespace.Texture({
        context: this._map.scene.context,
        source: {
          width: 1,
          height: 1,
          arrayBufferView: new Uint8Array([0, 0, 0, 0])
        },
        flipY: false
      });
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (this._hasTerrainShadows) {
        this._map.viewer.terrainShadows = Cesium__namespace.ShadowMode.ENABLED; // 山体阴影
      }

      this._updateDraw();

      this.primitiveCollection.add(this);
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this._hasTerrainShadows) {
        this._map.terrainShadows = Cesium__namespace.ShadowMode.DISABLED; // 山体阴影
      }

      this._clearDraw();

      if (this.primitiveCollection.contains(this)) {
        this._noDestroy = true;
        this.primitiveCollection.remove(this);
        this._noDestroy = false;
      }
    }

    // 调整heading、pitch触发
    updateModelMatrix() {
      this._updateDraw();
    }

    _updateDraw() {
      if (!this._map) {
        return
      }
      this._clearDraw();

      // createCamera
      const cameraPosition = this.position;
      if (!cameraPosition) {
        return
      }

      const hpr = new Cesium__namespace.HeadingPitchRoll(Cesium__namespace.Math.toRadians(this.heading), Cesium__namespace.Math.toRadians(this.pitch), Cesium__namespace.Math.toRadians(this.roll));

      const _camera = new Cesium__namespace.Camera(this._map.scene);
      _camera.position = cameraPosition;
      _camera.frustum.fov = Cesium__namespace.Math.toRadians(this.angle * 2);
      _camera.frustum.aspectRatio = this.angle / this.angle2;
      _camera.frustum.near = 0.01;
      _camera.frustum.far = this.distance;
      _camera.setView({
        destination: cameraPosition,
        orientation: {
          heading: hpr.heading,
          pitch: hpr.pitch,
          roll: hpr.roll
        }
      });

      this._createFrustumPrimitive(_camera);

      this._shadowMap = new Cesium__namespace.ShadowMap({
        lightCamera: _camera,
        context: this._map.scene.context,
        maximumDistance: this._maximumDistance,
        isSpotLight: true,
        cascadesEnabled: false,
        enabled: false
      });

      this._createPostProcessStage();
    }

    _clearDraw() {
      if (!this._map) {
        return
      }

      if (this._postProcessStage) {
        this._map.scene.postProcessStages.remove(this._postProcessStage);
        delete this._postProcessStage;
      }
      if (this._shadowMap) {
        this._shadowMap.destroy();
        delete this._shadowMap;
      }
      if (this._frustumPrimitive) {
        this._layer.removeGraphic(this._frustumPrimitive, true);
        delete this._frustumPrimitive;
      }
    }

    update(frameState) {
      if (this._shadowMap) {
        frameState.shadowMaps.push(this._shadowMap);
      }
    }

    // 创建 视椎体框线
    _createFrustumPrimitive(camera) {
      if (this._frustumPrimitive) {
        this._layer.removeGraphic(this._frustumPrimitive, true);
      }

      const radius = this.distance + 1;

      // this._frustumPrimitive = new EllipsoidEntity({
      //   position: this.position,
      //   style: {
      //     heading: this.heading - 90,
      //     pitch: this.pitch,
      //     roll: this.roll,
      //     radii: new Cesium.Cartesian3(radius, radius, radius),
      //     minimumClockDegree: -this.angle,
      //     maximumClockDegree: this.angle,
      //     minimumConeDegree: 180 - this.angle2,
      //     maximumConeDegree: this.angle2,
      //     fill: false,
      //     outline: true,
      //     outlineColor: "#ffffff",
      //     subdivisions: 64,
      //     stackPartitions: 32,
      //     slicePartitions: 32,
      //   },
      //   show: this.showFrustum && this.show,
      // });

      this._frustumPrimitive = new ArcFrustum({
        modelMatrix: camera.inverseViewMatrix,
        style: {
          angle: this.angle,
          angle2: this.angle2,
          distance: radius
        },
        show: this.showFrustum && this.show,
        private: true
      });
      this._layer.addGraphic(this._frustumPrimitive);
    }

    // 构造 PostProcessStage
    _createPostProcessStage() {
      if (this._postProcessStage) {
        this._map.scene.postProcessStages.remove(this._postProcessStage);
        delete this._postProcessStage;
      }

      const textureSize = new Cesium__namespace.Cartesian2();
      const texelSizeDepthBias = new Cesium__namespace.Cartesian4();
      const normalOffsetScale = new Cesium__namespace.Cartesian4();
      const bias = this._shadowMap._primitiveBias;

      this._postProcessStage = new Cesium__namespace.PostProcessStage({
        fragmentShader: ViewShedFS,
        uniforms: {
          mars3d_opacity: () => {
            return this.opacity
          },
          mars3d_visibleAreaColor: () => {
            return this.visibleAreaColor
          },
          mars3d_hiddenAreaColor: () => {
            return this.hiddenAreaColor
          },
          mars3d_distance: () => {
            return this.distance
          },
          mars3d_xAngle: () => {
            return this.angle
          },
          mars3d_yAngle: () => {
            return this.angle2
          },
          shadowMap_texture: () => {
            return this._shadowMap._shadowMapTexture || this._defaultColorTexture
          },
          shadowMap_matrix: () => {
            return this._shadowMap._shadowMapMatrix
          },
          shadowMap_lightPositionEC: () => {
            return this._shadowMap._lightPositionEC
          },
          shadowMap_lightDirectionEC: () => {
            return this._shadowMap._lightDirectionEC
          },
          shadowMap_lightUp: () => {
            return this._shadowMap._lightCamera.up
          },
          shadowMap_lightDir: () => {
            return this._shadowMap._lightCamera.direction
          },
          shadowMap_lightRight: () => {
            return this._shadowMap._lightCamera.right
          },
          shadowMap_texelSizeDepthBias: () => {
            textureSize.x = 1 / this._shadowMap._textureSize.x;
            textureSize.y = 1 / this._shadowMap._textureSize.y;
            return Cesium__namespace.Cartesian4.fromElements(textureSize.x, textureSize.y, bias.depthBias, bias.normalShadingSmooth, texelSizeDepthBias) // depthBias-深度偏差(范围0-16),确保共面的轮廓被适当地呈现出来
          },
          shadowMap_normalOffsetScale: () => {
            return Cesium__namespace.Cartesian4.fromElements(
              bias.normalOffsetScale,
              this._shadowMap._distance,
              this._shadowMap.maximumDistance,
              this._shadowMap._darkness,
              normalOffsetScale
            )
          }
        }
      });
      this._map.scene.postProcessStages.add(this._postProcessStage);
    }

    // style样式转object
    _style2JsonBase(style, isGeoJSON) {
      style.heading = formatNum$1(this.heading, 1);
      style.pitch = formatNum$1(this.pitch, 1);
      style.distance = formatNum$1(this.distance, 2);

      return getAttrVal(style, { onlySimpleType: true })
    }

    /**
     * 定位至相机的第一视角
     * @return {void}  无
     */
    setView() {
      if (!this._map) {
        return
      }

      const _camera = this.camera;
      if (!_camera) {
        return
      }

      this._map.camera.position = Cesium__namespace.clone(this.position);
      this._map.camera.direction = Cesium__namespace.clone(_camera.direction);
      this._map.camera.right = Cesium__namespace.clone(_camera.right);
      this._map.camera.up = Cesium__namespace.clone(_camera.up);
    }

    /**
     * 设置透明度
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this.style.opacity = value;
    }

    //= =================Draw绘制相关=================
    /**
     * 开始绘制矢量数据，绘制的数据会加载在layer图层。
     *
     * @param {GraphicLayer} layer 图层
     * @return {void}  无
     */
    startDraw(layer) {
      if (this._enabledDraw) {
        return this
      }
      this._enabledDraw = true;

      if (layer) {
        this.addTo(layer);
      }
      if (!this._map) {
        throw new Error("绘制时_map不能为空,请将对象添加到图层，并且图层已添加到Map")
      }

      this._map._setEditCursor(true);
      this.enableControl(false);

      this._startDrawHook();

      this.fire(EventType.drawStart, { drawtype: this.type, graphic: this }, true);
    }

    /**
     * 停止绘制
     * @return {void}  无
     */
    stopDraw() {
      if (!this._enabledDraw) {
        return this
      }

      this._stopDrawHook();

      this._map._setEditCursor(false);
      this.enableControl(true);
      this._map.closeSmallTooltip();

      this._enabledDraw = false;

      if (!this.position || !this.distance) {
        this.remove(true);
        return
      }
      this.fire(EventType.drawCreated, { drawtype: this.type, graphic: this }, true);

      if (this.options?.success) {
        this.options.success(this);
      }
      if (this.options?._promise?.resolve) {
        this.options._promise.resolve(this);
      }
    }

    _startDrawHook() {
      this._map.on(EventType.click, this._onClickHandler, this);
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);
    }

    _stopDrawHook() {
      this._map.off(EventType.click, this._onClickHandler, this);
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);
    }

    _onClickHandler(event) {
      let cartesian = event.cartesian;
      if (!cartesian) {
        return
      }

      this.fire(EventType.drawAddPoint, { ...event, drawtype: this.type, graphic: this }, true);

      if (!this.position) {
        this.position = addPositionsHeight(cartesian, this.style.addHeight); // 相机位置
        return
      }

      const len = Cesium__namespace.Cartesian3.distance(this.position, cartesian);
      if (len > this._maximumDistance) {
        cartesian = getOnLinePointByLen(this.position, cartesian, this._maximumDistance);
      }
      this.targetPosition = cartesian;

      this.stopDraw();
      this.fire(EventType.drawCreated, event);
    }

    _onMouseMoveHandler(event) {
      let targetPosition = event.cartesian;
      if (!targetPosition) {
        return
      }

      const position = this.position;
      if (position) {
        const len = Cesium__namespace.Cartesian3.distance(position, targetPosition);
        if (len > this._maximumDistance) {
          targetPosition = getOnLinePointByLen(position, targetPosition, this._maximumDistance);
        }
        this.targetPosition = targetPosition;

        this.fire(EventType.drawMouseMove, { ...event, drawtype: this.type, graphic: this }, true);

        this._map.openSmallTooltip(event.endPosition, this._map.getLangText("_单击完成绘制"));
      } else {
        this._map.openSmallTooltip(event.endPosition, this._map.getLangText("_单击开始绘制"));
      }
    }
  }

  // 注册下
  register$4("viewShed", ViewShed);

  var ViewVideoFS = "uniform float mars3d_opacity;\n\nuniform sampler2D mars3d_videoTexture;\nuniform sampler2D mars3d_maskTexture;\nuniform vec4 mars3d_hiddenAreaColor;\n\nuniform sampler2D shadowMap_texture;\nuniform mat4 shadowMap_matrix;\nuniform vec4 shadowMap_lightPositionEC;\nuniform vec4 shadowMap_texelSizeDepthBias;\nuniform vec4 shadowMap_normalOffsetScale;\n\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\n\nvec4 toEye(in vec2 uv, in float depth) {\n  vec2 xy = vec2((uv.x * 2.0 - 1.0), (uv.y * 2.0 - 1.0));\n  vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0);\n  posInCamera = posInCamera / posInCamera.w;\n  return posInCamera;\n}\n\nfloat getDepth(in vec4 depth) {\n  float z_window = czm_unpackDepth(depth);\n  z_window = czm_reverseLogDepth(z_window);\n  float n_range = czm_depthRange.near;\n  float f_range = czm_depthRange.far;\n  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv) {\n  return texture2D(shadowMap, uv).r;\n}\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth) {\n  return step(depth, _czm_sampleShadowMap(shadowMap, uv));\n}\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters) {\n  float depthBias = shadowParameters.depthBias;\n  float depth = shadowParameters.depth;\n  float nDotL = shadowParameters.nDotL;\n  float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n  float darkness = shadowParameters.darkness;\n  vec2 uv = shadowParameters.texCoords;\n  depth -= depthBias;\n  vec2 texelStepSize = shadowParameters.texelStepSize;\n  float radius = 1.0;\n  float dx0 = -texelStepSize.x * radius;\n  float dy0 = -texelStepSize.y * radius;\n  float dx1 = texelStepSize.x * radius;\n  float dy1 = texelStepSize.y * radius;\n  float visibility = (_czm_shadowDepthCompare(shadowMap, uv, depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)) * (1.0 / 9.0);\n  return visibility;\n}\n\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point) {\n  vec3 v01 = point - planeOrigin;\n  float d = dot(planeNormal, v01);\n  return (point - planeNormal * d);\n}\nfloat ptm(vec3 pt) {\n  return sqrt(pt.x * pt.x + pt.y * pt.y + pt.z * pt.z);\n}\n\nvoid main() {\n  const float PI = 3.141592653589793;\n  vec4 color = texture2D(colorTexture, v_textureCoordinates);\n  vec4 currD = texture2D(depthTexture, v_textureCoordinates);\n  if(currD.r >= 1.0) {\n    gl_FragColor = color;\n    return;\n  }\n  float depth = getDepth(currD);\n  vec4 positionEC = toEye(v_textureCoordinates, depth);\n  vec3 normalEC = vec3(1.0);\n  czm_shadowParameters shadowParameters;\n  shadowParameters.texelStepSize = shadowMap_texelSizeDepthBias.xy;\n  shadowParameters.depthBias = shadowMap_texelSizeDepthBias.z;\n  shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBias.w;\n  shadowParameters.darkness = shadowMap_normalOffsetScale.w;\n  shadowParameters.depthBias *= max(depth * 0.01, 1.0);\n\n  vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);\n  float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0);\n  vec4 shadowPosition = shadowMap_matrix * positionEC;\n  shadowPosition /= shadowPosition.w;\n  if(any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) {\n    gl_FragColor = color;\n    return;\n  }\n\n  shadowParameters.texCoords = shadowPosition.xy;\n  shadowParameters.depth = shadowPosition.z;\n  shadowParameters.nDotL = nDotL;\n  float visibility = _czm_shadowVisibility(shadowMap_texture, shadowParameters);\n\n  //视频投射\n  if(visibility == 1.0) {\n    vec4 videoColor = texture2D(mars3d_videoTexture, shadowPosition.xy);\n    vec4 maskColor = texture2D(mars3d_maskTexture, shadowPosition.xy);\n    videoColor *= maskColor;\n    gl_FragColor = mix(color, vec4(videoColor.xyz, 1.0), mars3d_opacity * videoColor.a);\n  } else {\n    if(abs(shadowPosition.z - 0.0) < 0.01) {\n      return;\n    }\n    gl_FragColor = vec4(mix(color.rgb, mars3d_hiddenAreaColor.rgb, mars3d_hiddenAreaColor.a), mars3d_hiddenAreaColor.a);\n  }\n}\n"; // eslint-disable-line

  const DEF_STYLE = {
    angle: 60,
    angle2: 45,
    distance: 1000,
    opacity: 1.0, // 透明度
    showFrustum: false,
    hiddenAreaColor: new Cesium__namespace.Color(0, 0, 0, 0.5)
  };

  // 原理：在可视域的基础上，着色器里传入纹理，再计算UV进行贴图

  /**
   * 视频融合（投射3D，贴物体表面） 支持的样式信息
   *
   * @typedef {Object} Video3D.StyleOptions
   *
   * @property {HTMLVideoElement} [container] video视频DOM容器
   * @property {String} [url] 视频的URL路径,与DOM二选一
   * @property {String} [maskImage] 遮盖融合的图片url地址，可以用于视频的四周羽化效果。
   *
   * @property {Number} angle  水平张角(度数)
   * @property {Number} angle2  垂直张角(度数)
   * @property {Number} [distance] 投射最远距离，单位：米
   * @property {Number} [heading = 0] 方向角 （度数值，0-360度）
   * @property {Number} [pitch = 0] 俯仰角（度数值，0-360度）
   * @property {Number} [roll = 0] 翻滚角（度数值，0-360度）
   * @property {Number} [opacity=1.0] 透明度 0.0 - 1.0
   * @property {Cesium.Color|String} [hiddenAreaColor=new Cesium.Color(0, 0, 0, 0.5)] 无视频投影区域的颜色
   * @property {Boolean} [showFrustum=false] 是否显示视椎体框线
   *
   */

  /**
   * 视频融合（投射3D，贴物体表面），该对象暂不支持鼠标交互和拾取
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} options.position 相机位置
   * @param {LngLatPoint|Cesium.Cartesian3|Number[]} [options.targetPosition] 目标视点位置,可以替代style中的相机heading\pitch\roll方向和distance距离参数
   * @param {Video3D.StyleOptions} options.style 样式信息
   * @param {Object} [options.attr] 附件的属性信息，可以任意附加属性，导出geojson或json时会自动处理导出。
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @export
   * @class Video3D
   * @extends {ViewShed}
   * @see [支持的事件类型]{@link BaseGraphic.EventType}
   */
  class Video3D extends ViewShed {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      options.style = {
        ...DEF_STYLE,
        ...(options.style || {})
      };
      options.terrain = false;
      super(options, false);

      this._videoPlay = true;
    }

    //= ========= 对外属性 ==========
    /**
     * 对应的视频DOM元素
     * @type {HTMLVideoElement}
     * @readonly
     */
    get container() {
      return this._videoContainer
    }

    /**
     * 最远投射距离，单位：米
     * @type {Number}
     */
    get distance() {
      return this.style.distance
    }

    set distance(val) {
      this.style.distance = val * 2;
      this._updateDraw();
    }

    /**
     * 暂停或播放 视频
     * @type {Boolean}
     */
    get play() {
      return this._videoPlay
    }

    set play(val) {
      this._videoPlay = Boolean(val);
      if (this._videoContainer) {
        try {
          if (this.videoPlay) {
            this._videoContainer.play();
          } else {
            this._videoContainer.pause();
          }
        } catch (e) {
          // 规避浏览器权限异常
        }
      }
    }

    //= ========= 方法 ==========

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      super._mountedHook();

      // 叠加mask图片
      const maskImage = this.style.maskImage;
      if (maskImage) {
        const image = new Image();
        image.onload = (e) => {
          this._maskTexture = new Cesium__namespace.Texture({
            context: this._map.scene.context,
            source: image
          });
        };
        image.onerror = (e) => {
          logError("图片加载失败：" + maskImage, e);
        };
        image.src = maskImage;
      } else {
        this._maskTexture = new Cesium__namespace.Texture({
          context: this._map.scene.context,
          source: {
            width: 1,
            height: 1,
            arrayBufferView: new Uint8Array([255, 255, 255, 255])
          },
          flipY: false
        });
      }

      // 创建DOM
      if (this.style.container) {
        this._videoContainer = this.style.container;
      } else if (this.style.url) {
        this._videoContainer = createVideo(this.style.url, this.style.fileType, "", document.body);
        this._videoContainer.style.display = "none";
        this._hasRemoveElement = true;
      }

      if (this._videoContainer) {
        this._map.on(EventType.clockTick, this._onClockTickHandler, this);
      }
    }

    /**
     * 对象从图层上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.off(EventType.clockTick, this._onClockTickHandler, this); // 删除视频播放监听
      if (this._hasRemoveElement && this._videoContainer?.parentNode) {
        this._videoContainer.parentNode.removeChild(this._videoContainer);
        delete this._hasRemoveElement;
        delete this._videoContainer;
      }
      super._removedHook();
    }

    _onClockTickHandler() {
      try {
        if (this._videoPlay && this._videoContainer.paused) {
          this._videoContainer.play();
        }
      } catch (e) {
        // 规避浏览器权限异常
      }

      if (!this._videoContainer || !this._map) {
        return
      }

      this._videoTexture && this._videoTexture.destroy();
      this._videoTexture = new Cesium__namespace.Texture({
        context: this._map.scene.context,
        source: this._videoContainer,
        pixelFormat: Cesium__namespace.PixelFormat.RGBA,
        pixelDatatype: Cesium__namespace.PixelDatatype.UNSIGNED_BYTE
      });
    }

    _clearDraw() {
      if (this._frustumPrimitive) {
        this.primitiveCollection.remove(this._frustumPrimitive);
        delete this._frustumPrimitive;
      }
      super._clearDraw();
    }

    // 创建 视椎体框线
    _createFrustumPrimitive(_camera) {
      // 计算视锥姿态
      const direction = _camera.directionWC;
      const up = _camera.upWC;
      let right = _camera.rightWC;
      right = Cesium__namespace.Cartesian3.negate(right, new Cesium__namespace.Cartesian3());

      const rotation = new Cesium__namespace.Matrix3();
      Cesium__namespace.Matrix3.setColumn(rotation, 0, right, rotation);
      Cesium__namespace.Matrix3.setColumn(rotation, 1, up, rotation);
      Cesium__namespace.Matrix3.setColumn(rotation, 2, direction, rotation);
      const orientation = Cesium__namespace.Quaternion.fromRotationMatrix(rotation, new Cesium__namespace.Quaternion());

      // 构造 FrustumOutlineGeometry
      if (this._frustumPrimitive) {
        this.primitiveCollection.remove(this._frustumPrimitive);
      }
      this._frustumPrimitive = new Cesium__namespace.Primitive({
        geometryInstances: new Cesium__namespace.GeometryInstance({
          id: this.id,
          geometry: new Cesium__namespace.FrustumOutlineGeometry({
            origin: _camera.position,
            orientation: orientation,
            frustum: _camera.frustum,
            _drawNearPlane: true
          }),
          attributes: {
            color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(Cesium__namespace.Color.AZURE)
          }
        }),
        appearance: new Cesium__namespace.PerInstanceColorAppearance({
          translucent: false,
          flat: true
        }),
        asynchronous: false,
        show: this.showFrustum && this.show
      });
      this.primitiveCollection.add(this._frustumPrimitive);
      this.bindPickId(this._frustumPrimitive);
    }

    // 构造 PostProcessStage
    _createPostProcessStage() {
      if (this._postProcessStage) {
        this._map.scene.postProcessStages.remove(this._postProcessStage);
        delete this._postProcessStage;
      }

      const textureSize = new Cesium__namespace.Cartesian2();
      const texelSizeDepthBias = new Cesium__namespace.Cartesian4();
      const normalOffsetScale = new Cesium__namespace.Cartesian4();
      const bias = this._shadowMap._primitiveBias;

      this._postProcessStage = new Cesium__namespace.PostProcessStage({
        fragmentShader: ViewVideoFS,
        uniforms: {
          mars3d_videoTexture: () => {
            return this._videoTexture || this._defaultColorTexture
          },
          mars3d_maskTexture: () => {
            return this._maskTexture
          },
          mars3d_opacity: () => {
            return this.opacity
          },
          mars3d_hiddenAreaColor: () => {
            return this.hiddenAreaColor
          },
          shadowMap_texture: () => {
            return this._shadowMap._shadowMapTexture || this._defaultColorTexture
          },
          shadowMap_matrix: () => {
            return this._shadowMap._shadowMapMatrix
          },
          shadowMap_lightPositionEC: () => {
            return this._shadowMap._lightPositionEC
          },
          shadowMap_texelSizeDepthBias: () => {
            textureSize.x = 1 / this._shadowMap._textureSize.x;
            textureSize.y = 1 / this._shadowMap._textureSize.y;
            return Cesium__namespace.Cartesian4.fromElements(textureSize.x, textureSize.y, bias.depthBias, bias.normalShadingSmooth, texelSizeDepthBias) // depthBias-深度偏差(范围0-16),确保共面的轮廓被适当地呈现出来
          },
          shadowMap_normalOffsetScale: () => {
            return Cesium__namespace.Cartesian4.fromElements(
              bias.normalOffsetScale,
              this._shadowMap._distance,
              this._shadowMap.maximumDistance,
              this._shadowMap._darkness,
              normalOffsetScale
            )
          }
        }
      });
      this._map.scene.postProcessStages.add(this._postProcessStage);
    }


  }

  // 注册下
  register$4("video3D", Video3D);

  let globeLastRoam;

  /**
   * @typedef {Object} Route.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} change 变化了
   * @property {String} endItem 完成了一个传入坐标点的漫游
   * @property {String} end 完成了当前所有点的漫游
   *
   * @property {String} add 添加对象
   * @property {String} remove 移除对象
   * @property {String} show 显示了对象
   * @property {String} hide 隐藏了对象
   *
   * @property {String} popupOpen popup弹窗打开后
   * @property {String} popupClose popup弹窗关闭
   * @property {String} tooltipOpen tooltip弹窗打开后
   * @property {String} tooltipClose tooltip弹窗关闭
   * @property {String} contextMenuOpen 右键菜单 打开后
   * @property {String} contextMenuClose 右键菜单 关闭
   * @property {String} contextMenuClick 右键菜单 单击某一项后
   * @property {String} highlightOpen highlight高亮后
   * @property {String} highlightClose highlight关闭后
   *
   * @property {String} click 左键单击 鼠标事件
   * @property {String} rightClick 右键单击 鼠标事件
   * @property {String} mouseOver 鼠标移入 鼠标事件
   * @property {String} mouseOut 鼠标移出 鼠标事件
   *
   * @example
   * //绑定监听事件
   * graphic.on(mars3d.EventType.change, function (event) {
   *   console.log('坐标发生了变化', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   *
   * 动态实时轨迹路线，是由多个其他类型Graphic组合而成，方便一起控制和管理。<br />
   * 使用 {@link Route#addDynamicPosition} 方法来添加动画轨迹点位置。
   * 如果只是显示单个模型等对象，建议直接使用对应的矢量对象，效率更高。
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Object} [options.attr] 矢量数据的 属性信息，可以任意附加属性。
   *
   * @param {LabelPrimitive.StyleOptions} [options.label]  使用 文本 对象，及其对应的样式
   * @param {BillboardEntity.StyleOptions} [options.billboard]  使用 图标 对象，及其对应的样式
   * @param {PointPrimitive.StyleOptions} [options.point]  使用 图标 对象，及其对应的样式
   * @param {ModelPrimitive.StyleOptions} [options.model]  使用 gltf模型 对象，及其对应的样式
   * @param {CircleEntity.StyleOptions} [options.circle]  使用 圆 对象，及其对应的样式
   * @param {ConeTrack.StyleOptions} [options.coneTrack]  使用 圆锥体 对象，及其对应的样式
   * @param {PathEntity.StyleOptions} [options.path]  使用 path轨迹 对象，及其对应的样式
   * @param {PolylineEntity.StyleOptions} [options.polyline]  使用 polyline路线 对象，及其对应的样式 <br/>
  //  * @param {Number} [options.polyline.maxDistance] 设置保留的轨迹长度值（单位：米），不设置时保留所有的轨迹
   * @param {WallEntity.StyleOptions} [options.wall]  使用 墙体 对象，及其对应的样式 <br/>
  //  * @param {Number} [options.wall.maxDistance] 设置保留的轨迹长度值（单位：米），不设置时保留所有的轨迹<br/>
  //  * @param {Number} [options.wall.surface] 设置墙底部高度是否贴地
   *
   * @param {Number} [options.frameRate = 1] 多少帧获取一次数据。用于控制效率，如果卡顿就把该数值调大一些。
   * @param {Number} [options.maxCacheCount=100] 保留的坐标点数量,当为-1时保留所有
   * @param {Cesium.ExtrapolationType} [options.forwardExtrapolationType= Cesium.ExtrapolationType.HOLD]   在任何可用坐标之后一次请求值时要执行的推断类型，默认为最后一个坐标位置。
   * @param {Cesium.ExtrapolationType} [options.backwardExtrapolationType= Cesium.ExtrapolationType.HOLD] 在任何可用坐标之前一次请求值时要执行的推断类型，默认为第一个坐标位置。
   * @param {Cesium.Transforms.LocalFrameToFixedFrame} [options.fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
   * @param {Cesium.Property|Object} [options.orientation] 自定义实体方向, 默认内部根据轨迹自动的
   *
   * @param {Object} [options.camera] 视角模式设置，包括：
   * @param {String} [options.camera.type]  视角模式类型，包括：'':无、'gs':跟随视角、'dy':第一视角、'sd':上帝视角
   * @param {Number} [options.camera.radius] 'gs'跟随视角时的 初始俯仰距离值（单位：米）
   * @param {Number} [options.camera.heading] 'gs'跟随视角时的 初始方向角度值，绕垂直于地心的轴旋转角度, 0至360
   * @param {Number} [options.camera.pitch] 'gs'跟随视角时的 初始俯仰角度值，绕纬度线旋转角度, 0至360
   * @param {Number} [options.camera.followedX=50] 'dy'锁定第一视角时，距离运动点的距离（后方）
   * @param {Number} [options.camera.followedZ=10] 'dy'锁定第一视角或'sd'上帝视角时，距离运动点的高度（上方）
   * @param {Number} [options.camera.offsetX=0] 'dy'锁定第一视角时，锁定点的本身的X轴方向（前后）偏移值
   * @param {Number} [options.camera.offsetY=0] 'dy'锁定第一视角时，锁定点的本身的Y轴方向（横向）偏移值
   * @param {Number} [options.camera.offsetZ=0] 'dy'锁定第一视角时，锁定点的本身的Z轴方向（高度）偏移值
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class Route
   * @extends {BasePointPrimitive}
   * @see [支持的事件类型]{@link Route.EventType}
   */
  class Route extends BasePointPrimitive {
    constructor(options = {}) {
      super(options);

      // 默认属性
      this.options.frameRate = this.options.frameRate ?? 1;
      this._maxCacheCount = this.options.maxCacheCount ?? 100; // 保留的坐标点数量
      this._fixedFrameTransform = this.options.fixedFrameTransform ?? Cesium__namespace.Transforms.eastNorthUpToFixedFrame; // 参考系

      // 内部变量
      this._child = {};
      this._position_result = new Cesium__namespace.Cartesian3();

      this.property = new Cesium__namespace.SampledPositionProperty();
      this.property.forwardExtrapolationType = this.options.forwardExtrapolationType ?? Cesium__namespace.ExtrapolationType.HOLD;
      this.property.backwardExtrapolationType = this.options.backwardExtrapolationType ?? Cesium__namespace.ExtrapolationType.HOLD;

      this._orientation = this.options.orientation || new Cesium__namespace.VelocityOrientationProperty(this.property);
    }

    /**
     * 文本 子对象
     * @type {LabelPrimitive|*}
     */
    get label() {
      return this._child.label
    }

    set label(value) {
      this.options.label = value;
      this._initChildGraphic("label", LabelPrimitive);
    }

    /**
     * 图标 子对象
     * @type {BillboardPrimitive}
     */
    get billboard() {
      return this._child.billboard
    }

    set billboard(value) {
      this.options.billboard = value;
      this._initChildGraphic("billboard", BillboardPrimitive);
    }

    /**
     * 像素点 子对象
     * @type {PointPrimitive|*}
     */
    get point() {
      return this._child.point
    }

    set point(value) {
      this.options.point = value;
      this._initChildGraphic("point", PointPrimitive);
    }

    /**
     * 模型 子对象
     * @type {ModelPrimitive}
     */
    get model() {
      return this._child.model
    }

    set model(value) {
      this.options.model = value;
      this._initChildGraphic("model", ModelPrimitive);
    }

    /**
     * 圆 子对象
     * @type {CircleEntity}
     */
    get circle() {
      return this._child.circle
    }

    set circle(value) {
      this.options.circle = value;
      this._initChildGraphic("circle", CircleEntity);
    }

    /**
     * 圆锥体 子对象
     * @type {ConeTrack}
     */
    get coneTrack() {
      return this._child.coneTrack
    }

    set coneTrack(value) {
      this.options.coneTrack = value;
      this._initChildGraphic("coneTrack", ConeTrack);
    }

    /**
     * path路径 子对象
     * @type {PathEntity}
     */
    get path() {
      return this._child.path
    }

    set path(value) {
      this.options.path = value;
      this._initChildGraphic("path", PathEntity);
    }

    /**
     * 路线 子对象
     * @type {PolylineEntity}
     */
    get polyline() {
      return this._child.polyline
    }

    set polyline(value) {
      this.options.polyline = value;
      this._initChildGraphic("polyline", PolylineEntity);
    }

    /**
     * 墙体 子对象
     * @type {WallEntity}
     */
    get wall() {
      return this._child.wall
    }

    set wall(value) {
      this.options.wall = value;
      this._initChildGraphic("wall", WallEntity);
    }

    /**
     * 将图元(所有几何实例)从模型转换为世界坐标的4x4变换矩阵。
     * <br/>提示：父类属性，非所有子类都具备
     * @type {Cesium.Matrix4}
     * @readonly
     */
    get modelMatrix() {
      if (this._modelMatrix) {
        return this._modelMatrix
      } else {
        return this._getModelMatrix(this.position, this._orientation)
      }
    }

    /**
     * 开始时间
     * @type {Cesium.JulianDate}
     * @readonly
     */
    get startTime() {
      const times = this.property?._property?._times;
      if (times.length > 0) {
        return times[0]
      } else {
        return null
      }
    }

    /**
     * 结束时间
     * @type {Cesium.JulianDate}
     * @readonly
     */
    get stopTime() {
      const times = this.property?._property?._times;
      if (times.length > 0) {
        return times[times.length - 1]
      } else {
        return null
      }
    }

    /**
     * 当前飞行过的positions轨迹点数组的index顺序
     * @type {Number}
     * @readonly
     */
    get currIndex() {
      return this._flyok_index
    }

    /**
     * 倍速，构造完成的对象，可以调用此属性调整速度。
     * @type {Number}
     */
    get multiplier() {
      return this._map?.clock.multiplier
    }

    set multiplier(val) {
      if (this._map) {
        this._map.clock.multiplier = val;
      }
    }

    /**
     * 是否暂停状态
     * @type {Boolean}
     */
    get isPause() {
      return !this._map?.clock.shouldAnimate
    }

    set isPause(val) {
      if (this._map) {
        this._map.clock.shouldAnimate = !val;
      }
    }

    // 覆盖父类
    _initSampledPositionProperty() {
      this._sampledPositionProperty = this.property; // BasePointPrimitive内使用

      // 绑定update事件
      this.bindUpdateEvent();
    }

    /**
     * 对象添加到图层前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      // 添加矢量
      this._initChildGraphic("label", LabelPrimitive);
      this._initChildGraphic("billboard", BillboardPrimitive);
      this._initChildGraphic("point", PointPrimitive);
      this._initChildGraphic("model", ModelPrimitive);
      this._initChildGraphic("circle", CircleEntity);
      this._initChildGraphic("coneTrack", ConeTrack);
      this._initChildGraphic("path", PathEntity);
      this._initChildGraphic("polyline", PolylineEntity);
      this._initChildGraphic("wall", WallEntity);
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show) {
        return
      }

      this._addChildGraphic(); // 添加到图层
    }

    _removedHook(style) {
      this._removeChildGraphic(); // 从图层移除
      super._removedHook(style);
    }

    _showHook(val) {
      if (val) {
        this.eachChildGraphic((graphic) => {
          graphic.show = graphic._lastShow;
          delete graphic._lastShow;
        });
      } else {
        this.eachChildGraphic((graphic) => {
          graphic._lastShow = graphic.show;
          graphic.show = false;
        });
      }
    }

    // 构造 子对象
    _initChildGraphic(typeName, ClassName) {
      const style = this.options[typeName]; // 参数值
      let graphic = this._child[typeName]; // 子对象

      if (!style) {
        if (graphic) {
          graphic.remove(true);
          delete this._child[typeName];
        }
        return
      }
      if (graphic) {
        graphic.setStyle(style);
        graphic.show = style.show ?? true;
      } else {
        graphic = new ClassName({
          style: clone(style, ["show"]),
          private: true,
          eventParent: this,
          show: style.show ?? true
        });

        if (this.isAdded) {
          this._layer.addGraphic(graphic);
        }

        // 绑定 子对象 的id指向当前 父对象
        if (graphic.czmObject) {
          this.bindPickId(graphic.czmObject);
        }
        if (graphic.czmObjectEx) {
          graphic.czmObjectEx.forEach((item) => {
            this.bindPickId(item);
          });
        }

        this._child[typeName] = graphic;

        if (typeName === "circle") {
          this._child.circle.position = new Cesium__namespace.CallbackProperty((time) => {
            return this._position
          }, false);
        } else if (typeName === "coneTrack") {
          this._child.coneTrack.position = new Cesium__namespace.CallbackProperty((time) => {
            return this._position
          }, false);
        } else if (typeName === "path") {
          this._child.path.position = this.property;
        } else if (typeName === "polyline") {
          this._polyline_positions = [];
          this._child.polyline.positions = new Cesium__namespace.CallbackProperty((time) => {
            return this._polyline_positions
          }, false);
        } else if (typeName === "wall") {
          this._wall_positions = [];
          this._child.wall.positions = new Cesium__namespace.CallbackProperty((time) => {
            return this._wall_positions
          }, false);
          this._wall_minimumHeights = [];
          this._child.wall.style.minimumHeights = new Cesium__namespace.CallbackProperty((time) => {
            return this._wall_minimumHeights
          }, false);
          this._wall_maximumHeights = [];
          this._child.wall.style.maximumHeights = new Cesium__namespace.CallbackProperty((time) => {
            return this._wall_maximumHeights
          }, false);
          this._child.wall._heights_cache = {};
        }
      }
    }

    _addChildGraphic() {
      // 添加到图层
      this.eachChildGraphic((graphic) => {
        this._layer.addGraphic(graphic);

        // 绑定 子对象 的id指向当前 父对象
        if (graphic.czmObject) {
          this.bindPickId(graphic.czmObject);
        }
        if (graphic.czmObjectEx) {
          graphic.czmObjectEx.forEach((item) => {
            this.bindPickId(item);
          });
        }
      });
    }

    _removeChildGraphic() {
      this.eachChildGraphic((graphic) => {
        this._layer.removeGraphic(graphic);
      });
    }

    /**
     * 遍历所有矢量数据并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} [context] 侦听器的上下文(this关键字将指向的对象)。
     * @return {Route} 当前对象本身,可以链式调用
     */
    eachChildGraphic(method, context) {
      if (!this._child) {
        return
      }
      Object.keys(this._child).forEach((key, index) => {
        method && method.call(context || this, this._child[key], index);
      });
      return this
    }

    // 内部自动刷新的方法体
    update(frameState) {
      if (!this.show) {
        return
      }

      this._position = this.getPropertyValue(frameState.time, this._position_result);
      if (!this._position) {
        return
      }

      this._orientation_show = this._orientation.getValue(frameState.time);

      this._updatePosition();
      this._updateCamera();

      if (this._map.clock.shouldAnimate) {
        this._updateForEvent();
      }
    }

    _updatePosition() {
      if (this._child.label?.show) {
        this._child.label._primitive.position = this._position;
      }
      if (this._child.billboard?.show) {
        this._child.billboard._primitive.position = this._position;
      }
      if (this._child.point?.show) {
        this._child.point._primitive.position = this._position;
      }
      if (this._child.model?.show) {
        this._modelMatrix = this._child.model._getModelMatrix(this._position, this._orientation_show);
        if (this._child.model?._primitive) {
          this._child.model._primitive.modelMatrix = this._modelMatrix;
        }
      }

      let hasLine = false;
      if (this._child.polyline?.show && !this.options.polyline?.showAll) {
        const values = this.property._property._values.slice(0, this._flyok_index * 3);
        if (this._flyok_index > 0) {
          let positions = Cesium__namespace.Cartesian3.unpackArray(values);
          if (this._position) {
            positions.push(this._position);
          }

          // 当限定长度时
          if (this.options.polyline.maxDistance) {
            positions = sliceByMaxDistance(positions, this.options.polyline.maxDistance);
            if (this._maxCacheCount > 0) {
              this._maxCacheCount = Math.max(this._maxCacheCount, positions.length * 2);
            }
          }
          this._polyline_positions = positions;
          hasLine = true;
        } else {
          this._polyline_positions = [];
        }
      }

      if (this._child.wall?.show) {
        const values = this.property._property._values.slice(0, this._flyok_index * 3);
        if (this._flyok_index > 0) {
          if (!hasLine) {
            let positions = Cesium__namespace.Cartesian3.unpackArray(values);
            if (this._position) {
              positions.push(this._position);
            }

            // 当限定长度时
            if (this.options.wall.maxDistance) {
              positions = sliceByMaxDistance(positions, this.options.wall.maxDistance);
              if (this._maxCacheCount > 0) {
                this._maxCacheCount = Math.max(this._maxCacheCount, positions.length * 2);
              }
            }
            this._polyline_positions = positions;
          }

          const minimumHeights = [];
          const maximumHeights = [];
          const positions = this._polyline_positions;
          for (let i = 0; i < positions.length; i++) {
            const point = positions[i];
            const carto = Cesium__namespace.Cartographic.fromCartesian(point);
            maximumHeights.push(carto.height);

            if (this.options.wall.surface) {
              positions[i].hbgd = positions[i].hbgd ?? getHeight(this._map?.scene, point, { has3dtiles: false });
              minimumHeights.push(positions[i].hbgd);
            } else {
              minimumHeights.push(0);
            }
          }
          this._wall_positions = positions;
          this._wall_minimumHeights = minimumHeights;
          this._wall_maximumHeights = maximumHeights;
        } else {
          this._wall_positions = [];
          this._wall_minimumHeights = [];
          this._wall_maximumHeights = [];
        }
      }
    }

    _updateCamera() {
      if (!this.options.camera) {
        return
      }

      // 如果位置都没有变化，直接返回
      switch (this.options.camera.type) {
        case "gs": {
          // 跟随视角
          const trackedEntity = this.trackedEntity;
          if (this._map.clock.shouldAnimate && this._map.trackedEntity !== trackedEntity) {
            this._map.trackedEntity = trackedEntity;
            trackedEntity._needFlyToPoint = true;
          }

          if (trackedEntity._needFlyToPoint && !this._map.viewer._needTrackedEntityUpdate) {
            trackedEntity._needFlyToPoint = false;
            this.flyToPoint({
              ...this.options.camera,
              lock: true,
              duration: 0
            });
          }
          break
        }
        case "dy": {
          // 锁定第一视角
          const trackedEntity = this.trackedEntity;
          if (this._map.trackedEntity !== trackedEntity) {
            this._map.trackedEntity = trackedEntity;
          }

          let transformX = this.options.camera.followedX; // 距离运动点的距离（后方）
          const transformZ = this.options.camera.followedZ; // 距离运动点的高度（上方）
          if (transformX === 0 && transformZ === 0) {
            transformX = 0.1;
          }

          let offset;
          if (this.options.camera.offsetX) {
            offset = offset || {};
            offset.x = this.options.camera.offsetX;
          }
          if (this.options.camera.offsetY) {
            offset = offset || {};
            offset.y = this.options.camera.offsetY;
          }
          if (this.options.camera.offsetZ) {
            offset = offset || {};
            offset.z = this.options.camera.offsetZ;
          }
          this._map.scene.camera.lookAtTransform(this.computeModelMatrix(offset), new Cesium__namespace.Cartesian3(-transformX, 0, transformZ));

          break
        }

        case "sd": {
          // 锁定上帝视角
          const trackedEntity = this.trackedEntity;
          if (this._map.trackedEntity !== trackedEntity) {
            this._map.trackedEntity = trackedEntity;
          }

          this._map.scene.camera.lookAtTransform(
            this.computeModelMatrix(),
            new Cesium__namespace.Cartesian3(-1, 0, this.options.camera.followedZ) // followedZ 距离运动点的高度（上方）
          );
          break
        }
        default: {
          // 无
          if (this._trackedEntity && this._map.trackedEntity === this._trackedEntity) {
            this._map.trackedEntity = undefined;
          }
          break
        }
      }
    }

    /**
     * 获取当前矩阵
     * @param {Object} offest 偏移值
     * @param {Number} offest.x X轴方向偏移值,单位：米
     * @param {Number} offest.y Y轴方向偏移值,单位：米
     * @param {Number} offest.z Z轴方向偏移值,单位：米
     * @return {Cesium.Matrix4}  当前矩阵
     */
    computeModelMatrix(offest) {
      if (!this._matrix4) {
        this._matrix4 = new Cesium__namespace.Matrix4();
        this._matrix3Scratch = new Cesium__namespace.Matrix3();
      }

      let position = this._position;
      if (!Cesium__namespace.defined(position) || !this._orientation_show) {
        return undefined
      }

      if (offest) {
        const hpr = new Cesium__namespace.HeadingPitchRoll(this._heading, this._pitch, this._roll);
        position = getPositionByHprAndOffset(position, new Cesium__namespace.Cartesian3(offest.x || 0, offest.y || 0, offest.z || 0), hpr);
      }

      this._matrix4 = Cesium__namespace.Matrix4.fromRotationTranslation(
        Cesium__namespace.Matrix3.fromQuaternion(this._orientation_show, this._matrix3Scratch),
        position,
        this._matrix4
      );

      return this._matrix4
    }

    _updateForEvent() {
      const currIndex = this._flyok_index ?? 0;

      // 变化事件
      this.fire(EventType.change, {
        index: currIndex,
        counts: this._counts,
        position: this._position
      });

      // 分步骤事件
      if (currIndex !== this._last_fireIndex) {
        if (Cesium__namespace.defined(this._last_fireIndex) && this._last_fireIndex + 1 !== currIndex) {
          while (++this._last_fireIndex < currIndex) {
            // 当1帧率超过2+坐标时,会跳过这些index，此处补充跳过的index事件
            this.fire(EventType.endItem, { counts: this._counts, index: this._last_fireIndex });
          }
        }

        this.fire(EventType.endItem, { counts: this._counts, index: currIndex });

        if (currIndex === this._counts) {
          this.fire(EventType.end);
        }

        this._last_fireIndex = currIndex;
      }
    }

    // 来源 SampledProperty.prototype.getValue
    getPropertyValue(time, result) {
      const _property = this.property?._property;
      const times = _property?._times;
      const timesLength = times.length;
      if (timesLength === 0) {
        return undefined
      }

      this._counts = timesLength; // 总数

      let timeout;
      const innerType = Cesium__namespace.Cartesian3; // _property._innerType
      const values = _property._values;
      this._flyok_index = Cesium__namespace.binarySearch(times, time, Cesium__namespace.JulianDate.compare);

      if (this._flyok_index < 0) {
        this._flyok_index = ~this._flyok_index;
        if (this._flyok_index === 0) {
          const startTime = times[this._flyok_index];
          timeout = _property._backwardExtrapolationDuration;
          if (
            _property._backwardExtrapolationType === Cesium__namespace.ExtrapolationType.NONE ||
            (timeout !== 0 && Cesium__namespace.JulianDate.secondsDifference(startTime, time) > timeout)
          ) {
            return undefined
          }
          if (_property._backwardExtrapolationType === Cesium__namespace.ExtrapolationType.HOLD) {
            return innerType.unpack(values, 0, result)
          }
        }

        if (this._flyok_index >= timesLength) {
          this._flyok_index = timesLength - 1;
          const endTime = times[this._flyok_index];
          timeout = _property._forwardExtrapolationDuration;
          if (
            _property._forwardExtrapolationType === Cesium__namespace.ExtrapolationType.NONE ||
            (timeout !== 0 && Cesium__namespace.JulianDate.secondsDifference(time, endTime) > timeout)
          ) {
            return undefined
          }
          if (_property._forwardExtrapolationType === Cesium__namespace.ExtrapolationType.HOLD) {
            this._flyok_index = timesLength - 1;
            return innerType.unpack(values, this._flyok_index * innerType.packedLength, result)
          }
        }

        const xTable = _property._xTable;
        const yTable = _property._yTable;
        const interpolationAlgorithm = _property._interpolationAlgorithm;
        const packedInterpolationLength = _property._packedInterpolationLength;
        const inputOrder = _property._inputOrder;

        if (_property._updateTableLength) {
          _property._updateTableLength = false;
          const numberOfPoints = Math.min(interpolationAlgorithm.getRequiredDataPoints(_property._interpolationDegree, inputOrder), timesLength);
          if (numberOfPoints !== _property._numberOfPoints) {
            _property._numberOfPoints = numberOfPoints;
            xTable.length = numberOfPoints;
            yTable.length = numberOfPoints * packedInterpolationLength;
          }
        }

        const degree = _property._numberOfPoints - 1;
        if (degree < 1) {
          return undefined
        }

        let firstIndex = 0;
        let lastIndex = timesLength - 1;
        const pointsInCollection = lastIndex - firstIndex + 1;

        if (pointsInCollection >= degree + 1) {
          let computedFirstIndex = this._flyok_index - ((degree / 2) | 0) - 1;
          if (computedFirstIndex < firstIndex) {
            computedFirstIndex = firstIndex;
          }
          let computedLastIndex = computedFirstIndex + degree;
          if (computedLastIndex > lastIndex) {
            computedLastIndex = lastIndex;
            computedFirstIndex = computedLastIndex - degree;
            if (computedFirstIndex < firstIndex) {
              computedFirstIndex = firstIndex;
            }
          }

          firstIndex = computedFirstIndex;
          lastIndex = computedLastIndex;
        }
        const length = lastIndex - firstIndex + 1;

        // Build the tables
        for (let i = 0; i < length; ++i) {
          xTable[i] = Cesium__namespace.JulianDate.secondsDifference(times[firstIndex + i], times[lastIndex]);
        }

        if (!Cesium__namespace.defined(innerType.convertPackedArrayForInterpolation)) {
          let destinationIndex = 0;
          const packedLength = _property._packedLength;
          let sourceIndex = firstIndex * packedLength;
          const stop = (lastIndex + 1) * packedLength;

          while (sourceIndex < stop) {
            yTable[destinationIndex] = values[sourceIndex];
            sourceIndex++;
            destinationIndex++;
          }
        } else {
          innerType.convertPackedArrayForInterpolation(values, firstIndex, lastIndex, yTable);
        }

        // Interpolate!
        const x = Cesium__namespace.JulianDate.secondsDifference(time, times[lastIndex]);
        let interpolationResult;
        if (inputOrder === 0 || !Cesium__namespace.defined(interpolationAlgorithm.interpolate)) {
          interpolationResult = interpolationAlgorithm.interpolateOrderZero(
            x,
            xTable,
            yTable,
            packedInterpolationLength,
            _property._interpolationResult
          );
        } else {
          const yStride = Math.floor(packedInterpolationLength / (inputOrder + 1));
          interpolationResult = interpolationAlgorithm.interpolate(x, xTable, yTable, yStride, inputOrder, inputOrder, _property._interpolationResult);
        }

        if (!Cesium__namespace.defined(innerType.unpackInterpolationResult)) {
          return innerType.unpack(interpolationResult, 0, result)
        }
        return innerType.unpackInterpolationResult(interpolationResult, values, firstIndex, lastIndex, result)
      }
      return innerType.unpack(values, this._flyok_index * _property._packedLength, result)
    }

    clearPosition() {
      const times = this.property?._property?._times;
      if (!times || times.length === 0) {
        return
      }

      // 清除之前的轨迹
      this.property.removeSamples(
        new Cesium__namespace.TimeInterval({
          start: times[0],
          stop: times[times.length - 1]
        })
      );
    }

    /**
     * 获取数据的矩形边界
     * @param {Boolean} [options] 控制参数
     * @param {Boolean} [options.isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */
    getRectangle(options) {
      const times = this.property?._property?._times;
      const values = this.property?._property?._values;

      if (!times || times.length === 0) {
        return
      }

      const positions = [];
      for (let i = 0, len = times.length; i < len; i++) {
        positions.push(new Cesium__namespace.Cartesian3(values[i * 3], values[i * 3 + 1], values[i * 3 + 2]));
      }

      const extent = getRectangle(positions, options?.isFormat);
      return extent
    }

    /**
     * 位置坐标(数组对象)，示例 [ [123.123456,32.654321,198.7], [111.123456,22.654321,50.7] ]
     * @param {Boolean} noAlt true时不导出高度值
     * @return {Array[]} 位置坐标(数组对象)
     */
    getCoordinates(noAlt) {
      const times = this.property?._property?._times;
      const values = this.property?._property?._values;

      if (!times || times.length === 0) {
        return []
      }

      const coords = [];
      for (let i = 0, len = times.length; i < len; i++) {
        const point = LngLatPoint.fromCartesian(new Cesium__namespace.Cartesian3(values[i * 3], values[i * 3 + 1], values[i * 3 + 2]));
        const arr = point.toArray(noAlt);
        arr.push(Cesium__namespace.JulianDate.toDate(times[i]).getTime());
        coords.push(arr);
      }
      return coords
    }

    /**
     * 定位至当前时间所在的位置 (非相机位置)
     *
     * @param {Object} [options={}] 具有以下属性的对象:
     * @param {Number} [options.radius] 相机距离目标点的距离（单位：米）
     * @param {Number} [options.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} [options.pitch] 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} [options.roll] 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行持续时间（秒）。如果省略，内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Matrix4} [options.endTransform] 表示飞行完成后摄像机将位于的参考帧的变换矩阵。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机的飞行角度高于该值，请在飞行过程中调整俯仰角度以向下看，并将地球保持在视口中。
     * @param {Number} [options.flyOverLongitude] 地球上2点之间总是有两种方式。此选项会迫使相机选择战斗方向以在该经度上飞行。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction]  控制在飞行过程中如何插值时间。
     * @return {void}  无
     *
     */
    flyToPoint(options = {}) {
      if (!this._map) {
        return
      }

      const position = this._position;
      if (!position) {
        return
      }

      let heading;
      if (Cesium__namespace.defined(options.heading)) {
        heading = options.heading + Cesium__namespace.Math.toDegrees(this.hpr?.heading || 0);
      }
      this._map.flyToPoint(position, { ...options, heading: heading });
    }

    /**
     * 清除最后一次的相机跟踪
     * @return {void}  无
     */
    static clearLastCamera() {
      if (globeLastRoam?.options?.camera?.type) {
        globeLastRoam.options.camera.type = "";
      }
      globeLastRoam = null;
    }

    /**
     * 更新视角模式,传入空值代表取消。
     *
     * @param {Object} [cameraOptions] 参数，包括：
     * @param {String} [cameraOptions.type]  视角模式类型，包括：'':无、'gs':跟随视角、'dy':第一视角、'sd':上帝视角
     * @param {Number} [cameraOptions.radius] 'gs'跟随视角时的 初始俯仰距离值（单位：米）
     * @param {Number} [cameraOptions.heading] 'gs'跟随视角时的 初始方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} [cameraOptions.pitch] 'gs'跟随视角时的 初始俯仰角度值，绕纬度线旋转角度, 0至360 *
     * @param {Number} [cameraOptions.followedX=50] 'dy'锁定第一视角时，距离运动点的距离（后方）
     * @param {Number} [cameraOptions.followedZ=10] 'dy'锁定第一视角或'sd'上帝视角时，距离运动点的高度（上方）
     * @return {void}  无
     */
    setCameraOptions(cameraOptions) {
      Route.clearLastCamera();

      if (this.options.camera) {
        this.options.camera = merge(this.options.camera, cameraOptions);
      } else if (cameraOptions) {
        this.options.camera = cameraOptions;
      } else {
        this.options.camera = { type: "" };
      }

      if (this.options.camera?.type !== "") {
        globeLastRoam = this;
      }

      if (cameraOptions && cameraOptions.type === "gs" && cameraOptions.radius) {
        this.flyToPoint({
          ...cameraOptions,
          duration: 0
        });
      }
    }

    /**
     * 暂停
     * @return {void}  无
     */
    pause() {
      if (this._map) {
        this._map.clock.shouldAnimate = false;
        if (this._trackedEntity && this._map.trackedEntity === this._trackedEntity) {
          this._map.trackedEntity = undefined;
        }
      }
    }

    /**
     * 继续
     * @return {void}  无
     */
    proceed() {
      if (this._map) {
        this._map.clock.shouldAnimate = true;
      }
    }

    _getPopupPosition() {
      return this.property
    }

    destroy(noDel) {
      this.eachChildGraphic((graphic) => {
        graphic.destroy(noDel);
      });
      super.destroy(noDel);
    }
  }
  // 注册下
  register$4("route", Route);

  /**
   *
   * 固定轨迹路线/历史轨迹路线，是由多个其他类型Graphic组合而成，方便一起控制和管理。<br />
   * 路线坐标是一次性postions参数或属性传入的，有开始和结束的概念。
   *
   * @param {Object} options 参数对象，包括以下：
   * @param {Array[]|LngLatPoint[]} options.positions 轨迹的 坐标数组
   * @param {Number} [options.offsetHeight=0]  轨迹偏移增加的高度
   * @param {Boolean} [options.interpolation]  是否LagrangePolynomialApproximation插值，对轨迹进行圆弧状插值
   * @param {Boolean} [options.interpolationDegree=2] 当interpolation为true时，使用的插值程度。
   * @param {Boolean} [options.showStop=true]  是否在start前或stop后显示矢量对象
   *
   * @param {Array[]|Number} options.speed 轨迹的 速度( 单位：千米/小时)
   * @param {String} [options.timeField]  当points数组中已有时间值，请传入该值的字段名称，同时speed将失效，已实际传入时间字段为准。
   * @param {String|Date|Cesium.JulianDate} [options.startTime]  轨迹的开始时间，默认当前时间
   * @param {Number|Function} [options.pauseTime]  每个点的停留时长（单位：秒）
   * @param {Boolean} [options.autoStop]  是否自动停止
   * @param {Boolean} [options.clockLoop]  是否循环播放，与 clockRange: Cesium.ClockRange.LOOP_STOP 效果类似，但不改变全局时钟时间。
   * @param {Cesium.ClockRange} [options.clockRange]  设定全局时钟播放的模式，可以设置到达终点后停止或循环播放
   *
   * @param {Object} [options.attr] 矢量数据的 属性信息，可以任意附加属性。
   *
   * @param {LabelPrimitive.StyleOptions} [options.label]  使用 文本 对象，及其对应的样式
   * @param {BillboardEntity.StyleOptions} [options.billboard]  使用 图标 对象，及其对应的样式
   * @param {PointPrimitive.StyleOptions} [options.point]  使用 图标 对象，及其对应的样式
   * @param {ModelPrimitive.StyleOptions} [options.model]  使用 gltf模型 对象，及其对应的样式
   * @param {CircleEntity.StyleOptions} [options.circle]  使用 圆 对象，及其对应的样式
   * @param {ConeTrack.StyleOptions} [options.coneTrack]  使用 圆锥体 对象，及其对应的样式
   * @param {PathEntity.StyleOptions} [options.path]  使用 path轨迹 对象，及其对应的样式
   * @param {PolylineEntity.StyleOptions} [options.polyline]  使用 polyline路线 对象，及其对应的样式 <br/>
  //  * @param {Number} [options.polyline.maxDistance] 设置保留的轨迹长度值（单位：米），不设置时保留所有的轨迹
  //  * @param {Boolean} [options.polyline.showAll] 是否一直显示展示所有坐标
   * @param {WallEntity.StyleOptions} [options.wall]  使用 墙体 对象，及其对应的样式 <br/>
  //  * @param {Number} [options.wall.maxDistance] 设置保留的轨迹长度值（单位：米），不设置时保留所有的轨迹<br/>
  //  * @param {Number} [options.wall.surface] 设置墙底部高度是否贴地
   *
   * @param {Number} [options.frameRate = 1] 多少帧获取一次数据。用于控制效率，如果卡顿就把该数值调大一些。
   * @param {Cesium.ExtrapolationType} [options.forwardExtrapolationType= Cesium.ExtrapolationType.HOLD]   在任何可用坐标之后一次请求值时要执行的推断类型，默认为最后一个坐标位置。
   * @param {Cesium.ExtrapolationType} [options.backwardExtrapolationType= Cesium.ExtrapolationType.HOLD] 在任何可用坐标之前一次请求值时要执行的推断类型，默认为第一个坐标位置。
   * @param {Cesium.Transforms.LocalFrameToFixedFrame} [options.fixedFrameTransform=Cesium.Transforms.eastNorthUpToFixedFrame] 参考系
   * @param {Cesium.Property|Object} [options.orientation] 自定义实体方向, 默认内部根据轨迹自动的
   *
   * @param {Object} [options.camera] 视角模式设置，包括：
   * @param {String} [options.camera.type]  视角模式类型，包括：'':无、'gs':跟随视角、'dy':第一视角、'sd':上帝视角
   * @param {Number} [options.camera.radius] 'gs'跟随视角时的 初始俯仰距离值（单位：米）
   * @param {Number} [options.camera.heading] 'gs'跟随视角时的 初始方向角度值，绕垂直于地心的轴旋转角度, 0至360
   * @param {Number} [options.camera.pitch] 'gs'跟随视角时的 初始俯仰角度值，绕纬度线旋转角度, 0至360
   * @param {Number} [options.camera.followedX=50] 'dy'锁定第一视角时，距离运动点的距离（后方）
   * @param {Number} [options.camera.followedZ=10] 'dy'锁定第一视角或'sd'上帝视角时，距离运动点的高度（上方）
   * @param {Number} [options.camera.offsetX=0] 'dy'锁定第一视角时，锁定点的本身的X轴方向（前后）偏移值
   * @param {Number} [options.camera.offsetY=0] 'dy'锁定第一视角时，锁定点的本身的Y轴方向（横向）偏移值
   * @param {Number} [options.camera.offsetZ=0] 'dy'锁定第一视角时，锁定点的本身的Z轴方向（高度）偏移值
   *
   * @param {String|Array|Function} [options.popup] 绑定的popup弹窗值，也可以bindPopup方法绑定
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   * @param {String|Array|Function} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Object} [options.contextmenuItems] 当矢量数据支持右键菜单时，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 矢量数据id标识
   * @param {String} [options.name = ''] 矢量数据名称
   * @param {Boolean} [options.show = true] 矢量数据是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的图层对象，false时不冒泡事件
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   * @export
   * @class FixedRoute
   * @extends {Route}
   * @see [支持的事件类型]{@link Route.EventType}
   */
  class FixedRoute extends Route {
    constructor(options = {}) {
      super(options);

      this.options.showStop = this.options.showStop ?? true;
    }

    /**
     * 开始时间
     * @type {Cesium.JulianDate}
     * @readonly
     */
    get startTime() {
      return this._startTime
    }

    /**
     * 结束时间
     * @type {Cesium.JulianDate}
     * @readonly
     */
    get stopTime() {
      return this._stopTime
    }

    /**
     * 位置坐标数组
     * @type {Array[]|LngLatPoint[]}
     */
    get points() {
      return this._points
    }

    set points(value) {
      this.positions = value;
    }

    /**
     * 位置坐标数组, 读取时是Cesium.Cartesian3[]，赋值可以是LngLatPoint[]等
     * @type {Array[]|LngLatPoint[]|Cesium.Cartesian3[]}
     */
    get positions() {
      return this._points.map((item) => {
        return item._position
      })
    }

    set positions(value) {
      if (!this._map || !value || !Array.isArray(value) || value.length === 0) {
        return
      }

      const points = LngLatArray.toPoints(value); // 坐标

      // 清除之前的轨迹
      this.clearPosition();

      // 飞行开始时间
      let startTime;
      if (this.options.startTime) {
        if (isString(this.options.startTime)) {
          if (this.options.startTime.indexOf("Z") === -1) {
            startTime = Cesium__namespace.JulianDate.fromDate(new Date(this.options.startTime));
          } else {
            startTime = Cesium__namespace.JulianDate.fromIso8601(this.options.startTime);
          }
        } else if (this.options.startTime instanceof Date) {
          startTime = Cesium__namespace.JulianDate.fromDate(this.options.startTime);
        } else {
          startTime = this.options.startTime;
        }
      } else {
        if (this.options.timeField) {
          const strTime = points[0][this.options.timeField];
          startTime = Cesium__namespace.JulianDate.fromDate(new Date(strTime));
        } else {
          startTime = this._map.clock.currentTime;
        }
      }

      const speedOption = this.options.speed;
      const isSpeedArray = speedOption && Array.isArray(speedOption);
      const defSpeed = 100; // 无速度值时的 默认速度  单位：千米/小时
      function getSpeed(index, point) {
        if (point.speed) {
          return point.speed
        }
        if (point._speed) {
          return point._speed
        }
        if (isSpeedArray) {
          return speedOption[index] || defSpeed
        }
        return speedOption || defSpeed
      }

      const offsetHeight = this.options.offsetHeight ?? 0;

      let alltimes = 0; // 总时长,单位：秒
      let alllen = 0; // 总长度,单位：米

      let lastPoint;
      let lastTime;
      const newPoinsts = [];
      for (let i = 0, length = points.length; i < length; i++) {
        const point = points[i];
        const position = Cesium__namespace.Cartesian3.fromDegrees(point.lng, point.lat, point.alt + offsetHeight);

        if (i === 0) {
          // 起点
          lastTime = startTime.clone();
          this.property.addSample(lastTime, position);

          // 记录到point中
          point._position = position;
          point._time = lastTime;
          point._distance = alllen; // 起点到当前点的 距离，单位：米
          point._second = alltimes; // 起点到当前点的 时长，单位：秒
          point._speed = 0; // 前一个点到当前点的速度，单位：米/秒
          newPoinsts.push(point);
        } else {
          const len = Cesium__namespace.Cartesian3.distance(position, lastPoint);
          if (len === 0) {
            continue // 已屏蔽相同点,如需暂停，请使用pauseTime参数"
          }

          let timeSecond;
          let speed;
          if (this.options.timeField) {
            const time = new Date(point[this.options.timeField]);
            const thisTime = Cesium__namespace.JulianDate.fromDate(time);
            timeSecond = Cesium__namespace.JulianDate.secondsDifference(thisTime, lastTime) || 0.01;

            lastTime = thisTime;
            speed = len / timeSecond; // 速度：m/s
            alltimes += timeSecond;
          } else {
            speed = getSpeed(i - 1, point) / 3.6; // 速度：km/h换算m/s
            timeSecond = len / speed;
            if (timeSecond < 0.01) {
              timeSecond = 0.01; // 限定为最小值，防止速度值设置太大时，为0的错误
            }
            alltimes += timeSecond;
            lastTime = Cesium__namespace.JulianDate.addSeconds(startTime, alltimes, new Cesium__namespace.JulianDate());
          }
          alllen += len;

          this.property.addSample(lastTime, position);

          // 记录到point中
          point._position = position;
          point._time = lastTime;
          point._distance = alllen; // 起点到当前点的 距离，单位：米
          point._second = alltimes; // 起点到当前点的 时长，单位：秒
          point._speed = speed; // 前一个点到当前点的速度，单位：米/秒
          newPoinsts.push(point);

          if (this.options.pauseTime) {
            const pauseLen = 0.01;
            const positionNew = getOnLinePointByLen(lastPoint, position, pauseLen, true);
            if (typeof this.options.pauseTime === "function") {
              alltimes += this.options.pauseTime(i, positionNew);
            } else {
              alltimes += this.options.pauseTime;
            }
            lastTime = Cesium__namespace.JulianDate.addSeconds(startTime, alltimes, new Cesium__namespace.JulianDate());
            this.property.addSample(lastTime, positionNew);

            alllen += pauseLen;

            // 记录到point中
            point._position = positionNew;
            point._time = lastTime;
            point._distance = alllen; // 起点到当前点的 距离，单位：米
            point._second = alltimes; // 起点到当前点的 时长，单位：秒
            point._speed = 0; // 前一个点到当前点的速度，单位：米/秒
            newPoinsts.push(point);
          }
        }
        lastPoint = position;
      }

      // 记录到类中
      this._points = newPoinsts;
      this._startTime = startTime;
      this._stopTime = lastTime.clone();
      this.second_all = alltimes; // 全程时长
      this.distance_all = alllen;// 全程距离

      // 插值，使折线边平滑 ,并且长距离下不穿地
      if (this.options.interpolation) {
        this.property.setInterpolationOptions({
          interpolationDegree: this.options.interpolationDegree || 2,
          interpolationAlgorithm: Cesium__namespace.LagrangePolynomialApproximation // HermitePolynomialApproximation
        });
      }

      if (this.options.showStop) {
        this.backToFirst();

        if (this.options?.polyline?.showAll) {
          this._child.polyline.positions = this.positions;
        }
      }

      this.fire(EventType.updatePosition, { position: this.property });
    }

    /**
     * 是否已启动
     * @type {Boolean}
     * @readonly
     */
    get isStart() {
      return this._isStart
    }

    /**
     * 当前实时信息
     * @type {Object}
     * @readonly
     */
    get info() {
      return this._timeinfo
    }

    /**
     * 对象添加到图层上的创建钩子方法，
     * 每次add时都会调用
     * @param {Object} style 完整样式信息
     * @return {void}  无
     * @private
     */
    _addedHook(style) {
      if (!this.show) {
        return
      }

      super._addedHook();

      this.positions = this.options.positions;
    }

    /**
     * 开始飞行漫游
     * @return {void}  无
     */
    start() {
      if (!this._map || this._isStart) {
        return
      }

      if (!Cesium__namespace.defined(this._points) || this._points.length === 0) {
        logError("没有坐标数据，漫游路线启动失败", this._points);
        return
      }

      this._isStart = true;
      this.positions = this._points; // 更新时间

      if (this._child.model?.show) {
        this._map.clock.shouldAnimate = false;
        this._map.clock.currentTime = this.startTime.clone();
        this._child.model.readyPromise.then(() => {
          this._start(); // 等模型加载好再飞行
        });
      } else {
        this._start();
      }
    }

    // 开始
    _start() {
      this._map.clock.shouldAnimate = true;
      this._map.clock.currentTime = this.startTime.clone();

      if (!this.options.clockLoop && this.options.clockRange) {
        this._bak_clockRange = this._map.clock.clockRange; // 循环播放
        this._bak_startTime = this._map.clock.startTime;
        this._bak_stopTime = this._map.clock.stopTime;

        // Cesium.ClockRange.CLAMPED 到达终点后停止，Cesium.ClockRange.LOOP_STOP 到达终止时间后 循环从头播放
        this._map.clock.clockRange = this.options.clockRange ?? Cesium__namespace.ClockRange.LOOP_STOP;
        this._map.clock.startTime = this.startTime.clone();
        this._map.clock.stopTime = this.stopTime.clone();

        if (this._map.controls.timeline) {
          this._map.controls.timeline.zoomTo(this.startTime, this.stopTime);
        }
      }

      if (this._child.path?.entity) {
        this._child.path.entity.availability = new Cesium__namespace.TimeIntervalCollection([
          new Cesium__namespace.TimeInterval({ start: this._startTime, stop: this._stopTime })
        ]);
      }

      this.fire(EventType.start);

      // 绑定update事件
      this.bindUpdateEvent();
    }

    /**
     * 停止飞行漫游
     * @return {void}  无
     */
    stop() {
      if (!this._isStart || !this._map) {
        return
      }

      this._map.trackedEntity = undefined;
      this.unbindUpdateEvent();

      if (this.options.showStop) {
        this.backToFirst();
      } else {
        this._position = undefined;
        this._updatePosition();
      }

      // 清除path的显示
      this._polyline_positions = [];
      if (this._child.path?.entity) {
        this._child.path.entity.availability = undefined;
      }

      this._isStart = false;
      this.fire(EventType.end);

      this.fire(EventType.updatePosition, { position: this._position });
    }

    // 回调第1个点的位置
    backToFirst() {
      this._flyok_index = 0;
      this._position = this._points[0]._position;
      this._orientation_show = this._orientation.getValue(this.startTime);

      this._updatePosition();
      this._updateForEvent(false);
    }

    _updatePositionEx() {
      if (this.options?.polyline?.showAll) {
        this._child.polyline.positions = this.positions;
      }
    }

    _updateForEvent(fireEvent = true) {
      const currIndex = this._flyok_index;
      const endItem = this._points[this._points.length - 1];
      const item = this._points[Math.max(currIndex - 1, 0)];

      const point = LngLatPoint.fromCartesian(this._position);
      let distance = item._distance + Cesium__namespace.Cartesian3.distance(this._position, item._position);
      if (distance > endItem._distance) {
        distance = endItem._distance;
      }

      let time = 0; // 已飞行时间
      if (currIndex > 1) {
        time = Cesium__namespace.JulianDate.secondsDifference(this._map.clock.currentTime, this.startTime);
        if (time > endItem._second) {
          time = endItem._second;
        }
      }

      this._timeinfo = {
        index: currIndex,
        counts: this._counts ?? this._points.length,
        point: point,
        position: this._position,
        second: time, // 已飞行时间，单位：秒
        second_all: endItem._second, // 全程时长
        distance: distance, // 已飞行距离，单位：米
        distance_all: endItem._distance, // 全程距离
        speed: item._speed // 前一个点到当前点的速度，单位：米/秒
      };

      if (!fireEvent) {
        return
      }

      this.fire(EventType.change, this._timeinfo); // 变化事件

      // 分步骤事件
      if (currIndex !== this._last_fireIndex) {
        if (Cesium__namespace.defined(this._last_fireIndex) && this._last_fireIndex + 1 !== currIndex) {
          while (++this._last_fireIndex < currIndex) {
            // 当1帧率超过2+坐标时,会跳过这些index，此处补充跳过的index事件
            this.fire(EventType.endItem, {
              counts: this._counts,
              index: this._last_fireIndex,
              point: this._points[this._last_fireIndex]
            });
          }
        }

        this.fire(EventType.endItem, {
          counts: this._counts,
          index: currIndex,
          point: this._points[currIndex]
        });

        if (currIndex === this._counts) {
          this.fire(EventType.end);
        }

        this._last_fireIndex = currIndex;
      }

      // 结束事件
      if (time >= endItem._second) {
        if (this.options.clockLoop && !this.options.clockRange) {
          this.unbindUpdateEvent();
          this.positions = this._points; // 更新时间
          this.bindUpdateEvent();
          return
        }

        if (this.options.autoStop) {
          this.stop();
        }
      }
    }

    _getPopupPosition() {
      if (this._isStart) {
        return this.property
      } else {
        return this._position
      }
    }

    /**
     * 计算贴地线
     * @param {Object} [options] 控制参数
     * @param {Number} [options.splitNum=100] 插值数，等比分割的个数
     * @param {Number} [options.minDistance] 插值最小间隔(单位：米)，优先级高于splitNum
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @param {Number} [options.offset=0]  可以按需增加偏移高度（单位：米），便于可视
     * @return {Promise<Object>} 异步计算完成的Promise
     */
    autoSurfaceHeight(options = {}) {
      const points = this._points; // 原始坐标

      // 剖面的数据
      let alllen = 0;
      const arrLength = [];
      const arrHbgd = [];
      const arrFxgd = [];
      const arrPoint = [];

      const pointsNew = [];

      return new Promise((resolve, reject) => {
        const positions = [];
        points.forEach((item) => {
          positions.push(item._position);
        });

        computeStepSurfaceLine({
          objectsToExclude: this.objectsToExclude,
          ...options,
          scene: this._map.scene,
          positions: positions,
          // 计算每个分段后的回调方法
          endItem: (raisedPositions, noHeight, index) => {
            if (!this._map) {
              return
            }

            const itemOld = points[index];

            if (noHeight) {
              pointsNew.push(itemOld);
            } else {
              for (let i = 0; i < raisedPositions.length; i++) {
                const point = LngLatPoint.fromCartesian(raisedPositions[i]);
                point._speed = itemOld._speed;
                pointsNew.push(point);
              }
            }

            // 剖面的数据
            const h1 = points[index]?.alt || 0;
            const h2 = points[index + 1]?.alt || 0;
            const hstep = (h2 - h1) / raisedPositions.length;

            for (let i = 0; i < raisedPositions.length; i++) {
              // 已飞行长度
              if (i !== 0) {
                alllen += Cesium__namespace.Cartesian3.distance(raisedPositions[i], raisedPositions[i - 1]);
              }
              arrLength.push(Number(alllen.toFixed(1)));

              // 坐标
              const point = LngLatPoint.fromCartesian(raisedPositions[i]);
              arrPoint.push(point);

              // 海拔高度
              const hbgd = noHeight ? 0 : point.alt;
              arrHbgd.push(hbgd);

              // 飞行高度
              const fxgd = Number((h1 + hstep * i).toFixed(1));
              arrFxgd.push(fxgd);
            }
          },
          // 计算全部完成的回调方法
          end: () => {
            if (!this._map) {
              return
            }

            // 剖面的数据(记录下，提高效率，避免多次计算)
            this._terrainHeight = {
              arrLength: arrLength,
              arrFxgd: arrFxgd,
              arrHbgd: arrHbgd,
              arrPoint: arrPoint
            };

            this.positions = pointsNew;

            resolve(pointsNew);
          }
        });
      })
    }

    // 兼容旧版本命名，同updateSurfaceHeight
    clampToGround(options) {
      return this.autoSurfaceHeight(options)
    }

    /**
     * 获取剖面数据
     * @param {Object} [options] 控制参数
     * @param {Number} [options.splitNum=100] 插值数，等比分割的个数
     * @param {Number} [options.minDistance] 插值最小间隔(单位：米)，优先级高于splitNum
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Object[]} [options.objectsToExclude]  贴模型分析时，排除的不进行贴模型计算的模型对象，可以是： primitives, entities, 或 3D Tiles features
     * @param {Number} [options.offset=0]  可以按需增加偏移高度（单位：米），便于可视
     * @return {Promise<Object>} 异步计算完成的Promise
     */
    getTerrainHeight(options = {}) {
      const points = this._points; // 原始坐标

      return new Promise((resolve, reject) => {
        if (this._terrainHeight) {
          resolve(this._terrainHeight);
          return
        }

        this._getTerrainHeight_ing = true;

        // 剖面的数据
        let alllen = 0;
        const arrLength = [];
        const arrHbgd = [];
        const arrFxgd = [];
        const arrPoint = [];

        computeStepSurfaceLine({
          scene: this._map.scene,
          positions: points,
          objectsToExclude: this.objectsToExclude,
          ...options,
          // 计算每个分段后的回调方法
          endItem: (raisedPositions, noHeight, index) => {
            // 剖面的数据
            const h1 = points[index].alt;
            const h2 = points[index + 1].alt;
            const hstep = (h2 - h1) / raisedPositions.length;

            for (let i = 0; i < raisedPositions.length; i++) {
              // 已飞行长度
              if (i !== 0) {
                alllen += Cesium__namespace.Cartesian3.distance(raisedPositions[i], raisedPositions[i - 1]);
              }
              arrLength.push(Number(alllen.toFixed(1)));

              // 坐标
              const point = LngLatPoint.fromCartesian(raisedPositions[i]);
              arrPoint.push(point);

              // 海拔高度
              const hbgd = noHeight ? 0 : point.alt;
              arrHbgd.push(hbgd);

              // 飞行高度
              const fxgd = Number((h1 + hstep * i).toFixed(1));
              arrFxgd.push(fxgd);
            }
          },
          // 计算全部完成的回调方法
          end: () => {
            this._getTerrainHeight_ing = false;

            // 剖面的数据(记录下，提高效率，避免多次计算)
            this._terrainHeight = {
              arrLength: arrLength,
              arrFxgd: arrFxgd,
              arrHbgd: arrHbgd,
              arrPoint: arrPoint
            };
            resolve(this._terrainHeight);
          }
        });
      })
    }
  }
  // 注册下
  register$4("fixedRoute", FixedRoute);

  var index$6 = {
    __proto__: null,
    BaseGraphic: BaseGraphic,
    BaseEntity: BaseEntity,
    BasePointEntity: BasePointEntity,
    BasePolyEntity: BasePolyEntity,
    BasePrimitive: BasePrimitive,
    BasePointPrimitive: BasePointPrimitive,
    BasePolyPrimitive: BasePolyPrimitive,
    PointEntity: PointEntity,
    BillboardEntity: BillboardEntity,
    FontBillboardEntity: FontBillboardEntity,
    DivBillboardEntity: DivBillboardEntity,
    LabelEntity: LabelEntity,
    CanvasLabelEntity: CanvasLabelEntity,
    ModelEntity: ModelEntity,
    BoxEntity: BoxEntity,
    PlaneEntity: PlaneEntity,
    CircleEntity: CircleEntity,
    CylinderEntity: CylinderEntity,
    ConeTrack: ConeTrack,
    EllipsoidEntity: EllipsoidEntity,
    PolylineEntity: PolylineEntity,
    CurveEntity: CurveEntity,
    PolylineVolumeEntity: PolylineVolumeEntity,
    PathEntity: PathEntity,
    CorridorEntity: CorridorEntity,
    WallEntity: WallEntity,
    RectangleEntity: RectangleEntity,
    PolygonEntity: PolygonEntity,
    EllipseEntity: EllipseEntity,
    RectangularSensor: RectangularSensor,
    Video2D: Video2D,
    AttackArrow: AttackArrow,
    AttackArrowPW: AttackArrowPW,
    AttackArrowYW: AttackArrowYW,
    CloseVurve: CloseVurve,
    DoubleArrow: DoubleArrow,
    FineArrow: FineArrow,
    FineArrowYW: FineArrowYW,
    GatheringPlace: GatheringPlace,
    IsosTriangle: IsosTriangle,
    Lune: Lune,
    Regular: Regular,
    Sector: Sector,
    StraightArrow: StraightArrow,
    PointMeasure: PointMeasure,
    DistanceMeasure: DistanceMeasure,
    DistanceSurfaceMeasure: DistanceSurfaceMeasure,
    SectionMeasure: SectionMeasure,
    AngleMeasure: AngleMeasure,
    HeightMeasure: HeightMeasure,
    HeightTriangleMeasure: HeightTriangleMeasure,
    AreaMeasure: AreaMeasure,
    AreaSurfaceMeasure: AreaSurfaceMeasure,
    VolumeMeasure: VolumeMeasure,
    PointPrimitive: PointPrimitive,
    BillboardPrimitive: BillboardPrimitive,
    CloudPrimitive: CloudPrimitive,
    LabelPrimitive: LabelPrimitive,
    ModelPrimitive: ModelPrimitive,
    CirclePrimitive: CirclePrimitive,
    PlanePrimitive: PlanePrimitive,
    BoxPrimitive: BoxPrimitive,
    CylinderPrimitive: CylinderPrimitive,
    ConeTrackPrimitive: ConeTrackPrimitive,
    EllipsoidPrimitive: EllipsoidPrimitive,
    PolylinePrimitive: PolylinePrimitive,
    PolylineSimplePrimitive: PolylineSimplePrimitive,
    WallPrimitive: WallPrimitive,
    CorridorPrimitive: CorridorPrimitive,
    PolylineVolumePrimitive: PolylineVolumePrimitive,
    RectanglePrimitive: RectanglePrimitive,
    PolygonPrimitive: PolygonPrimitive,
    FrustumPrimitive: FrustumPrimitive,
    LightCone: LightCone,
    Water: Water,
    DiffuseWall: DiffuseWall,
    ScrollWall: ScrollWall,
    DynamicRiver: DynamicRiver,
    Road: Road,
    Pit: Pit,
    BaseCombine: BaseCombine,
    FlatBillboard: FlatBillboard,
    ModelCombine: ModelCombine,
    PlaneCombine: PlaneCombine,
    BoxCombine: BoxCombine,
    CircleCombine: CircleCombine,
    CylinderCombine: CylinderCombine,
    FrustumCombine: FrustumCombine,
    EllipsoidCombine: EllipsoidCombine,
    PolylineCombine: PolylineCombine,
    PolylineVolumeCombine: PolylineVolumeCombine,
    CorridorCombine: CorridorCombine,
    WallCombine: WallCombine,
    PolygonCombine: PolygonCombine,
    WaterCombine: WaterCombine,
    RectangleCombine: RectangleCombine,
    DivGraphic: DivGraphic,
    DivBoderLabel: DivBoderLabel,
    DivLightPoint: DivLightPoint,
    DivUpLabel: DivUpLabel,
    Popup: Popup,
    Tooltip: Tooltip,
    ParticleSystem: ParticleSystem,
    ArcFrustum: ArcFrustum,
    Tetrahedron: Tetrahedron,
    ViewShed: ViewShed,
    Video3D: Video3D,
    Route: Route,
    FixedRoute: FixedRoute
  };

  // 标准XYZ地图
  class XyzImageryProvider$1 extends Cesium__namespace.UrlTemplateImageryProvider {
    constructor(options = {}) {
      options.customTags = options.customTags || {};

      // 对同域的一些url的支持
      options.customTags.host = function (imageryProvider, x, y, level) {
        return location.host
      };
      options.customTags.hostname = function (imageryProvider, x, y, level) {
        return location.hostname
      };

      // 对EPSG:4490支持
      options.customTags.z4490 = function (imageryProvider, x, y, level) {
        return level + 1
      };

      super(options);
      this.options = options;
    }
  }

  class TdtImageryProvider extends Cesium__namespace.WebMapTileServiceImageryProvider {
    constructor(options = {}) {
      let _layer;

      let maxLevel = 18;

      switch (options.layer) {
        case "vec_d":
          _layer = "vec";
          break
        case "vec_z":
          _layer = "cva";
          break
        case "vec_e":
          _layer = "eva"; // 英文注记
          break
        case "img_d":
          _layer = "img";
          break
        case "img_z":
          _layer = "cia";
          break
        case "img_e":
          _layer = "eia"; // 英文注记
          break
        case "ter_d":
          _layer = "ter";
          maxLevel = 14;
          break
        case "ter_z":
          _layer = "cta";
          maxLevel = 14;
          break
        default:
          _layer = "vec";
          break
      }

      if (options.key == null || options.key.length === 0) {
        options.key = tiandituArr;
      }
      const _key = getArrayRandomOne(options.key);

      let _url;
      if (options.crs === CRS.EPSG4490 || options.crs === CRS.EPSG4326) {
        // wgs84
        _url =
          "https://t{s}.tianditu.gov.cn/" +
          _layer +
          "_c/wmts?service=WMTS&version=1.0.0&request=GetTile&tilematrix={TileMatrix}&layer=" +
          _layer +
          "&style={style}&tilerow={TileRow}&tilecol={TileCol}&tilematrixset={TileMatrixSet}&format=tiles&tk=" +
          _key;

        if (options.proxy || options.headers || options.queryParameters) {
          // 存在代理等参数时
          _url = getUrlResource({
            url: _url.replace("{s}", "0"),
            proxy: options.proxy,
            headers: options.headers,
            queryParameters: options.queryParameters
          });
        }

        options = {
          subdomains: ["0", "1", "2", "3", "4", "5", "6", "7"],
          maximumLevel: maxLevel,
          ...options,

          url: _url,
          layer: _layer,
          style: "default",
          format: "tiles",
          tileMatrixSetID: "c",
          tileMatrixLabels: [...Array(20).keys()].map((level) => (level + 1).toString()),
          tilingScheme: new Cesium__namespace.GeographicTilingScheme()
        };
      } else {
        // 墨卡托
        _url =
          "https://t{s}.tianditu.gov.cn/" +
          _layer +
          "_w/wmts?service=WMTS&version=1.0.0&request=GetTile&tilematrix={TileMatrix}&layer=" +
          _layer +
          "&style={style}&tilerow={TileRow}&tilecol={TileCol}&tilematrixset={TileMatrixSet}&format=tiles&tk=" +
          _key;

        if (options.proxy || options.headers || options.queryParameters) {
          // 存在代理等参数时
          _url = getUrlResource({
            url: _url.replace("{s}", "0"),
            proxy: options.proxy,
            headers: options.headers,
            queryParameters: options.queryParameters
          });
        }

        options = {
          subdomains: ["0", "1", "2", "3", "4", "5", "6", "7"],
          maximumLevel: maxLevel,
          ...options,

          url: _url,
          layer: _layer,
          style: "default",
          format: "tiles",
          tileMatrixSetID: "w",
          tileMatrixLabels: [...Array(20).keys()].map((level) => level.toString()),
          tilingScheme: new Cesium__namespace.WebMercatorTilingScheme()
        };
      }

      super(options);
      this.options = options;
    }
  }

  // 高德地图
  class GaodeImageryProvider extends XyzImageryProvider$1 {
    constructor(options = {}) {
      let _url;
      switch (options.layer) {
        case "vec":
          // style=7是立体的，style=8是灰色平面的
          _url =
            "https://" + (options.bigfont ? "wprd" : "webrd") + "0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}";
          break
        case "img_d":
          _url = "https://webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}";
          break
        case "img_z":
          _url = "https://webst0{s}.is.autonavi.com/appmaptile?x={x}&y={y}&z={z}&lang=zh_cn&size=1&scale=1&style=8";
          break
        case "time": {
          const time = new Date().getTime();
          _url = "https://tm.amap.com/trafficengine/mapabc/traffictile?v=1.0&t=1&x={x}&y={y}&z={z}&&t=" + time;
          break
        }
        default:
          _url = options.url;
          break
      }

      if (options.proxy || options.headers || options.queryParameters) {
        // 存在代理等参数时
        _url = getUrlResource({
          url: _url.replace("{s}", "1"),
          proxy: options.proxy,
          headers: options.headers,
          queryParameters: options.queryParameters
        });
      }
      super({
        subdomains: ["1", "2", "3", "4"],
        maximumLevel: 18,
        ...options,
        url: _url
      });
    }
  }

  const EARTH_RADIUS = 6370996.81;
  const MC_BAND = [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0];
  const LL_BAND = [75, 60, 45, 30, 15, 0];
  const MC2LL = [
    [
      1.410526172116255e-8, 8.98305509648872e-6, -1.9939833816331, 2.009824383106796e2, -1.872403703815547e2, 91.6087516669843, -23.38765649603339,
      2.57121317296198, -0.03801003308653, 1.73379812e7
    ],
    [
      -7.435856389565537e-9, 8.983055097726239e-6, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737,
      -16.50741931063887, 2.28786674699375, 1.026014486e7
    ],
    [
      -3.030883460898826e-8, 8.98305509983578e-6, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908,
      -3.29883767235584, 0.32710905363475, 6.85681737e6
    ],
    [
      -1.981981304930552e-8, 8.983055099779535e-6, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263,
      0.12923347998204, -0.04625736007561, 4.48277706e6
    ],
    [
      3.09191371068437e-9, 8.983055096812155e-6, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273,
      0.03430082397953, -0.00466043876332, 2.5551644e6
    ],
    [
      2.890871144776878e-9, 8.983055095805407e-6, -0.00000003068298, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596,
      0.00010322952773, -0.00000323890364, 8.260885e5
    ]
  ];
  const LL2MC = [
    [
      -0.0015702102444, 1.113207020616939e5, 1.704480524535203e15, -1.033898737604234e16, 2.611266785660388e16, -3.51496691766537e16,
      2.659570071840392e16, -1.072501245418824e16, 1.800819912950474e15, 82.5
    ],
    [
      // eslint-disable-next-line no-loss-of-precision
      8.277824516172526e-4, 1.113207020463578e5, 6.477955746671608e8, -4.082003173641316e9, 1.077490566351142e10, -1.517187553151559e10,
      1.205306533862167e10, -5.124939663577472e9, 9.133119359512032e8, 67.5
    ],
    [
      0.00337398766765, 1.113207020202162e5, 4.481351045890365e6, -2.339375119931662e7, 7.968221547186455e7, -1.159649932797253e8, 9.723671115602145e7,
      -4.366194633752821e7, 8.477230501135234e6, 52.5
    ],
    [
      0.00220636496208, 1.113207020209128e5, 5.175186112841131e4, 3.796837749470245e6, 9.920137397791013e5, -1.22195221711287e6, 1.340652697009075e6,
      -6.209436990984312e5, 1.444169293806241e5, 37.5
    ],
    [
      -3.441963504368392e-4, 1.113207020576856e5, 2.782353980772752e2, 2.485758690035394e6, 6.070750963243378e3, 5.482118345352118e4,
      9.540606633304236e3, -2.71055326746645e3, 1.405483844121726e3, 22.5
    ],
    [
      -3.218135878613132e-4, 1.113207020701615e5, 0.00369383431289, 8.237256402795718e5, 0.46104986909093, 2.351343141331292e3, 1.58060784298199,
      8.77738589078284, 0.37238884252424, 7.45
    ]
  ];

  class BaiduMercatorProjection {
    constructor() {
      this.isWgs84 = false;
    }

    getDistanceByMC(point1, point2) {
      if (!point1 || !point2) {
        return 0
      }
      point1 = this.convertMC2LL(point1);
      if (!point1) {
        return 0
      }
      const x1 = this.toRadians(point1.lng);
      const y1 = this.toRadians(point1.lat);
      point2 = this.convertMC2LL(point2);
      if (!point2) {
        return 0
      }
      const x2 = this.toRadians(point2.lng);
      const y2 = this.toRadians(point2.lat);
      return this.getDistance(x1, x2, y1, y2)
    }

    getDistanceByLL(point1, point2) {
      if (!point1 || !point2) {
        return 0
      }
      point1.lng = this.getLoop(point1.lng, -180, 180);
      point1.lat = this.getRange(point1.lat, -74, 74);
      point2.lng = this.getLoop(point2.lng, -180, 180);
      point2.lat = this.getRange(point2.lat, -74, 74);
      const x1 = this.toRadians(point1.lng);
      const y1 = this.toRadians(point1.lat);
      const x2 = this.toRadians(point2.lng);
      const y2 = this.toRadians(point2.lat);
      return this.getDistance(x1, x2, y1, y2)
    }

    convertMC2LL(point) {
      if (!point) {
        return { lng: 0, lat: 0 }
      }
      let lnglat = {};
      if (this.isWgs84) {
        lnglat.lng = (point.lng / 20037508.34) * 180;
        const mmy = (point.lat / 20037508.34) * 180;
        lnglat.lat = (180 / Math.PI) * (2 * Math.atan(Math.exp((mmy * Math.PI) / 180)) - Math.PI / 2);
        return {
          lng: lnglat.lng.toFixed(6),
          lat: lnglat.lat.toFixed(6)
        }
      }

      const temp = {
        lng: Math.abs(point.lng),
        lat: Math.abs(point.lat)
      };

      let factor;
      for (let i = 0; i < MC_BAND.length; i++) {
        if (temp.lat >= MC_BAND[i]) {
          factor = MC2LL[i];
          break
        }
      }
      lnglat = this.convertor(point, factor);
      return {
        lng: lnglat.lng.toFixed(6),
        lat: lnglat.lat.toFixed(6)
      }
    }

    // /**
    //  * The latitude and longitude coordinates are converted to plane cartesian coordinates
    //  * @param point
    //  * @returns {{lng: number, lat: number}|*}
    //  */
    convertLL2MC(point) {
      if (!point) {
        return { lng: 0, lat: 0 }
      }
      if (point.lng > 180 || point.lng < -180 || point.lat > 90 || point.lat < -90) {
        return point
      }

      if (this.isWgs84) {
        const mercator = {};
        const earthRad = 6378137.0;
        mercator.lng = ((point.lng * Math.PI) / 180) * earthRad;
        const a = (point.lat * Math.PI) / 180;
        mercator.lat = (earthRad / 2) * Math.log((1.0 + Math.sin(a)) / (1.0 - Math.sin(a)));

        return {
          lng: parseFloat(mercator.lng.toFixed(2)),
          lat: parseFloat(mercator.lat.toFixed(2))
        }
      }

      point.lng = this.getLoop(point.lng, -180, 180);
      point.lat = this.getRange(point.lat, -74, 74);
      const temp = { lng: point.lng, lat: point.lat };
      let factor;
      for (let i = 0; i < LL_BAND.length; i++) {
        if (temp.lat >= LL_BAND[i]) {
          factor = LL2MC[i];
          break
        }
      }
      if (!factor) {
        for (let i = 0; i < LL_BAND.length; i++) {
          if (temp.lat <= -LL_BAND[i]) {
            factor = LL2MC[i];
            break
          }
        }
      }
      const mc = this.convertor(point, factor);
      return {
        lng: parseFloat(mc.lng.toFixed(2)),
        lat: parseFloat(mc.lat.toFixed(2))
      }
    }

    // /**
    //  *
    //  * @param fromPoint
    //  * @param factor
    //  * @returns {{lng: *, lat: *}}
    //  */
    convertor(fromPoint, factor) {
      if (!fromPoint || !factor) {
        return { lng: 0, lat: 0 }
      }
      let x = factor[0] + factor[1] * Math.abs(fromPoint.lng);
      const temp = Math.abs(fromPoint.lat) / factor[9];
      let y =
        factor[2] +
        factor[3] * temp +
        factor[4] * temp * temp +
        factor[5] * temp * temp * temp +
        factor[6] * temp * temp * temp * temp +
        factor[7] * temp * temp * temp * temp * temp +
        factor[8] * temp * temp * temp * temp * temp * temp;
      x *= fromPoint.lng < 0 ? -1 : 1;
      y *= fromPoint.lat < 0 ? -1 : 1;
      return {
        lng: x,
        lat: y
      }
    }

    getDistance(x1, x2, y1, y2) {
      return EARTH_RADIUS * Math.acos(Math.sin(y1) * Math.sin(y2) + Math.cos(y1) * Math.cos(y2) * Math.cos(x2 - x1))
    }

    toRadians(deg) {
      return (Math.PI * deg) / 180
    }

    toDegrees(rad) {
      return (180 * rad) / Math.PI
    }

    getRange(v, a, b) {
      if (a != null) {
        v = Math.max(v, a);
      }
      if (b != null) {
        v = Math.min(v, b);
      }
      return v
    }

    getLoop(v, a, b) {
      while (v > b) {
        v -= b - a;
      }
      while (v < a) {
        v += b - a;
      }
      return v
    }

    lngLatToMercator(point) {
      return this.convertLL2MC(point)
    }

    lngLatToPoint(point) {
      const mercator = this.convertLL2MC(point);
      return {
        x: mercator.lng,
        y: mercator.lat
      }
    }

    // /**
    //  * WebMercator transforms to latitude and longitude
    //  * @param point
    //  * @returns {Point|{lng: number, lat: number}}
    //  */
    mercatorToLngLat(point) {
      return this.convertMC2LL(point)
    }

    pointToLngLat(point) {
      const mercator = { lng: point.x, lat: point.y };
      return this.convertMC2LL(mercator)
    }

    pointToPixel(point, zoom, mapCenter, mapSize) {
      if (!point) {
        return { x: 0, y: 0 }
      }
      point = this.lngLatToMercator(point);
      const zoomUnits = this.getZoomUnits(zoom);
      const x = Math.round((point.lng - mapCenter.lng) / zoomUnits + mapSize.width / 2);
      const y = Math.round((mapCenter.lat - point.lat) / zoomUnits + mapSize.height / 2);
      return { x, y }
    }

    pixelToPoint(pixel, zoom, mapCenter, mapSize) {
      if (!pixel) {
        return { lng: 0, lat: 0 }
      }
      const zoomUnits = this.getZoomUnits(zoom);
      const lng = mapCenter.lng + zoomUnits * (pixel.x - mapSize.width / 2);
      const lat = mapCenter.lat - zoomUnits * (pixel.y - mapSize.height / 2);
      const point = { lng, lat };
      return this.mercatorToLngLat(point)
    }

    getZoomUnits(zoom) {
      return Math.pow(2, 18 - zoom)
    }
  }

  class BaiduMercatorTilingScheme extends Cesium__namespace.WebMercatorTilingScheme {
    constructor(options) {
      super(options);

      const dstCoordType = options.mapChinaCRS || ChinaCRS.WGS84; // map地图的坐标系
      const srcCoordType = ChinaCRS.BAIDU; // layer图层的坐标系（默认与地图一致）
      const Map2CrsLayerCrs = getTransFun(dstCoordType, srcCoordType);
      const LayerCrs2MapCrs = getTransFun(srcCoordType, dstCoordType);

      const projection = new BaiduMercatorProjection();
      this._projection.project = function (cartographic, result) {
        result = [Cesium__namespace.Math.toDegrees(cartographic.longitude), Cesium__namespace.Math.toDegrees(cartographic.latitude)];
        if (Map2CrsLayerCrs) {
          result = Map2CrsLayerCrs(result);
        }
        result[0] = Math.min(result[0], 180);
        result[0] = Math.max(result[0], -180);
        result[1] = Math.min(result[1], 85.05112877980659);
        result[1] = Math.max(result[1], -85.05112877980659);
        result = projection.lngLatToPoint({
          lng: result[0],
          lat: result[1]
        });
        return new Cesium__namespace.Cartesian2(result.x, result.y)
      };
      this._projection.unproject = function (cartesian, result) {
        result = projection.mercatorToLngLat({
          lng: cartesian.x,
          lat: cartesian.y
        });
        result = [result.lng, result.lat];
        if (LayerCrs2MapCrs) {
          result = LayerCrs2MapCrs(result);
        }
        return new Cesium__namespace.Cartographic(Cesium__namespace.Math.toRadians(result[0]), Cesium__namespace.Math.toRadians(result[1]))
      };
      this.resolutions = options.resolutions || [];
    }

    tileXYToNativeRectangle(x, y, level, result) {
      const tileWidth = this.resolutions[level];
      const west = x * tileWidth;
      const east = (x + 1) * tileWidth;
      const north = ((y = -y) + 1) * tileWidth;
      const south = y * tileWidth;

      if (!Cesium__namespace.defined(result)) {
        return new Cesium__namespace.Rectangle(west, south, east, north)
      }

      result.west = west;
      result.south = south;
      result.east = east;
      result.north = north;
      return result
    }

    positionToTileXY(position, level, result) {
      const rectangle = this._rectangle;
      if (!Cesium__namespace.Rectangle.contains(rectangle, position)) {
        return undefined
      }
      const projection = this._projection;
      const webMercatorPosition = projection.project(position);
      if (!Cesium__namespace.defined(webMercatorPosition)) {
        return undefined
      }
      const tileWidth = this.resolutions[level];
      const xTileCoordinate = Math.floor(webMercatorPosition.x / tileWidth);
      const yTileCoordinate = -Math.floor(webMercatorPosition.y / tileWidth);
      if (!Cesium__namespace.defined(result)) {
        return new Cesium__namespace.Cartesian2(xTileCoordinate, yTileCoordinate)
      }
      result.x = xTileCoordinate;
      result.y = yTileCoordinate;
      return result
    }
  }

  // 百度地图

  class BaiduImageryProvider {
    constructor(options = {}) {
      let url;
      switch (options.layer) {
        case "vec":
          url =
            "https://maponline{s}.bdimg.com/tile/?qt=vtile&x={x}&y={y}&z={z}&styles=" + (options.bigfont ? "ph" : "pl") + "&scaler=2&udt=&from=jsapi2_0";
          break
        case "img_d":
          url = "https://maponline{s}.bdimg.com/starpic/?qt=satepc&u=x={x};y={y};z={z};v=009;type=sate&fm=46&app=webearth2&v=009&udt=20210830";

          // 卫星图参数不一样，特殊处理下
          this.requestImage = (x, y, level) => {
            return Cesium__namespace.ImageryProvider.loadImage(
              this,
              new Cesium__namespace.Resource({
                url: "https://maponline{s}.bdimg.com/starpic/".replace("{s}", getArrayRandomOne(this._subdomains)),
                queryParameters: {
                  u: `x=${x};y=${-y};z=${level};v=009;type=sate`,
                  qt: "satepc",
                  app: "webearth2",
                  udt: "20210830",
                  fm: "46",
                  v: "009"
                }
              })
            )
          };
          break
        case "img_z":
          url = "https://online{s}.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=" + (options.bigfont ? "sh" : "sl") + "&v=020";
          break

        case "custom": // Custom 各种自定义样式 , 没有https
          // 可选值：dark,midnight,grayscale,hardedge,light,redalert,googlelite,grassgreen,pink,darkgreen,bluish
          options.style = options.style || "midnight";
          url = "http://api{s}.map.bdimg.com/customimage/tile?&x={x}&y={y}&z={z}&scale=1&customid=" + options.style;
          break

        case "time": // 实时路况   , 没有https
          url = `http://its.map.baidu.com:8002/traffic/TrafficTileService?x={x}&y={y}&level={z}&time=${new Date().getTime()}&label=${
          options.label || "web2D"
        }&v=017`;
          break
        case "streetview": // 街景
          url = `https://gss{s}.bdstatic.com/5LUZemja_QUU8t7mm9GUKT-xh_/tile/?udt=20150114&qt=tile&styles=pl&x={x}&y={y}&z={z}`;
          break
        default:
          url = options.url;
          break
      }
      this._url = url;
      this._subdomains = ["0", "1", "2", "3"];
      this.options = options;

      this._tileWidth = 256;
      this._tileHeight = 256;
      this._maximumLevel = 18;

      const resolutions = [];
      for (let i = 0; i < 19; i++) {
        resolutions[i] = 256 * Math.pow(2, 18 - i);
      }
      this._tilingScheme = new BaiduMercatorTilingScheme({
        resolutions,
        rectangleSouthwestInMeters: new Cesium__namespace.Cartesian2(-20037726.37, -12474104.17),
        rectangleNortheastInMeters: new Cesium__namespace.Cartesian2(20037726.37, 12474104.17),
        mapChinaCRS: options.mapChinaCRS
      });
      this._rectangle = this._tilingScheme.rectangle;

      this._readyPromise = Cesium__namespace.defer ? Cesium__namespace.defer() : Cesium__namespace.when.defer();
      this._errorEvent = new Cesium__namespace.Event();

      this._readyPromise.resolve(true);
    }

    get url() {
      return this._url
    }

    get errorEvent() {
      return this._errorEvent
    }

    get tileWidth() {
      if (!this.ready) {
        throw new Cesium__namespace.DeveloperError("tileWidth must not be called before the imagery provider is ready.")
      }
      return this._tileWidth
    }

    get tileHeight() {
      if (!this.ready) {
        throw new Cesium__namespace.DeveloperError("tileHeight must not be called before the imagery provider is ready.")
      }
      return this._tileHeight
    }

    get maximumLevel() {
      if (!this.ready) {
        throw new Cesium__namespace.DeveloperError("maximumLevel must not be called before the imagery provider is ready.")
      }
      return this._maximumLevel
    }

    get minimumLevel() {
      if (!this.ready) {
        throw new Cesium__namespace.DeveloperError("minimumLevel must not be called before the imagery provider is ready.")
      }
      return 0
    }

    get tilingScheme() {
      if (!this.ready) {
        throw new Cesium__namespace.DeveloperError("tilingScheme must not be called before the imagery provider is ready.")
      }
      return this._tilingScheme
    }

    get rectangle() {
      if (!this.ready) {
        throw new Cesium__namespace.DeveloperError("rectangle must not be called before the imagery provider is ready.")
      }
      return this._rectangle
    }

    get ready() {
      return !!this._url
    }

    get readyPromise() {
      return this._readyPromise.promise
    }

    get credit() {
      return this._credit
    }

    get hasAlphaChannel() {
      return true
    }

    requestImage(x, y, level) {
      let url = this._url;
      if (url instanceof Cesium__namespace.Resource) {
        url = url.url;
      }
      url = url.replace("{x}", String(x)).replace("{y}", String(-y)).replace("{z}", level).replace("{s}", getArrayRandomOne(this._subdomains));

      return Cesium__namespace.ImageryProvider.loadImage(this, url)
    }
  }

  // 腾讯地图

  class TencentImageryProvider extends XyzImageryProvider$1 {
    constructor(options = {}) {
      switch (options.layer) {
        case "vec":
          options.url = "https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={reverseY}&styleid=1&scene=0";
          break
        case "img_d":
          options.url = "https://p{s}.map.gtimg.com/sateTiles/{z}/{sx}/{sy}/{x}_{reverseY}.jpg?version=400";
          options.customTags = {
            sx: (imageryProvider, x, y, level) => {
              return x >> 4
            },
            sy: (imageryProvider, x, y, level) => {
              return ((1 << level) - y) >> 4
            }
          };
          break
        case "img_z":
          options.url = "https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={reverseY}&styleid=2&scene=0";
          break
        case "custom": // Custom 各种自定义样式
          // 可选值：灰白地图:3,暗色地图:4
          options.style = options.style || "4";
          options.url = "https://rt{s}.map.gtimg.com/tile?z={z}&x={x}&y={reverseY}&styleid=" + options.style + "&scene=0";
          break
      }

      options.subdomains = options.subdomains ?? ["0", "1", "2"];

      super(options);
    }
  }

  class GoogleImageryProvider extends XyzImageryProvider$1 {
    constructor(options = {}) {
      let _url;

      if (options.chinaCRS === ChinaCRS.WGS84) {
        // 无偏移
        _url = options.url || "http://mt{s}.google.cn/vt?lyrs=s@187&hl=us&gl=us&x={x}&y={y}&z={z}";
      } else {
        // 有偏移
        switch (options.layer) {
          case "vec":
            _url = "https://mt{s}.google.cn/vt/lyrs=m@207000000&hl=zh-CN&gl=CN&src=app&x={x}&y={y}&z={z}&s=Galile";
            break
          case "img_d":
            _url = "http://mt{s}.google.cn/vt/lyrs=s&hl=zh-CN&gl=CN&x={x}&y={y}&z={z}&s=Gali";
            break
          case "img_z":
            _url = "http://mt{s}.google.cn/vt/imgtp=png32&lyrs=h@207000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Galil";
            break
          case "ter":
            _url = "http://mt{s}.google.cn/vt/lyrs=t@131,r@227000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Galile";
            break
          default:
            _url = options.url;
            break
        }
      }

      if (options.proxy || options.headers || options.queryParameters) {
        // 存在代理等参数时
        _url = getUrlResource({
          url: _url.replace("{s}", "1"),
          proxy: options.proxy,
          headers: options.headers,
          queryParameters: options.queryParameters
        });
      }

      super({
        subdomains: ["1", "2", "3"],
        maximumLevel: 20,
        ...options,
        url: _url
      });
    }
  }

  // OSM
  class OsmImageryProvider extends XyzImageryProvider$1 {
    constructor(options = {}) {
      let _url = "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";

      if (options.proxy || options.headers || options.queryParameters) {
        // 存在代理等参数时
        _url = getUrlResource({
          url: _url.replace("{s}", "a"),
          proxy: options.proxy,
          headers: options.headers,
          queryParameters: options.queryParameters
        });
      }
      super({
        subdomains: "abc",
        maximumLevel: 18,
        ...options,
        url: _url
      });
    }
  }

  // 空白图层，目前主要在Lod矢量数据加载作为事件触发使用。
  class EmptyImageryProvider extends Cesium__namespace.TileCoordinatesImageryProvider {
    constructor(options = {}) {
      super(options);

      this.options = options;

      this._minimumLevel = options.minimumLevel ?? 0;
      this._maximumLevel = options.maximumLevel;

      this._tilingScheme = options.tilingScheme ?? new Cesium__namespace.GeographicTilingScheme({ ellipsoid: options.ellipsoid });
      if (options.rectangle) {
        this._rectangle = Cesium__namespace.Rectangle.intersection(options.rectangle, this._tilingScheme.rectangle);
      } else {
        this._rectangle = this._tilingScheme.rectangle;
      }
      this.options = options;
    }

    requestImage(x, y, level) {
      return new Promise((resolve, reject) => {
        const canvas = document.createElement("canvas");
        canvas.width = 256;
        canvas.height = 256;

        if (level < this._minimumLevel || (Cesium__namespace.defined(this._maximumLevel) && level > this._maximumLevel)) {
          return canvas
        }

        if (this.options.debuggerTileInfo) {
          const context = canvas.getContext("2d");

          context.strokeStyle = "#ffff00";
          context.lineWidth = 2;
          context.strokeRect(1, 1, 255, 255);

          const label = "L" + level + "X" + x + "Y" + y;
          context.font = "bold 25px Arial";
          context.textAlign = "center";
          context.fillStyle = "black";
          context.fillText(label, 127, 127);
          context.fillStyle = "#ffff00";
          context.fillText(label, 124, 124);
        }
        resolve(canvas);
      })
    }
  }

  var index$5 = {
    __proto__: null,
    XyzImageryProvider: XyzImageryProvider$1,
    TdtImageryProvider: TdtImageryProvider,
    GaodeImageryProvider: GaodeImageryProvider,
    BaiduImageryProvider: BaiduImageryProvider,
    TencentImageryProvider: TencentImageryProvider,
    GoogleImageryProvider: GoogleImageryProvider,
    OsmImageryProvider: OsmImageryProvider,
    EmptyImageryProvider: EmptyImageryProvider
  };

  /**
   * 图层组，可以用于将多个图层组合起来方便控制（比如将 卫星底图 和 文字注记层 放在一起控制管理），或用于 图层管理 的图层分组节点（虚拟节点）。
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Object[]} [options.layers] 子图层数组，每个子图层的配置见按各类型图层配置即可。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class GroupLayer
   * @extends {BaseGraphicLayer}
   */
  class GroupLayer extends BaseGraphicLayer {
    constructor(options = {}) {
      super(options);
      this._arrLayer = [];
    }

    // 父类使用的
    get layer() {
      return this._arrLayer
    }

    /**
     * 子图层对象数组
     *
     * @type {BaseLayer[]|GraphicLayer[]}
     * @readonly
     */
    get arrLayer() {
      return this._arrLayer
    }

    /**
     * 是否空组 ，空组目前就图层管理用于图层分组节点（虚拟节点）。
     *
     * @type {Boolean}
     * @readonly
     */
    get hasEmptyGroup() {
      return this.length === 0
    }

    /**
     * 是否有子图层
     *
     * @type {Boolean}
     * @readonly
     */
    get hasChildLayer() {
      return this.length > 0
    }

    /**
     * 子图层的个数
     *
     * @type {Number}
     * @readonly
     */
    get length() {
      if (this.options.layers?.length > 0) {
        return this.options.layers.length
      } else {
        return this._arrLayer.length
      }
    }

    /**
     * 是否可以调整透明度
     *
     * @type {Boolean}
     * @readonly
     */
    get hasOpacity() {
      if (this._arrLayer.length === 0) {
        return false
      }
      return this._arrLayer[0].hasOpacity
    }

    /**
     * 是否可以调整图层顺序（在同类型图层间）
     *
     * @type {Boolean}
     * @readonly
     */
    get hasZIndex() {
      if (this._arrLayer.length === 0) {
        return false
      }
      return this._arrLayer[0].hasZIndex
    }

    /**
     * 图层顺序，数字大的在上面。（当hasZIndex为true时）
     * @type {Number}
     */
    get zIndex() {
      return this.options.zIndex
    }

    set zIndex(zIndex) {
      this.options.zIndex = zIndex;

      this.eachLayer((layer) => {
        if (layer.hasZIndex) {
          layer.zIndex = zIndex;
        }
      }, this);
    }

    // 显示隐藏
    _showHook(value) {
      this.eachLayer((layer) => {
        layer.show = value;
      }, this);
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      super._mountedHook();

      const layers = this.options.layers;
      if (layers && layers.length > 0) {
        for (let index = 0; index < layers.length; index++) {
          const item = layers[index];
          item.eventParent = this;
          item.private = this.isPrivate;
          const childlayer = create$2(item, this.options.templateValues);
          if (childlayer) {
            this.addLayer(childlayer);
          }
        }
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      const layersPromse = [];
      this.eachLayer((layer) => {
        layer.eventParent = this;
        this._map.addLayer(layer);
        layersPromse.push(layer.readyPromise);
      }, this);

      Promise.all(layersPromse).then((result) => {
        this._readyPromise.resolve(this);
      });
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.removeMapChilds();
    }

    /**
     * 添加所有子图层到map上
     * @return {GroupLayer} 当前对象本身，可以链式调用
     */
    addChildsToMap() {
      this.eachLayer((layer) => {
        this._map.addLayer(layer);
      }, this);
    }

    /**
     *  将所有子图层从map中移除
     * @return {GroupLayer} 当前对象本身，可以链式调用
     */
    removeMapChilds() {
      this.eachLayer((layer) => {
        this._map.removeLayer(layer);
      }, this);
    }

    /**
     * 添加子图层，并绑定关联关系。
     *
     * @param {BaseLayer|GraphicLayer} childlayer 子图层对象
     * @return {GroupLayer} 当前对象本身，可以链式调用
     */
    addLayer(childlayer) {
      if (childlayer.parent) {
        // 已经在其他graphic内时
        childlayer.removeEventParent(childlayer.parent);
        childlayer.parent = null;
      }
      childlayer.pid = this.id;
      childlayer.parent = this;
      childlayer.options.eventParent = this;
      this._arrLayer.push(childlayer);

      if (this.isAdded && !childlayer.isAdded) {
        this._map.addLayer(childlayer);
      } else {
        childlayer.removeEventParent(this._map);
        childlayer.addEventParent(this);
      }

      return this
    }

    /**
     * 移除子图层，并解除关联关系。
     *
     * @param {BaseLayer|GraphicLayer} childlayer 子图层对象
     * @return {GroupLayer} 当前对象本身，可以链式调用
     */
    removeLayer(childlayer) {
      childlayer.parent = null;
      childlayer.removeEventParent(this);
      removeArrayItem(this._arrLayer, childlayer);

      if (this._map && childlayer.isAdded) {
        this._map.removeLayer(childlayer);
      }

      return this
    }

    /**
     * 遍历每一个子图层并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} [context] 侦听器的上下文(this关键字将指向的对象)。
     * @return {GroupLayer} 当前对象本身,可以链式调用
     */
    eachLayer(method, context) {
      if (!this._arrLayer) {
        return
      }
      this._arrLayer.forEach((layer) => {
        method.call(context, layer);
      });
      return this
    }

    /**
     * 获取所有内置子图层对象
     * @return {BaseLayer[]|GraphicLayer[]} 所有子图层对象
     */
    getLayers() {
      return this._arrLayer
    }

    /**
     * 获取地图所有的子图层对象(包括pid和id关联的图层)
     * @return {BaseLayer[]|GraphicLayer[]} 所有子图层对象
     */
    getInMapChilds() {
      const arr = this._arrLayer || [];
      this._map.eachLayer((layer) => {
        if (layer.pid !== this.id) {
          return
        }
        if (this._arrLayer.indexOf(layer) !== -1) {
          return
        }

        arr.push(layer);
      }, this);
      return arr
    }

    /**
     * 根据ID或取图层
     *
     * @param {String|Number} id 图层id或uuid
     * @return {BaseLayer|GraphicLayer|*} 图层对象
     */
    getLayerById(id) {
      const layers = this._arrLayer;
      if (!this._arrLayer || this._arrLayer.length === 0) {
        return
      }
      for (let i = 0, len = layers.length; i < len; i++) {
        const layer = layers[i];
        if (layer.id === id) {
          return layer
        }
      }
      return undefined
    }

    /**
     * 根据id或name属性获取图层
     *
     * @param {String|Number} name 图层id或uuid或name值
     * @return {BaseLayer|GraphicLayer} 图层对象
     */
    getLayer(name) {
      if (!this._arrLayer || this._arrLayer.length === 0) {
        return undefined
      }
      for (let i = 0; i < this._arrLayer.length; i++) {
        const layer = this._arrLayer[i];
        if (layer.name === name || layer.id === name) {
          return layer
        }
      }
      return undefined
    }

    /**
     * 是否有同名的子图层，一般用于新增时判断
     *
     * @param {String} name 图层名称
     * @param {BaseLayer} [excludedLayer] 可以指定不进行判断的图层，比如当前图层本身
     * @return {Boolean} 是否同名
     */
    hasLayer(name, excludedLayer) {
      for (let i = 0; i < this._arrLayer.length; i++) {
        const layer = this._arrLayer[i];
        if (excludedLayer && layer === excludedLayer) {
          continue
        }

        if (layer.name === name || layer.id === name) {
          return true
        }
      }
      return false
    }

    /**
     * 获取图层内所有数据的 矩形边界值
     * @param {Boolean} [isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */
    getRectangle(isFormat) {
      let rectangleAll;

      const arr = this.getInMapChilds();
      arr.forEach((layer) => {
        if (!layer.getRectangle) {
          return
        }

        const rectangle = layer.getRectangle();
        if (!Cesium__namespace.defined(rectangle)) {
          return
        }

        if (rectangleAll) {
          rectangleAll = Cesium__namespace.Rectangle.union(rectangle, rectangleAll);
        } else {
          rectangleAll = rectangle;
        }
      }, this);

      if (isFormat) {
        return formatRectangle(rectangleAll)
      } else {
        return rectangleAll
      }
    }

    // 设置透明度
    setOpacity(value) {
      this.eachLayer((layer) => {
        layer.opacity = value;
      }, this);
    }

    // 销毁释放对象
    destroy(noDel) {
      this.eachLayer((layer) => {
        if (layer?.destroy) {
          layer.destroy(noDel);
        }
      }, this);
      super.destroy(noDel);
    }
  }

  // 注册下
  register$2("group", GroupLayer);

  /**
   * @typedef {Object} BaseTileLayer.EventType
   * 当前栅格瓦片图层支持的{@link EventType}事件类型
   *
   * @property {String} add 添加对象
   * @property {String} remove 移除对象
   * @property {String} show 显示了对象
   * @property {String} hide 隐藏了对象
   *
   * @property {String} load 瓦片图层初始化完成
   * @property {String} addTile 栅格瓦片图层，开始加载瓦片
   * @property {String} addTileSuccess 栅格瓦片图层，加载瓦片完成
   * @property {String} addTileError 栅格瓦片图层，加载瓦片出错了
   *
   * @property {String} click  鼠标单击事件【WMS等动态服务enablePickFeatures:true时,支持单击获取对应的矢量对象】
   * @property {String} popupOpen 当存在popup时，popup弹窗打开后
   * @property {String} popupClose 当存在popup时，popup弹窗关闭
   * @property {String} highlightOpen highlight高亮后
   * @property {String} highlightClose highlight关闭后
   *
   * @example
   * //绑定监听事件
   * layer.on(mars3d.EventType.addTile, function (event) {
   *   console.log('addTile', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 栅格Tile瓦片图层 基类
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则 {@link UrlTemplateImageryProvider#pickFeatures} 请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
   *        如果为 false{@link UrlTemplateImageryProvider#pickFeatures} 会立即返回未定义（表示没有可拾取的内容） 功能）而无需与服务器通信。如果您知道数据，则将此属性设置为false 源不支持选择功能，或者您不希望该提供程序的功能可供选择。注意 可以通过修改 {@link UriTemplateImageryProvider#enablePickFeatures}来动态覆盖 属性。
   * @param {Cesium.GetFeatureInfoFormat[]} [options.getFeatureInfoFormats] 在某处获取功能信息的格式 调用 {@link UrlTemplateImageryProvider#pickFeatures} 的特定位置。如果这 参数未指定，功能选择已禁用。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class BaseTileLayer
   * @extends {BaseLayer}
   *
   * @see Cesium.UrlTemplateImageryProvider
   * @see Cesium.ImageryLayer
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   */
  class BaseTileLayer extends BaseLayer {
    constructor(options = {}) {
      super(options);

      this._setRectangleByOptions(options);

      /**
       * 当前是否为瓦片图层
       * @type {Boolean}
       * @readonly
       */
      this.isTile = true;
    }

    /**
     * 瓦片图层对应的内部ImageryLayer对象
     *
     * @type {Cesium.ImageryLayer}
     * @readonly
     */
    get layer() {
      return this._imageryLayer
    }

    /**
     * 瓦片图层对应的内部ImageryProvider对象
     *
     * @type {Cesium.ImageryProvider}
     * @readonly
     */
    get imageryProvider() {
      return this._imageryLayer?.imageryProvider
    }

    /**
     * 坐标系
     * @type {CRS|String}
     * @readonly
     */
    get crs() {
      return this.options.crs || CRS.EPSG3857
    }

    /**
     * 透明度，同opacity。从0.0到1.0。
     *
     * @type {Number}
     * @default 1.0
     */
    get alpha() {
      return this.opacity
    }

    set alpha(value) {
      this.opacity = value;
    }

    /**
     * 亮度，取值范围：0.0-1.0。
     *
     * @type {Number}
     * @default 1.0
     */
    get brightness() {
      return this.options.brightness || this._imageryLayer?.brightness
    }

    set brightness(value) {
      this.options.brightness = value;
      if (this._imageryLayer == null) {
        return
      }
      this._imageryLayer.brightness = value;
    }

    /**
     * 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
     *
     * @type {Number}
     * @default 1.0
     */
    get contrast() {
      return this.options.contrast || this._imageryLayer?.contrast
    }

    set contrast(value) {
      this.options.contrast = value;
      if (this._imageryLayer == null) {
        return
      }
      this._imageryLayer.contrast = value;
    }

    /**
     * 色调。 0.0 时未修改的图像颜色。
     *
     * @type {Number}
     * @default 0.0
     */
    get hue() {
      return this.options.hue || this._imageryLayer?.hue
    }

    set hue(value) {
      this.options.hue = value;
      if (this._imageryLayer == null) {
        return
      }
      this._imageryLayer.hue = value;
    }

    /**
     * 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
     *
     * @type {Number}
     * @default 1.0
     */
    get saturation() {
      return this.options.saturation || this._imageryLayer?.saturation
    }

    set saturation(value) {
      this.options.saturation = value;
      if (this._imageryLayer == null) {
        return
      }
      this._imageryLayer.saturation = value;
    }

    /**
     * 伽马校正值。 1.0使用未修改的图像颜色。
     *
     * @type {Number}
     * @default 1.0
     */
    get gamma() {
      return this.options.gamma || this._imageryLayer?.gamma
    }

    set gamma(value) {
      this.options.gamma = value;
      if (this._imageryLayer == null) {
        return
      }
      this._imageryLayer.gamma = value;
    }

    /**
     * 是否可以调整图层顺序（在同类型图层间）
     *
     * @type {Boolean}
     * @readonly
     */
    get hasZIndex() {
      return true
    }

    /**
     * 图层顺序，数字大的在上面。（当hasZIndex为true时）
     * @type {Number}
     */
    get zIndex() {
      return this.options.zIndex
    }

    set zIndex(zIndex) {
      this.options.zIndex = zIndex;

      if (this._imageryLayer == null || zIndex == null) {
        return
      }

      // 先移动到最顶层
      this._map.imageryLayers.raiseToTop(this._imageryLayer);

      const layers = this._map.imageryLayers._layers;
      for (let i = layers.length - 1; i >= 0; i--) {
        const imageLayer = layers[i];
        if (imageLayer === this._imageryLayer) {
          continue
        }
        const options = imageLayer._mars3d_config;
        if (options && options.zIndex) {
          if (zIndex < options.zIndex) {
            this._map.imageryLayers.lower(this._imageryLayer); // 下移一个位置
          }
        }
      }
    }

    /**
     * 瓦片数据范围
     * @type {Cesium.Rectangle}
     */
    get rectangle() {
      if (this._rectangle) {
        return this._rectangle
      } else if (this._imageryLayer?.imageryProvider?.ready && this._imageryLayer.imageryProvider.rectangle) {
        return this._imageryLayer.imageryProvider.rectangle
      } else {
        return null
      }
    }

    set rectangle(value) {
      this._rectangle = value || Cesium__namespace.Rectangle.MAX_VALUE;
      this.options.rectangle = formatRectangle(this._rectangle);

      if (this._imageryLayer?.imageryProvider?.ready && this._imageryLayer.imageryProvider.rectangle) {
        this._imageryLayer.imageryProvider._rectangle = this._rectangle;
      }
    }

    _setRectangleByOptions(options) {
      if (Cesium__namespace.defined(options.rectangle)) {
        if (
          Cesium__namespace.defined(options.rectangle.xmin) &&
          Cesium__namespace.defined(options.rectangle.xmax) &&
          Cesium__namespace.defined(options.rectangle.ymin) &&
          Cesium__namespace.defined(options.rectangle.ymax)
        ) {
          this._rectangle = Cesium__namespace.Rectangle.fromDegrees(options.rectangle.xmin, options.rectangle.ymin, options.rectangle.xmax, options.rectangle.ymax);
        } else {
          this._rectangle = options.rectangle;
        }
      } else if (Cesium__namespace.defined(options.bbox) && options.bbox.length && options.bbox.length === 4) {
        // bbox: xmin, ymin, xmax, ymax
        this._rectangle = Cesium__namespace.Rectangle.fromDegrees(options.bbox[0], options.bbox[1], options.bbox[2], options.bbox[3]);
      }
    }

    // 更新参数
    _setOptionsHook(options) {
      this._setRectangleByOptions(options);
      this.reload();
    }

    /**
     * 创建瓦片图层对应的ImageryProvider对象
     * @param {Object} [options={}] 参数对象，具体每类瓦片图层都不一样。
     * @return {Cesium.UrlTemplateImageryProvider|*}  创建完成的 ImageryProvider 对象
     * @abstract
     */
    _createImageryProvider(options) {
      return new Cesium__namespace.UrlTemplateImageryProvider(options)
    }

    // 对象添加到地图上的创建钩子方法
    _addedHook() {
      if (this.options.highlight) {
        this.options.enablePickFeatures = true;
      }

      const imageryProvider = this._createImageryProvider({
        ...this.options,
        rectangle: this.rectangle,
        mapChinaCRS: this._map.chinaCRS // map地图的坐标系
      });
      if (!Cesium__namespace.defined(imageryProvider)) {
        return
      }

      if (imageryProvider.then) {
        imageryProvider.then((result) => {
          this._addImageryLayer(result);
        });
      } else {
        this._addImageryLayer(imageryProvider);
      }
    }

    _addImageryLayer(imageryProvider) {
      const options = this.options;

      const layerOpts = {
        show: this.show, // 避免异步加载中设置show=false，需要赋值下
        alpha: this.opacity,
        ...options,
        rectangle: this.rectangle,
        marsOptions: {
          // 以下4个接口为修改mars3d-cesium实现
          onAddTile: (imagery) => {
            const params = this._getTileEventParams(imagery);
            this.fire(EventType.addTile, params); // 添加瓦片，请求前
          },
          onAddTileSuccess: (imagery) => {
            const params = this._getTileEventParams(imagery);
            this.fire(EventType.addTileSuccess, params);
          },
          onAddTileError: (imagery) => {
            const params = this._getTileEventParams(imagery);
            this.fire(EventType.addTileError, params);
          },
          onRemoveTile: (imagery) => {
            const params = this._getTileEventParams(imagery);
            this.fire(EventType.removeTile, params);
          }
        }
      };
      this._imageryLayer = new Cesium__namespace.ImageryLayer(imageryProvider, layerOpts);
      this._imageryLayer._mars3d_layerId = this.id;
      this._imageryLayer._mars3d_config = this.options;
      this._map.imageryLayers.add(this._imageryLayer);

      // 调整顺序
      if (this.options.zIndex) {
        this.zIndex = this.options.zIndex;
      }

      // 高亮绑定处理:arcgis、wms等图层
      if (this.options.highlight) {
        this.options.enablePickFeatures = true;
        this.bindHighlight(this.options.highlight);
      } else if (this.options.symbol?.styleOptions?.highlight) {
        this.bindHighlight(this.options.symbol.styleOptions.highlight);
      }

      imageryProvider.readyPromise.then((e) => {
        this.fire(EventType.load, {}, true);

        this._readyPromise.resolve(this);

        setTimeout(() => {
          if (this.options?.flyTo) {
            this.flyToByAnimationEnd();
          }
        }, 50);
      });
    }

    _getTileEventParams(imagery) {
      return {
        x: imagery.x,
        y: imagery.y,
        level: imagery.level,
        extent: formatRectangle(imagery.rectangle)
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.unbindHighlight();

      this._map.imageryLayers.remove(this._imageryLayer, true);
      this._imageryLayer = null;
    }

    /**
     * 重新加载图层
     * @return {void}  无
     */
    reload() {
      if (this._imageryLayer) {
        this._removedHook();
        this._addedHook();
      }
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      if (this._imageryLayer) {
        this._imageryLayer.alpha = value;
      }
    }

    // 定位至数据区域
    flyTo(options = {}) {
      if (!this._map || !this._imageryLayer) {
        return Promise.resolve(false)
      }
      this._map.cancelFlyTo();

      if (this.options.center) {
        return this._map.setCameraView(this.options.center, options)
      } else if (this.options.extent) {
        return this._map.flyToExtent(this.options.extent, options)
      } else {
        const rectangle = this.rectangle; // arcgis图层等，读取配置信息
        if (
          Cesium__namespace.defined(rectangle) &&
          !rectangle.equals(Cesium__namespace.Rectangle.MAX_VALUE) &&
          rectangle.west > 0 &&
          rectangle.south > 0 &&
          rectangle.east > 0 &&
          rectangle.north > 0
        ) {
          return this._map.camera.flyTo({
            ...options,
            destination: rectangle
          })
        }
      }
      return Promise.resolve(false)
    }

    //= ============= Highlight ======================
    /**
     * 绑定鼠标移入或单击后的 对象高亮
     * @param {Object} [options] 高亮的样式，具体见各{@link GraphicType}矢量数据的style参数。
     * @param {String} [options.type] 事件类型，默认为鼠标移入高亮，也可以指定'click'单击高亮.
     * @return {void}  无
     */
    bindHighlight(options) {
      this.unbindHighlight();

      this._highlightOptions = options;

      this.on(EventType.click, this._highlight_mouseEventHandler, this);
    }

    /**
     * 解绑鼠标移入或单击后的高亮处理
     * @return {void}  无
     */
    unbindHighlight() {
      if (this._highlightOptions) {
        this.off(EventType.click, this._highlight_mouseEventHandler, this);

        this._map.closeHighlight();
        this._highlightOptions = null;
      }
    }

    // 移入
    _highlight_mouseEventHandler(event) {
      this._map.closeHighlight(); // 需要关闭下

      const graphicsOptions = event.graphics;

      if (graphicsOptions) {
        this._last_graphicsOptions = graphicsOptions;
        this._map.openHighlight(this, this._highlightOptions, event);
      }
    }

    // 移出
    _highlight_mouseOutHandler(event) {
      this._map.closeHighlight();
    }

    /**
     * 高亮对象。
     * @param {Object} [highlightStyle] 高亮的样式，具体见各{@link GraphicType}矢量数据的style参数。
     * @param {Boolean} [closeLast=true] 是否清除地图上上一次的高亮对象
     * @return {void}  无
     */
    openHighlight(highlightStyle, closeLast = true) {
      if (closeLast) {
        this._map.closeHighlight();
        this._map.last_highlighGraphic = this;
      }

      const style = highlightStyle || this._highlightOptions;
      if (this._last_graphicsOptions && style) {
        if (!this._graphicLayer) {
          this._graphicLayer = new GraphicLayer({
            name: "高亮对象图层",
            private: true
          });
          this._map.addLayer(this._graphicLayer);
        }
        this._graphicLayer.addGraphic(this._last_graphicsOptions);

        this.fire(EventType.highlightOpen, {}, true);
      }
    }

    /**
     * 清除已选中的高亮，原有style的配置项需要与highlightStyle配置有一一对应关系，否则无法清除
     * @return {void}  无
     */
    closeHighlight() {
      if (!this._graphicLayer || this._map?.last_highlighGraphic !== this) {
        return
      }

      this._graphicLayer.clear();
      this._map._clearLastHighlight();

      this.fire(EventType.highlightClose, {}, true);
    }
  }

  /**
   * 地形服务图层，一个地图中只会生效一个地形服务图层（单选）
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Object} options.terrain 地形服务配置
   * @param {TerrainType} [options.terrain.type='xyz'] 地形类型
   * @param {String|Cesium.Resource} options.terrain.url 地形服务地址
   * @param {Boolean} [options.terrain.requestVertexNormals=true] 是否应该从服务器请求额外的光照信息，如果可用，以每个顶点法线的形式。
   * @param {Boolean} [options.terrain.requestWaterMask=false] 是否应该向服务器请求每个瓦的水掩膜(如果有的话)。
   * @param {Boolean} [options.terrain.requestMetadata=true] 是否应该从服务器请求每个块元数据(如果可用)。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示（多个地形服务时，请只设置一个TerrainLayer图层的show为tue）
   * @export
   * @class TerrainLayer
   * @extends {BaseLayer}
   */
  class TerrainLayer extends BaseLayer {
    _showHook(show) {
      if (show) {
        this._addedHook();
      } else {
        this._removedHook();
      }
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._terrainProvider = createTerrainProvider(this._getTerrainOptions());
    }

    _getTerrainOptions() {
      const terrainOptions = {
        templateValues: this.options.templateValues,
        marsOptions: {
          onLoadSuccess: (data) => {
            this._readyPromise.resolve(this);
            this.fire(EventType.load, { terrain: this._terrainProvider });
          },
          onLoadError: (error) => {
            this._readyPromise && this._readyPromise.reject(error);
          }
        },
        ...this.options.terrain
      };
      return terrainOptions
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.terrainProvider = this._terrainProvider;
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.terrainProvider = getNoTerrainProvider();
    }
  }
  // 注册下
  register$2("terrain", TerrainLayer);

  /**
   * ArcGIS生成的金字塔瓦片数据
   *
   * @param {Object} [options] 参数对象，包括以下：
   *
   * @param {Cesium.Resource|String} options.url  用于请求瓦片图块的URL模板。它具有以下关键字:
   * <ul>
   *     <li><code>{z}</code>: 切片方案中切片的级别。零级是四叉树金字塔的根。</li>
   *     <li><code>{x}</code>:切片方案中的图块X坐标，其中0是最西端的图块。</li>
   *     <li><code>{y}</code>: 切片方案中的图块Y坐标，其中0是最北的图块。</li>
   *     <li><code>{s}</code>:可用的子域之一，用于克服浏览器对每个主机的并发请求数的限制。</li>
   * </ul>
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是一个数组，数组中的每个元素都是一个子域。
   * @param {Boolean} [options.upperCase] url请求的瓦片图片名称是否大写。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则 {@link UrlTemplateImageryProvider#pickFeatures} 请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
   *        如果为 false{@link UrlTemplateImageryProvider#pickFeatures} 会立即返回未定义（表示没有可拾取的内容） 功能）而无需与服务器通信。如果您知道数据，则将此属性设置为false 源不支持选择功能，或者您不希望该提供程序的功能可供选择。注意 可以通过修改 {@link UriTemplateImageryProvider#enablePickFeatures}来动态覆盖 属性。
   * @param {Cesium.GetFeatureInfoFormat[]} [options.getFeatureInfoFormats] 在某处获取功能信息的格式 调用 {@link UrlTemplateImageryProvider#pickFeatures} 的特定位置。如果这 参数未指定，功能选择已禁用。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class ArcGisCacheLayer
   * @extends {BaseTileLayer}
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @example
  let tileLayer = new mars3d.layer.ArcGisCacheLayer({
    url: 'http://data.mars3d.cn/tile/hf/guihua/_alllayers/{z}/{y}/{x}.png',
    minimumLevel: 1,
    maximumLevel: 17,
    minimumTerrainLevel: 1,
    // "maximumTerrainLevel": 17, //如果需要大于maximumTerrainLevel层时不显示瓦片，则取消注释
    rectangle: { xmin: 116.846, xmax: 117.642, ymin: 31.533, ymax: 32.185 }, // 控制切片如果在矩形坐标内才显示，如果不在矩形坐标内不显示
  })
  map.addLayer(tileLayer)
   */
  class ArcGisCacheLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$j(options)
    }
  }

  function createImageryProvider$j(options) {
    options.url = options.url.replace("{x}", "C{arc_x}").replace("{y}", "R{arc_y}").replace("{z}", "L{arc_z}");

    const upperCase = options.upperCase; // 是否大写

    // 对arcgis切片的支持 ，示例 /_alllayers/L{arc_z}/R{arc_y}/C{arc_x}.jpg
    options.customTags = options.customTags || {};
    options.customTags.arc_x = function (imageryProvider, x, y, level) {
      if (upperCase) {
        return padLeft0(x.toString(16), 8).toUpperCase()
      } else {
        return padLeft0(x.toString(16), 8)
      }
    };
    options.customTags.arc_y = function (imageryProvider, x, y, level) {
      if (upperCase) {
        return padLeft0(y.toString(16), 8).toUpperCase()
      } else {
        return padLeft0(y.toString(16), 8)
      }
    };
    options.customTags.arc_z = function (imageryProvider, x, y, level) {
      if (upperCase) {
        return padLeft0(level.toString(), 2).toUpperCase()
      } else {
        return padLeft0(level.toString(), 2)
      }
    };
    options.customTags.arc_z4490 = function (imageryProvider, x, y, level) {
      if (upperCase) {
        return padLeft0((level + 1).toString(), 2).toUpperCase()
      } else {
        return padLeft0((level + 1).toString(), 2)
      }
    };
    options = converOptions(options);
    return new XyzImageryProvider$1(options)
  }

  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  ArcGisCacheLayer.createImageryProvider = createImageryProvider$j;

  // 注册下
  const layerType$j = "arcgis_cache"; // 图层类型
  register$2(layerType$j, ArcGisCacheLayer);
  registerImageryProvider(layerType$j, createImageryProvider$j);

  /**
   * ArcGIS瓦片服务（使用XYZ瓦片方式请求读取），可用于ArcGisLayer读取异常时。
   *
   * @param {Object} [options] 参数对象，包括以下：
   *
   * @param {String} options.url 用于请求瓦片图块的URL模板，比如："http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer"
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是一个数组，数组中的每个元素都是一个子域。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则 {@link UrlTemplateImageryProvider#pickFeatures} 请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
   *        如果为 false{@link UrlTemplateImageryProvider#pickFeatures} 会立即返回未定义（表示没有可拾取的内容） 功能）而无需与服务器通信。如果您知道数据，则将此属性设置为false 源不支持选择功能，或者您不希望该提供程序的功能可供选择。注意 可以通过修改 {@link UriTemplateImageryProvider#enablePickFeatures}来动态覆盖 属性。
   * @param {Cesium.GetFeatureInfoFormat[]} [options.getFeatureInfoFormats] 在某处获取功能信息的格式 调用 {@link UrlTemplateImageryProvider#pickFeatures} 的特定位置。如果这 参数未指定，功能选择已禁用。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class ArcGisTileLayer
   * @extends {BaseTileLayer}
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @example
  let tileLayer = new mars3d.layer.ArcGisTileLayer({
    url: 'http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer',
    minimumLevel: 1,
    maximumLevel: 17,
    minimumTerrainLevel: 1,
    // "maximumTerrainLevel": 17, //如果需要大于maximumTerrainLevel层时不显示瓦片，则取消注释
    rectangle: { xmin: 116.846, xmax: 117.642, ymin: 31.533, ymax: 32.185 }, // 控制切片如果在矩形坐标内才显示，如果不在矩形坐标内不显示
  })
  map.addLayer(tileLayer)
   */
  class ArcGisTileLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$i(options)
    }
  }

  function createImageryProvider$i(options) {
    options = converOptions(options);
    if (isString(options.url)) {
      options.url = options.url + "/tile/{z}/{y}/{x}";
    } else if (options.url instanceof Cesium__namespace.Resource) {
      options.url.url = options.url.url + "/tile/{z}/{y}/{x}";
    }

    return new XyzImageryProvider$1(options)
  }

  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  ArcGisTileLayer.createImageryProvider = createImageryProvider$i;

  // 注册下
  const layerType$i = "arcgis_tile"; // 图层类型
  register$2(layerType$i, ArcGisTileLayer);
  registerImageryProvider(layerType$i, createImageryProvider$i);

  // 基于 Cesium.ArcGisMapServerImageryProvider 优化重写
  class ArcGisImageryProvider {
    constructor(options = {}) {
      this.options = options;

      // url
      const resource = Cesium__namespace.Resource.createIfNeeded(options.url);
      resource.appendForwardSlash();
      if (Cesium__namespace.defined(options.token)) {
        resource.setQueryParameters({
          token: options.token
        });
      }
      this._resource = resource;

      // 参数
      this._tileDiscardPolicy = options.tileDiscardPolicy;
      this._tileWidth = options.tileWidth ?? 256;
      this._tileHeight = options.tileHeight ?? 256;
      this._maximumLevel = options.maximumLevel;
      this._maxTileLevel = options.maxTileLevel; // 最大瓦片层级，大于该层级用动态服务
      this._crs = options.crs;
      this.enablePickFeatures = options.enablePickFeatures ?? true;
      this._useTiles = options.usePreCachedTilesIfAvailable ?? true;

      this._initTilingSchemeByCrs(options.crs || CRS.EPSG4326);

      this._errorEvent = new Cesium__namespace.Event();
      this._ready = false;
      this._readyPromise = Cesium__namespace.defer ? Cesium__namespace.defer() : Cesium__namespace.when.defer();

      if (this._useTiles) {
        this._requestMetadata();
      } else {
        this._ready = true;
        this._readyPromise.resolve(true);
      }
    }

    get url() {
      return this._resource._url
    }

    get token() {
      return this._resource.queryParameters.token
    }

    get proxy() {
      return this._resource.proxy
    }

    get tileWidth() {
      return this._tileWidth
    }

    get tileHeight() {
      return this._tileHeight
    }

    get maximumLevel() {
      return this._maximumLevel
    }

    get minimumLevel() {
      return 0
    }

    get tilingScheme() {
      return this._tilingScheme
    }

    get rectangle() {
      return this._rectangle
    }

    get tileDiscardPolicy() {
      return this._tileDiscardPolicy
    }

    get errorEvent() {
      return this._errorEvent
    }

    get ready() {
      return this._ready
    }

    get readyPromise() {
      return this._readyPromise.promise
    }

    get credit() {
      return this._credit
    }

    get usingPrecachedTiles() {
      return this._useTiles
    }

    get hasAlphaChannel() {
      return true
    }

    get layers() {
      return this.options.layers
    }

    get layerDefs() {
      return this.options.layerDefs
    }

    _initTilingSchemeByCrs(crs) {
      if (crs === CRS.EPSG3857) {
        this._tilingScheme = this.options.tilingScheme || new Cesium__namespace.WebMercatorTilingScheme({ ellipsoid: this.options.ellipsoid });
        this._rectangle = this.options.rectangle ?? this._tilingScheme.rectangle;
        return true
      } else if (crs === CRS.EPSG4326 || crs === CRS.EPSG4490) {
        this._tilingScheme = this.options.tilingScheme || new Cesium__namespace.GeographicTilingScheme({ ellipsoid: this.options.ellipsoid });
        this._rectangle = this.options.rectangle ?? this._tilingScheme.rectangle;
        return true
      } else {
        return false
      }
    }

    // 请求服务配置
    _requestMetadata() {
      const resource = this._resource.getDerivedResource({ queryParameters: { f: "json" } });
      resource
        .fetchJsonp()
        .then((result) => {
          this._metadataSuccess(result);
        })
        .catch((e) => {
          this._metadataFailure(e);
        });
    }

    _metadataSuccess(data) {
      this.capabilities = data;

      if (!Cesium__namespace.defined(data.tileInfo)) {
        this._useTiles = false; // 使用动态服务
        if (!this.options.crs) {
          this._crs = getCRSByWkid(data.spatialReference?.wkid);
          this._initTilingSchemeByCrs(this._crs);
        }
      } else {
        this._useTiles = true; // 使用瓦片服务

        const tileInfo = data.tileInfo;
        this._tileWidth = tileInfo.rows;
        this._tileHeight = tileInfo.cols;

        if (!this._maximumLevel) {
          this._maximumLevel = tileInfo.lods.length - 1; // 外部没有设置时才去读取服务中的配置。
        }

        if (!this.options.crs) {
          this._crs = getCRSByWkid(tileInfo.spatialReference?.wkid);
          this._useTiles = this._initTilingSchemeByCrs(this._crs); // 不支持的瓦片服务，转为动态服务调用
        }

        // Install the default tile discard policy if none has been supplied.
        if (this._useTiles && !Cesium__namespace.defined(this._tileDiscardPolicy)) {
          this._tileDiscardPolicy = new Cesium__namespace.DiscardMissingTileImagePolicy({
            missingImageUrl: this._buildImageResource(0, 0, this._maximumLevel).url,
            pixelsToCheck: [
              new Cesium__namespace.Cartesian2(0, 0),
              new Cesium__namespace.Cartesian2(200, 20),
              new Cesium__namespace.Cartesian2(20, 200),
              new Cesium__namespace.Cartesian2(80, 110),
              new Cesium__namespace.Cartesian2(160, 130)
            ],
            disableCheckIfAllPixelsAreTransparent: true
          });
        }
      }

      // 边界
      let extent = data.fullExtent || data.extent;
      if (!this.options.rectangle && extent) {
        let crs = this._crs;
        if (extent?.spatialReference?.wkid) {
          crs = getCRSByWkid(extent.spatialReference.wkid);
        }

        if (crs) {
          if (crs !== CRS.EPSG4326 && crs !== CRS.EPSG4490) {
            const ptMin = proj4Trans([extent.xmin, extent.ymin], crs);
            const ptMax = proj4Trans([extent.xmax, extent.ymax], crs);
            extent = { xmin: ptMin[0], ymin: ptMin[1], xmax: ptMax[0], ymax: ptMax[1] };
          }
          this._extent = extent;
          if (extent.xmin > 0 && extent.xmax < 179 && extent.ymin > 0 && extent.ymax < 85) {
            this._rectangle = Cesium__namespace.Rectangle.fromDegrees(extent.xmin, extent.ymin, extent.xmax, extent.ymax);
          }
        }
      }

      this._ready = true;
      this._readyPromise.resolve(true);
      Cesium__namespace.TileProviderError.handleSuccess(this._metadataError);
    }

    _metadataFailure(e) {
      const message = `An error occurred while accessing ${this._resource.url}.`;
      this._metadataError = Cesium__namespace.TileProviderError.handleError(
        this._metadataError,
        this,
        this._errorEvent,
        message,
        undefined,
        undefined,
        undefined,
        this._requestMetadata
      );
      this._readyPromise.reject(new Cesium__namespace.RuntimeError(message));
    }

    getTileCredits(x, y, level) {
      return undefined
    }

    requestImage(x, y, level, request) {
      return Cesium__namespace.ImageryProvider.loadImage(this, this._buildImageResource(x, y, level, request))
    }

    _buildImageResource(x, y, level, request) {
      let _useTiles = this._useTiles;
      if (_useTiles && Cesium__namespace.defined(this._maxTileLevel)) {
        _useTiles = level < this._maxTileLevel; // 增加瓦片级别限定
      }

      if (_useTiles) {
        // 使用瓦片服务时
        if (this._crs === CRS.EPSG4490) {
          level = level + 1; //  对4490瓦片支持
        }

        return this._resource.getDerivedResource({
          url: `tile/${level}/${y}/${x}`,
          request: request
        })
      } else {
        // 使用动态服务时
        const nativeRectangle = this._tilingScheme.tileXYToNativeRectangle(x, y, level);
        const bbox = `${nativeRectangle.west},${nativeRectangle.south},${nativeRectangle.east},${nativeRectangle.north}`;

        const query = {
          bbox: bbox,
          size: `${this._tileWidth},${this._tileHeight}`,
          format: "png32",
          transparent: true,
          f: "image"
        };

        if (this._tilingScheme.projection instanceof Cesium__namespace.GeographicProjection) {
          query.bboxSR = this._wkid || 4326;
          query.imageSR = this._wkid || 4326;
        } else {
          query.bboxSR = this._wkid || 3857;
          query.imageSR = this._wkid || 3857;
        }
        if (this.layers) {
          query.layers = `show:${this.layers}`;
        }
        if (this.layerDefs) {
          query.layerDefs = this.layerDefs; // 增加查询条件
        }

        return this._resource.getDerivedResource({
          url: "export",
          request: request,
          queryParameters: query
        })
      }
    }

    pickFeatures(x, y, level, longitude, latitude) {
      if (!this.enablePickFeatures) {
        return undefined
      }

      const rectangle = this._tilingScheme.tileXYToNativeRectangle(x, y, level);

      let horizontal;
      let vertical;
      let sr;
      if (this._tilingScheme.projection instanceof Cesium__namespace.GeographicProjection) {
        horizontal = Cesium__namespace.Math.toDegrees(longitude);
        vertical = Cesium__namespace.Math.toDegrees(latitude);
        sr = "4326";
      } else {
        const projected = this._tilingScheme.projection.project(new Cesium__namespace.Cartographic(longitude, latitude, 0.0));
        horizontal = projected.x;
        vertical = projected.y;
        sr = "3857";
      }

      let layers = "visible";
      if (Cesium__namespace.defined(this.layers)) {
        layers += `:${this.layers}`;
      }

      const query = {
        f: "json",
        tolerance: 2,
        geometryType: "esriGeometryPoint",
        geometry: `${horizontal},${vertical}`,
        mapExtent: `${rectangle.west},${rectangle.south},${rectangle.east},${rectangle.north}`,
        imageDisplay: `${this._tileWidth},${this._tileHeight},96`,
        sr: sr,
        layers: layers
      };

      // 扩展，增加查询条件
      if (Cesium__namespace.defined(this.layerDefs)) {
        query.layerDefs = this.layerDefs;
      }

      const resource = this._resource.getDerivedResource({
        url: "identify",
        queryParameters: query
      });

      return resource.fetchJson().then(function (json) {
        const result = [];

        const features = json.results;
        if (!Cesium__namespace.defined(features)) {
          return result
        }

        const crs = "EPSG:" + sr; // 无论服务本身是什么坐标系，数据都是固定的

        for (let i = 0; i < features.length; ++i) {
          const feature = features[i];

          const featureInfo = new Cesium__namespace.ImageryLayerFeatureInfo();
          featureInfo.data = feature;
          featureInfo.crs = crs;
          featureInfo.name = feature.value;
          featureInfo.properties = feature.attributes;
          featureInfo.configureDescriptionFromProperties(feature.attributes);

          result.push(featureInfo);
        }

        return result
      })
    }
  }

  function getCRSByWkid(wkid) {
    switch (wkid) {
      case 4326:
      case 4283:
        return CRS.EPSG4326
      case 4490:
        return CRS.EPSG4490
      case 102100:
      case 900913:
      case 3857:
        return CRS.EPSG3857
      default:
        if (turf.isNumber(wkid)) {
          return "EPSG:" + wkid
        } else {
          return undefined
        }
    }
  }

  /**
   * @typedef {Object} ArcGisLayer.EventType
   * ArcGIS服务图层支持的{@link EventType}事件类型
   *
   * @property {String} loadConfig 加载metadata配置信息完成事件
   * @property {String} click  鼠标单击事件【enablePickFeatures:true时,支持单击获取对应的矢量对象】
   *
   * @example
   * //绑定监听事件
   * layer.on(mars3d.EventType.loadConfig, function (event) {
   *   console.log('loadConfig', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * ArcGIS标准服务图层
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Resource|String} options.url ArcGIS MapServer服务的网址。
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是一个数组，数组中的每个元素都是一个子域。
   * @param {String} [options.layers] 要显示的图层的逗号分隔列表，如果应显示所有图层，则未定义。
   * @param {String} [options.layerDefs] 可以对动态服务加条件筛选数据，示例："{\"0\":\"用地编号 = 'R'\"}"，具体可以参阅arcgis官方帮助文档理解layerDefs参数。
   * @param {Boolean} [options.usePreCachedTilesIfAvailable=true]  如果为true，则表示优先使用服务的瓦片图片，没有瓦片时再使用动态服务。如果为false，则将忽略所有瓦片，直接使用动态服务。
   * @param {Number} [options.maxTileLevel] 指定在小于此层级时用瓦片加载，大于该层级用动态服务.可以在瓦片服务类型时，同时使用瓦片和动态服务。
   * @param {Number} [options.wkid] 当非标准EPSG标号时，可以指定wkid值。
   * @param {String} [options.token] 用于通过ArcGIS MapServer服务进行身份验证的ArcGIS令牌。
   * @param {Cesium.TileDiscardPolicy} [options.tileDiscardPolicy] 于确定图块是否为 无效，应将其丢弃。如果未指定此值，则为默认 {@link DiscardMissingTileImagePolicy} 用于平铺的地图服务器，并且{@link NeverTileDiscardPolicy} 用于非平铺地图服务器。在前一种情况下， 我们要求最大图块级别的图块0,0并检查像素（0,0），（200,20），（20,200）， （80,110）和（160，130）。如果所有这些像素都是透明的，则丢弃检查为 禁用，并且不会丢弃任何图块。如果它们中的任何一种具有不透明的颜色， 在这些像素位置具有相同值的图块将被丢弃。的最终结果 对于标准ArcGIS Server，这些默认值应该是正确的图块丢弃。确保 不会丢弃任何图块，为此构造并传递 {@link NeverTileDiscardPolicy} 参数。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG4326] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则请求 单击坐标处服务中对应的矢量数据 并尝试解释响应中包含的功能。为false时不去服务请求。
   * @param {Function} [options.featureToGraphic=mars3d.Util.geoJsonToGraphics] 解析单击返回的矢量数据信息为Graphic构造参数，可以按需自定义。
   * @param {Number|Boolean|Function} [options.hasToGraphic] 筛选或判断是否解析，单击获取到的数据进行按需筛选解析，大数据解析很卡，可以设定阀值屏蔽大数据，避免卡顿，Number类型时代表字符串长度值。
   * @param {Object} [options.highlight] 鼠标单击高亮显示对应的矢量数据 及其样式，具体见各{@link GraphicType}矢量数据的style参数。
   * @param {GraphicType|String} [options.highlight.type] 构造成的矢量数据类型。
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class ArcGisLayer
   * @extends {BaseTileLayer}
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see [支持的事件类型]{@link ArcGisLayer.EventType}
   * @see {@link https://developers.arcgis.com/rest/|ArcGIS Server REST API}
   * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
   */
  class ArcGisLayer extends BaseTileLayer {
    /**
     * 坐标系
     * @type {CRS|String}
     * @readonly
     */
    get crs() {
      return this.imageryProvider?._crs || this.options.crs || CRS.EPSG4326
    }

    get capabilities() {
      return this.imageryProvider?.capabilities
    }

    _addedHook() {
      super._addedHook();
    }

    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$h(options)
    }

    //= ============= popup ======================

    /**
     *  是否存在Popup绑定
     * @return {Boolean} 是否存在Popup绑定
     */
    hasPopup() {
      if (this._popupConfig) {
        return true
      }
      return false
    }

    /**
     * 绑定鼠标单击对象后的弹窗。
     *
     * @param {String|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Popup.StyleOptions} [options] 控制参数
     * @return {ArcGisLayer} 当前对象本身，可以链式调用
     *
     */
    bindPopup(content, options) {
      this._popupConfig = {
        content: content,
        options: options,
        layer: this
      };
      this._bindControl();
      return this
    }

    /**
     * 解除绑定的鼠标单击对象后的弹窗。
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    unbindPopup() {
      this.closePopup();
      this._popupConfig = null;
      return this
    }

    /**
     * 关闭弹窗
     *
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    closePopup() {
      if (this._map && this.hasPopup()) {
        this._map.popup.close(null, this);
      }
      return this
    }
  }

  function createImageryProvider$h(options) {
    if (Cesium__namespace.defined(options.layer) && !Cesium__namespace.defined(options.url)) {
      switch (options.layer) {
        case "vec":
          options.url = "https://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer";
          break
        case "img_d":
          options.url = "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer";
          break
      }
    }
    options = converOptions(options);

    if (options.czm) {
      return new Cesium__namespace.ArcGisMapServerImageryProvider(options) // cesium原生的
    } else {
      return new ArcGisImageryProvider(options)
    }
  }

  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  ArcGisLayer.createImageryProvider = createImageryProvider$h;

  // 注册下
  const layerType$h = "arcgis"; // 图层类型
  register$2(layerType$h, ArcGisLayer);
  registerImageryProvider(layerType$h, createImageryProvider$h);

  /**
   * 百度地图
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.layer] 图层类型，以及以下内容:<br />
   * <ul>
   *     <li><code>vec</code>: 电子图层</li>
   *     <li><code>img_d</code>: 卫星影像</li>
   *     <li><code>img_z</code>: 影像注记</li>
   *     <li><code>custom</code>: 自定义样式图层</li>
   *     <li><code>time</code>: 实时路况信息</li>
   *     <li><code>streetview</code>: 街景覆盖图层</li>
   * </ul>
   * @param {String} [options.url] 当未指定layer类型时，可以传入外部指定url的服务地址，常用于离线服务。
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是一个数组，数组中的每个元素都是一个子域。
   * @param {Boolean} [options.bigfont] 当layer为vec或img_z时，来标识使用是否大写字体。
   * @param {String} [options.style] 当layer为custom时，标识的样式，可选值：dark,midnight,grayscale,hardedge,light,redalert,googlelite,grassgreen,pink,darkgreen,bluish
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {ChinaCRS} [options.chinaCRS=ChinaCRS.BAIDU] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   */
  class BaiduLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$g(options)
    }
  }

  function createImageryProvider$g(options) {
    options = converOptions(options);
    return new BaiduImageryProvider(options)
  }
  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  BaiduLayer.createImageryProvider = createImageryProvider$g;

  // 注册下
  const layerType$g = "baidu"; // 图层类型
  register$2(layerType$g, BaiduLayer);
  registerImageryProvider(layerType$g, createImageryProvider$g);

  /**
   * 微软bing地图
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Resource|String} [options.url='https://dev.virtualearth.net'] 托管影像图像的Bing Maps服务器的网址。
   * @property {String} [options.key=mars3d.Token.bing] 您的应用程序的Bing Maps密钥，可以在{@link https://www.bingmapsportal.com/}中创建
   * @property {Cesium.BingMapsStyle} [mapStyle=Cesium.BingMapsStyle.AERIAL] 要加载的必应地图图像的类型。
   * @property {String} [tileProtocol] 加载图块时要使用的协议，例如' http'或' https'。 默认情况下，将使用与页面相同的协议来加载图块。
   * @property {String} [culture='zh-Hans'] 请求Bing Maps图像时要使用的区域性标记。不支持所有文化。请参阅   {@link http://msdn.microsoft.com/en-us/library/hh441729.aspx}了解有关支持的文化的信息。
   * @param {Cesium.TileDiscardPolicy} [options.tileDiscardPolicy] 于确定图块是否为无效，应将其丢弃。如果未指定此值，则为默认 {@link DiscardMissingTileImagePolicy} 用于平铺的地图服务器，并且{@link NeverTileDiscardPolicy} 用于非平铺地图服务器。在前一种情况下， 我们要求最大图块级别的图块0,0并检查像素（0,0），（200,20），（20,200）， （80,110）和（160，130）。如果所有这些像素都是透明的，则丢弃检查为 禁用，并且不会丢弃任何图块。如果它们中的任何一种具有不透明的颜色， 在这些像素位置具有相同值的图块将被丢弃。的最终结果 对于标准ArcGIS Server，这些默认值应该是正确的图块丢弃。确保 不会丢弃任何图块，为此构造并传递 {@link NeverTileDiscardPolicy} 参数。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则 {@link UrlTemplateImageryProvider#pickFeatures} 请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
   *        如果为 false{@link UrlTemplateImageryProvider#pickFeatures} 会立即返回未定义（表示没有可拾取的内容） 功能）而无需与服务器通信。如果您知道数据，则将此属性设置为false 源不支持选择功能，或者您不希望该提供程序的功能可供选择。注意 可以通过修改 {@link UriTemplateImageryProvider#enablePickFeatures}来动态覆盖 属性。
   * @param {Cesium.GetFeatureInfoFormat[]} [options.getFeatureInfoFormats] 在某处获取功能信息的格式 调用 {@link UrlTemplateImageryProvider#pickFeatures} 的特定位置。如果这 参数未指定，功能选择已禁用。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   */
  class BingLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$f(options)
    }
  }

  function createImageryProvider$f(options) {
    options.url = options.url ?? "https://dev.virtualearth.net";
    options.culture = options.culture ?? "zh-Hans";
    options.key = options.key ?? bing;
    options.layer = options.layer ?? Cesium__namespace.BingMapsStyle.Aerial;

    options = converOptions(options);
    return new Cesium__namespace.BingMapsImageryProvider({
      mapStyle: options.layer,
      ...options
    })
  }
  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  BingLayer.createImageryProvider = createImageryProvider$f;

  // 注册下
  const layerType$f = "bing"; // 图层类型
  register$2(layerType$f, BingLayer);
  registerImageryProvider(layerType$f, createImageryProvider$f);

  /**
   * 高德
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.layer] 图层类型，以及以下内容:<br />
   * <ul>
   *     <li><code>vec</code>: 电子图层</li>
   *     <li><code>img_d</code>: 卫星影像</li>
   *     <li><code>img_z</code>: 影像注记</li>
   *     <li><code>time</code>: 实时路况信息</li>
   * </ul>
   * @param {String} [options.url] 当未指定layer类型时，可以传入外部指定url的服务地址，常用于离线服务。
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   * @param {Boolean} [options.bigfont] 当layer为vec时，来标识使用是否大写字体。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {ChinaCRS} [options.chinaCRS=ChinaCRS.GCJ02] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则 {@link UrlTemplateImageryProvider#pickFeatures} 请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
   *        如果为 false{@link UrlTemplateImageryProvider#pickFeatures} 会立即返回未定义（表示没有可拾取的内容） 功能）而无需与服务器通信。如果您知道数据，则将此属性设置为false 源不支持选择功能，或者您不希望该提供程序的功能可供选择。注意 可以通过修改 {@link UriTemplateImageryProvider#enablePickFeatures}来动态覆盖 属性。
   * @param {Cesium.GetFeatureInfoFormat[]} [options.getFeatureInfoFormats] 在某处获取功能信息的格式 调用 {@link UrlTemplateImageryProvider#pickFeatures} 的特定位置。如果这 参数未指定，功能选择已禁用。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   *
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   */
  class GaodeLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$e(options)
    }
  }
  function createImageryProvider$e(options) {
    options.chinaCRS = options.chinaCRS || ChinaCRS.GCJ02;
    options = converOptions(options);
    return new GaodeImageryProvider(options)
  }
  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  GaodeLayer.createImageryProvider = createImageryProvider$e;

  // 注册下
  const layerType$e = "gaode"; // 图层类型
  register$2(layerType$e, GaodeLayer);
  registerImageryProvider(layerType$e, createImageryProvider$e);

  /**
   * GoogleEarth Enterprise企业版本 影像服务
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Resource|String} options.url  承载瓦片服务的谷歌地球企业服务器的url
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则 {@link UrlTemplateImageryProvider#pickFeatures} 请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
   *        如果为 false{@link UrlTemplateImageryProvider#pickFeatures} 会立即返回未定义（表示没有可拾取的内容） 功能）而无需与服务器通信。如果您知道数据，则将此属性设置为false 源不支持选择功能，或者您不希望该提供程序的功能可供选择。注意 可以通过修改 {@link UriTemplateImageryProvider#enablePickFeatures}来动态覆盖 属性。
   * @param {Cesium.GetFeatureInfoFormat[]} [options.getFeatureInfoFormats] 在某处获取功能信息的格式 调用 {@link UrlTemplateImageryProvider#pickFeatures} 的特定位置。如果这 参数未指定，功能选择已禁用。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   * @see Cesium.GoogleEarthEnterpriseImageryProvider
   */
  class GeeLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$d(options)
    }
  }

  function createImageryProvider$d(options) {
    options = converOptions(options);

    return new Cesium__namespace.GoogleEarthEnterpriseImageryProvider({
      ...options,
      metadata: new Cesium__namespace.GoogleEarthEnterpriseMetadata(options.url)
    })
  }
  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  GeeLayer.createImageryProvider = createImageryProvider$d;

  // 注册下
  const layerType$d = "gee"; // 图层类型
  register$2(layerType$d, GeeLayer);
  registerImageryProvider(layerType$d, createImageryProvider$d);

  /**
   * 谷歌
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.layer] 图层类型，以及以下内容:<br />
   * <ul>
   *     <li><code>vec</code>: 电子图层</li>
   *     <li><code>img_d</code>: 卫星影像</li>
   *     <li><code>img_z</code>: 影像注记</li>
   *     <li><code>ter</code>: 地形渲染图</li>
   * </ul>
   * @param {String} [options.url] 当未指定layer类型时，可以传入外部指定url的服务地址，常用于离线服务。
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS='GCJ02'] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则 {@link UrlTemplateImageryProvider#pickFeatures} 请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
   *        如果为 false{@link UrlTemplateImageryProvider#pickFeatures} 会立即返回未定义（表示没有可拾取的内容） 功能）而无需与服务器通信。如果您知道数据，则将此属性设置为false 源不支持选择功能，或者您不希望该提供程序的功能可供选择。注意 可以通过修改 {@link UriTemplateImageryProvider#enablePickFeatures}来动态覆盖 属性。
   * @param {Cesium.GetFeatureInfoFormat[]} [options.getFeatureInfoFormats] 在某处获取功能信息的格式 调用 {@link UrlTemplateImageryProvider#pickFeatures} 的特定位置。如果这 参数未指定，功能选择已禁用。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   */
  class GoogleLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$c(options)
    }
  }
  function createImageryProvider$c(options) {
    options.chinaCRS = options.chinaCRS || ChinaCRS.GCJ02;
    options = converOptions(options);
    return new GoogleImageryProvider(options)
  }

  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  GoogleLayer.createImageryProvider = createImageryProvider$c;

  // 注册下
  const layerType$c = "google"; // 图层类型
  register$2(layerType$c, GoogleLayer);
  registerImageryProvider(layerType$c, createImageryProvider$c);

  /**
   * 单张图片图层
   *
   * @param {Object} [options] 参数对象，包括以下：
   *
   * @param {Cesium.Resource|String} options.url 图片url地址
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.SingleTileImageryProvider
   */
  class ImageLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$b(options)
    }
  }

  function createImageryProvider$b(options) {
    options = converOptions(options);
    return new Cesium__namespace.SingleTileImageryProvider(options)
  }
  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  ImageLayer.createImageryProvider = createImageryProvider$b;

  // 注册下
  const layerType$b = "image"; // 图层类型
  register$2(layerType$b, ImageLayer);
  registerImageryProvider(layerType$b, createImageryProvider$b);

  /**
   * cesium ion资源地图，官网： {@link https://cesium.com/ion/signin/}
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Number} options.assetId ION服务 assetId
   * @param {String} [options.accessToken=mars3d.Token.ion] ION服务 token令牌
   * @param {String|Cesium.Resource} [options.server=Ion.defaultServer] Cesium ion API服务器的资源。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则 {@link UrlTemplateImageryProvider#pickFeatures} 请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
   *        如果为 false{@link UrlTemplateImageryProvider#pickFeatures} 会立即返回未定义（表示没有可拾取的内容） 功能）而无需与服务器通信。如果您知道数据，则将此属性设置为false 源不支持选择功能，或者您不希望该提供程序的功能可供选择。注意 可以通过修改 {@link UriTemplateImageryProvider#enablePickFeatures}来动态覆盖 属性。
   * @param {Cesium.GetFeatureInfoFormat[]} [options.getFeatureInfoFormats] 在某处获取功能信息的格式 调用 {@link UrlTemplateImageryProvider#pickFeatures} 的特定位置。如果这 参数未指定，功能选择已禁用。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   * @see Cesium.IonImageryProvider
   */
  class IonLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$a(options)
    }
  }

  function createImageryProvider$a(options) {
    options.accessToken = options.accessToken ?? ion;

    options = converOptions(options);
    return new Cesium__namespace.IonImageryProvider(options)
  }

  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  IonLayer.createImageryProvider = createImageryProvider$a;

  // 注册下
  const layerType$a = "ion"; // 图层类型
  register$2(layerType$a, IonLayer);
  registerImageryProvider(layerType$a, createImageryProvider$a);

  /**
   * Mapbox地图服务
   *
   * @param {Object} [options] 参数对象，包括以下：
   *
   * @param {Cesium.Resource|String} [options.url='https://api.mapbox.com/styles/v1/'] Mapbox服务器网址。
   * @param {String} [options.username='marsgis'] 地图帐户的用户名。
   * @param {String} options.styleId Mapbox样式ID。
   * @param {String} [options.accessToken=mars3d.Token.mapbox] 图像的Token公共访问令牌。
   * @param {Number} [options.tilesize=512] 图像块的大小。
   * @param {Boolean} [options.scaleFactor=true] 确定贴图是否以 @2x 比例因子渲染。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则 {@link UrlTemplateImageryProvider#pickFeatures} 请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
   *        如果为 false{@link UrlTemplateImageryProvider#pickFeatures} 会立即返回未定义（表示没有可拾取的内容） 功能）而无需与服务器通信。如果您知道数据，则将此属性设置为false 源不支持选择功能，或者您不希望该提供程序的功能可供选择。注意 可以通过修改 {@link UriTemplateImageryProvider#enablePickFeatures}来动态覆盖 属性。
   * @param {Cesium.GetFeatureInfoFormat[]} [options.getFeatureInfoFormats] 在某处获取功能信息的格式 调用 {@link UrlTemplateImageryProvider#pickFeatures} 的特定位置。如果这 参数未指定，功能选择已禁用。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   * @see Cesium.MapboxStyleImageryProvider
   */
  class MapboxLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$9(options)
    }
  }

  function createImageryProvider$9(options) {
    // 参考：https://docs.mapbox.com/api/maps/#request-embeddable-html
    options.url = options.url ?? "https://api.mapbox.com/styles/v1";
    options.username = options.username ?? "marsgis";
    options.accessToken = options.accessToken ?? mapbox;
    options.scaleFactor = options.scaleFactor ?? true;

    options = converOptions(options);
    const provider = new Cesium__namespace.MapboxStyleImageryProvider(options);
    Promise.resolve(options).then(function (properties) {
      if (options.tilingScheme) {
        provider._imageryProvider._tilingScheme = options.tilingScheme;
      }
    });
    return provider
  }
  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  MapboxLayer.createImageryProvider = createImageryProvider$9;

  // 注册下
  const layerType$9 = "mapbox"; // 图层类型
  register$2(layerType$9, MapboxLayer);
  registerImageryProvider(layerType$9, createImageryProvider$9);

  /**
   * OSM开源地图
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Resource|String} [options.url='https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'] 服务url地址
   * @param {String|String[]} [options.subdomains='abc'] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel=18] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   */
  class OsmLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$8(options)
    }
  }

  function createImageryProvider$8(options) {
    options = converOptions(options);
    return new OsmImageryProvider(options)
  }
  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  OsmLayer.createImageryProvider = createImageryProvider$8;

  // 注册下
  const layerType$8 = "osm"; // 图层类型
  register$2(layerType$8, OsmLayer);
  registerImageryProvider(layerType$8, createImageryProvider$8);

  // 标准XYZ地图
  class XyzImageryProvider extends Cesium__namespace.UrlTemplateImageryProvider {
    constructor(options = {}) {
      options.customTags = options.customTags || {};

      // 对同域的一些url的支持
      options.customTags.host = function (imageryProvider, x, y, level) {
        return location.host
      };
      options.customTags.hostname = function (imageryProvider, x, y, level) {
        return location.hostname
      };

      // 对EPSG:4490支持
      options.customTags.z4490 = function (imageryProvider, x, y, level) {
        return level + 1
      };

      super(options);
      this.options = options;
    }
  }

  /**
   * 天地图
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.layer] 图层类型，以及以下内容:<br />
   * <ul>
   *     <li><code>vec_d</code>: 电子图层</li>
   *     <li><code>vec_z</code>: 电子注记</li>
   *     <li><code>vec_e</code>: 电子注记英文</li>
   *     <li><code>img_d</code>: 卫星影像</li>
   *     <li><code>img_z</code>: 影像注记</li>
   *     <li><code>img_e</code>: 影像注记英文</li>
   *     <li><code>ter_d</code>: 地形渲染图</li>
   *     <li><code>ter_z</code>: 地形渲染图注记</li>
   * </ul>
   * @param {String[]} [options.key=mars3d.Token.tiandituArr] 天地图服务Token，可以自行注册官网： {@link https://console.tianditu.gov.cn/api/key}
   *
   * @param {String} [options.url] 服务URL地址，同xyz服务
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影,也支持传入EPSG4490坐标系
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   * @param {String|String[]} [options.subdomains='01234567'] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   */
  class TdtLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$7(options)
    }
  }

  function createImageryProvider$7(options) {
    options = converOptions(options);
    if (options.url) {
      options.subdomains = options.subdomains || "01234567";
      options.url += "&tk=" + (options.key || tianditu);
      return new XyzImageryProvider(options)
    } else {
      return new TdtImageryProvider(options)
    }
  }

  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  TdtLayer.createImageryProvider = createImageryProvider$7;

  // 注册下
  const layerType$7 = "tdt"; // 图层类型
  register$2(layerType$7, TdtLayer);
  registerImageryProvider(layerType$7, createImageryProvider$7);

  /**
   * 腾讯
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.layer] 图层类型，以及以下内容:<br />
   * <ul>
   *     <li><code>vec</code>: 电子图层</li>
   *     <li><code>img_d</code>: 卫星影像</li>
   *     <li><code>img_z</code>: 影像注记</li>
   *     <li><code>custom</code>: 地形渲染图</li>
   * </ul>
   * @param {String} [options.style] 当layer为custom时，标识的样式，可选值：灰白地图:3,暗色地图:4
   * @param {String} [options.url] 当未指定layer类型时，可以传入外部指定url的服务地址，常用于离线服务。
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是一个数组，数组中的每个元素都是一个子域。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {ChinaCRS} [options.chinaCRS=ChinaCRS.GCJ02] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   */
  class TencentLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$6(options)
    }
  }

  function createImageryProvider$6(options) {
    options.chinaCRS = options.chinaCRS || ChinaCRS.GCJ02;
    options = converOptions(options);
    return new TencentImageryProvider(options)
  }
  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  TencentLayer.createImageryProvider = createImageryProvider$6;

  // 注册下
  const layerType$6 = "tencent"; // 图层类型
  register$2(layerType$6, TencentLayer);
  registerImageryProvider(layerType$6, createImageryProvider$6);

  /**
   * TMS服务，比如由MapTiler，GDAL2Tiles等生成的切片图像的加载。
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Resource|String|Promise<Cesium.Resource>|Promise<String>} [options.url] 服务地址
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   * @param {String} [options.fileExtension='png'] 服务器上图像的文件扩展名。
   * @param {Boolean} [options.flipXY] gdal2tiles.py的旧版本将tilemapresource.xml中的X和Y值翻转了。指定此选项将执行相同的操作，从而允许加载这些不正确的图块集。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则 {@link UrlTemplateImageryProvider#pickFeatures} 请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
   *        如果为 false{@link UrlTemplateImageryProvider#pickFeatures} 会立即返回未定义（表示没有可拾取的内容） 功能）而无需与服务器通信。如果您知道数据，则将此属性设置为false 源不支持选择功能，或者您不希望该提供程序的功能可供选择。注意 可以通过修改 {@link UriTemplateImageryProvider#enablePickFeatures}来动态覆盖 属性。
   * @param {Cesium.GetFeatureInfoFormat[]} [options.getFeatureInfoFormats] 在某处获取功能信息的格式 调用 {@link UrlTemplateImageryProvider#pickFeatures} 的特定位置。如果这 参数未指定，功能选择已禁用。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   * @see Cesium.TileMapServiceImageryProvider
   */
  class TmsLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$5(options)
    }
  }

  function createImageryProvider$5(options) {
    options = converOptions(options);

    if (!options.url) {
      options.url = Cesium__namespace.buildModuleUrl("Assets/Textures/NaturalEarthII");
    }
    return new Cesium__namespace.TileMapServiceImageryProvider(options)
  }
  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  TmsLayer.createImageryProvider = createImageryProvider$5;

  // 注册下
  const layerType$5 = "tms"; // 图层类型
  register$2(layerType$5, TmsLayer);
  registerImageryProvider(layerType$5, createImageryProvider$5);

  /**
   * WMS服务
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Resource|String} options.url WMS服务的URL。
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   * @param {String} options.layers 要包含的图层，用逗号分隔。
   * @param {Object} [options.parameters=Cesium.WebMapServiceImageryProvider.DefaultParameters] 要在URL中 传递给[WMS服务]{@link https://docs.geoserver.org/stable/en/user/services/wms/index.html}GetMap请求的其他参数。
   * @param {String} [options.parameters.format='image/jpeg'] 瓦片格式
   * @param {Boolean} [options.parameters.transparent] 是否透明
   * @param {String} [options.parameters.cql_filter] 筛选服务数据的SQL语句
   * @param {String} [options.parameters.service='WMS'] 服务类型
   * @param {String} [options.parameters.version='1.1.1'] 服务版本
   * @param {String} [options.parameters.request='GetMap'] 请求方法
   * @param {String} [options.parameters.styles=''] 样式
   * @param {String|CRS} [options.crs='EPSG:3857'] 瓦片数据的坐标系信息，默认为墨卡托投影，CRS规范，用于WMS规范>= 1.3.0。
   * @param {String} [options.srs] SRS规范，与WMS规范1.1.0或1.1.1一起使用
   * @param {Boolean} [options.getCapabilities=true] 是否通过服务本身的GetCapabilities来读取一些参数，减少options配置项
   * @param {Cesium.Clock} [options.clock] 一个时钟实例，用于确定时间维度的值。指定' times '时需要。
   * @param {Cesium.TimeIntervalCollection} [options.times] TimeIntervalCollection 的数据属性是一个包含时间动态维度及其值的对象。
   *
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则请求 单击坐标处服务中对应的矢量数据 并尝试解释响应中包含的功能。为false时不去服务请求。
   * @param {Function} [options.featureToGraphic=mars3d.Util.geoJsonToGraphics] 解析单击返回的矢量数据信息为Graphic构造参数，可以按需自定义。
   * @param {Number|Boolean|Function} [options.hasToGraphic] 筛选或判断是否解析，单击获取到的数据进行按需筛选解析，大数据解析很卡，可以设定阀值屏蔽大数据，避免卡顿，Number类型时代表字符串长度值。
   * @param {Object} [options.getFeatureInfoParameters] 在单击坐标处通过GetFeatureInfo请求接口时,传递给WMS服务器的附加参数。
   *
   * @param {Object} [options.highlight] 鼠标单击高亮显示对应的矢量数据 及其样式，包括type参数指定构造的类型，其他参数见各{@link GraphicType}矢量数据的style参数项。
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360allowPick
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   * @see Cesium.WebMapServiceImageryProvider
   */
  class WmsLayer extends BaseTileLayer {
    _addedHook() {
      if (Cesium__namespace.defaultValue(this.options.getCapabilities, true)) {
        this.getMetadata().then((data) => {
          if (this.isAdded) {
            super._addedHook();
          }
        });
      } else {
        super._addedHook();
      }
    }

    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$4(options)
    }

    // 读取配置信息
    getMetadata() {
      return new Promise((resolve, reject) => {
        if (this.capabilities) {
          resolve(this.capabilities);
          return
        }

        // 请求的wms参数
        const parameters = {
          service: "WMS",
          request: "GetCapabilities",
          version: "1.3.0"
        };

        let url = this.options.url;
        if (this.options.templateValues) {
          url = template(url, this.options.templateValues);
        }
        Cesium__namespace.Resource.fetchXML({
          ...this.options,
          url: url,
          queryParameters: parameters,
          proxy: this._proxy
        })
          .then((data) => {
            if (this.isDestroy) {
              return
            }

            if (data) {
              this.capabilities = data;
              try {
                this._initByMetaData(data);
              } catch (e) {
                logInfo("WMS 解析GetCapabilities有误", e);
              }
            }
            resolve(data);
            this.fire(EventType.loadConfig, { capabilities: data });
          })
          .catch((error) => {
            logInfo("WMS getMetadata请求出错", error);
            resolve(error);
          });
      })
    }

    // 根据服务配置信息，加一些处理
    _initByMetaData(data) {
      let layerName = this.options.layers;
      if (layerName.indexOf(":") !== -1) {
        layerName = layerName.split(":")[1];
      }

      const contents = this._readChildNode(data, "Layer");
      const layers = contents.getElementsByTagName("Layer");
      for (let i = 0, len = layers.length; i < len; i++) {
        const item = layers[i];
        const currName = this._readChildNodeVal(item, "Name");
        if (currName === layerName) {
          const crs = this._readChildNodeVal(item, "CRS");
          if (!this.options.crs && crs) {
            this.options.crs = crs;
          }

          const bbox = this._readChildNode(item, "BoundingBox");
          if (!this.options.rectangle && bbox) {
            const xmin = Number(bbox.getAttribute("minx"));
            const ymin = Number(bbox.getAttribute("miny"));
            const xmax = Number(bbox.getAttribute("maxx"));
            const ymax = Number(bbox.getAttribute("maxy"));
            const _extent = { xmin: xmin, ymin: ymin, xmax: xmax, ymax: ymax };

            this.options.extent = _extent;
            this._rectangle = Cesium__namespace.Rectangle.fromDegrees(_extent.xmin, _extent.ymin, _extent.xmax, _extent.ymax);
          }
          break
        }
      }
    }

    _readChildNode(node, tagName) {
      const tagChildNodes = node.getElementsByTagName(tagName);
      if (tagChildNodes.length > 0) {
        return tagChildNodes[0]
      } else {
        return null
      }
    }

    _readChildNodeVal(node, tagName) {
      const childNode = this._readChildNode(node, tagName);
      if (childNode?.innerHTML) {
        return childNode.innerHTML
      } else if (childNode?.getInnerHTML) {
        return childNode.getInnerHTML()
      } else {
        return null
      }
    }

    //= ============= popup ======================

    /**
     *  是否存在Popup绑定
     * @return {Boolean} 是否存在Popup绑定
     */
    hasPopup() {
      if (this._popupConfig) {
        return true
      }
      return false
    }

    /**
     * 绑定鼠标单击对象后的弹窗。
     *
     * @param {String|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Popup.StyleOptions} [options] 控制参数
     * @return {WmsLayer} 当前对象本身，可以链式调用
     *
     */
    bindPopup(content, options) {
      this._popupConfig = {
        content: content,
        options: options,
        layer: this
      };
      this._bindControl();
      return this
    }

    /**
     * 解除绑定的鼠标单击对象后的弹窗。
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    unbindPopup() {
      this.closePopup();
      this._popupConfig = null;
      return this
    }

    /**
     * 关闭弹窗
     *
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    closePopup() {
      if (this._map && this.hasPopup()) {
        this._map.popup.close(null, this);
      }
      return this
    }
  }

  function createImageryProvider$4(options) {
    options = converOptions(options);
    return new Cesium__namespace.WebMapServiceImageryProvider(options)
  }
  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  WmsLayer.createImageryProvider = createImageryProvider$4;

  // 注册下
  const layerType$4 = "wms"; // 图层类型
  register$2(layerType$4, WmsLayer);
  registerImageryProvider(layerType$4, createImageryProvider$4);

  /**
   * WMTS服务
   *
   * @param {Object} [options] 参数对象，包括以下：
   *
   * @param {Cesium.Resource|String} options.url WMTS GetTile操作(用于kvp编码的请求)或tile-URL模板(用于RESTful请求)的基本URL。tile-URL模板应该包含以下变量:&#123;style&#125;, &#123;TileMatrixSet&#125;, &#123;TileMatrix&#125;, &#123;TileRow&#125;, &#123;TileCol&#125; 前两个是可选的，如果实际值是硬编码的或者服务器不需要。 &#123;s&#125;关键字可用于指定子域。
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是 一个数组，数组中的每个元素都是一个子域。
   * @param {String} [options.format='image/jpeg'] 要从服务器检索的瓦片图像的MIME类型。
   * @param {String} options.layer WMTS请求的层名。
   * @param {String} options.style WMTS请求的样式名称。
   * @param {String} options.tileMatrixSetID 用于WMTS请求的TileMatrixSet的标识符。
   * @param {String[]} [options.tileMatrixLabels] 瓦片矩阵中用于WMTS请求的标识符列表，每个瓦片矩阵级别一个。
   *
   * @param {Cesium.Clock} [options.clock] 一个时钟实例，用于确定时间维度的值。指定' times '时需要。
   * @param {Cesium.TimeIntervalCollection} [options.times] TimeIntervalCollection 的数据属性是一个包含时间动态维度及其值的对象。
   * @param {Boolean} [options.getCapabilities=true] 是否通过服务本身的GetCapabilities来读取一些参数，减少options配置项
   *
   * @param {Boolean} [options.enablePickFeatures=false] 如果为true，则请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
   * @param {Cesium.Resource|String} [options.pickFeaturesUrl] enablePickFeatures为true时，用于单击查看矢量对象功能的对应wms服务url。
   * @param {Object} [options.getFeatureInfoParameters] 在单击坐标处通过GetFeatureInfo请求接口时,传递给WMS服务器的附加参数。
   * @param {Function} [options.pickFeatures]  外部自定义单击请求对应矢量数据的处理。与pickFeaturesUrl二选一
   *
   * @param {Object} [options.highlight] 鼠标单击高亮显示对应的矢量数据 及其样式，具体见各{@link GraphicType}矢量数据的style参数。
   * @param {GraphicType|String} [options.highlight.type] 构造成的矢量数据类型。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   * @see Cesium.WebMapTileServiceImageryProvider
   */
  class WmtsLayer extends BaseTileLayer {
    _addedHook() {
      if (this.options.getCapabilities ?? true) {
        this.getMetadata().then((data) => {
          if (this.isAdded) {
            super._addedHook();
          }
        });
      } else {
        super._addedHook();
      }
    }

    // 构建ImageryProvider
    _createImageryProvider(options) {
      const imageryProvider = createImageryProvider$3(options);
      if (options.pickFeatures) {
        imageryProvider.pickFeatures = options.pickFeatures;
      } else if (options.pickFeaturesUrl) {
        imageryProvider.pickFeatures = (x, y, level, longitude, latitude) => {
          return this.pickFeatures(x, y, level, longitude, latitude)
        };
      }
      return imageryProvider
    }

    // 单击图上点去查询对应矢量数据
    pickFeatures(x, y, level, longitude, latitude) {
      if (!this.options.enablePickFeatures) {
        return undefined
      }

      const imageryProvider = this.imageryProvider;
      const longitudeLatitudeProjectedScratch = new Cesium__namespace.Cartesian3();
      if (imageryProvider.tilingScheme.projection instanceof Cesium__namespace.GeographicProjection) {
        longitudeLatitudeProjectedScratch.x = Cesium__namespace.Math.toDegrees(longitude);
        longitudeLatitudeProjectedScratch.y = Cesium__namespace.Math.toDegrees(latitude);
      } else {
        const cartographic = new Cesium__namespace.Cartographic();
        cartographic.longitude = longitude;
        cartographic.latitude = latitude;
        imageryProvider.tilingScheme.projection.project(cartographic, longitudeLatitudeProjectedScratch);
      }

      const ijScratch = new Cesium__namespace.Cartesian2();
      const rectangle = imageryProvider.tilingScheme.tileXYToNativeRectangle(x, y, level, new Cesium__namespace.Rectangle());
      ijScratch.x = ((imageryProvider.tileWidth * (longitudeLatitudeProjectedScratch.x - rectangle.west)) / rectangle.width) | 0;
      ijScratch.y = ((imageryProvider.tileHeight * (rectangle.north - longitudeLatitudeProjectedScratch.y)) / rectangle.height) | 0;

      // 请求的wms参数
      const parameters = {
        ...(this.options.getFeatureInfoParameters || {}),
        service: "WMS",
        version: "1.1.1",
        request: "GetFeatureInfo",
        layers: this.options.layer,
        query_layers: this.options.layer,
        info_format: "application/json",
        srs: this.options.crs ?? (this.options.tilingScheme?.projection instanceof Cesium__namespace.WebMercatorProjection ? "EPSG:3857" : "EPSG:4326"),
        bbox: `${rectangle.west},${rectangle.south},${rectangle.east},${rectangle.north}`,
        width: imageryProvider.tileWidth,
        height: imageryProvider.tileHeight,
        x: ijScratch.x,
        y: ijScratch.y
      };

      return fetchJson({
        ...this.options,
        url: this.options.pickFeaturesUrl,
        queryParameters: parameters,
        proxy: this._proxy
      }).then((json) => {
        const result = [];
        const features = json.features;
        for (let i = 0; i < features.length; ++i) {
          const feature = features[i];

          const featureInfo = new Cesium__namespace.ImageryLayerFeatureInfo();
          featureInfo.data = feature;
          featureInfo.properties = feature.properties;
          featureInfo.configureNameFromProperties(feature.properties);
          featureInfo.configureDescriptionFromProperties(feature.properties);

          // If this is a point feature, use the coordinates of the point.
          if (Cesium__namespace.defined(feature.geometry) && feature.geometry.type === "Point") {
            const longitude = feature.geometry.coordinates[0];
            const latitude = feature.geometry.coordinates[1];
            featureInfo.position = Cesium__namespace.Cartographic.fromDegrees(longitude, latitude);
          }

          result.push(featureInfo);
        }
        return result
      })
    }

    // 读取配置信息
    getMetadata() {
      return new Promise((resolve, reject) => {
        if (this.capabilities) {
          resolve(this.capabilities);
          return
        }
        // 请求的wfs参数
        const parameters = {
          service: "WMTS",
          request: "GetCapabilities",
          version: "1.0.0"
        };

        Cesium__namespace.Resource.fetchXML({
          ...this.options,
          queryParameters: parameters,
          proxy: this._proxy
        })
          .then((data) => {
            if (this.isDestroy) {
              return
            }

            if (data) {
              this.capabilities = data;
              try {
                this._initByMetaData(data);
              } catch (e) {
                logInfo("解析GetCapabilities出错", e);
              }
            }

            resolve(data);
            this.fire(EventType.loadConfig, { capabilities: data });
          })
          .catch((error) => {
            logInfo("WMTS GetCapabilities请求出错", error);
            resolve(error);
          });
      })
    }

    // 根据服务配置信息，加一些处理
    _initByMetaData(data) {
      const contents = this._readChildNode(data, "Contents");
      const layers = contents.getElementsByTagName("Layer");
      for (let i = 0, len = layers.length; i < len; i++) {
        const item = layers[i];
        const layerName = this._readChildNodeVal(item, "ows:Identifier");
        if (layerName === this.options.layer) {
          const bbox = this._readChildNode(item, "ows:WGS84BoundingBox");
          if (!this.options.rectangle && bbox) {
            let lower = this._readChildNodeVal(bbox, "ows:LowerCorner");
            let upper = this._readChildNodeVal(bbox, "ows:UpperCorner");
            if (lower && upper) {
              lower = lower.split(" ");
              upper = upper.split(" ");

              const xmin = Number(lower[0]);
              const ymin = Number(lower[1]);
              const xmax = Number(upper[0]);
              const ymax = Number(upper[1]);
              const _extent = { xmin: xmin, ymin: ymin, xmax: xmax, ymax: ymax };
              this.options.extent = _extent;
              this._rectangle = Cesium__namespace.Rectangle.fromDegrees(_extent.xmin, _extent.ymin, _extent.xmax, _extent.ymax);
            }
          }

          if (!Cesium__namespace.defined(this.options.style)) {
            this.options.style = this._readChildNodeVal(this._readChildNode(item, "Style"), "ows:Identifier");
          }

          const TileMatrixSetLink = item.getElementsByTagName("TileMatrixSetLink");

          for (let j = 0, len = TileMatrixSetLink.length; j < len; j++) {
            const tileMatrixSet = TileMatrixSetLink[j];
            const tileMatrixSetID = this._readChildNodeVal(tileMatrixSet, "TileMatrixSet");

            if (!Cesium__namespace.defined(this.options.tileMatrixSetID)) {
              this.options.tileMatrixSetID = tileMatrixSetID; // 默认就使用第0个
            }

            if (tileMatrixSetID === this.options.tileMatrixSetID) {
              if (!this.options.tileMatrixLabels) {
                const tileMatrixSetLimits = this._readChildNode(tileMatrixSet, "TileMatrixSetLimits");
                const tileMatrixList = tileMatrixSetLimits.getElementsByTagName("TileMatrixLimits");
                const tileMatrixLabels = [];
                for (let k = 0, len = tileMatrixList.length; k < len; k++) {
                  const tileMatrix = this._readChildNodeVal(tileMatrixList[k], "TileMatrix");
                  tileMatrixLabels.push(tileMatrix);
                }
                this.options.tileMatrixLabels = tileMatrixLabels;
              }
              break
            }
          }
          break
        }
      }
    }

    _readChildNode(node, tagName) {
      if (!node) {
        return null
      }
      const tagChildNodes = node.getElementsByTagName(tagName);
      if (tagChildNodes.length > 0) {
        return tagChildNodes[0]
      } else {
        return null
      }
    }

    _readChildNodeVal(node, tagName) {
      if (!node) {
        return null
      }

      const childNode = this._readChildNode(node, tagName);
      if (childNode?.innerHTML) {
        return childNode.innerHTML
      } else if (childNode?.getInnerHTML) {
        return childNode.getInnerHTML()
      } else {
        return null
      }
    }
  }

  function createImageryProvider$3(options) {
    options = converOptions(options);

    if (options.crs === CRS.EPSG4490) {
      options.tileMatrixLabels = [...Array(20).keys()].map((level) => (level + 1).toString());
    }
    return new Cesium__namespace.WebMapTileServiceImageryProvider(options)
  }
  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  WmtsLayer.createImageryProvider = createImageryProvider$3;

  // 注册下
  const layerType$3 = "wmts"; // 图层类型
  register$2(layerType$3, WmtsLayer);
  registerImageryProvider(layerType$3, createImageryProvider$3);

  /**
   * 标准xyz金字塔
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Resource|String} options.url  用于请求瓦片图块的URL模板。它具有以下关键字:
   * <ul>
   *     <li><code>{z}</code>: 切片方案中切片的级别。零级是四叉树金字塔的根。</li>
   *     <li><code>{x}</code>:切片方案中的图块X坐标，其中0是最西端的图块。</li>
   *     <li><code>{y}</code>: 切片方案中的图块Y坐标，其中0是最北的图块。</li>
   *     <li><code>{s}</code>:可用的子域之一，用于克服浏览器对每个主机的并发请求数的限制。</li>
   *     <li><code>{reverseX}</code>: 切片方案中的图块X坐标，其中0是最东的图块。</li>
   *     <li><code>{reverseY}</code>:切片方案中的图块Y坐标，其中0是最南端的图块,用于TMS服务。</li>
   *     <li><code>{reverseZ}</code>:在切片方案中切片的级别，其中级别0是四叉树金字塔的最大级别。为了使用reverseZ，必须定义maximumLevel。</li>
   *     <li><code>{westDegrees}</code>: 瓦片图块在测地角度上的西边缘。</li>
   *     <li><code>{southDegrees}</code>:瓦片图块在测地角度上的南边缘。</li>
   *     <li><code>{eastDegrees}</code>:以大地测量度表示的图块的东边缘。</li>
   *     <li><code>{northDegrees}</code>: 瓦片图块在测地角度上的北边缘。</li>
   *     <li><code>{westProjected}</code>:图块方案的墨卡托投影坐标中图块的西边缘。</li>
   *     <li><code>{southProjected}</code>: 图块方案的墨卡托投影坐标中图块的南边缘。</li>
   *     <li><code>{eastProjected}</code>: :图块方案的墨卡托投影坐标中图块的东边缘。</li>
   *     <li><code>{northProjected}</code>:图块方案的墨卡托投影坐标中图块的北边缘。</li>
   *     <li><code>{width}</code>:每个图块的宽度（以像素为单位）。</li>
   *     <li><code>{height}</code>: 每个图块的高度（以像素为单位）。</li>
   * </ul>
   * @param {Object} [options.urlSchemeZeroPadding] 为每个图块坐标获取URL方案零填充。格式为' 000'，其中每个坐标将在左侧用零填充，以匹配传递的零字符串的宽度。例如设置:
   * urlSchemeZeroPadding:{'{x}':'0000'}将导致'x'值为12，以在生成的URL中返回{x}的字符串'0012'。传递的对象具有以下关键字:
   * <ul>
   *  <li> <code>{z}</code>: 切片方案中图块级别的零填充。</li>
   *  <li> <code>{x}</code>: 切片方案中图块X坐标的零填充。</li>
   *  <li> <code>{y}</code>: 切片方案中图块Y坐标的零填充。</li>
   *  <li> <code>{reverseX}</code>: 在平铺方案中图块reverseX坐标的零填充。</li>
   *  <li> <code>{reverseY}</code>: 在切片方案中，图块反向Y坐标的零填充,用于TMS服务。</li>
   *  <li> <code>{reverseZ}</code>: 在切片方案中，图块的reverseZ坐标的零填充。</li>
   * </ul>
   * @param {String|String[]} [options.subdomains] URL模板中用于 {s} 占位符的子域。 如果此参数是单个字符串，则字符串中的每个字符都是一个子域。如果是一个数组，数组中的每个元素都是一个子域。
   * @param {Boolean} [options.tms] 如果此值为true，反转切片Y轴的编号（对于TMS服务需可将将此项打开）
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'},
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' },
   *
   * @param {Boolean} [options.enablePickFeatures=true] 如果为true，则 {@link UrlTemplateImageryProvider#pickFeatures} 请求 pickFeaturesUrl 并尝试解释响应中包含的功能。
   *        如果为 false{@link UrlTemplateImageryProvider#pickFeatures} 会立即返回未定义（表示没有可拾取的内容） 功能）而无需与服务器通信。如果您知道数据，则将此属性设置为false 源不支持选择功能，或者您不希望该提供程序的功能可供选择。注意 可以通过修改 {@link UriTemplateImageryProvider#enablePickFeatures}来动态覆盖 属性。
   * @param {Cesium.Resource|String} [options.pickFeaturesUrl] 用于选择功能的URL模板。如果未指定此属性，
   *                 {@link Cesium.UrlTemplateImageryProvider#pickFeatures} 会立即返回undefined，表示没有 功能选择。
   *      网址模板支持 <code>url</code>参数支持的所有关键字参数，以及以下内容:
   * <ul>
   *     <li><code>{i}</code>: 所选位置的像素列（水平坐标），其中最西端的像素为0。</li>
   *     <li><code>{j}</code>: 所选位置的像素行（垂直坐标），其中最北端的像素为0。</li>
   *     <li><code>{reverseI}</code>: 所选位置的像素列（水平坐标），其中最东端的像素为0。</li>
   *     <li><code>{reverseJ}</code>: 所选位置的像素行（垂直坐标），其中最南端的像素为0。</li>
   *     <li><code>{longitudeDegrees}</code>: 所选位置的经度（以度为单位）。</li>
   *     <li><code>{latitudeDegrees}</code>: 所选位置的纬度（以度为单位）。</li>
   *     <li><code>{longitudeProjected}</code>:在平铺方案的投影坐标中所拾取位置的经度。</li>
   *     <li><code>{latitudeProjected}</code>: 在平铺方案的投影坐标中所拾取位置的纬度。</li>
   *     <li><code>{format}</code>: 获取功能信息的格式，如 {@link GetFeatureInfoFormat}中所指定。</li>
   * </ul>
   *  @param {Cesium.GetFeatureInfoFormat[]} [options.getFeatureInfoFormats] 在某处获取功能信息的格式 调用 {@link UrlTemplateImageryProvider#pickFeatures} 的特定位置。如果这 参数未指定，功能选择已禁用。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   * @param {Object} [options.customTags] 允许替换网址模板中的自定义关键字。该对象必须具有字符串作为键，并且必须具有值。
   *
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class XyzLayer
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   */
  class XyzLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$2(options)
    }
  }

  function createImageryProvider$2(options) {
    options = converOptions(options);
    return new XyzImageryProvider$1(options)
  }

  /**
   * 创建用于图层的 ImageryProvider对象
   *
   * @param {Object} options Provider参数，同图层构造参数。
   * @return {*} ImageryProvider类
   * @function
   */
  XyzLayer.createImageryProvider = createImageryProvider$2;

  // 注册下
  const layerType$2 = "xyz"; // 图层类型
  register$2(layerType$2, XyzLayer);
  registerImageryProvider(layerType$2, createImageryProvider$2);

  /**
   * 网格线
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Number} [options.cells=2] 网格单元格的数量。
   * @param {String} [options.color=rgba(255,255,255,1)] 绘制网格线的颜色。
   * @param {String} [options.glowColor=color.withAlpha(0.3)] 为网格线绘制渲染线发光效果的颜色。
   * @param {Number} [options.glowWidth=3] 用于渲染线发光效果的线的宽度。
   * @param {String} [options.backgroundColor='rgba(0,0,0,0)'] 背景填充颜色。
   * @param {Number} [options.canvasSize=256] 用于渲染的画布的大小。
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {CRS} [options.crs=CRS.EPSG:3857] 瓦片数据的坐标系信息，默认为墨卡托投影
   * @param {ChinaCRS} [options.chinaCRS] 标识瓦片的国内坐标系（用于自动纠偏或加偏），自动将瓦片转为map对应的chinaCRS类型坐标系。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   * @see Cesium.GridImageryProvider
   */
  class GridLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider$1(options)
    }
  }

  function createImageryProvider$1(options) {
    options.cells = options.cells ?? 2;
    options.color = Cesium__namespace.Color.fromCssColorString(options.color ?? "rgba(255,255,255,1)");
    options.glowWidth = options.glowWidth ?? 3;
    if (options.glowColor) {
      options.glowColor = Cesium__namespace.Color.fromCssColorString(options.glowColor);
    } else {
      options.glowColor = options.color.withAlpha(0.3);
    }
    options.backgroundColor = Cesium__namespace.Color.fromCssColorString(options.backgroundColor ?? "rgba(0,0,0,0)");

    options = converOptions(options);
    return new Cesium__namespace.GridImageryProvider(options)
  }
  GridLayer.createImageryProvider = createImageryProvider$1;

  // 注册下
  const layerType$1 = "grid"; // 图层类型
  register$2(layerType$1, GridLayer);
  registerImageryProvider(layerType$1, createImageryProvider$1);

  /**
   * 瓦片信息，一般用于测试
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.color=rgba(255,0,0,1)]  画瓦片边框线和标签的颜色
   *
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   *
   * @param {Number} [options.opacity = 1.0] 透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.alpha=1.0] 同opacity。
   * @param {Number|Function} [options.nightAlpha=1.0] 当 enableLighting 为 true 时 ，在地球的夜晚区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.dayAlpha=1.0]  当 enableLighting 为 true 时，在地球的白天区域的透明度，取值范围：0.0-1.0。
   * @param {Number|Function} [options.brightness=1.0] 亮度
   * @param {Number|Function} [options.contrast=1.0] 对比度。 1.0使用未修改的图像颜色，小于1.0会降低对比度，而大于1.0则会提高对比度。
   * @param {Number|Function} [options.hue=0.0] 色调。 0.0 时未修改的图像颜色。
   * @param {Number|Function} [options.saturation=1.0] 饱和度。 1.0使用未修改的图像颜色，小于1.0会降低饱和度，而大于1.0则会增加饱和度。
   * @param {Number|Function} [options.gamma=1.0] 伽马校正值。 1.0使用未修改的图像颜色。
   * @param {Boolean} [options.invertColor] 是否反向颜色，内部计算规则: color.r = 1.0 - color.r
   * @param {String|Cesium.Color} [options.filterColor] 滤镜颜色，内部计算规则: color.r = color.r * filterColor.r
   * @param {Number} [options.maximumAnisotropy=maximum supported] 使用的最大各向异性水平 用于纹理过滤。如果未指定此参数，则支持最大各向异性 将使用WebGL堆栈。较大的值可使影像在水平方向上看起来更好 视图。
   * @param {Cesium.Rectangle} [options.cutoutRectangle] 制图矩形，用于裁剪此ImageryLayer的一部分。
   * @param {Cesium.Color} [options.colorToAlpha]  用作Alpha的颜色。
   * @param {Number} [options.colorToAlphaThreshold=0.004] 颜色到Alpha的阈值。
   * @param {Boolean} [options.hasAlphaChannel=true] 如果此图像提供者提供的图像为真 包括一个Alpha通道；否则为假。如果此属性为false，则为Alpha通道，如果 目前，将被忽略。如果此属性为true，则任何没有Alpha通道的图像都将 它们的alpha随处可见。当此属性为false时，内存使用情况 和纹理上传时间可能会减少。
   * @param {Number} [options.tileWidth=256] 图像图块的像素宽度。
   * @param {Number} [options.tileHeight=256] 图像图块的像素高度。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @extends {BaseTileLayer}
   *
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   * @see Cesium.UrlTemplateImageryProvider
   * @see Cesium.TileCoordinatesImageryProvider
   */
  class TileInfoLayer extends BaseTileLayer {
    // 构建ImageryProvider
    _createImageryProvider(options) {
      return createImageryProvider(options)
    }
  }
  function createImageryProvider(options) {
    options.color = Cesium__namespace.Color.fromCssColorString(options.color || "rgba(255,0,0,1)");

    options = converOptions(options);
    return new Cesium__namespace.TileCoordinatesImageryProvider(options)
  }
  TileInfoLayer.createImageryProvider = createImageryProvider;

  // 注册下
  const layerType = "tileinfo"; // 图层类型
  register$2(layerType, TileInfoLayer);
  registerImageryProvider(layerType, createImageryProvider);

  /**
   * 空白图层，目前主要在Lod矢量数据加载作为事件触发使用。
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Number} [options.minimumLevel=0] 瓦片所支持的最低层级，如果数据没有第0层，该参数必须配置,当地图小于该级别时，平台不去请求服务数据。
   * @param {Number} [options.maximumLevel] 瓦片所支持的最大层级,大于该层级时会显示上一层拉伸后的瓦片，当地图大于该级别时，平台不去请求服务数据。
   * @param {Number} [options.minimumTerrainLevel] 展示影像图层的最小地形细节级别，小于该级别时，平台不显示影像数据。
   * @param {Number} [options.maximumTerrainLevel] 展示影像图层的最大地形细节级别，大于该级别时，平台不显示影像数据。
   * @param {Object} [options.rectangle] 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class EmptyTileLayer
   * @extends {BaseTileLayer}
   * @see [支持的事件类型]{@link BaseTileLayer.EventType}
   */
  class EmptyTileLayer extends BaseTileLayer {
    constructor(options = {}) {
      super(options);

      this._minimumLevel = options.minimumLevel ?? 0;
      this._maximumLevel = options.maximumLevel;
    }

    // 构建ImageryProvider
    _createImageryProvider(options) {
      options = converOptions(options);
      options.minimumTerrainLevel = this._minimumLevel;
      options.maximumTerrainLevel = this._maximumLevel;
      return new EmptyImageryProvider(options)
    }

    getMaxLevel() {
      let maxLevel = 0;
      for (const i in this._imageryLayer._imageryCache) {
        const imagery = this._imageryLayer._imageryCache[i];
        if (imagery.level > maxLevel) {
          maxLevel = imagery.level;
        }
      }
      return maxLevel
    }

    /**
     * 判断级别是否在当前图层的最大最小层级范围内
     * @param {Number} level 判断的级别
     * @return {Boolean} 是否在限定的范围内
     */
    isInRange(level) {
      const maxLevel = this.getMaxLevel();
      if (level < this._minimumLevel || level < maxLevel - 1 || (Cesium__namespace.defined(this._maximumLevel) && level >= this._maximumLevel)) {
        return false
      } else {
        return true
      }
    }

    /**
     * 判断所有瓦片 是否都在最大最小层级范围外，用于判断清除数据
     * @param {Number} level 判断的级别
     * @return {Boolean} 是否都在范围外
     */
    isAllOutRange(level) {
      const maxLevel = this.getMaxLevel();
      return maxLevel < this._minimumLevel || (Cesium__namespace.defined(this._maximumLevel) && level >= this._maximumLevel)
    }
  }

  new Cesium__namespace.Color(0.0, 0.0, 0.0, 0.01);

  // 根据config配置，更新entitys
  // 目前仅czml、kml、geojson 的 ceisum 原始加载方式用到
  function config2Entity(entities, config, lblAddFun) {
    for (let i = entities.length - 1; i >= 0; i--) {
      const entity = entities[i];

      // 样式
      const symbol = config.symbol;
      if (symbol) {
        if (typeof symbol === "function") {
          // 完全自定义的回调方法，自行处理entity
          symbol(entity, entity._attr);
        } else {
          setConfigSymbol(entity, config, lblAddFun);
        }
      }
    }

    return entities
  }

  function getStyleBySymbolConfig(symbol, attr, entity) {
    let styleOpt = symbol.styleOptions;

    if (symbol.styleField && attr) {
      // 存在多个symbol，按styleField进行分类
      const styleFieldVal = attr[symbol.styleField];
      const styleOptField = symbol.styleFieldOptions[styleFieldVal];
      if (styleOptField != null) {
        styleOpt = clone(styleOpt);
        styleOpt = { ...styleOpt, ...styleOptField };
      }
    }

    // 外部使用代码示例
    // var layerWork = map.getLayerById(301087)
    // layerWork.config.symbol.callback = function (attr, entity, styleOpt) {
    //     var val = attr.floor;
    //     if (val < 10)
    //         return { color: "#ff0000" };
    //     else
    //         return { color: "#0000ff" };
    // }
    if (typeof symbol.callback === "function") {
      // 只是动态返回symbol的自定义的回调方法，返回style
      styleOpt = clone(styleOpt);
      const styleOptField = symbol.callback(attr, entity, styleOpt);
      if (styleOptField) {
        styleOpt = { ...styleOpt, ...styleOptField };
      }
    }
    styleOpt = styleOpt || {};

    return styleOpt
  }

  // 外部配置的symbol
  function setConfigSymbol(entity, config, lblAddFun) {
    let attr = entity._attr;
    if (attr && attr.type && attr.attr) {
      // 兼容历史数据,V2内部标绘生产的geojson
      attr = attr.attr;
    }

    const entityCollection = entity.entityCollection; // entity原有的集合
    const styleOpt = getStyleBySymbolConfig(config.symbol, attr, entity);

    // 添加文本的统一回调方法 ，默认为entity方式，可以外部处理。
    function defaultLblAdd(position, labelattr, attr) {
      if (labelattr.text === "") {
        return null
      }

      if (Cesium__namespace.defined(labelattr.height)) {
        position = setPositionsHeight(position, labelattr.height);
      }

      const lblEx = entityCollection.add({
        position: position,
        label: labelattr,
        _attr: attr
      });
      return lblEx
    }
    lblAddFun = lblAddFun || defaultLblAdd;

    if (entity.polyline) {
      PolylineStyleConver.toCesiumVal(styleOpt, entity.polyline, true);

      // 存在附加的条带时
      if (styleOpt.corridor) {
        const corridorStyle = {
          color: styleOpt.color,
          opacity: styleOpt.opacity,
          ...styleOpt.corridor
        };
        // 可采用格式化字符串
        if (isString(styleOpt.corridor.width)) {
          corridorStyle.width = template(styleOpt.corridor.width, attr);
        }

        if (entity._corridorEx) {
          CorridorStyleConver.toCesiumVal(corridorStyle, entity._corridorEx.corridor, true);
        } else {
          const corridor = CorridorStyleConver.toCesiumVal(corridorStyle, {}, true);
          corridor.positions = getCesiumValue(entity.polyline.positions);
          const lineEx = entityCollection.add({
            corridor: corridor,
            _attr: attr
          });
          lineEx._mars3d_layerId = config.id;

          entity._corridorEx = lineEx;
        }
      }

      // 线时，加上文字标签
      if (styleOpt.label && styleOpt.label.text) {
        if (entity._labelEx) {
          LabelStyleConver.toCesiumVal(styleOpt.label, entity._labelEx.label, attr);
        } else {
          // 计算中心点
          const pots = getCesiumValue(entity.polyline.positions);
          let position = pots[Math.floor(pots.length / 2)];
          if (styleOpt.label.position) {
            if (styleOpt.label.position === "center") {
              position = centerOfMass(pots, styleOpt.label.height);
            } else if (isNumber(styleOpt.label.position)) {
              position = pots[styleOpt.label.position];
            }
          }

          // 文本属性
          const labelattr = LabelStyleConver.toCesiumVal(styleOpt.label, {}, attr);
          labelattr.heightReference = labelattr.heightReference ?? Cesium__namespace.HeightReference.CLAMP_TO_GROUND;

          const lblEx = lblAddFun(position, labelattr, attr);
          if (lblEx) {
            lblEx._mars3d_layerId = config.id;
          }
          entity._labelEx = lblEx;
        }
      }
    }
    if (entity.polygon) {
      PolygonStyleConver.toCesiumVal(styleOpt, entity.polygon, true);

      // 加上线宽
      if (styleOpt.outline && (styleOpt.outlineWidth > 1 || styleOpt.outlineStyle?.width > 1)) {
        entity.polygon.outline = false;
        const outlineStyle = {
          ...styleOpt,
          outline: false,
          color: styleOpt.outlineColor,
          width: styleOpt.outlineWidth,
          opacity: styleOpt.outlineOpacity,
          ...(styleOpt.outlineStyle || {})
        };
        // _outlineEx是数组，支持挖洞多边形的多个边线。
        if (entity._outlineEx) {
          for (let i = 0, len = entity._outlineEx.length; i < len; i++) {
            PolylineStyleConver.toCesiumVal(outlineStyle, entity._outlineEx[i].polyline, true);
          }
        } else {
          const arrline = getAllPositions(entity);
          entity._outlineEx = [];
          for (let i = 0, len = arrline.length; i < len; i++) {
            const polyline = PolylineStyleConver.toCesiumVal(outlineStyle, {}, true);
            polyline.positions = arrline[i];
            const lineEx = entityCollection.add({
              polyline: polyline,
              _attr: attr
            });
            lineEx._mars3d_layerId = config.id;
            entity._outlineEx.push(lineEx);
          }
        }
      }

      // 面时，加上文字标签
      if (styleOpt.label && styleOpt.label.text) {
        if (entity._labelEx) {
          LabelStyleConver.toCesiumVal(styleOpt.label, entity._labelEx.label, attr);
        } else {
          // 计算中心点
          const position = centerOfMass(getPositions(entity), styleOpt.label.height);

          // 文本属性
          const labelattr = LabelStyleConver.toCesiumVal(styleOpt.label, {}, attr);
          labelattr.heightReference = labelattr.heightReference ?? Cesium__namespace.HeightReference.CLAMP_TO_GROUND;

          const lblEx = lblAddFun(position, labelattr, attr);
          if (lblEx) {
            lblEx._mars3d_layerId = config.id;
          }
          entity._labelEx = lblEx;
        }
      }
    }

    // entity本身存在文字标签
    if (entity.label) {
      styleOpt.label = styleOpt.label || styleOpt || {};

      if (!Cesium__namespace.defined(styleOpt.label.clampToGround) && !Cesium__namespace.defined(styleOpt.label.heightReference)) {
        styleOpt.label.heightReference = styleOpt.label.heightReference ?? Cesium__namespace.HeightReference.CLAMP_TO_GROUND;
      }

      LabelStyleConver.toCesiumVal(styleOpt.label, entity.label, attr);
    } else {
      // 外部完全自定义的方式
      if (styleOpt.label && typeof styleOpt.label === "function") {
        styleOpt.label(entity, attr, function (position, styleLbl) {
          // 文本属性
          const labelattr = LabelStyleConver.toCesiumVal(styleLbl, {}, attr);
          labelattr.heightReference = (labelattr.heightReference, Cesium__namespace.HeightReference.CLAMP_TO_GROUND);

          const lblEx = lblAddFun(position, labelattr, attr);
          if (lblEx) {
            lblEx._mars3d_layerId = config.id;
          }
        });
      }
    }

    // 图标时
    if (entity.billboard) {
      if (!Cesium__namespace.defined(styleOpt.clampToGround) && !Cesium__namespace.defined(styleOpt.heightReference)) {
        styleOpt.heightReference = styleOpt.heightReference ?? Cesium__namespace.HeightReference.CLAMP_TO_GROUND;
      }
      // 可采用格式化字符串
      styleOpt.image = template(styleOpt.image, attr);

      BillboardStyleConver.toCesiumVal(styleOpt, entity.billboard, true);

      // 支持小模型
      if (styleOpt.model) {
        if (entity._modelEx) {
          ModelStyleConver.toCesiumVal(styleOpt.model, entity._modelEx.model, true);
        } else {
          const modelattr = ModelStyleConver.toCesiumVal(styleOpt.model, true);
          modelattr.heightReference = (modelattr.heightReference, Cesium__namespace.HeightReference.CLAMP_TO_GROUND);

          const modelEx = entityCollection.add({
            position: entity.position,
            model: modelattr,
            _attr: attr
          });
          modelEx._mars3d_layerId = config.id;
          entity._modelEx = modelEx;
        }
      }

      // 支持point
      if (styleOpt.point) {
        if (entity._pointEx) {
          PointStyleConver.toCesiumVal(styleOpt.point, entity._pointEx.point, true);
        } else {
          const modelattr = PointStyleConver.toCesiumVal(styleOpt.point, {}, true);
          modelattr.heightReference = modelattr.heightReference ?? Cesium__namespace.HeightReference.CLAMP_TO_GROUND;

          const pointEx = entityCollection.add({
            position: entity.position,
            point: modelattr,
            _attr: attr
          });
          pointEx._mars3d_layerId = config.id;
          entity._pointEx = pointEx;
        }
      }

      // 加上文字标签 (entity本身不存在label时)
      if (styleOpt.label && styleOpt.label.text && !entity.label) {
        if (entity._labelEx) {
          LabelStyleConver.toCesiumVal(styleOpt.label, entity._labelEx.label, attr);
        } else {
          // 计算中心点
          const position = entity.position;

          // 文本属性
          const labelattr = LabelStyleConver.toCesiumVal(styleOpt.label, {}, attr);
          labelattr.heightReference = labelattr.heightReference ?? Cesium__namespace.HeightReference.CLAMP_TO_GROUND;

          const lblEx = lblAddFun(position, labelattr, attr);
          if (lblEx) {
            lblEx._mars3d_layerId = config.id;
          }
          entity._labelEx = lblEx;
        }
      }
    }

    // 记录下样式配置
    entity.styleOpt = styleOpt;
  }

  /**
   * @typedef {Object} CzmGeoJsonLayer.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} add 添加对象
   * @property {String} remove 移除对象
   * @property {String} show 显示了对象
   * @property {String} hide 隐藏了对象
   *
   * @property {String} click 左键单击 鼠标事件
   * @property {String} rightClick 右键单击 鼠标事件
   * @property {String} mouseOver 鼠标移入 鼠标事件
   * @property {String} mouseOut 鼠标移出 鼠标事件
   *
   * @property {String} popupOpen popup弹窗打开后
   * @property {String} popupClose popup弹窗关闭
   * @property {String} tooltipOpen tooltip弹窗打开后
   * @property {String} tooltipClose tooltip弹窗关闭
   * @property {String} load 完成加载，执行所有内部处理后
   * @property {String} addGraphic 添加矢量数据时
   *
   * @example
   * //绑定监听事件
   * layer.on(mars3d.EventType.load, function (event) {
   *   console.log('矢量数据对象加载完成', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * GeoJSON数据图层(ceisum原生)，该类中矢量数据是使用ceisum原生方法加载的entity对象。
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.url] geojson文件或服务url地址
   * @param {Object} [options.data] geojson格式规范数据对象，与url二选一即可。
   * @param {Function} [options.format] 可以对加载的geojson数据进行格式化或转换操作
   *
   * @param {Number} [options.zIndex] 控制图层的叠加层次，默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面(只对同类型图层间有效)。
   * @param {Number} [options.opacity = 1] 透明度，取值范围：0.0-1.0
   * @param {Object} [options.symbol] 矢量数据的style样式
   * @param {BillboardEntity.StyleOptions|PolylineEntity.StyleOptions|PolygonEntity.StyleOptions|*} options.symbol.styleOptions 数据的Style样式
   * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
   * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
   * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, entity, styleOpt){  return { color: "#ff0000" };  }
   *
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑定，参数与popup属性完全相同。
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数,还包括：
   * @param {String} [options.tooltipOptions.title] 固定的标题名称
   * @param {String} [options.tooltipOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.tooltipOptions.noTitle] 不显示标题
   * @param {Object} [options.contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @class CzmGeoJsonLayer
   * @extends {BaseGraphicLayer}
   *
   * @see [支持的事件类型]{@link CzmGeoJsonLayer.EventType}
   * @see Cesium.GeoJsonDataSource
   */
  class CzmGeoJsonLayer extends BaseGraphicLayer {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      this._setOptionsHook(options);
    }

    /**
     * GeoJsonDataSource 对象
     * @type {Cesium.GeoJsonDataSource}
     * @readonly
     */
    get layer() {
      return this._dataSource
    }

    /**
     * Entity矢量数据 集合
     * @type {Cesium.EntityCollection}
     * @readonly
     */
    get entities() {
      if (this._dataSource) {
        return this._dataSource.entities
      } else {
        return null
      }
    }

    /**
     * 当存在 文字primitive 数据的内部Cesium容器
     * @type {Cesium.LabelCollection}
     * @readonly
     */
    get labelCollection() {
      if (!this._labelCollection) {
        this._labelCollection = new Cesium__namespace.LabelCollection({ scene: this._map.scene });
        if (this._state === State.ADDED) {
          this._map.scene.primitives.add(this._labelCollection);
        }
      }
      return this._labelCollection
    }

    /**
     * 是否可以调整图层顺序（在同类型图层间）
     *
     * @type {Boolean}
     * @readonly
     */
    get hasZIndex() {
      return true
    }

    /**
     * 图层顺序，数字大的在上面。（当hasZIndex为true时）
     * @type {Number}
     */
    get zIndex() {
      return this.options.zIndex
    }

    set zIndex(zIndex) {
      this.options.zIndex = zIndex;

      if (this._dataSource == null || zIndex == null) {
        return
      }
      if (!this._map.dataSources.contains(this._dataSource)) {
        return
      }

      this._dataSource.zIndex = zIndex;

      // 先移动到最顶层
      this._map.dataSources.raiseToTop(this._dataSource);

      const layers = this._map.dataSources;
      for (let i = layers.length - 1; i >= 0; i--) {
        const layer = layers.get(i);
        if (layer === this._dataSource) {
          continue
        }
        if (Cesium__namespace.defined(layer.zIndex) && zIndex < layer.zIndex) {
          this._map.dataSources.lower(this._dataSource); // 下移一个位置
        }
      }
    }

    /**
     * 是否贴地
     *
     * @type {Boolean}
     * @readonly
     */
    get clampToGround() {
      if (this.options.clampToGround) {
        return true
      }
      if (this.options.symbol && this.options.symbol.styleOptions && this.options.symbol.styleOptions.clampToGround) {
        return true
      }
      return false
    }

    _setOptionsHook(options) {
      super._setOptionsHook(options);

      // GeoJsonDataSource.load中使用
      if (this.options.symbol?.styleOptions) {
        const style = this.options.symbol.styleOptions;
        if (Cesium__namespace.defined(style.clampToGround)) {
          this.options.clampToGround = style.clampToGround;
        }
        if (Cesium__namespace.defined(style.color)) {
          const color = Cesium__namespace.Color.fromCssColorString(style.color ?? "#FFFF00").withAlpha(Number(style.opacity ?? 0.5));
          this.options.fill = color;
        }
        if (Cesium__namespace.defined(style.outlineColor)) {
          const outlineColor = Cesium__namespace.Color.fromCssColorString(style.outlineColor ?? style.color ?? "#FFFFFF").withAlpha(
            style.outlineOpacity ?? (style.opacity, 1.0)
          );
          this.options.stroke = outlineColor;
        }
        if (Cesium__namespace.defined(style.outlineWidth)) {
          this.options.strokeWidth = style.outlineWidth;
        }
      }
    }

    _showHook(val) {
      super._showHook(val);

      if (this._labelCollection) {
        this._labelCollection.show = val;
      }
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      super._mountedHook();

      this.load();
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      super._addedHook();

      if (this._dataSource) {
        this._map.dataSources.add(this._dataSource);
      }
      if (this._labelCollection) {
        this._map.scene.primitives.add(this._labelCollection);
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      super._removedHook();

      if (this._labelCollection) {
        this._map.scene.primitives.remove(this._labelCollection);
        this._labelCollection = null;
      }
      if (this._dataSource) {
        this._map.dataSources.remove(this._dataSource);
      }
    }

    // 定位至数据区域
    flyTo(options) {
      if (!this._map) {
        return Promise.resolve(false)
      }
      this._map.cancelFlyTo();

      if (this.options.center) {
        return this._map.setCameraView(this.options.center, options)
      } else if (this.options.extent) {
        return this._map.flyToExtent(this.options.extent, options)
      } else if (this._dataSource) {
        return this._map.viewer.flyTo(this._dataSource, options)
      }
      return Promise.resolve(false)
    }

    /**
     * 加载新数据 或 刷新数据
     *
     * @param {Object} [newOptions={}] 新设定的参数，会与类的构造参数合并。
     * @param {String} [newOptions.url] geojson文件或服务url地址
     * @param {Object} [newOptions.data] geojson格式规范数据对象，与url二选一即可。
     * @param {Object} [newOptions.类参数] 包含当前类支持的所有参数
     * @return {CzmGeoJsonLayer} 当前对象本身，可以链式调用
     */
    load(newOptions) {
      if (newOptions) {
        if (newOptions.clear ?? true) {
          delete this.options.url;
          delete this.options.data;
        }
        this.clear();

        this.options = {
          ...this.options,
          ...newOptions
        };
      }

      if (this.options.url) {
        fetchJson({ ...this.options, proxy: this._proxy })
          .then((data) => {
            if (!this._map || this._state !== State.ADDED) {
              return
            }
            this._load_data(data);
          })
          .catch((error) => {
            logError("fetchJson出错了", error);
            this._readyPromise && this._readyPromise.reject(error);
          });
      } else if (this.options.data) {
        this._load_data(this.options.data);
      } else {
        if (newOptions) {
          logWarn("CzmGeoJsonLayer：没有传入 url 或 data 参数,请确认是否有误。");
        }
      }
      return this
    }

    _load_data(geojson) {
      if (this.options.format) {
        geojson = this.options.format(geojson);
      }

      const loadPromise = Cesium__namespace.GeoJsonDataSource.load(geojson, this.options);
      loadPromise.then((dataSource) => {
        this.showResult(dataSource);
      });
    }

    showResult(dataSource) {
      if (this._dataSource) {
        this._map.dataSources.remove(this._dataSource);
        delete this._dataSource;
      }
      if (!dataSource || this._state === State.REMOVED) {
        return
      }

      dataSource.show = this.show; // 避免异步加载中设置show=false，需要赋值下
      this._map.dataSources.add(dataSource);

      this._readyPromise.resolve(this);

      this._dataSource = dataSource;
      if (this.options.zIndex) {
        this.zIndex = this.options.zIndex;
      }

      const entities = dataSource.entities.values;
      const list = [];
      for (let i = 0, len = entities.length; i < len; i++) {
        const entity = entities[i];

        entity._mars3d_layerId = this.id;

        // 属性
        const attr = this.getEntityAttr(entity);
        entity._attr = attr || {}; // 重新绑定，后续使用

        this.fire(EventType.addGraphic, {
          czmObject: entity,
          attr: attr
        });
        list.push({
          ...attr,
          _entity: entity
        });
      }

      this.options.id = this.id;
      config2Entity(entities, this.options, (position, labelattr, attr) => {
        return this.lblAddFun(position, labelattr, attr)
      });

      if (this._opacity !== 1) {
        this.setOpacity(this._opacity);
      }

      if (this.options.flyTo) {
        this.flyToByAnimationEnd();
      }

      this.fire(EventType.load, {
        dataSource: dataSource,
        entities: entities,
        list: list
      });
    }

    /**
     * 加载新数据 或 刷新数据
     *
     * @param {Object} symbol 设置新的symbol 矢量数据样式.  {@link GraphicType}
     * @param {Object} symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
     * @param {String} [symbol.styleField] 按 styleField 属性设置不同样式。
     * @param {Object} [symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
     * @return {CzmGeoJsonLayer} 当前对象本身，可以链式调用
     */
    updateStyle(symbol) {
      if (!this._dataSource) {
        return
      }

      if (symbol) {
        this.options.symbol = {
          ...this.options.symbol,
          ...symbol
        };
      }

      const entities = this._dataSource.entities.values;

      this.options.id = this.id;
      config2Entity(entities, this.options, (position, labelattr, attr) => {
        return this.lblAddFun(position, labelattr, attr)
      });
      return this
    }

    /**
     * 添加label文本注记
     *
     * @param {Cesium.Cartesian3|Cesium.SampledPositionProperty|*} position 坐标位置
     * @param {Object} labelattr label文本的属性
     * @param {Object} attr 属性信息
     * @return {Cesium.Label} label文本对象
     */
    lblAddFun(position, labelattr, attr) {
      if (labelattr.text === "") {
        return null
      }

      if (Cesium__namespace.defined(labelattr.height)) {
        position = setPositionsHeight(position, labelattr.height);
      }

      // entity方式
      // let lblEx = this._dataSource.entities.add({
      //   position: position,
      //   label: labelattr,
      //   properties: attr,
      // })

      // LabelCollection方式
      if (!this.labelCollection) {
        this.labelCollection = new Cesium__namespace.LabelCollection({ scene: this.viewer.scene });
        this.viewer.scene.primitives.add(this.labelCollection);
      }
      labelattr.position = getPositionValue(position);
      const lblEx = this.labelCollection.add(labelattr);
      lblEx.properties = attr;

      lblEx._mars3d_layerId = this.id;

      return lblEx
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      this._opacity = value;
      if (!this._dataSource) {
        return
      }

      const entities = this._dataSource.entities.values;

      for (let i = 0, len = entities.length; i < len; i++) {
        const entity = entities[i];

        if (entity.polygon && entity.polygon.material && entity.polygon.material.color) {
          this._updatEntityAlpha(entity.polygon.material.color, this._opacity);
          if (entity.polygon.outlineColor) {
            this._updatEntityAlpha(entity.polygon.outlineColor, this._opacity);
          }
        }

        if (entity.polyline && entity.polyline.material && entity.polyline.material.color) {
          this._updatEntityAlpha(entity.polyline.material.color, this._opacity);
        }

        if (entity.billboard) {
          entity.billboard.color = Cesium__namespace.Color.WHITE.withAlpha(this._opacity);
        }

        if (entity.model) {
          entity.model.color = Cesium__namespace.Color.WHITE.withAlpha(this._opacity);
        }

        if (entity.label) {
          let _opacity = this._opacity;
          if (entity.styleOpt && entity.styleOpt.label && entity.styleOpt.label.opacity) {
            _opacity = entity.styleOpt.label.opacity;
          }

          if (entity.label.fillColor) {
            this._updatEntityAlpha(entity.label.fillColor, _opacity);
          }
          if (entity.label.outlineColor) {
            this._updatEntityAlpha(entity.label.outlineColor, _opacity);
          }
          if (entity.label.backgroundColor) {
            this._updatEntityAlpha(entity.label.backgroundColor, _opacity);
          }
        }
      }
    }

    _updatEntityAlpha(color, opacity) {
      if (!color) {
        return
      }
      let newclr = getCesiumValue(color, Cesium__namespace.Color, this._map.clock.currentTime);
      if (!newclr || !newclr.withAlpha) {
        return color
      }

      newclr = newclr.withAlpha(opacity);
      color.setValue(newclr);
    }

    /**
     * 获取Entity矢量对象上绑定的 数据
     *
     * @param {Cesium.Entity} entity Entity矢量对象
     * @return {Object} 数据
     */
    getEntityAttr(entity) {
      return getAttrVal(entity.properties)
    }

    /**
     * 清除所有数据
     * @return {CzmGeoJsonLayer} 当前对象本身，可以链式调用
     */
    clear() {
      if (this._labelCollection) {
        this._labelCollection.removeAll();
      }
      if (this._dataSource) {
        this._dataSource.entities.removeAll();
      }
      this._closeAllControl();

      return this
    }
  }

  // 注册下
  register$2("czmGeojson", CzmGeoJsonLayer);

  /**
   * KML数据图层
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.url] KML文件或服务url地址
   * @param {Document | Blob} [options.data] 已解析的KML文档或包含二进制KMZ数据或已解析的KML文档的Blob，与url二选一即可。
   *
   * @param {Number} [options.zIndex] 控制图层的叠加层次（部分图层），默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面。
   * @param {Number} [options.opacity = 1.0] 透明度（部分图层），取值范围：0.0-1.0
   * @param {Object} [options.symbol] 矢量数据的style样式
   * @param {BillboardEntity.StyleOptions|PolylineEntity.StyleOptions|PolygonEntity.StyleOptions|*} options.symbol.styleOptions 数据的Style样式
   * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
   * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
   * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, entity, styleOpt){  return { color: "#ff0000" };  }
   *
   *
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑定，参数与popup属性完全相同。
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数,还包括：
   * @param {String} [options.tooltipOptions.title] 固定的标题名称
   * @param {String} [options.tooltipOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.tooltipOptions.noTitle] 不显示标题
   * @param {Object} [options.contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
   *
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class KmlLayer
   * @extends {CzmGeoJsonLayer}
   *
   * @see [支持的事件类型]{@link CzmGeoJsonLayer.EventType}
   * @see Cesium.KmlDataSource
   */
  class KmlLayer extends CzmGeoJsonLayer {
    /**
     * 加载新数据 或 刷新数据
     *
     * @param {Object} [newOptions={}] 新设定的参数，会与类的构造参数合并。
     * @param {Document | Blob} [newOptions.data] 已解析的KML文档或包含二进制KMZ数据或已解析的KML文档的Blob，与url二选一即可。
     *
     * @param {String} [newOptions.url] KML文件或服务url地址
     * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
     * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
     * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'}
     * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' }
     *
     * @param {Object} [newOptions.类参数] 包含当前类支持的所有参数
     * @return {KmlLayer} 当前对象本身，可以链式调用
     * @override
     */
    load(newOptions = {}) {
      this.options = {
        ...this.options,
        ...newOptions
      };

      let loadPromise;
      if (this.options.url) {
        const url = getUrlResource(this.options);
        loadPromise = Cesium__namespace.KmlDataSource.load(url, {
          camera: this._map.scene.camera,
          canvas: this._map.scene.canvas,
          clampToGround: this.options.clampToGround
        });
      } else if (this.options.data) {
        loadPromise = Cesium__namespace.KmlDataSource.load(this.options.data, {
          camera: this._map.scene.camera,
          canvas: this._map.scene.canvas,
          clampToGround: this.options.clampToGround
        });
        logError("KmlLayer：请必须传入 url 或 data 参数");
      }

      loadPromise.then((dataSource) => {
        this.showResult(dataSource);
      });
    }

    /**
     * 获取Entity矢量对象上绑定的 数据
     *
     * @param {Cesium.Entity} entity Entity矢量对象
     * @return {Object} 数据
     * @override
     */
    getEntityAttr(entity) {
      let attr = { name: entity.name, description: entity.description };
      const extendedData = entity._kml.extendedData;
      for (const key in extendedData) {
        attr[key] = extendedData[key].value;
      }
      attr = getAttrVal(attr);

      if (attr.description) {
        attr.description = attr.description.replace(/<div[^>]+>/g, ""); // 剔除div html标签
      }

      return attr
    }
  }

  // 注册下
  register$2("kml", KmlLayer);

  /**
   * CZML数据图层
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.url] CZML文件或服务url地址
   * @param {Object} [options.data] CZML格式规范数据对象，与url二选一即可。
   *
   * @param {Number} [options.zIndex] 控制图层的叠加层次（部分图层），默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面。
   *
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑定，参数与popup属性完全相同。
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数,还包括：
   * @param {String} [options.tooltipOptions.title] 固定的标题名称
   * @param {String} [options.tooltipOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.tooltipOptions.noTitle] 不显示标题
   * @param {Object} [options.contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class CzmlLayer
   * @extends {CzmGeoJsonLayer}
   *
   * @see [支持的事件类型]{@link CzmGeoJsonLayer.EventType}
   * @see Cesium.CzmlDataSource
   */
  class CzmlLayer extends CzmGeoJsonLayer {
    _showHook(val) {
      super._showHook(val);
      if (val) {
        this.setCzmlTime();
      } else {
        this.setNowTime();
      }
    }

    setCzmlTime() {
      if (this._dataSource?.clock) {
        this._map.clock.clockRange = this._dataSource.clock.clockRange;
        this._map.clock.multiplier = this._dataSource.clock.multiplier;

        this._map.clock.startTime = this._dataSource.clock.startTime;
        this._map.clock.stopTime = this._dataSource.clock.stopTime;
        this._map.clock.currentTime = this._dataSource.clock.startTime;
      }
    }

    setNowTime() {
      this._map.clock.clockRange = Cesium__namespace.ClockRange.UNBOUNDED;
      this._map.clock.multiplier = 1;

      const now = Cesium__namespace.JulianDate.fromDate(new Date());
      this._map.clock.startTime = now.clone();
      this._map.clock.stopTime = Cesium__namespace.JulianDate.addDays(now, 1.0, new Cesium__namespace.JulianDate());
      this._map.clock.currentTime = now.clone();
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      super._removedHook();
      this.setNowTime();
    }

    /**
     * 加载新数据 或 刷新数据
     *
     * @param {Object} [newOptions={}] 新设定的参数，会与类的构造参数合并。
     * @param {Object} [newOptions.data] CZML格式规范数据对象，与url二选一即可。
     *
     * @param {String} [newOptions.url] CZML文件或服务url地址
     * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
     * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
     * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'}
     * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' }
     *
     * @param {Object} [newOptions.类参数] 包含当前类支持的所有参数
     * @return {CzmlLayer} 当前对象本身，可以链式调用
     * @override
     */
    load(newOptions = {}) {
      this.options = {
        ...this.options,
        ...newOptions
      };

      let loadPromise;
      if (this.options.url) {
        const url = getUrlResource(this.options);
        loadPromise = Cesium__namespace.CzmlDataSource.load(url, this.options);
      } else if (this.options.data) {
        loadPromise = Cesium__namespace.CzmlDataSource.load(this.options.data, this.options);
      } else {
        logError("CzmlLayer：请必须传入 url 或 data 参数");
      }

      loadPromise.then((dataSource) => {
        this.showResult(dataSource);
      });
    }

    /**
     * 获取Entity矢量对象上绑定的 数据
     *
     * @param {Cesium.Entity} entity Entity矢量对象
     * @return {Object} 数据
     * @override
     */
    getEntityAttr(entity) {
      if (entity.properties) {
        return getAttrVal(entity.properties)
      }
      if (entity.description) {
        return { description: getCesiumValue(entity.description) }
      }
    }
  }

  // 注册下
  register$2("czml", CzmlLayer);

  /**
   * 矢量数据图层组，主要用于 多图层的标绘
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {GraphicLayer[]} [options.layers] 子图层数组，每个子图层的配置见按各类型图层配置即可。
   * @param {String} [options.defaultLayer] 默认图层的图层名称
   *
   * @param {Boolean} [options.hasEdit=false] 是否自动激活编辑（true时，单击后自动激活编辑）
   * @param {Boolean} [options.isAutoEditing=true] 完成标绘时是否自动启动编辑(需要hasEdit:true时)
   * @param {Boolean} [options.isContinued=false] 是否连续标绘
   * @param {Boolean} [options.isRestorePositions=false] 在标绘和编辑结束时，是否将坐标还原为普通值，true: 停止编辑时会有闪烁，但效率要好些。
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class GraphicGroupLayer
   * @extends {GroupLayer}
   */
  class GraphicGroupLayer extends GroupLayer {
    /**
     * 是否可以编辑
     *
     * @type {Boolean}
     */
    get hasEdit() {
      return this._hasEdit
    }

    set hasEdit(val) {
      this._hasEdit = val;
      if (this._selectedLayer) {
        if (val) {
          this._selectedLayer.activateEdit();
        } else {
          this._selectedLayer.disableEdit();
        }
      }
    }

    /**
     * 完成标绘时是否自动启动编辑(需要hasEdit:true时)
     * @type {Boolean}
     */
    get isAutoEditing() {
      return this.options.isAutoEditing
    }

    set isAutoEditing(val) {
      this.options.isAutoEditing = val;
      this.eachLayer((layer) => {
        layer.isAutoEditing = val;
      }, this);
    }

    /**
     * 当前激活的图层
     * @type {GraphicLayer}
     */
    get selectedLayer() {
      return this._selectedLayer
    }

    set selectedLayer(layer) {
      if (this._selectedLayer) {
        // 上一次的取消激活状态
        delete this._selectedLayer.isActivate;
        this._selectedLayer.disableEdit();
      }

      if (!(layer instanceof GraphicLayer)) {
        layer = this.getLayer(layer);
      }

      this._selectedLayer = layer;
      if (this._selectedLayer) {
        // 本次的标记为激活状态
        this._selectedLayer.isActivate = true;
        if (this._hasEdit) {
          this._selectedLayer.activateEdit();
        }
      }
    }

    /**
     * 判断图层是否激活状态
     *
     * @param {GraphicLayer} layer 图层
     * @return {boolean} 是否激活状态
     * @memberof GraphicGroupLayer
     */
    isActivate(layer) {
      return layer.isActivate
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      super._mountedHook();
      if (this.options.geojson) {
        this.loadGeoJSON(this.options.geojson);
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      super._addedHook();
      this._processForRemoveLayer();
    }

    // 新增或获取已有分组
    _getOrCreateLayer(name) {
      if (!name) {
        return this.selectedLayer
      }
      const layer = this.getLayer(name);
      if (layer) {
        return layer
      } else {
        return this.createLayer(name)
      }
    }

    /**
     * 创建并添加指定名称的图层
     *
     * @param {String} name 图层名称
     * @return {GraphicLayer} 创建完成的图层
     */
    createLayer(name) {
      const layerOptions = clone(this.options, ["id", "pid", "geojson", "data"]);
      layerOptions.name = name;
      layerOptions.pid = this.id;

      // 创建图层
      const graphicLayer = new GraphicLayer(layerOptions);
      if (this._events) {
        graphicLayer._events = {
          ...this._events
        };
      }
      this._map.addLayer(graphicLayer);

      this.addLayer(graphicLayer);

      return graphicLayer
    }

    /**
     * 删除指定名称的图层
     *
     * @param {String} name 图层名称
     * @return {Boolean} 是否删除成功
     */
    deleteLayer(name) {
      let layer;
      if (name instanceof GraphicLayer) {
        layer = name;
      } else {
        layer = this.getLayer(name);
      }

      if (layer) {
        if (this.selectedLayer === layer) {
          this.selectedLayer = null;
        }
        removeArrayItem(this._arrLayer, layer);
        this._map.removeLayer(layer, true);

        this._processForRemoveLayer();
        return true
      } else {
        return false
      }
    }

    /**
     * 删除所有没有数据的矢量图层
     *
     * @return {GraphicGroupLayer} 当前对象本身，可以链式调用
     */
    deleteEmptyLayer() {
      for (let i = this._arrLayer.length - 1; i >= 0; i--) {
        const layer = this._arrLayer[i];
        if (layer.length === 0) {
          if (this.selectedLayer === layer) {
            this.selectedLayer = null;
          }
          this._arrLayer.splice(i, 1);
          this._map.removeLayer(layer, true);
        }
      }
      this._processForRemoveLayer();

      return this
    }

    // 删除分组后的对默认图层和激活图层的特殊处理
    _processForRemoveLayer() {
      if (this._arrLayer.length === 0 && this.options.defaultLayer) {
        // 如果有指定默认图层，自动加个图层
        this.selectedLayer = this.createLayer(this.options.defaultLayer);
      }
      if (this.selectedLayer == null && this._arrLayer.length > 0) {
        // 再次激活第1个图层
        this.selectedLayer = this._arrLayer[0];
      }
    }

    //= =========================Graphic===========================

    /**
     *  移动矢量对象到新分组
     *
     * @param {BaseGraphic|*} graphic  矢量对象
     * @param {GraphicLayer} layer 图层
     * @return {void}  无
     */
    moveToLayer(graphic, layer) {
      if (!(layer instanceof GraphicLayer)) {
        layer = this.getLayer(layer);
      }

      graphic.remove(); // 从原有的集合中删除
      layer.addGraphic(graphic); // 加入到draw集合图层中
    }

    /**
     * 获取图层内 所有矢量数据
     * @return {BaseGraphic[]} 矢量数据数组
     */
    getGraphics() {
      const result = [];
      this.eachGraphic((graphic) => {
        if (graphic.isPrivate) {
          return
        }

        result.push(graphic);
      }, this);
      return result
    }

    /**
     * 根据id或uuid取矢量数据对象
     *
     * @param {String|Number} id  矢量数据id或uuid
     * @return {BaseGraphic|*} 矢量数据对象
     */
    getGraphicById(id) {
      if (!id) {
        return undefined
      }
      for (let i = this._arrLayer.length - 1; i >= 0; i--) {
        const layer = this._arrLayer[i];
        const graphic = layer.getGraphicById(id);
        if (graphic) {
          return graphic
        }
      }
      return undefined
    }

    /**
     * 遍历所有矢量数据并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} [context] 侦听器的上下文(this关键字将指向的对象)。
     * @return {GraphicGroupLayer} 当前对象本身,可以链式调用
     */
    eachGraphic(method, context) {
      this.eachLayer((layer) => {
        layer.eachGraphic(method, context);
      }, this);
      return this
    }

    /**
     * 清除图层内所有矢量数据
     *
     * @param {Boolean} [hasDestroy=false] 是否释放矢量对象
     * @return {void}  无
     */
    clear(hasDestroy) {
      this.eachLayer((layer) => {
        layer.clear(hasDestroy);
      }, this);
    }

    /**
     * 将图层数据导出为GeoJSON格式规范对象。
     * @param {Object} [options] 参数对象:
     * @param {Boolean} [options.noAlt] 不导出高度值
     * @param {Boolean} [options.stopEdit = false] 是否停止绘制或编辑
     * @return {Object} GeoJSON格式规范对象
     */
    toGeoJSON(options) {
      if (options?.stopEdit) {
        this.stopDraw();
      }

      const features = [];
      const layerNames = [];

      this.eachLayer((layer) => {
        layerNames.push(layer.name);

        layer.eachGraphic((graphic) => {
          if (graphic.isPrivate) {
            return
          }
          const feature = graphic.toGeoJSON(options);
          feature.properties._layer = layer.name; // 记录分组信息
          features.push(feature);
        }, this);
      }, this);

      return {
        type: "FeatureCollection",
        layer: { id: this.id, name: this.name, layers: layerNames, selected: this.selectedLayer.name },
        features: features
      }
    }

    /**
     * 加载转换GeoJSON格式规范数据为Graphic后加载到图层中。
     *
     * @param {String|Object} geojson GeoJSON格式规范数据
     * @param {Object} [options] 加载控制参数,包含：
     * @param {Boolean} [options.clear=false] 是否清除图层已有数据
     * @param {Boolean} [options.flyTo=false] 是否加载完成后进行飞行到数据区域
     * @param {Object} [options.style] 可以设置指定style样式
     * @param {String} [options.layer] 指定导入所有数据到指定的图层
     * @return {BaseGraphic[]} 转换后的Graphic对象数组
     */
    loadGeoJSON(geojson, options = {}) {
      try {
        if (isString(geojson)) {
          geojson = JSON.parse(geojson);
        }
      } catch (e) {
        alert(e.name + ": " + e.message + " \n请确认json文件格式正确!!!");
        return
      }

      if (options.clear) {
        this.clear(true);
      }

      // 存在分组信息
      let fixedLayer;
      if (options.layer) {
        fixedLayer = this.getLayer(options.layer);
      } else {
        const objLayer = {};
        const layerNames = geojson?.layer?.layers;
        if (layerNames) {
          for (let k = 0; k < layerNames.length; k++) {
            const layer = this._getOrCreateLayer(layerNames[k]);
            objLayer[layerNames[k]] = layer;
          }

          if (geojson?.layer?.selected) {
            const slayer = objLayer[geojson?.layer?.selected];
            if (slayer) {
              this.selectedLayer = slayer;
            }
          }
        }
      }

      const features = getGeoJsonFeatures(geojson);

      let arrthis = [];
      for (let i = 0, len = features.length; i < len; i++) {
        const feature = features[i];

        let layer;
        if (fixedLayer) {
          layer = fixedLayer;
        } else {
          const layerName = feature?.properties?._layer;
          layer = layerName ? this.getLayer(layerName) : null;
          if (!layer) {
            layer = this.selectedLayer;
          }
        }

        const arr = layer.loadGeoJSON(feature, {
          ...options,
          clear: false,
          flyTo: false
        });
        arrthis = arrthis.concat(arr);
      }

      if (options.flyTo) {
        this._map.flyToGraphic(arrthis);
      }
      return arrthis
    }

    // 转为json的额外需要处理的对象
    _toJsonEx(newData) {
      newData.geojson = this.toGeoJSON();
    }

    /**
     * 获取图层内所有数据的 矩形边界值
     * @param {Boolean} [isFormat=false] 是否格式化，格式化时示例： { xmin: 73.16895, xmax: 134.86816, ymin: 12.2023, ymax: 54.11485 }
     * @return {Cesium.Rectangle|Object} isFormat：true时，返回格式化对象，isFormat：false时返回Cesium.Rectangle对象
     */
    getRectangle(isFormat) {
      let rectangleAll;
      this.eachGraphic((graphic) => {
        if (graphic.isPrivate) {
          return
        }

        if (!graphic.getRectangle) {
          return
        }

        const rectangle = graphic.getRectangle();
        if (!Cesium__namespace.defined(rectangle)) {
          return
        }

        if (rectangleAll) {
          rectangleAll = Cesium__namespace.Rectangle.union(rectangle, rectangleAll);
        } else {
          rectangleAll = rectangle;
        }
      }, this);

      if (isFormat) {
        return formatRectangle(rectangleAll)
      } else {
        return rectangleAll
      }
    }

    //= =================绘制及编辑=======================
    /**
     * 开始绘制矢量数据，绘制的数据会加载在当前图层。
     *
     * @param {Object|*} options 绘制参数，包含：
     * @param {GraphicType|String} options.type 类型
     * @param {Object} [options.style] 矢量数据样式，具体参考支持 {@link GraphicType}查询对应type的类
     * @param {Object} [options.attr] 矢量数据的 属性信息，可以任意附加属性。
     * @param {Function} [options.success] 绘制创建完成的回调方法，同drawCreated事件，例如： success: function (graphic){  }
     * //以下为Entity支持的构造参数
     * @param {String} [options.name] 矢量数据名称
     * @param {Number} [options.maxPointNum] 线面数据时限定的最大坐标个数
     * @param {Boolean} [options.drawShow=true] 绘制时，是否自动隐藏entity，可避免拾取坐标存在问题。
     * @param {Number} [options.addHeight] 在绘制时，在绘制点的基础上增加的高度值
     * @param {Cesium.TimeIntervalCollection} [options.availability] 与该对象关联的可用性(如果有的话)。
     * @param {Cesium.Property | string} [options.description] 指定此实体的HTML描述的字符串属性（infoBox中展示）。
     * @return {Promise<BaseGraphic|*>} 绘制创建完成的Promise,等价于success参数
     */
    startDraw(options) {
      return this._selectedLayer.startDraw(options)
    }

    /**
     * 停止绘制，如有未完成的绘制会自动删除
     *
     * @return {GraphicGroupLayer} 当前对象本身,可以链式调用
     */
    stopDraw() {
      return this._selectedLayer.stopDraw()
    }

    /**
     * 激活编辑，绑定相关处理，同 hasEdit=true
     * @return {GraphicGroupLayer} 当前对象本身,可以链式调用
     */
    activateEdit() {
      return this._selectedLayer.activateEdit()
    }

    /**
     * 释放编辑，解除绑定相关事件，同 hasEdit=false
     * @return {GraphicGroupLayer} 当前对象本身,可以链式调用
     */
    disableEdit() {
      return this._selectedLayer.disableEdit()
    }
  }

  // 注册下
  register$2("graphicGroup", GraphicGroupLayer);

  /**
   * @typedef {Object} GeoJsonLayer.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} load 完成加载，执行所有内部处理后
   *
   * @property {String} add 添加对象
   * @property {String} remove 移除对象
   * @property {String} show 显示了对象
   * @property {String} hide 隐藏了对象
   *
   * @property {String} click 左键单击 鼠标事件
   * @property {String} rightClick 右键单击 鼠标事件
   * @property {String} mouseOver 鼠标移入 鼠标事件
   * @property {String} mouseOut 鼠标移出 鼠标事件
   *
   * @property {String} popupOpen popup弹窗打开后
   * @property {String} popupClose popup弹窗关闭
   * @property {String} tooltipOpen tooltip弹窗打开后
   * @property {String} tooltipClose tooltip弹窗关闭
   * @property {String} contextMenuOpen 右键菜单 打开后
   * @property {String} contextMenuClose 右键菜单 关闭
   * @property {String} contextMenuClick 右键菜单 单击某一项后
   *
   * @property {String} drawStart 开始绘制 标绘事件
   * @property {String} drawMouseMove 正在移动鼠标中，绘制过程中鼠标移动了点 标绘事件
   * @property {String} drawAddPoint 绘制过程中增加了点 标绘事件
   * @property {String} drawRemovePoint 绘制过程中删除了最后一个点 标绘事件
   * @property {String} drawCreated 创建完成 标绘事件
   * @property {String} editStart 开始编辑 标绘事件
   * @property {String} editMouseDown 移动鼠标按下左键（LEFT_DOWN）标绘事件
   * @property {String} editMouseMove 正在移动鼠标中，正在编辑拖拽修改点中（MOUSE_MOVE） 标绘事件
   * @property {String} editMovePoint 编辑修改了点（LEFT_UP）标绘事件
   * @property {String} editRemovePoint 编辑删除了点 标绘事件
   * @property {String} editStyle 图上编辑修改了相关style属性 标绘事件
   * @property {String} editStop 停止编辑 标绘事件
   *
   *
   * @example
   * //绑定监听事件
   * layer.on(mars3d.EventType.load, function (event) {
   *   console.log('矢量数据对象加载完成', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 加载展示 GeoJSON数据 的图层
   *
   * @param {Object} [options] 参数对象，包括以下：
   *
   * @param {String} [options.url] geojson文件或服务url地址
   * @param {Object} [options.data] geojson格式规范数据对象，与url二选一即可。
   * @param {String} [options.crs]  原始数据的坐标系，如'EPSG:3857'
   * @param {ChinaCRS} [options.chinaCRS] 标识数据的国内坐标系（用于自动纠偏或加偏）
   * @param {Function} [options.format] 可以对加载的geojson数据进行格式化或转换操作
   * @param {Function} [options.onCreateGraphic] 解析geojson后，外部自定义方法来创建Graphic对象
   * @param {Boolean|Object} [options.mask] 标识是否绘制区域边界的反选遮罩层，也可以传入object配置范围： { xmin: 73.0, xmax: 136.0, ymin: 3.0, ymax: 59.0 }
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   *
   * @param {Number} [options.opacity = 1.0] 透明度（部分图层），取值范围：0.0-1.0
   * @param {Number} [options.zIndex] 控制图层的叠加层次（部分图层），默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面。
   * @param {Object|Function} [options.symbol] 矢量数据的style样式,为Function时是完全自定义的回调处理 symbol(attr, style, feature)
   * @param {GraphicType|String} [options.symbol.type] 标识数据类型，默认是根据数据生成 point、polyline、polygon
   * @param {Object} options.symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各{@link GraphicType}矢量数据的style参数。
   * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
   * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
   * @param {Boolean} [options.symbol.merge] 是否合并并覆盖json中已有的style，默认不合并。
   * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
   * @param {Object} [options.graphicOptions] 默认的graphic的构造参数，每种不同类型数据都有不同的属性，具体见各{@link GraphicType}矢量数据的构造参数。
   *
   * @param {Object} [options.buildings] 标识当前图层为建筑物白膜类型数据
   * @param {String} [options.buildings.bottomHeight] 建筑物底部高度（如:0） 属性字段名称（如:{bottomHeight}）
   * @param {String} [options.buildings.cloumn=1]  层数，楼的实际高度 = height*cloumn
   * @param {String|Number} [options.buildings.height=3.5]  层高的  固定层高数值（如:10） 或 属性字段名称（如:{height}）
   *
   * @param {String} [options.proxy] 加载资源时要使用的代理服务url。
   * @param {Object} [options.templateValues] 一个对象，用于替换Url中的模板值的键/值对
   * @param {Object} [options.queryParameters] 一个对象，其中包含在检索资源时将发送的查询参数。比如：queryParameters: {'access_token': '123-435-456-000'}
   * @param {Object} [options.headers] 一个对象，将发送的其他HTTP标头。比如：headers: { 'X-My-Header': 'valueOfHeader' }
   *
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑定，参数与popup属性完全相同。
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数,还包括：
   * @param {String} [options.tooltipOptions.title] 固定的标题名称
   * @param {String} [options.tooltipOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.tooltipOptions.noTitle] 不显示标题
   * @param {Object} [options.contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class GeoJsonLayer
   * @extends {GraphicLayer}
   * @see [支持的事件类型]{@link GeoJsonLayer.EventType}
   */
  class GeoJsonLayer extends GraphicLayer {
    _showHook(val) {
      super._showHook(val);
      if (val && this._hasLoad) {
        this._hasLoad = false;
        this.load();
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      super._addedHook();
      if (this.show) {
        this.load();
      } else {
        this._hasLoad = true;
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      super._removedHook();
      this.clear();
    }

    /**
     * 加载新数据 或 刷新数据
     *
     * @param {Object} [newOptions] 新设定的参数，会与类的构造参数合并。
     * @param {String} [newOptions.url] geojson文件或服务url地址
     * @param {Object} [newOptions.data] geojson格式规范数据对象，与url二选一即可。
     * @param {Object} [newOptions.类参数] 包含当前类支持的所有参数
     * @return {GeoJsonLayer} 当前对象本身，可以链式调用
     */
    load(newOptions) {
      if (newOptions) {
        if (Cesium__namespace.defaultValue(newOptions.clear, true)) {
          delete this.options.url;
          delete this.options.data;
        }
        this.clear();

        this.options = {
          ...this.options,
          ...newOptions
        };
      }

      if (this.options.url) {
        fetchJson({ ...this.options, proxy: this._proxy })
          .then((data) => {
            if (!this._map || this._state !== State.ADDED) {
              return
            }
            this._load_data(data);
          })
          .catch((error) => {
            logError("fetchJson出错了", error);
            this._readyPromise && this._readyPromise.reject(error);
          });
      } else if (this.options.data) {
        this._load_data(this.options.data);
      } else {
        if (newOptions) {
          logWarn("GeoJsonLayer：没有传入 url 或 data 参数,请确认是否有误。");
        }
      }
    }

    // geojson转换为图层的矢量数据对象
    _load_data(geojson) {
      if (this.options.format) {
        geojson = this.options.format(geojson);
      }

      // 如果是行政区域反选遮罩层
      this._formatForMask(geojson);

      const arr = this.loadGeoJSON(geojson, { clear: true });

      const listAttr = [];
      arr.forEach((graphic) => {
        listAttr.push({
          ...graphic.attr,
          graphic: graphic
        });
      });

      this.fire(EventType.load, { geojson: geojson, list: listAttr, graphics: arr });

      if (this.options.flyTo) {
        this.flyToByAnimationEnd();
      }

      this._readyPromise.resolve(this);
    }

    // 如果是行政区域反选遮罩层
    _formatForMask(geojson) {
      const maskCfg = this.options.mask;
      if (!maskCfg) {
        return
      }

      if (!geojson.features || geojson.features.length === 0) {
        return
      }

      // 只保留1个feature
      geojson.features.splice(1, geojson.features.length - 1);

      this._extent = getExtentByGeoJSON(geojson);

      let extent = { xmin: 73.0, xmax: 136.0, ymin: 3.0, ymax: 59.0 };
      if (
        isObject(maskCfg) &&
        Cesium__namespace.defined(maskCfg.xmin) &&
        Cesium__namespace.defined(maskCfg.xmax) &&
        Cesium__namespace.defined(maskCfg.ymin) &&
        Cesium__namespace.defined(maskCfg.ymax)
      ) {
        extent = maskCfg;
      }

      const outPositions = [
        [extent.xmin, extent.ymax],
        [extent.xmin, extent.ymin],
        [extent.xmax, extent.ymin],
        [extent.xmax, extent.ymax],
        [extent.xmin, extent.ymax]
      ];

      const feature = geojson.features[0];
      if (feature.geometry.type === "MultiPolygon") {
        const coordinates = [outPositions];
        for (let i = 0, len = feature.geometry.coordinates.length; i < len; i++) {
          const thisCoor = feature.geometry.coordinates[i];

          coordinates.push(thisCoor[0]);
        }
        feature.geometry = { type: "Polygon", coordinates: [coordinates] };
      } else {
        feature.geometry = { type: "Polygon", coordinates: [outPositions, feature.geometry.coordinates[0]] };
      }

      return geojson
    }

    _toJsonEx(newData) {
      // 覆盖
    }
  }

  // 注册下
  register$2("geojson", GeoJsonLayer);

  /**
   * 3dtiles对象 标绘处理对应的编辑类
   *
   * @export
   * @class EditTileset
   * @extends {EditBase}
   */
  class EditTileset extends EditBase {
    get layer() {
      return this._graphic
    }

    get style() {
      return this._graphic.options
    }

    bindDraggers() {
      this._contextmenuConfig_bak = this.layer._contextmenuConfig;

      this.createDragger({
        dragger: this._graphic,
        onDrag: (dragger, newPosition) => {
          this._graphic.position = newPosition;
        }
      });
    }

    // 图形编辑结束后调用
    finish() {
      delete this._graphic._draw_tooltip;
      delete this._graphic._isDragger;
      delete this._graphic._noMousePick;
      delete this._graphic._pointType;
      delete this._graphic.onDrag;

      this._graphic.unbindContextMenu();
      if (this._contextmenuConfig_bak) {
        this.layer._contextmenuConfig = this._contextmenuConfig_bak;
        delete this._contextmenuConfig_bak;
      }
    }

    _onLeftDownHandler(event) {
      const result = this._map.mouseEvent.getPickTarget(event.position, event);
      if (result.layer !== this.layer) {
        return
      }

      const layer = result?.layer;
      if (!layer || !layer._isDragger) {
        return
      }

      if (this._map.scene.screenSpaceCameraController.enableInputs) {
        this._map.scene.screenSpaceCameraController.enableInputs = false;
        this._hasChangeEnableInputs = true;
      }

      this._map._setEditCursor(true);
      layer._closeAllControl();

      this._draggerIng = layer;

      this.fire(EventType.editMouseDown, { ...event, ...result, index: this._draggerIng.index });
    }

    _onMouseMoveDraggerHandler(event) {
      // 默认修改位置
      this._map.openSmallTooltip(event.endPosition, this._map.getLangText("_释放后完成修改"));

      const cartesian = getCurrentMouseTerrainPosition(this._map.scene, event.endPosition);
      if (cartesian) {
        if (this._draggerIng.onDrag) {
          this._draggerIng.onDrag(this._draggerIng, cartesian);
        }
      }

      this.fire(EventType.editMouseMove, { ...event, index: this._draggerIng.index, cartesian: cartesian, windowPosition: event.endPosition });
    }

    _onMouseMoveMapHandler(event) {
      const result = this._map.mouseEvent.getPickTarget(event.endPosition, event);
      const layer = result?.layer;
      if (layer == null) {
        this._map.closeSmallTooltip();
        return
      }

      if (result.layer !== this.layer || !layer._isDragger) {
        return
      }
      // 右键菜单打开了，跳出
      if (this._map.contextmenu.show && this._map.contextmenu.target === layer) {
        return
      }

      const _draw_tooltip = layer._draw_tooltip;
      if (!_draw_tooltip) {
        return
      }
      this._map.openSmallTooltip(event.endPosition, _draw_tooltip);
    }

    getDraggerContextMenu(dragger) {
      const arr = super.getDraggerContextMenu(dragger);

      // 3轴方向
      if (Cesium__namespace.defaultValue(this.style.hasEditRotate, true)) {
        arr.push({
          text: "按轴旋转",
          icon: Icon.BloomEffectYes,
          show: (event) => {
            return !this._matrixRotate || this._matrixRotate._dragger_index !== dragger.index
          },
          callback: (event) => {
            const target = event.graphic?.position ? event.graphic : event.layer;
            this._startMatrixRotate(target, event);
          }
        });
        arr.push({
          text: "停止按轴旋转",
          icon: Icon.BloomEffectNo,
          show: (event) => {
            return this._matrixRotate && this._matrixRotate._dragger_index === dragger.index
          },
          callback: (event) => {
            this._removeMatrixRotate();
          }
        });
      }

      return arr
    }

    // 旋转矩阵
    _startMatrixRotate(layer, eventRM) {
      this._removeMatrixMove();
      this._removeMatrixRotate();

      this._matrixRotate = new MatrixRotate({
        map: this._map,
        position: layer.position,
        roll: layer.rotation_x,
        pitch: layer.rotation_y,
        heading: layer.rotation_z
      });
      this._map.addThing(this._matrixRotate);

      this._matrixRotate.on(EventType.change, (event) => {
        layer.rotation = {
          x: formatNum$1(event.roll, 2),
          y: formatNum$1(event.pitch, 2),
          z: formatNum$1(event.heading, 2)
        };
      });

      // 同步坐标
      layer.off(EventType.updatePosition, this._updateMatrixMovePosition, this);
      layer.off(EventType.updatePosition, this._updateMatrixRotatePosition, this);
      layer.on(EventType.updatePosition, this._updateMatrixRotatePosition, this);
    }
  }

  var TilesetEditVS = "attribute vec3 position;\nvarying vec2 depth;\n\nvoid main() {\n  vec4 pos = vec4(position.xyz, 1.0);\n  depth = pos.zw;\n  pos.z = 0.0;\n  gl_Position = czm_projection * pos;\n}\n"; // eslint-disable-line

  var TilesetEditFS = "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define OES_texture_float_linear\n\nvarying vec2 depth;\n\nvec4 packDepth(float depth) {\n  vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  enc = fract(enc);\n  enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return enc;\n}\n\nvoid main() {\n  float fDepth = (depth.x / 5000.0) / 2.0 + 0.5;\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n"; // eslint-disable-line

  /**
   * 3dtiles模型分析（裁剪、压平、淹没） 基础类
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {TilesetLayer} options.layer 需要模型分析的对象（3dtiles图层）
   * @param {Object[]} [options.area] 多区域数组对象, 示例： [{ positions: [[108.959062, 34.220134, 397], [108.959802, 34.220147, 397], [108.959106, 34.21953, 398]] }]
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class TilesetEditBase
   * @extends {BaseThing}
   */
  class TilesetEditBase extends BaseThing {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      if (!isMars3DCesium) {
        logError("该功能需要引入mars3d修改版Cesium库(mars3d-cesium库)才支持!", this);
      }

      this._areaList = []; // 区域数组
    }
    //= ========= 对外属性 ==========

    get marsEditor() {
      return this._layer._marsEditor
    }

    /**
     * 区域 列表
     * @type {Object[]}
     * @readonly
     */
    get list() {
      return this._areaList
    }

    /**
     * 需要分析的模型（3dtiles图层）
     * @type {TilesetLayer}
     */
    get layer() {
      return this._layer
    }

    set layer(tilesetLayer) {
      this._layer = tilesetLayer;

      tilesetLayer.readyPromise.then((e) => {
        if (!this.isAdded) {
          return
        }

        this._initLayer(tilesetLayer.tileset);

        if (this.options.area) {
          this.options.area.forEach((element) => {
            this.addArea(element.positions, element);
          });
        }
      });
    }

    /**
     * 需要分析的模型 对应的 Cesium3DTileset 对象
     * @type {Cesium.Cesium3DTileset}
     * @readonly
     */
    get tileset() {
      return this._layer.tileset
    }

    /**
     * 压平高度 (单位：米)，基于压平区域最低点高度的偏移量
     * @type {Number}
     * @readonly
     */
    get layerHeight() {
      const tilesetLayer = this.layer;
      if (tilesetLayer?.options?.flatHeight) {
        return tilesetLayer.options.flatHeight
      }
      if (this.options.flatHeight) {
        return this.options.flatHeight
      }
      return 0
    }

    /**
     * 已添加的区域个数
     * @type {Number}
     * @readonly
     */
    get length() {
      if (this._areaList) {
        return this._areaList?.length
      } else {
        return 0
      }
    }

    //= ========= 方法 ==========

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      if (this.options.layer) {
        this.layer = this.options.layer;
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.clear();

      if (this.cacheMarsOptions) {
        this.cacheMarsOptions();
      }
    }

    /**
     * 清除分析
     * @return {void}  无
     */
    clear() {
      this._areaList = [];
      this._disable();
    }

    /**
     * 根据id获取区域对象
     *
     * @param {Number} id id值
     * @return {Object} 区域对象
     */
    getAreaById(id) {
      if (!isNumber(id)) {
        return id
      }

      for (let i = 0; i < this._areaList.length; i++) {
        const item = this._areaList[i];
        if (item.id === id) {
          return item
        }
      }
      return null
    }

    /**
     * 隐藏单个区域
     * @param {Number} id 区域id值
     * @return {void}  无
     */
    hideArea(id) {
      const item = this.getAreaById(id);
      if (item) {
        item.show = false;

        this._isUpdate = true;
      }
    }

    /**
     * 显示单个区域
     * @param {Number} id 区域id值
     * @return {void}  无
     */
    showArea(id) {
      const item = this.getAreaById(id);
      if (item) {
        item.show = true;

        this._isUpdate = true;
      }
    }

    /**
     * 移除单个区域
     * @param {Number|Object} item 区域的id，或 addArea返回的区域对象
     * @return {void}  无
     */
    removeArea(item) {
      if (isNumber(item)) {
        item = this.getAreaById(item);
      }
      if (item) {
        removeArrayItem(this._areaList, item);

        this._disable();
        this._activete();

        this.fire(EventType.removeItem, { area: item });
      }
    }

    /**
     * 添加区域
     *
     * @param {String[]|Array[]|LngLatPoint[]|Cesium.Cartesian3[]} positions 坐标位置数组
     * @return {Object} 添加区域的记录对象
     */
    addArea(positions) {
      if (!positions || positions.length === 0) {
        return
      }
      positions = LngLatArray.toCartesians(positions);

      const areaObj = {
        id: getGlobalId(),
        show: true,
        positions: positions
      };
      this._areaList.push(areaObj);

      if (this._layer.loadOk) {
        this._disable();
        this._activete();
      }

      this.fire(EventType.addItem, { area: areaObj });

      return areaObj
    }

    // 对模型初始化参数
    _initLayer(tileset) {
      if (this._areaList.length > 0) {
        this._disable();
        this._activete();
      }

      // 劫持3dtiles更新函数
      const tileset_update_old = tileset.update;
      const that = this;
      tileset.update = function (frameState) {
        if (that._isUpdate) {
          that._update(frameState);
        }
        tileset_update_old.bind(this)(frameState);
      };

      this.cacheMarsOptions = function () {
        tileset.update = tileset_update_old;
      };
    }

    _activete() {
      if (!this.layer) {
        return
      }

      this._preparePos();
      this._createTexture();
    }

    _disable() {
      if (this.marsEditor.polygonTexture) {
        this.marsEditor.polygonTexture.destroy();
        this.marsEditor.polygonTexture = null;
      }
      if (this._framebuffer && this._framebuffer.destroy) {
        this._framebuffer.destroy();
        this._framebuffer = null;
      }

      this.marsEditor.IsYaPing = new Cesium__namespace.Cartesian4(false, false, false, false); // [是否开启编辑，是否开启压平，是否开启裁剪，是否开启淹没]
      this.marsEditor.editVar = new Cesium__namespace.Cartesian4(false, false, false, false); // [是否开启裁剪外部，是否开启淹没全局，]

      this.marsEditor.floodColor = new Cesium__namespace.Cartesian4(0.15, 0.7, 0.95, 0.5); // [淹没颜色的r(0-1之间)，淹没颜色的g，淹没颜色的b，淹没混合系数（建议取值范围0.3-0.7）]
      this.marsEditor.floodVar = new Cesium__namespace.Cartesian4(0, 0, 0, 0); // [基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]
      this.marsEditor.heightVar = new Cesium__namespace.Cartesian2(0, 0); // 基础压平高度，调整压平高度值

      this._isUpdate = true;
    }

    // 更新纹理
    _update(frameState) {
      if (!this._areaList || this._areaList.length === 0) {
        return
      }
      this._createCommand();
      this._activeMarsEditor();

      const context = frameState.context;
      const width = 4096;
      const height = 4096;
      if (!this._passState) {
        this._passState = new Cesium__namespace.PassState(context);
      }
      this._passState.framebuffer = this._framebuffer;
      this._passState.viewport = new Cesium__namespace.BoundingRectangle(0, 0, width, height);

      const us = context.uniformState;
      us.updateCamera(this._camera);

      this._fboClearCommand.execute(frameState.context);

      this._areaList.forEach((areaObj) => {
        const command = areaObj.drawCommand;
        if (command && areaObj.show) {
          us.updatePass(command.pass);
          command.framebuffer = this._framebuffer;
          command.execute(context, this._passState);
        }
      });

      this._isUpdate = false;
    }

    _activeMarsEditor() {}

    deActiveEdit() {
      // 激活
      this.marsEditor.IsYaPing.x = false;
    }

    // 预处理顶点
    _preparePos() {
      let minZAll = 99999;
      this._areaList.forEach((areaObj) => {
        if (!areaObj.show) {
          return
        }

        if (!areaObj.positions_local) {
          const positions_local = []; // 将多边形顶点转换到tile局部坐标系中计算 减少顶点过大引起float精度问题
          let minZ = 99999;
          for (let i = 0; i < areaObj.positions.length; i++) {
            positions_local[i] = Cesium__namespace.Matrix4.multiplyByPoint(this._layer.inverseMatrix, areaObj.positions[i], new Cesium__namespace.Cartesian3());
            minZ = Math.min(minZ, positions_local[i].z);
          }

          areaObj.positions_local = positions_local;
          areaObj.minZ = minZ;
        }

        minZAll = Math.min(minZAll, areaObj.minZ);
      });
      this._minLocalZ = minZAll;
    }

    _createTexture() {
      // 创建FBO以及清除指令
      const context = this._map.scene.context;

      this.marsEditor.polygonTexture = new Cesium__namespace.Texture({
        context: context,
        width: 4096,
        height: 4096,
        pixelFormat: Cesium__namespace.PixelFormat.RGBA,
        pixelDatatype: Cesium__namespace.PixelDatatype.FLOAT,
        sampler: new Cesium__namespace.Sampler({
          wrapS: Cesium__namespace.TextureWrap.CLAMP_TO_EDGE,
          wrapT: Cesium__namespace.TextureWrap.CLAMP_TO_EDGE,
          minificationFilter: Cesium__namespace.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium__namespace.TextureMagnificationFilter.NEAREST
        })
      });

      const depthStencilTexture = new Cesium__namespace.Texture({
        context: context,
        width: 4096,
        height: 4096,
        pixelFormat: Cesium__namespace.PixelFormat.DEPTH_STENCIL,
        pixelDatatype: Cesium__namespace.PixelDatatype.UNSIGNED_INT_24_8
      });

      this._framebuffer = new Cesium__namespace.Framebuffer({
        context: context,
        colorTextures: [this.marsEditor.polygonTexture],
        depthStencilTexture: depthStencilTexture,
        destroyAttachments: false
      });

      this._fboClearCommand = new Cesium__namespace.ClearCommand({
        color: new Cesium__namespace.Color(0.0, 0.0, 0.0, 0.0),
        framebuffer: this._framebuffer
      });
    }

    _createCommand() {
      // 创建指令
      const context = this._map.scene.context;

      let minX = 1e10;
      let minY = 1e10;
      let maxX = -1e10;
      let maxY = -1e10;

      this._areaList.forEach((areaObj) => {
        const positions_local = areaObj.positions_local;
        if (positions_local) {
          // 创建geometry
          const flattenPolygon = new Cesium__namespace.PolygonGeometry({
            polygonHierarchy: new Cesium__namespace.PolygonHierarchy(positions_local),
            perPositionHeight: true
          });
          const ppp = Cesium__namespace.PolygonGeometry.createGeometry(flattenPolygon);
          const sp = Cesium__namespace.ShaderProgram.fromCache({
            context: context,
            vertexShaderSource: TilesetEditVS,
            fragmentShaderSource: TilesetEditFS,
            attributeLocations: {
              position: 0
            }
          });
          const vao = Cesium__namespace.VertexArray.fromGeometry({
            context: context,
            geometry: ppp,
            attributeLocations: sp._attributeLocations,
            bufferUsage: Cesium__namespace.BufferUsage.STATIC_DRAW,
            interleave: true
          });

          const rs = new Cesium__namespace.RenderState();
          rs.depthTest.enabled = false;
          rs.depthRange.near = -1000000.0;
          rs.depthRange.far = 1000000.0;

          const bg = Cesium__namespace.BoundingRectangle.fromPoints(areaObj.positions_local, new Cesium__namespace.BoundingRectangle());
          if (minX > bg.x) {
            minX = bg.x;
          }
          if (minY > bg.y) {
            minY = bg.y;
          }
          if (maxX < bg.x + bg.width) {
            maxX = bg.x + bg.width;
          }
          if (maxY < bg.y + bg.height) {
            maxY = bg.y + bg.height;
          }

          const myPorjection = Cesium__namespace.Matrix4.computeOrthographicOffCenter(
            bg.x,
            bg.x + bg.width,
            bg.y,
            bg.y + bg.height,
            1,
            500000000,
            new Cesium__namespace.Matrix4()
          );

          areaObj._flatExtent = new Cesium__namespace.Cartesian4(bg.x, bg.y, bg.x + bg.width, bg.y + bg.height);

          areaObj.drawCommand = new Cesium__namespace.DrawCommand({
            boundingVolume: ppp.boundingVolume,
            primitiveType: Cesium__namespace.PrimitiveType.TRIANGLES,
            vertexArray: vao,
            shaderProgram: sp,
            renderState: rs,
            pass: Cesium__namespace.Pass.CESIUM_3D_TILE,
            uniformMap: {
              myPorjection: function () {
                return myPorjection
              }
            }
          });
        }
      });
      this.marsEditor.flatExtent = new Cesium__namespace.Cartesian4(minX, minY, maxX, maxY);

      // 创建相机
      const _camera = {
        viewMatrix: Cesium__namespace.Matrix4.IDENTITY,
        inverseViewMatrix: Cesium__namespace.Matrix4.IDENTITY,
        frustum: new Cesium__namespace.OrthographicOffCenterFrustum(),
        positionCartographic: new Cesium__namespace.Cartographic(),
        positionWC: new Cesium__namespace.Cartesian3(),
        directionWC: Cesium__namespace.Cartesian3.UNIT_Z,
        upWC: Cesium__namespace.Cartesian3.UNIT_Y,
        rightWC: Cesium__namespace.Cartesian3.UNIT_X,
        viewProjectionMatrix: Cesium__namespace.Matrix4.IDENTITY
      };
      _camera.frustum.left = minX;
      _camera.frustum.top = maxY;
      _camera.frustum.right = maxX;
      _camera.frustum.bottom = minY;
      this._camera = _camera;
    }
  }

  /**
   * 3dtiles模型裁剪
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {TilesetLayer} options.layer 需要裁剪的对象（3dtiles图层）
   * @param {Object[]} [options.area] 多区域数组对象, 示例： [{ positions: [[108.959062, 34.220134, 397], [108.959802, 34.220147, 397], [108.959106, 34.21953, 398]] }]
   * @param {Boolean} [options.clipOutSide = false] 是否外裁剪
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class TilesetClip
   * @extends {TilesetEditBase}
   */
  class TilesetClip extends TilesetEditBase {
    /**
     * 是否外裁剪
     * @type {Boolean}
     */
    get clipOutSide() {
      return this.options.clipOutSide
    }

    set clipOutSide(val) {
      this.options.clipOutSide = val;

      this.marsEditor.editVar.x = val;
    }

    _activeMarsEditor() {
      this.marsEditor.IsYaPing.x = true;
      this.marsEditor.IsYaPing.z = true;
      this.marsEditor.editVar.x = Boolean(this.clipOutSide);
    }
  }

  /**
   * 3dtiles模型压平
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {TilesetLayer} options.layer 需要压平的对象（3dtiles图层）
   * @param {Object[]} [options.area] 多区域数组对象, 示例： [{ positions: [[108.959062, 34.220134, 397], [108.959802, 34.220147, 397], [108.959106, 34.21953, 398]] }]
   * @param {Number} [options.height] 压平高度 (单位：米)，基于压平区域最低点高度的偏移量
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class TilesetFlatOld
   * @extends {TilesetEditBase}
   */
  class TilesetFlatOld extends TilesetEditBase {
    /**
     * 压平高度 (单位：米)，基于压平区域最低点高度的偏移量
     * @type {Number}
     */
    get height() {
      return this.options.height || 0
    }

    set height(val) {
      this.updateHeight(val);
    }

    _activeMarsEditor() {
      this.marsEditor.IsYaPing.x = true;
      this.marsEditor.IsYaPing.y = true;
      this.marsEditor.heightVar.x = this._minLocalZ;
      this.marsEditor.heightVar.y = this.layerHeight + this.height;
    }

    /**
     * 更新压平高度 (单位：米)
     * @param {Number} height 高度值（单位：米）
     * @returns {void}
     */
    updateHeight(height) {
      this.options.height = height;
      this.marsEditor.heightVar.y = this.layerHeight + height;
    }
  }

  /**
   * 3dtiles模型压平
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {TilesetLayer} options.layer 需要压平的对象（3dtiles图层）
   * @param {Object[]} [options.area] 多区域数组对象, 示例： [{ positions: [[108.959062, 34.220134, 397], [108.959802, 34.220147, 397], [108.959106, 34.21953, 398]] }]
   * @param {Number} [options.flatHeight]  模型基准高度(单位：米)，基于压平区域最低点高度的纠偏，也支持定义在模型图层中
   * @param {Boolean} [options.old] 使用老版本压平，即内部自动使用{@link TilesetFlatOld}类
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class TilesetFlat
   * @extends {TilesetEditBase}
   */
  class TilesetFlat extends BaseThing {
    constructor(options = {}) {
      super(options);

      if (options.old) {
        return new TilesetFlatOld(options)
      }

      if (!isMars3DCesium) {
        logError("该功能需要引入mars3d修改版Cesium库(mars3d-cesium库)才支持!", this);
      }

      // 是否开启区域抬高
      this._raise = options.raise ?? true;

      this._polygonFloat32 = [];
      this._matrixFloat32 = [];
      this._areaList = []; // 区域数组

      this._multipleDirty = false;
      this._onUpdate = false;
      this._isUpdate = false;
      this._maxPositionsLength = -1;

      this._flatExtent = new Cesium__namespace.Cartesian4();
    }

    //= ========= 对外属性 ==========

    /**
     * 区域 列表
     * @type {Object[]}
     * @readonly
     */
    get list() {
      return this._areaList
    }

    /**
     * 需要分析的模型（3dtiles图层）
     * @type {TilesetLayer}
     */
    get layer() {
      return this._layer
    }

    set layer(tilesetLayer) {
      this._layer = tilesetLayer;

      tilesetLayer.readyPromise.then((e) => {
        if (!this.isAdded) {
          return
        }

        this._initLayer(tilesetLayer.tileset);

        if (this.options.area) {
          this.options.area.forEach((element) => {
            this.addArea(element.positions, element);
          });
        }
      });
    }

    /**
     * 需要分析的模型 对应的 Cesium3DTileset 对象
     * @type {Cesium.Cesium3DTileset}
     * @readonly
     */
    get tileset() {
      return this._layer.tileset
    }

    /**
     * 压平高度 (单位：米)，基于压平区域最低点高度的偏移量
     * @type {Number}
     * @readonly
     */
    get layerHeight() {
      const tilesetLayer = this.layer;
      if (tilesetLayer?.options?.flatHeight) {
        return tilesetLayer.options.flatHeight
      }
      if (this.options.flatHeight) {
        return this.options.flatHeight
      }
      return 0
    }

    /**
     * 已添加的区域个数
     * @type {Number}
     * @readonly
     */
    get length() {
      if (this._areaList) {
        return this._areaList?.length
      } else {
        return 0
      }
    }

    //= ========= 方法 ==========
    // _enabledHook(val) {}

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      if (this.options.layer) {
        this.layer = this.options.layer;
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.clear();

      if (this.cacheMarsOptions) {
        this.cacheMarsOptions();
      }
    }

    clear() {
      if (Cesium__namespace.defined(this._polygonTexture)) {
        this._polygonTexture.destroy();
        this._polygonTexture = null;
      }

      if (Cesium__namespace.defined(this._matrixTexture)) {
        this._matrixTexture.destroy();
        this._matrixTexture = null;
      }

      this._polygonFloat32 = [];
      this._matrixFloat32 = [];
      this._areaList = []; // 区域数组

      this._multipleDirty = false;
      this._onUpdate = false;
      this._isUpdate = false;
      this._maxPositionsLength = -1;
    }

    /**
     * 添加单个区域
     *
     * @param {String[]|Array[]|LngLatPoint[]|Cesium.Cartesian3[]} positions 坐标位置数组
     * @param {Object} [options={}] 控制的参数
     * @param {Object} [options.height] 开挖深度（地形开挖时，可以控制单个区域的开挖深度）
     * @return {Promise<Object>} 添加区域的记录对象
     */
    addArea(positions, options = {}) {
      if (!positions || positions.length === 0) {
        return
      }
      positions = LngLatArray.toCartesians(positions);

      this._maxPositionsLength = Math.max(this._maxPositionsLength, positions.length);

      const areaObj = {
        id: getGlobalId(),
        show: true,
        height: options.height || 0,
        positions: positions
      };
      this._areaList.push(areaObj);

      if (this._layer.loadOk) {
        this._isUpdate = true;
        this._onUpdate = true;
      }

      this.fire(EventType.addItem, { area: areaObj });

      return areaObj
    }

    /**
     * 根据id获取区域对象
     *
     * @param {Number} id id值
     * @return {Object} 区域对象
     */
    getAreaById(id) {
      if (!isNumber(id)) {
        return
      }

      for (let i = 0; i < this._areaList.length; i++) {
        const item = this._areaList[i];
        if (item.id === id) {
          return item
        }
      }
      return null
    }

    /**
     * 更新压平高度 (单位：米)
     * @param {Number} height 高度值（单位：米）
     * @param {Number} [id]  区域对象id
     * @returns {void}
     */
    updateHeight(height, id) {
      if (Cesium__namespace.defined(id)) {
        const item = this.getAreaById(id);
        if (item) {
          item.height = height;
          this._multipleDirty = true;
        }
      } else {
        for (let i = 0; i < this._areaList.length; i++) {
          const item = this._areaList[i];
          item.height = height;
        }
        this._multipleDirty = true;
      }
    }

    /**
     * 隐藏单个区域
     * @param {Number} id 区域id值
     * @return {void}  无
     */
    hideArea(id) {
      const item = this.getAreaById(id);
      if (item) {
        item.show = false;

        this._multipleDirty = true;
      }
    }

    /**
     * 显示单个区域
     * @param {Number} id 区域id值
     * @return {void}  无
     */
    showArea(id) {
      const item = this.getAreaById(id);
      if (item) {
        item.show = true;

        this._multipleDirty = true;
      }
    }

    /**
     * 移除单个区域
     * @param {Number|Object} item 区域的id，或 addArea返回的区域对象
     * @return {void}  无
     */
    removeArea(item) {
      if (isNumber(item)) {
        item = this.getAreaById(item);
      }
      if (item) {
        removeArrayItem(this._areaList, item);
        this._multipleDirty = true;

        this.fire(EventType.removeItem, { area: item });
      }
    }

    // 对模型初始化参数
    _initLayer(tileset) {
      // 劫持3dtiles更新函数
      const tileset_update_old = tileset.update;
      const that = this;
      tileset.update = function (frameState) {
        if (that._isUpdate) {
          that._update(frameState);
        }
        tileset_update_old.bind(this)(frameState);
      };

      // UniformMap
      const tilesetHeight = this.layerHeight;
      const defaultTexture = this._map.scene.context.defaultTexture;
      const updateModelUniformMap = tileset._marsOptions.updateModelUniformMap;

      // 模型mv矩阵
      updateModelUniformMap.u_mars_mvMatrix = function (model) {
        if (this.u_mv) {
          return this.u_mv()
        }
        if (this.u_modelViewMatrix) {
          return this.u_modelViewMatrix()
        }
        return Cesium__namespace.Cartesian4.ZERO
      };
      // 修改的模型高程
      updateModelUniformMap.u_mars_tilesetHeight = () => {
        return tilesetHeight + (this._flatExtent?.minz || 0)
      };
      // 多边形数组纹理
      updateModelUniformMap.u_mars_flatPolygonTexture = () => {
        return this._polygonTexture ?? defaultTexture
      };
      // 矩阵数组纹理
      updateModelUniformMap.u_mars_matrixTexture = () => {
        return this._matrixTexture ?? defaultTexture
      };
      // 多边形外包矩形
      updateModelUniformMap.u_mars_flatExtent = () => {
        return this._flatExtent ?? Cesium__namespace.Cartesian4.ZERO
      };
      // 单个网格大小
      updateModelUniformMap.u_mars_size = () => {
        // 获取纹理图每行行内平均宽距 / 网格大小
        const gridSize = 1 / ((this._maxPositionsLength || 0) - 1);
        return parseFloat(gridSize.toFixed(3))
      };
      // 行宽
      updateModelUniformMap.u_mars_width = () => {
        // 获取纹理图行宽 / 网格横向平均宽度
        const lengths = this._areaList?.length || 0;
        const rowWidth = lengths <= 1 ? 0 : 1 / (lengths - 1);
        return parseFloat(rowWidth.toFixed(3))
      };
      // 行数
      updateModelUniformMap.u_mars_rows = () => {
        // 获取纹理图行数 / 网格横向总高度
        return parseFloat(this._areaList?.length ?? 0)
      };
      // 区域平整
      updateModelUniformMap.u_mars_raise = () => {
        return this._raise
      };

      const upZ = this._layer.upAxis === Cesium__namespace.Axis.Z;
      tileset._marsOptions.updateModelVS = (drawVS) => {
        return this._updateVertexShader(drawVS, upZ)
      };

      this.cacheMarsOptions = function () {
        tileset.update = tileset_update_old;
        delete tileset._marsOptions.updateModelVS;

        // delete updateModelUniformMap.u_mars_tilesetHeight
        // delete updateModelUniformMap.u_mars_flatPolygonTexture
        // delete updateModelUniformMap.u_mars_matrixTexture
        // delete updateModelUniformMap.u_mars_flatExtent
        // delete updateModelUniformMap.u_mars_size
        // delete updateModelUniformMap.u_mars_width
        // delete updateModelUniformMap.u_mars_rows
      };
    }

    _updateVertexShader(drawVS, upZ) {
      let mcPos = "a_pos";
      if (drawVS.indexOf("a_position") !== -1) {
        mcPos = "a_position";
      }
      if (!upZ && drawVS.indexOf("gltf_a_dec_position") !== -1) {
        mcPos = "gltf_a_dec_position";
      }

      drawVS =
        `
    ${!this.layer.transform ? "#define MARS3D_CUSTOM_MVP" : ""}
    uniform sampler2D u_mars_flatPolygonTexture;
    uniform sampler2D u_mars_matrixTexture;
    uniform bool u_mars_raise;
    // uniform bool u_mars_modelUpZ;
    uniform vec4 u_mars_flatExtent;
    uniform float u_mars_size;
    uniform float u_mars_width;
    uniform float u_mars_rows;
    uniform float u_mars_tilesetHeight;
    #ifdef MARS3D_CUSTOM_MVP
        uniform mat4 u_mars_tilesetMatrix;
        uniform mat4 u_mars_mvMatrix;
    #endif
    \n
  ` + drawVS;

      drawVS = Cesium__namespace.ShaderSource.replaceMain(drawVS, "mars3d_flat_main");

      drawVS =
        drawVS +
        `
    bool isPointInPolygon( vec2 start ,vec2 end, vec2 test){
        if ( ((start.y > test.y) != (end.y > test.y)) &&
            (test.x < ((end.x-start.x) * (test.y-start.y) / (end.y-start.y) + start.x)) )
            return true;
        return  false;
    }

    bool isInRect(vec2 minval,vec2 maxval,vec2 test){
        return test.x > minval.x && test.x < maxval.x && test.y > minval.y && test.y <maxval.y;
    }

    mat4 getInvWordMatrix(vec2 matUV , float matUVY){
        vec4 row1 = texture2D(u_mars_matrixTexture, vec2(matUV.x * 1.0, matUVY));
        vec4 row2 = texture2D(u_mars_matrixTexture, vec2(matUV.x * 2.0, matUVY));
        vec4 row3 = texture2D(u_mars_matrixTexture, vec2(matUV.x * 3.0, matUVY));
        vec4 row4 = texture2D(u_mars_matrixTexture, vec2(matUV.x * 4.0, matUVY));

        return mat4(row1,row2,row3,row4);
    }

   void main() {
      mars3d_flat_main();

      vec4 modelPos = vec4(${mcPos}, 1.0);

      vec2 matUV = vec2(0.25, u_mars_width);
      if(int(u_mars_rows)!=-1){
          for(int i = 0 ; i < 100; i++){
            if(int(u_mars_rows) == i)break;
            bool flatStatus = false;
            float matUVY = matUV.y * float(i);
            vec4 mars_row = texture2D(u_mars_matrixTexture, vec2(0.0, matUVY ));
            if(mars_row.w < 0.0)continue;
            mars_row.z = mars_row.z + u_mars_tilesetHeight;
            mat4 invWordMatrix = getInvWordMatrix(matUV , matUVY);

            vec4 localpos;
            #ifdef MARS3D_CUSTOM_MVP
                localpos = u_mars_mvMatrix * modelPos;
                localpos = czm_inverseView * localpos;
                localpos = invWordMatrix * localpos;
                if(!u_mars_raise&&localpos.z < mars_row.z)continue;
            #else
                localpos = invWordMatrix * czm_model * modelPos;
                if(!u_mars_raise&&modelPos.z < mars_row.z)continue;
            #endif

            if(!isInRect( vec2(u_mars_flatExtent.xy), vec2(u_mars_flatExtent.zw) , localpos.xy ))break;

            int len = int(mars_row.y);
            int jj = len - 1;
            for(int ii = 0 ; ii < 200; ii++){
                if(ii >= len )break;
                vec2 start = texture2D (u_mars_flatPolygonTexture, vec2(float(ii) * u_mars_size, matUVY)).xy;
                vec2 end = texture2D( u_mars_flatPolygonTexture, vec2(float(jj) * u_mars_size, matUVY)).xy;
                if(isPointInPolygon(start, end, localpos.xy)){
                    flatStatus = !flatStatus;
                }
                jj = ii;
            }
            if(flatStatus){
                vec4 position;
                #ifdef MARS3D_CUSTOM_MVP
                    localpos.z = mars_row.z;
                    localpos = u_mars_tilesetMatrix * localpos;
                    position = czm_view * localpos;
                #else
                    if(u_mars_modelUpZ)
                      modelPos.z = mars_row.z;
                    else
                      modelPos.y = mars_row.z;
                    position = u_modelViewMatrix * modelPos;
                #endif
                gl_Position = czm_projection * position;
                break;
            }
        }
      }
    }
  `;
      return drawVS
    }

    // 更新纹理
    _update(frameState) {
      const context = frameState.context;
      const useFloatTexture = context.floatingPointTexture;
      const height = this._maxPositionsLength * this._areaList.length;

      // 初始rt
      if (Cesium__namespace.defined(this._polygonTexture) && this._polygonTexture.width * this._polygonTexture.height !== height) {
        this._polygonTexture.destroy();
        this._polygonTexture = null;

        this._matrixTexture.destroy();
        this._matrixTexture = null;

        this._onUpdate = true;
      }

      if (this._onUpdate && this._maxPositionsLength > 3) {
        const resolution = new Cesium__namespace.Cartesian2(this._maxPositionsLength, this._areaList.length);

        if (useFloatTexture) {
          this._polygonTexture = new Cesium__namespace.Texture({
            context: context,
            width: resolution.x,
            height: resolution.y,
            pixelFormat: Cesium__namespace.PixelFormat.RGB,
            pixelDatatype: Cesium__namespace.PixelDatatype.FLOAT,
            sampler: Cesium__namespace.Sampler.NEAREST,
            flipY: false
          });
          this._polygonFloat32 = new Float32Array(resolution.x * resolution.y * 3);
          this._matrixTexture = new Cesium__namespace.Texture({
            context: context,
            width: 5,
            height: resolution.y,
            pixelFormat: Cesium__namespace.PixelFormat.RGBA,
            pixelDatatype: Cesium__namespace.PixelDatatype.FLOAT,
            sampler: Cesium__namespace.Sampler.NEAREST,
            flipY: false
          });
          this._matrixFloat32 = new Float32Array(5 * resolution.y * 4);
        }

        this._multipleDirty = true;
        this._onUpdate = false;
      }

      if (useFloatTexture && this._multipleDirty) {
        this._packPolygonFloatArray();

        this._polygonTexture.copyFrom({
          source: {
            width: this._polygonTexture.width,
            height: this._polygonTexture.height,
            arrayBufferView: this._polygonFloat32 // 存储边界float纹理
          }
        });

        this._matrixTexture.copyFrom({
          source: {
            width: this._matrixTexture.width,
            height: this._matrixTexture.height,
            arrayBufferView: this._matrixFloat32 // 存储矩阵float纹理
          }
        });

        this._multipleDirty = false;
      }
    }

    // 将多边形顶点坐标和变换矩阵打包成数组纹理
    _packPolygonFloatArray() {
      let polygonsLen = 0;
      let wordMatrixlen = 0;
      let east = -1e10;
      let west = 1e10;
      let north = -1e10;
      let south = 1e10;

      let minZAll = 1e10;

      // 遍历压平多边形数组
      for (let i = 0; i < this._areaList.length; i++) {
        const areaObj = this._areaList[i];
        if (!areaObj.show) {
          continue
        }

        if (!areaObj.positions_local) {
          const positions_local = []; // 将多边形顶点转换到tile局部坐标系中计算 减少顶点过大引起float精度问题
          let minZ = 99999;
          for (let i = 0; i < areaObj.positions.length; i++) {
            positions_local[i] = Cesium__namespace.Matrix4.multiplyByPoint(this._layer.inverseMatrix, areaObj.positions[i], new Cesium__namespace.Cartesian3());
            minZ = Math.min(minZ, positions_local[i].z);
          }

          areaObj.positions_local = positions_local;
          areaObj.minZ = minZ;
        }

        const polygon = areaObj.positions_local;
        minZAll = Math.min(minZAll, areaObj.minZ);

        // 填充多边形floatView
        for (let m = 0; m < this._maxPositionsLength; ++m) {
          let localpos = Cesium__namespace.Cartesian3.ZERO;

          // 更新外包矩形区域
          if (m < polygon.length) {
            localpos = polygon[m];
            east = localpos.x > east ? localpos.x : east;
            north = localpos.y > north ? localpos.y : north;
            west = localpos.x < west ? localpos.x : west;
            south = localpos.y < south ? localpos.y : south;
          }

          // 存储多边形区域
          this._polygonFloat32[polygonsLen] = localpos.x;
          this._polygonFloat32[polygonsLen + 1] = localpos.y;
          this._polygonFloat32[polygonsLen + 2] = localpos.z;
          polygonsLen += 3;
        }

        // 填充矩阵floatView
        this._matrixFloat32[wordMatrixlen++] = 1;
        this._matrixFloat32[wordMatrixlen++] = this._maxPositionsLength;
        this._matrixFloat32[wordMatrixlen++] = areaObj.height;

        if (areaObj.height === undefined) {
          this._matrixFloat32[wordMatrixlen++] = -1;
        } else {
          this._matrixFloat32[wordMatrixlen++] = 1;
        }

        for (let ii = 0; ii < 16; ii++) {
          this._matrixFloat32[wordMatrixlen++] = this._layer.inverseMatrix[ii];
        }
      }
      this._flatExtent.x = west;
      this._flatExtent.y = south;
      this._flatExtent.z = east;
      this._flatExtent.w = north;
      this._flatExtent.minz = minZAll;
    }
  }

  /**
   * @typedef {Object} TilesetFlood.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} start 开始分析
   * @property {String} change 变化了
   * @property {String} end  完成分析
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.end, function (event) {
   *   console.log('分析完成', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 3dtiles模型淹没分析
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {TilesetLayer} options.layer 需要裁剪的对象（3dtiles图层）
   * @param {Object[]} [options.area] 多区域数组对象, 示例： [{ positions: [[108.959062, 34.220134, 397], [108.959802, 34.220147, 397], [108.959106, 34.21953, 398]] }]
   * @param {Number} [options.speed] 淹没速度，米/秒（默认刷新频率为55Hz）
   * @param {Number} [options.minHeight] 淹没起始的海拔高度（单位：米）
   * @param {Number} [options.maxHeight] 淹没结束的海拔高度（单位：米）
   * @param {Cesium.Color|String} [options.color=new Cesium.Color(0.15, 0.7, 0.95, 0.5)] 淹没颜色
   * @param {Boolean} [options.floodAll] 是否对整个模型进行分析
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class TilesetFlood
   * @extends {TilesetEditBase}
   * @see [支持的事件类型]{@link TilesetFlood.EventType}
   */
  class TilesetFlood extends TilesetEditBase {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      this.options.speed = this.options.speed ?? 5;
      this.options.color = getCesiumColor(this.options.color, new Cesium__namespace.Color(0.15, 0.7, 0.95, 0.5));
    }

    /**
     * 淹没速度，米/秒（默认刷新频率为55Hz）
     * @type {Number}
     */
    get speed() {
      return this.options.speed
    }

    set speed(val) {
      this.options.speed = val;
    }

    /**
     * 是否对整个模型进行分析
     * @type {Boolean}
     */
    get floodAll() {
      return this.options.floodAll
    }

    set floodAll(val) {
      this.options.floodAll = val;

      this.marsEditor.editVar.y = val;
    }

    /**
     * 淹没高度（单位：米）
     * @type {Number}
     */
    get height() {
      return this.marsEditor.floodVar.y + this._localZOffset
    }

    set height(val) {
      this.marsEditor.floodVar.y = val - this._localZOffset;
    }

    /**
     * 淹没颜色
     * @type {Cesium.Color}
     */
    get color() {
      return this.options.color
    }

    set color(val) {
      this.options.color = val;
    }

    _activete() {
      this.setOptions();
      super._activete();
    }

    /**
     * 重新赋值参数，同构造方法参数一致。
     * @param {Object} options 参数,与类的构造方法参数相同
     * @return {TilesetFlood} 当前对象本身，可以链式调用
     */
    setOptions(options) {
      if (options) {
        this.options = {
          ...this.options,
          ...options
        };
      }
      this.stop();

      const center = this.layer?.center;
      if (Cesium__namespace.defined(this.options.minHeight)) {
        const minHeight = this.options.minHeight;
        const _minHeightLocalZ = this._getLocalZ(Cesium__namespace.Cartesian3.fromDegrees(center.lng, center.lat, minHeight));
        this._localZOffset = minHeight - _minHeightLocalZ;

        this.marsEditor.floodVar.x = _minHeightLocalZ;
        this.marsEditor.floodVar.y = _minHeightLocalZ;
      }
      if (Cesium__namespace.defined(this.options.maxHeight)) {
        const maxHeight = this.options.maxHeight;
        this.marsEditor.floodVar.z = this._getLocalZ(Cesium__namespace.Cartesian3.fromDegrees(center.lng, center.lat, maxHeight));
      }

      this.marsEditor.floodColor = new Cesium__namespace.Cartesian4(this.color.red, this.color.green, this.color.blue, this.color.alpha);

      this._activeMarsEditor();

      return this
    }

    _getLocalZ(position) {
      const currLocalPos = Cesium__namespace.Matrix4.multiplyByPoint(this._layer.inverseMatrix, position, new Cesium__namespace.Cartesian3());
      return Math.floor(currLocalPos.z) || 0
    }

    _activeMarsEditor() {
      this.marsEditor.IsYaPing.x = true;
      this.marsEditor.IsYaPing.w = true;
      this.marsEditor.floodVar.w = 200; // 相对模型的本地坐标系
      this.marsEditor.editVar.y = this.floodAll;
    }

    /**
     * 开始播放淹没动画效果
     * @return {void}  无
     */
    start() {
      this.stop();

      this.isStart = true;
      this.fire(EventType.start);

      this._map.on(EventType.clockTick, this._onClockTickHandler, this);
    }

    _onClockTickHandler(event) {
      this.marsEditor.floodVar.y += this.speed / 50; // 55帧每秒

      if (this.marsEditor.floodVar.y > this.marsEditor.floodVar.z) {
        this.marsEditor.floodVar.y = this.marsEditor.floodVar.z;
        this.stop();
        return
      }
      if (this.marsEditor.floodVar.y < this.marsEditor.floodVar.x) {
        this.marsEditor.floodVar.y = this.marsEditor.floodVar.x;
        this.stop();
        return
      }

      this.fire(EventType.change, {
        height: this.height
      });
    }

    /**
     * 暂停播放淹没动画效果
     * @return {void}  无
     */
    stop() {
      if (!this.isStart) {
        return
      }

      this._map.off(EventType.clockTick, this._onClockTickHandler, this);

      this.isStart = false;
      this.fire(EventType.end);
    }

    /**
     * 重新开始播放淹没动画效果
     * @return {void}  无
     */
    restart() {
      this.marsEditor.floodVar.y = this.marsEditor.floodVar.x;
      this.start();
    }

    /**
     * 清除分析
     * @return {void}  无
     */
    clear() {
      this.stop();
      super.clear();
    }
  }

  /**
   * 3dtiles模型裁剪，
   * 基于clippingPlanes接口，只支持单个开挖。
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {TilesetLayer} options.layer 需要裁剪的对象（3dtiles图层）
   * @param {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]} [options.positions] 裁剪区域坐标数组(按面或线裁剪)
   * @param {Number} [options.height] 当有裁剪区域挖时，底面的高度（单位米），未设置时不显示底面。
   *
   * @param {ClipType} [options.type]  裁剪类型（按方向类型正方向单面裁剪）
   * @param {Number} [options.distance=0] 裁剪的距离
   *
   * @param {Boolean} [options.clipOutSide = false] 是否外裁剪
   * @param {Number} [options.edgeWidth=0] 裁剪区域边线宽度，0时不显示
   * @param {Cesium.Color} [options.edgeColor=Cesium.Color.WHITE] 裁剪区域边线颜色
   *
   * @param {Boolean} [options.showPlane = false] 是否显示裁剪平面
   * @param {Boolean} [options.editPlane = false] 是否可以拖拽裁剪平面进行编辑，需要showPlane：true时有效
   * @param {PlaneEntity.StyleOptions} [options.planeStyle] 裁剪平面显示时的样式
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class TilesetPlanClip
   * @extends {BaseThing}
   */
  class TilesetPlanClip extends BaseThing {
    /**
     * 裁剪的对象模型 对应的 Cesium3DTileset 对象
     * @type {Cesium.Cesium3DTileset}
     * @private
     */
    get clipTarget() {
      return this._tileset
    }

    set clipTarget(val) {
      this._tileset = val;
      this._inverseMatrix = null;

      if (Cesium__namespace.defined(this.options.positions)) {
        this.positions = this.options.positions;
      }
      if (Cesium__namespace.defined(this.options.type)) {
        this.type = this.options.type;
      }
      if (Cesium__namespace.defined(this.options.distance)) {
        this.distance = this.options.distance;
      }
      if (Cesium__namespace.defined(this.options.normalZ)) {
        this.normalZ = this.options.normalZ;
      }
    }

    /**
     * 需要裁剪的对象（3dtiles图层）
     * @type {TilesetLayer}
     */
    get layer() {
      return this._layer
    }

    set layer(tilesetLayer) {
      this._layer = tilesetLayer;

      if (tilesetLayer.loadOk) {
        this.clipTarget = tilesetLayer.tileset;
      } else {
        tilesetLayer.on(EventType.load, (e) => {
          this.clipTarget = tilesetLayer.tileset;
        });
      }
    }

    /**
     * 裁剪面集合
     * @type {Cesium.ClippingPlaneCollection}
     * @readonly
     */
    get planes() {
      return this.clippingPlanes
    }

    /**
     * 获取当前转换计算模型逆矩阵，
     * 用于 局部坐标系 与 世界坐标系 的转换。
     * @type {Cesium.Matrix4}
     * @readonly
     */
    get inverseMatrix() {
      if (!this._inverseMatrix) {
        let transform;
        const tmp = this._tileset.root.transform;
        if ((tmp && tmp.equals(Cesium__namespace.Matrix4.IDENTITY)) || !tmp) {
          // 如果root.transform不存在，则3DTiles的原点变成了boundingSphere.center
          transform = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(this._tileset.boundingSphere.center);
        } else {
          transform = Cesium__namespace.Matrix4.fromArray(this._tileset.root.transform);
        }
        this._inverseMatrix = Cesium__namespace.Matrix4.inverseTransformation(transform, new Cesium__namespace.Matrix4());
      }
      return this._inverseMatrix
    }

    /**
     * 模型当前中心点坐标
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get center() {
      if (this._layer) {
        return this._layer.position
      }
      return this._tileset.boundingSphere.center
    }

    /**
     * 更新最后一个面的 裁剪距离 (单位：米)
     * @type {Number}
     */
    get distance() {
      return this._distance
    }

    set distance(val) {
      this._distance = val;

      if (this.clippingPlanes && this.clippingPlanes.length > 0) {
        const plane = this.clippingPlanes.get(this.clippingPlanes.length - 1);
        plane.distance = val;
      }
    }

    /**
     * 裁剪的斜面偏移量
     * @type {Number}
     */
    get normalZ() {
      return this._normalZ || 0
    }

    set normalZ(val) {
      this._normalZ = val;

      if (this.clippingPlanes && this.clippingPlanes.length > 0) {
        const plane = this.clippingPlanes.get(this.clippingPlanes.length - 1);
        plane.normal.z = val;
      }
    }

    /**
     * 裁剪类型（按方向类型正方向单面裁剪）
     * @type {ClipType}
     */
    get type() {
      return this._type
    }

    set type(val) {
      this._type = val;

      // 裁剪面
      let planes;
      switch (val) {
        case ClipType.Z: // 水平切底部
          planes = [
            new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(0, 0, 1), 1) // z水平面
          ];
          break
        case ClipType.ZR: // 水平切顶部
          planes = [
            new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(0, 0, -1), 1) // z水平面
          ];
          break
        case ClipType.X: // 东西方向切1
          planes = [
            new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(1, 0, 0), 1) // x垂直面
          ];
          break
        case ClipType.XR: // 东西方向切2
          planes = [
            new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(-1, 0, 0), 1) // x垂直面
          ];
          break
        case ClipType.Y: // 南北方向切1
          planes = [
            new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(0, 1, 0), 1) // y垂直面
          ];
          break
        case ClipType.YR: // 南北方向切2
          planes = [
            new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(0, -1, 0), 1) // y垂直面
          ];
          break
      }
      this.setPlanes(planes);
    }

    /**
     * 裁剪区域坐标数组(按面或线裁剪)
     * @type {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]}
     */
    get positions() {
      return this._positions
    }

    set positions(val) {
      this._positions = LngLatArray.toCartesians(val);
      this._setPositions(this._positions);
    }

    /**
     * 是否外裁剪
     * @type {Boolean}
     */
    get clipOutSide() {
      return this.options.clipOutSide
    }

    set clipOutSide(val) {
      this.options.clipOutSide = val;

      if (this._map && this._positions) {
        this._setPositions(this._positions);
      }
    }

    //= ========= 方法 ==========

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      if (this.options.showPlane) {
        this._graphicLayer = new GraphicLayer({
          ...this.options,
          private: true
        });

        if (this.options.editPlane) {
          this._graphicLayer.bindContextMenu([
            {
              text: this._map.getLangText("_删除"),
              icon: Icon.Delete,
              callback: (event) => {
                const graphic = event.graphic;
                if (!graphic) {
                  return
                }
                this._graphicLayer.removeGraphic(graphic);
                this.fire(EventType.remove, event);
              }
            }
          ]);
        }
      }

      if (this.options.layer) {
        this.layer = this.options.layer; // mars3d.layer.TilesetLayer 时
      } else if (this.options.tileset) {
        this.clipTarget = this.options.tileset; // Cesium.Cesium3DTileset 时
      }
    }

    _map_click(event) {
      if (this._last_planeGraphics) {
        this._last_planeGraphics.hasEdit = false;
        this._last_planeGraphics.material.color = this._last_planeGraphics.material.color_bak;
        delete this._last_planeGraphics;
      }
      this._graphicLayer_leftUp(event);
    }

    _graphicLayer_click(event) {
      const planeGraphics = event.graphic?.entity?.plane;
      if (Cesium__namespace.defined(planeGraphics)) {
        this._map_click();

        planeGraphics.hasEdit = !planeGraphics.hasEdit;
        planeGraphics.material.color_bak = planeGraphics.material.color;
        planeGraphics.material.color = event.graphic.style.editColor;

        if (planeGraphics.hasEdit) {
          this._last_planeGraphics = planeGraphics;
        }
        event.stopPropagation();
      }
    }

    _graphicLayer_leftDown(event) {
      const planeGraphics = event.graphic?.entity?.plane;
      if (Cesium__namespace.defined(planeGraphics) && planeGraphics.hasEdit) {
        this._selectedPlane = planeGraphics.plane.getValue();

        if (this._map.scene.screenSpaceCameraController.enableInputs) {
          this._map.scene.screenSpaceCameraController.enableInputs = false;
          this._hasChangeEnableInputs = true;
        }
      }
    }

    _graphicLayer_leftUp(event) {
      if (Cesium__namespace.defined(this._selectedPlane)) {
        delete this._selectedPlane;

        if (this._hasChangeEnableInputs) {
          this._map.scene.screenSpaceCameraController.enableInputs = true;
          delete this._hasChangeEnableInputs;
        }
      }
    }

    _map_mouseMove(event) {
      if (Cesium__namespace.defined(this._selectedPlane)) {
        const deltaX = event.startPosition.x - event.endPosition.x;
        const deltaY = event.startPosition.y - event.endPosition.y;
        const dis = (deltaX + deltaY) / 2;
        this._selectedPlane.distance = (this._selectedPlane.distance || 0) + dis;

        // const pt = Cesium.Matrix4.multiplyByPoint(this.inverseMatrix, event.cartesian, new Cesium.Cartesian3(0, 0, 0))
        // this._selectedPlane.distance = -Cesium.Plane.getPointDistance(this._selectedPlaneCenter, pt)

        this._map.openSmallTooltip(event.endPosition, this._map.getLangText("_释放后完成修改"));
      } else {
        this._map.closeSmallTooltip();
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      if (this._graphicLayer) {
        this._map.addLayer(this._graphicLayer);
        if (this.options.editPlane) {
          this._map.on(EventType.click, this._map_click, this);
          this._graphicLayer.on(EventType.click, this._graphicLayer_click, this);
          this._graphicLayer.on(EventType.leftDown, this._graphicLayer_leftDown, this);
          this._graphicLayer.on(EventType.leftUp, this._graphicLayer_leftUp, this);
          this._map.on(EventType.mouseMove, this._map_mouseMove, this);
        }
      }

      if (this.clipTarget) {
        if (Cesium__namespace.defined(this.options.positions)) {
          this.positions = this.options.positions;
        }
        if (Cesium__namespace.defined(this.options.type)) {
          this.type = this.options.type;
        }
        if (Cesium__namespace.defined(this.options.distance)) {
          this.distance = this.options.distance;
        }
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.clear();

      if (this._graphicLayer) {
        if (this.options.editPlane) {
          this._map.off(EventType.click, this._map_click, this);
          this._graphicLayer.off(EventType.click, this._graphicLayer_click, this);
          this._graphicLayer.off(EventType.leftDown, this._graphicLayer_leftDown, this);
          this._graphicLayer.off(EventType.leftUp, this._graphicLayer_leftUp, this);
          this._map.off(EventType.mouseMove, this._map_mouseMove, this);
        }
        this._map.removeLayer(this._graphicLayer);
      }
    }

    // 根据坐标 创建裁剪面
    _setPositions(points) {
      if (points.length < 2) {
        return
      }

      const planes = [];
      if (points.length === 2) {
        // 线
        const plan = this._createPlaneByLine(points[0], points[1]);
        if (plan) {
          planes.push(plan);
        }
      } else {
        // 面

        // 是否顺时针
        let direction;
        const startAngle = formatNum$1(getAngle(points[0], points[1]), 2);
        if (startAngle > -0.02 && startAngle < 0.02) {
          direction = false;
        } else {
          const endAngle = formatNum$1(getAngle(points[0], points[2]), 2);
          direction = startAngle < endAngle;
        }

        if (this.clipOutSide) {
          direction = !direction;
        }

        let plan;
        for (let i = 0, len = points.length; i < len; ++i) {
          const nextIndex = (i + 1) % len;

          if (direction) {
            plan = this._createPlaneByLine(points[nextIndex], points[i]);
          } else {
            plan = this._createPlaneByLine(points[i], points[nextIndex]);
          }

          if (plan) {
            if (this._normalZ) {
              plan.normal.z = this._normalZ;
            }
            planes.push(plan);
          }
        }

        if (Cesium__namespace.defined(this.options.height)) {
          plan = new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(0, 0, -1), this.options.height); // 底面
          planes.push(plan);
        }
      }

      this.setPlanes(planes);
    }

    _createPlaneByLine(p1, p2) {
      if (Cesium__namespace.Cartesian3.distance(p1, p2) < 0.1) {
        return null
      }

      // 将仅包含经纬度信息的p1,p2，转换为相应坐标系的cartesian3对象
      const inverseMatrix = this.inverseMatrix;
      const p1C3 = Cesium__namespace.Matrix4.multiplyByPoint(inverseMatrix, p1, new Cesium__namespace.Cartesian3());
      const p2C3 = Cesium__namespace.Matrix4.multiplyByPoint(inverseMatrix, p2, new Cesium__namespace.Cartesian3());

      // 定义一个垂直向上的向量up
      const up = new Cesium__namespace.Cartesian3(0, 0, 10);

      //  right 实际上就是由p1指向p2的向量
      const right = Cesium__namespace.Cartesian3.subtract(p2C3, p1C3, new Cesium__namespace.Cartesian3());

      // 计算normal， right叉乘up，得到平面法向量，这个法向量指向right的右侧
      let normal = Cesium__namespace.Cartesian3.cross(right, up, new Cesium__namespace.Cartesian3());
      normal = Cesium__namespace.Cartesian3.normalize(normal, normal);

      // 由于已经获得了法向量和过平面的一点，因此可以直接构造Plane,并进一步构造ClippingPlane
      const planeTmp = Cesium__namespace.Plane.fromPointNormal(p1C3, normal);
      return Cesium__namespace.ClippingPlane.fromPlane(planeTmp)
    }

    setPlanes(planes) {
      if (!planes) {
        return
      }

      const clippingPlanes = new Cesium__namespace.ClippingPlaneCollection({
        planes: planes,
        edgeWidth: this.options.edgeWidth ?? 0.0,
        edgeColor: this.options.edgeColor ?? Cesium__namespace.Color.WHITE,
        unionClippingRegions: this.clipOutSide ?? false
      });
      this.clippingPlanes = clippingPlanes;

      if (this.clipTarget) {
        this.clipTarget.clippingPlanes = clippingPlanes;
      }

      // 将绘制的裁剪平面绘制到场景中。
      if (this.options.showPlane) {
        this._graphicLayer.clear();

        const radius = this._tileset.boundingSphere.radius;

        for (let i = 0; i < clippingPlanes.length; ++i) {
          const plane = clippingPlanes.get(i);

          const graphic = new PlaneEntity({
            position: this.center,
            style: {
              dimensions: new Cesium__namespace.Cartesian2(radius, radius),
              color: Cesium__namespace.Color.WHITE.withAlpha(0.2),
              editColor: Cesium__namespace.Color.WHITE.withAlpha(0.5),
              outline: true,
              outlineColor: Cesium__namespace.Color.WHITE,
              ...(this.options.planeStyle || {}),
              plane: new Cesium__namespace.CallbackProperty(createPlaneUpdateFunction(plane), false)
            }
          });
          this._graphicLayer.addGraphic(graphic);
        }
      }
    }

    /**
     *  清除裁剪面
     * @return {void}  无
     */
    clear() {
      if (this._graphicLayer) {
        this._graphicLayer.clear();
      }

      this._positions = null;
      this._normalZ = 0;
      this.options.clipOutSide = false;

      if (this.clippingPlanes) {
        delete this.clippingPlanes;
      }
      if (this.clipTarget?.clippingPlanes?.enabled) {
        this.clipTarget.clippingPlanes.enabled = false;
      }
      this.clipTarget.clippingPlanes = undefined;
    }

    /**
     * 更新所有面的 裁剪距离 (单位：米)
     *
     * @param {Number} val 裁剪距离 (单位：米)
     * @return {void}  无
     */
    updateAllDistance(val) {
      if (this.clippingPlanes == null) {
        return
      }

      for (let i = 0; i < this.clippingPlanes.length; i++) {
        const plane = this.clippingPlanes.get(i);
        plane.distance = val;
      }
    }

    /**
     * 更新所有面的 裁剪的斜面偏移量
     *
     * @param {Number} val 斜面偏移量
     * @return {void}  无
     */
    updateAllNormalZ(val) {
      if (this.clippingPlanes == null) {
        return
      }

      for (let i = 0; i < this.clippingPlanes.length; i++) {
        const plane = this.clippingPlanes.get(i);
        plane.normal.z = val;
      }
    }
  }

  // 兼容v3.1历史挂载
  TilesetPlanClip.Type = ClipType;

  function createPlaneUpdateFunction(plane) {
    return function () {
      return plane
    }
  }

  /**
   * @typedef {Object} TilesetLayer.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} add 添加对象
   * @property {String} remove 移除对象
   * @property {String} show 显示了对象
   * @property {String} hide 隐藏了对象
   *
   * @property {String} click 左键单击 鼠标事件
   * @property {String} rightClick 右键单击 鼠标事件
   * @property {String} mouseOver 鼠标移入 鼠标事件
   * @property {String} mouseOut 鼠标移出 鼠标事件
   *
   * @property {String} popupOpen popup弹窗打开后
   * @property {String} popupClose popup弹窗关闭
   * @property {String} tooltipOpen tooltip弹窗打开后
   * @property {String} tooltipClose tooltip弹窗关闭
   * @property {String} initialTilesLoaded 3dtiles模型，模型瓦片初始化完成 该回调只执行一次
   * @property {String} allTilesLoaded 3dtiles模型
   * @property {String} loadBefore 完成加载，但未做任何其他处理前
   * @property {String} load 完成加载，执行所有内部处理后
   *
   * @property {String} highlightOpen highlight高亮后
   * @property {String} highlightClose highlight关闭后
   *
   * @example
   * //绑定监听事件
   * layer.on(mars3d.EventType.load, function (event) {
   *   console.log('矢量数据对象加载完成', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 3dtiles 三维模型图层。
   *
   * @param {Object} options 参数对象， 构造参数建议从{@link http://mars3d.cn/editor.html?id=layer-tileset/manager/edit|模型编辑页面}设置后保存参数后拷贝json参数即可。参数包括以下：
   * @param {String|Cesium.Resource|Cesium.IonResource} options.url tileset的主JSON文件的 url ，ION资源时可以写 url: Cesium.IonResource.fromAssetId(8564),
   * @param {Number} [options.maximumScreenSpaceError=16] 用于驱动细化细节级别的最大屏幕空间错误。可以简单理解为：数值加大，能让最终成像变模糊。
   * @param {Number} [options.maximumMemoryUsage=512] 数据集可以使用的最大内存量(以MB计)，这个参数要根据当前客户端显卡显存来配置，如果我们场景只显示这一个模型数据，这个可以设置到显存的50% 左右，比如我的显存是4G，这个可以设置到2048左右。那么既保证不超过显存限制，又可以最大利用显存缓存。<br />
   * 解释：
   * 这个参数默认是512，也即是当几何体和纹理资源大于512MB的时候，cesium就会淘汰掉当前帧中没有visited的所有块，这个值其实很小，也是cesium为了避免资源占用过高的一个保障.<br />
   * 这个值如果设置的过小，导致cesium几乎每帧都在尝试淘汰数据，增加了遍历的时间，也同时增加了崩溃的风险。<br />
   * 这个值如果设置的过大，cesium的淘汰机制失效，那么容易导致显存超过显卡内存，也会导致崩溃。 这个值应该处于最差视角下资源占用 和 显存最大量之间。<br />
   *
   *
   * @param {Object} [options.position] 自定义新的中心点位置（移动模型）
   * @param {Number} options.position.lng 经度值, 180 - 180
   * @param {Number} options.position.lat 纬度值, -90 - 90
   * @param {Number} options.position.alt 高度值（单位：米）
   * @param {Object} [options.rotation] 自定义旋转方向（旋转模型）
   * @param {Number} options.rotation.x X方向，角度值0-360
   * @param {Number} options.rotation.y Y方向，角度值0-360
   * @param {Number} options.rotation.z 四周方向，角度值0-360
   * @param {Cesium.Matrix4} [options.modelMatrix] 模型的矩阵位置，内部无坐标位置的模型使用，此时position和rotation等参数均无效。
   * @param {function} [options.updateMatrix] 外部自定义修复模型矩阵位置
   * @param {Number} [options.scale=1] 自定义缩放比例
   * @param {String|Cesium.Axis} [options.axis] 自定义轴方向
   *
   * @param {Object|Cesium.Cesium3DTileStyle|Function} [options.style]  模型样式， 使用{@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.
   * @param {Boolean|String} [options.marsJzwStyle=false] 开启或设置建筑物特效样式。
   * @param {Cesium.CustomShader} [options.customShader] 自定义shader效果
   *
   * @param {Object|OutlineEffect.Options} [options.highlight]  高亮及其样式配置
   * @param {String} [options.highlight.type] 鼠标移入高亮 或 单击高亮(type:'click')
   * @param {Boolean} [options.highlight.all] 是否整体高亮， true:模型整体全部高亮，false:单个构件高亮
   * @param {String|function} [options.highlight.color='#FFFF00'] 颜色，支持rgba字符串
   * @param {Boolean} [options.highlight.outlineEffect=false] 默认为修改矢量对象本身的style高亮，true时采用{@link OutlineEffect}方式高亮。
   * @param {Function} [options.highlight.filter] 可以设置筛选排除一些构件, 排除的构件在filter方法内返回false
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   *
   * @param {Boolean} [options.clampToGround] 是否贴地,true时自动调用贴地计算，但此属性只适合标准的与地形数据匹配的模型，并不精确，建议通过模型编辑页面调试给具体高度值。
   * @param {ChinaCRS} [options.chinaCRS] 标识模型的国内坐标系（用于自动纠偏或加偏）
   *
   * @param {Object} [options.clip] 模型裁剪 对象, 可传入{@link TilesetClip}构造参数
   * @param {Object} [options.flat] 模型压平 对象, 可传入{@link TilesetFlat}构造参数
   * @param {Object} [options.flood] 模型淹没 对象, 可传入{@link TilesetFlood}构造参数
   * @param {Object} [options.planClip] 模型Plan裁剪 对象, 可传入{@link TilesetPlanClip}构造参数
   *
   *
   * @param {Cesium.ShadowMode} [options.shadows=ShadowMode.ENABLED] 确定tileset是否投射或接收来自光源的阴影。
   * @param {Boolean} [options.cullWithChildrenBounds=true] 优化选择。是否使用子绑定卷的并集来筛选贴图。
   * @param {Boolean} [options.cullRequestsWhileMoving=true] 优化选择。不要要求贴图，当他们回来的时候可能不会使用，因为相机的运动。这个优化只适用于固定瓷砖组。
   * @param {Number} [options.cullRequestsWhileMovingMultiplier=60.0] 优化选择。在移动时选择请求时使用的倍增器。越大的选择性越强，越小的选择性越弱。值越小能够更快的剔除。
   * @param {Boolean} [options.preloadWhenHidden=false] 当true时，tileset.show是false，也去预加载数据。
   * @param {Boolean} [options.preloadFlightDestinations=true] 优化选择。当摄像机在飞行时，在摄像机的飞行目的地预加载贴图。
   * @param {Boolean} [options.preferLeaves=false] 优化选择。最好先加载上叶子节点数据。这个参数默认是false，同等条件下，叶子节点会优先加载。但是Cesium的tile加载优先级有很多考虑条件，这个只是其中之一，如果skipLevelOfDetail=false，这个参数几乎无意义。所以要配合skipLevelOfDetail=true来使用，此时设置preferLeaves=true。这样我们就能最快的看见符合当前视觉精度的块，对于提升大数据以及网络环境不好的前提下有一点点改善意义。
   * @param {Boolean} [options.dynamicScreenSpaceError=false] 优化选择。减少远离摄像头的贴图的屏幕空间误差。true时会在真正的全屏加载完之后才清晰化模型.
   * @param {Number} [options.dynamicScreenSpaceErrorDensity=0.00278] 密度用来调整动态画面空间误差，类似于雾密度。
   * @param {Number} [options.dynamicScreenSpaceErrorFactor=4.0] 用于增加计算的动态屏幕空间误差的因素。
   * @param {Number} [options.dynamicScreenSpaceErrorHeightFalloff=0.25] 瓷砖密度开始下降时的高度之比。
   * @param {Number} [options.progressiveResolutionHeightFraction=0.3] 优化选择。如果在(0.0,0.5)之间，在屏幕空间或以上的瓷砖错误降低屏幕分辨率 <code>progressiveResolutionHeightFraction*screenHeight</code> 将优先。这可以帮助得到一个快速层的瓷砖下来，而全分辨率的瓷砖继续加载。
   * @param {Boolean} [options.foveatedScreenSpaceError=true] 优化选择。通过暂时提高屏幕边缘的贴图的屏幕空间误差，优先加载屏幕中央的贴图。一旦所有由{@link cesium3dtilesset#foveatedConeSize}确定的屏幕中央的贴图被加载，屏幕空间错误就会恢复正常。
   * @param {Number} [options.foveatedConeSize=0.1] 优化选择。当{@link cesium3dtilesset#foveatedScreenSpaceError}为true时使用，以控制决定哪些贴图被延迟的锥大小。装在这个圆锥体里的瓷砖会立即被装入。锥外的贴图有可能被延迟，这取决于它们在锥外的距离和它们的屏幕空间误差。这是由{@link Cesium3DTileset#foveatedInterpolationCallback}和{@link Cesium3DTileset#foveatedMinimumScreenSpaceErrorRelaxation}控制的。设置为0.0意味着圆锥将是由相机位置和它的视图方向形成的线。将此设置为1.0意味着圆锥将包含相机的整个视场，禁用此效果。
   * @param {Number} [options.foveatedMinimumScreenSpaceErrorRelaxation=0.0] 优化选择。当{@link cesium3dtilesset#foveatedScreenSpaceError}为true时使用，以控制中心锥形以外的贴图的初始屏幕空间误差松弛。屏幕空间错误将基于所提供的{@link Cesium3DTileset#foveatedInterpolationCallback}从tileset值开始直到{@link Cesium3DTileset#maximumScreenSpaceError}。
   * @param {Cesium.Cesium3DTileset.foveatedInterpolationCallback} [options.foveatedInterpolationCallback=Math.lerp] 优化选择。当{@link cesium3dtilesset#foveatedScreenSpaceError}为true时使用，以控制中心锥形以外的贴图的初始屏幕空间误差松弛。优化选择。当{@link Cesium3DTileset#foveatedScreenSpaceError}为true时使用，以控制凸出圆锥外的贴图的屏幕空间误差提高多少，插值在{@link Cesium3DTileset#foveatedminimumscreenspaceerror}和{@link Cesium3DTileset#maximumScreenSpaceError}之间。
   * @param {Number} [options.foveatedTimeDelay=0.2] 优化选择。当{@link cesium3dtilesset#foveatedScreenSpaceError}为true时使用，以控制中心锥形以外的贴图的初始屏幕空间误差松弛。优化选择。优化选择。当{@link cesium3dtilesset#foveatedScreenSpaceError}为true时使用，以控制在延迟tile开始加载前摄像机停止移动后等待多长时间(秒)。这个时间延迟阻止了在相机移动时请求屏幕边缘的贴图。将此设置为0.0将立即请求任何给定视图中的所有贴图。
   * @param {Boolean} [options.skipLevelOfDetail=false] 优化选择。确定在遍历过程中是否应应用跳过详细信息的级别。是Cesium在1.5x 引入的一个优化参数，这个参数在金字塔数据加载中，可以跳过一些级别，这样整体的效率会高一些，数据占用也会小一些。但是带来的异常是：1） 加载过程中闪烁，看起来像是透过去了，数据载入完成后正常。2，有些异常的面片，这个还是因为两级LOD之间数据差异较大，导致的。当这个参数设置false，两级之间的变化更平滑，不会跳跃穿透，但是清晰的数据需要更长，而且还有个致命问题，一旦某一个tile数据无法请求到或者失败，导致一直不清晰。所以我们建议：对于网络条件好，并且数据总量较小的情况下，可以设置false，提升数据显示质量。
   * @param {Number} [options.baseScreenSpaceError=1024] 当skipLevelOfDetail为true时，跳过详细级别之前必须达到的屏幕空间错误。
   * @param {Number} [options.skipScreenSpaceErrorFactor=16] 当skipLevelOfDetail = true时，一个定义要跳过的最小屏幕空间错误的乘法器。与skipLevels一起使用，以决定加载哪些贴图。
   * @param {Number} [options.skipLevels=1] 当skipLevelOfDetail是true，一个常量定义了加载tiles时要跳过的最小级别数。当它为0时，不会跳过任何级别。与skipScreenSpaceErrorFactor一起使用，以决定加载哪些贴图。
   * @param {Boolean} [options.immediatelyLoadDesiredLevelOfDetail=false] 当skipLevelOfDetail为true时，只有满足最大屏幕空间错误的tiles才会被下载。跳过因素将被忽略，并且只加载所需的块。
   * @param {Boolean} [options.loadSiblings=false] 当skipLevelOfDetail = true时，判断遍历过程中是否总是下载可见块的兄弟块。如果为true则不会在已加载完模型后，自动从中心开始超清化模型。
   * @param {Cesium.ClippingPlaneCollection} [options.clippingPlanes] {@link Cesium.ClippingPlaneCollection}用于选择性地禁用tile集的渲染。
   * @param {Cesium.ClassificationType} [options.classificationType] 确定地形、3D贴图或两者都将被这个贴图集分类。有关限制和限制的详细信息，请参阅{@link cesium3dtilesset #classificationType}。
   * @param {Object} [options.pointCloudShading] 基于几何误差和光照构造一个{@link Cesium.PointCloudShading}对象来控制点衰减的选项。
   * @param {Cesium.Cartesian3} [options.lightColor] 光的颜色当遮光模型。当undefined场景的浅色被使用代替。表示，rgb的倍数，new Cesium.Cartesian3(100.0,100.0, 100.0)表示白光增强到100倍。对Pbrt材质有效，倾斜摄影不生效。
   * @param {Boolean} [options.backFaceCulling=true] 是否剔除面向背面的几何图形。当为真时，背面剔除由glTF材质的双面属性决定;当为false时，禁用背面剔除。
   * @param {String} [options.debugHeatmapTilePropertyName] 是否剔除面向背面的几何图形。当为真时，背面剔除由glTF材质的双面属性决定;作为热图着色的tile变量。所有渲染的贴图都将相对于其他指定的变量值着色。
   * @param {Object} [options.pickPrimitive]  要在拾取过程中呈现的原语，而不是tile集合。
   *
   *
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑定，参数与popup属性完全相同。
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数,还包括：
   * @param {String} [options.tooltipOptions.title] 固定的标题名称
   * @param {String} [options.tooltipOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.tooltipOptions.noTitle] 不显示标题
   * @param {Object} [options.contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
   * @param {Boolean} [options.hasEdit=true] 是否允许编辑，且需要transform是true的模型才支持编辑
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class TilesetLayer
   * @extends {BaseGraphicLayer}
   *
   * @see Cesium.Cesium3DTileset
   * @see [支持的事件类型]{@link TilesetLayer.EventType}
   */
  class TilesetLayer extends BaseGraphicLayer {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 原始的旋转角度，示例：{ x: 0, y: 0, z: 0 }
       * @type {Object}
       * @readonly
       */
      this.orginRotation = { x: 0, y: 0, z: 0 }; // 原始的旋转角度

      this._orginCenterPoint = new LngLatPoint(); // 原始的中心点位置
      this._hasEdit = options.hasEdit ?? true;
      this._marsOptions = {}; // 用于传递给 mars3d-cesium 内部
    }

    get layer() {
      return this._tileset
    }

    /**
     * 模型对应的 Cesium3DTileset对象
     * @type {Cesium.Cesium3DTileset}
     * @readonly
     */
    get tileset() {
      return this._tileset
    }

    /**
     * 变换矩阵。
     * @type {Cesium.Matrix4}
     * @readonly
     */
    get modelMatrix() {
      if (!this.loadOk) {
        return Cesium__namespace.Matrix4.ZERO
      }
      if (!this._tilesetMatrix) {
        if (this.transform) {
          this._tilesetMatrix = this._tileset.root.transform;
        } else {
          this._tilesetMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(this._tileset.boundingSphere.center);
        }
      }
      return this._tilesetMatrix
    }

    /**
     * 逆变换矩阵。
     * @type {Cesium.Matrix4}
     * @readonly
     */
    get inverseMatrix() {
      if (!this.loadOk) {
        return Cesium__namespace.Matrix4.ZERO
      }

      if (!this._inverseMatrix) {
        this._inverseMatrix = Cesium__namespace.Matrix4.inverse(this.modelMatrix, new Cesium__namespace.Matrix4());
      }
      return this._inverseMatrix
    }

    /**
     * 鼠标移入或单击(type:'click')后的对应高亮的部分样式,空值时不高亮
     * @type {Object}
     * @readonly
     */
    get highlight() {
      return this.options.highlight
    }

    set highlight(value) {
      this.options.highlight = value;
      if (value) {
        this.bindHighlight(this.options.highlight);
      } else {
        this.unbindHighlight();
      }
    }

    /**
     * 开启或设置建筑物特效样式。
     * @type {Boolean|Object}
     */
    get marsJzwStyle() {
      return this.options.marsJzwStyle
    }

    set marsJzwStyle(value) {
      this.options.marsJzwStyle = value;
      this._conventMarsOptions();
    }

    /**
     * 模型样式，
     * 使用{@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.
     * @type {Object|Cesium.Cesium3DTileStyle|Function}
     */
    get style() {
      return this.options.style
    }

    set style(value) {
      this.options.style = value;
      this._styleCallback = null;

      if (this._tileset) {
        if (value instanceof Cesium__namespace.Cesium3DTileStyle) {
          this._tileset.style = value;
        } else if (typeof value === "function") {
          this._styleCallback = value;
          this._bindVisibleEvent();
        } else {
          this._tileset.style = new Cesium__namespace.Cesium3DTileStyle(value);
        }
      }
    }

    /**
     * 自定义shader效果, <br/>
     * 如果默认无customShader，加载模型后动态修改customShader值
     * @type {Cesium.CustomShader}
     */
    get customShader() {
      return this.options.customShader
    }

    set customShader(value) {
      this.options.customShader = value;

      if (this._tileset) {
        this._tileset.customShader = value;
        this._tileset.enableModelExperimental = !!value;
      }
    }

    /**
     * 模型原始的中心点坐标
     * @type {LngLatPoint}
     * @readonly
     */
    get orginCenterPoint() {
      return this._orginCenterPoint
    }

    /**
     * 模型原始的中心点坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get orginCenterPosition() {
      return this._orginCenterPosition
    }

    /**
     * 模型当前中心点坐标 （笛卡尔坐标）
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get position() {
      return this._center.toCartesian()
    }

    set position(value) {
      this.center = value; // 同center
    }

    /**
     * 模型当前中心点坐标
     * @type {LngLatPoint}
     */
    get center() {
      return this._center
    }

    set center(value) {
      this._center = LngLatPoint.parse(value);

      this.updateMatrix();
    }

    /**
     * 调整修改模型高度
     * @type {LngLatPoint}
     */
    get height() {
      if (this.center) {
        return this.center.alt
      }
      return 0
    }

    set height(value) {
      if (!this._tileset) {
        return
      }
      this.center.alt = value;

      this.updateMatrix();
    }

    /**
     * 模型的边界球体。
     *
     * @type {Cesium.BoundingSphere}
     * @readonly
     */
    get boundingSphere() {
      return this._tileset?.boundingSphere
    }

    /**
     * 模型的向上轴，比如Cesium.Axis.Z 或 Cesium.Axis.Y
     * @type {Cesium.Axis}
     * @readonly
     */
    get upAxis() {
      if (Cesium__namespace.defined(this._tileset?._modelUpAxis)) {
        return this._tileset?._modelUpAxis
      }

      if (Cesium__namespace.defined(this._tileset?._gltfUpAxis)) {
        return this._tileset?._gltfUpAxis
      }

      return undefined
    }

    /**
     * 旋转方向，示例：{ x: 0, y: 0, z: 0 }
     * @type {Object}
     */
    get rotation() {
      if (this.options.rotation) {
        return this.options.rotation
      }
      return this.orginRotation
    }

    set rotation(value) {
      this.options.rotation = value;
      this.updateMatrix();
    }

    /**
     * X轴上的旋转方向
     * @type {Number}
     */
    get rotation_x() {
      if (this.options.rotation && Cesium__namespace.defined(this.options.rotation.x)) {
        return this.options.rotation.x
      }
      return this.orginRotation.x
    }

    set rotation_x(value) {
      this.options.rotation = this.options.rotation || {};
      this.options.rotation.x = value;
      this.updateMatrix();
    }

    /**
     * Y轴上的旋转方向
     * @type {Number}
     */
    get rotation_y() {
      if (this.options.rotation && Cesium__namespace.defined(this.options.rotation.y)) {
        return this.options.rotation.y
      }
      return this.orginRotation.y
    }

    set rotation_y(value) {
      this.options.rotation = this.options.rotation || {};
      this.options.rotation.y = value;
      this.updateMatrix();
    }

    /**
     * Z轴上的旋转方向
     * @type {Number}
     */
    get rotation_z() {
      if (this.options.rotation && Cesium__namespace.defined(this.options.rotation.z)) {
        return this.options.rotation.z
      }
      return this.orginRotation.z
    }

    set rotation_z(value) {
      this.options.rotation = this.options.rotation || {};
      this.options.rotation.z = value;
      this.updateMatrix();
    }

    /**
     * 轴方向
     * @type {String|Cesium.Axis}
     */
    get axis() {
      return this.options.axis || ""
    }

    set axis(value) {
      this.options.axis = value;
      this.updateMatrix();
    }

    /**
     * 缩放比例
     * @type {Number}
     */
    get scale() {
      return this.options.scale || 1
    }

    set scale(value) {
      this.options.scale = value;
      this.updateMatrix();
    }

    /**
     * 是否允许鼠标穿透拾取
     * @type {Boolean|Function}
     */
    get allowDrillPick() {
      return this.options.allowDrillPick
    }

    set allowDrillPick(value) {
      this.options.allowDrillPick = value;
    }

    /**
     * 模型裁剪 对象
     * @type {TilesetPlanClip}
     * @readonly
     */
    get planClip() {
      if (this._map && !this._tilesetPlanClip) {
        this._initTilesetPlanClip();
      }
      return this._tilesetPlanClip
    }

    /**
     * 是否可以编辑
     * @type {Boolean}
     */
    get hasEdit() {
      return this._hasEdit && this.transform
    }

    set hasEdit(val) {
      this._hasEdit = val;
    }

    _initTilesetPlanClip() {
      if (this._tilesetPlanClip) {
        this._tilesetPlanClip.destroy();
      }
      this._tilesetPlanClip = new TilesetPlanClip({
        ...this.options.planClip,
        layer: this
      });
      this._map.addThing(this._tilesetPlanClip);
    }

    /**
     * 模型裁剪 对象
     * @type {TilesetClip}
     * @readonly
     */
    get clip() {
      if (this._map && !this._tilesetClip) {
        this._initTilesetClip();
      }
      return this._tilesetClip
    }

    _initTilesetClip() {
      if (this._tilesetClip) {
        this._tilesetClip.destroy();
      }
      this._tilesetClip = new TilesetClip({
        ...this.options.clip,
        layer: this
      });
      this._map.addThing(this._tilesetClip);
    }

    /**
     * 模型压平 对象
     * @type {TilesetFlat}
     * @readonly
     */
    get flat() {
      if (this._map && !this._tilesetFlat) {
        this._initTilesetFlat();
      }
      return this._tilesetFlat
    }

    _initTilesetFlat() {
      if (this._tilesetFlat) {
        this._tilesetFlat.destroy();
      }

      this._tilesetFlat = new TilesetFlat({
        ...this.options.flat,
        layer: this
      });
      this._map.addThing(this._tilesetFlat);
    }

    /**
     * 模型淹没 对象
     * @type {TilesetFlood}
     * @readonly
     */
    get flood() {
      if (this._map && !this._tilesetFlood) {
        this._initTilesetFlood();
      }
      return this._tilesetFlood
    }

    _initTilesetFlood() {
      if (this._tilesetFlood) {
        this._tilesetFlood.destroy();
      }
      this._tilesetFlood = new TilesetFlood({
        ...this.options.flat,
        layer: this
      });
      this._map.addThing(this._tilesetFlood);
    }

    /**
     * 是否正在编辑状态
     * @type {Boolean}
     * @readonly
     */
    get isEditing() {
      return this._enabledEdit
    }

    _createCesium3DTileset() {
      const tileset = new Cesium__namespace.Cesium3DTileset({
        ...this.options,
        enableModelExperimental: !!this.options.customShader,
        url: getUrlResource(this.options),
        marsOptions: this._marsOptions
      });
      return tileset
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      super._addedHook();

      this._conventMarsOptions();
      this._initByEdit();

      if (this.options.flat) {
        this._initTilesetFlat();
      }
      if (this.options.flood) {
        this._initTilesetFlood();
      }
      if (this.options.clip) {
        this._initTilesetClip();
      }
      if (this.options.planClip) {
        this._initTilesetPlanClip();
      }

      this._tileset = this._createCesium3DTileset();
      this._tileset.name = this.name;
      this._tileset._mars3d_layerId = this.id;

      this.loadOk = false;
      this._tileset.readyPromise
        .then((tileset) => {
          this.loadOk = true;
          this._tileset.show = this.show;

          this._initModel();

          this._readyPromise.resolve(this);
        })
        .catch((error) => {
          this._readyPromise && this._readyPromise.reject(error);
        });

      this._map.scene.primitives.add(this._tileset);

      // 绑定一些事件
      this._tileset.initialTilesLoaded.addEventListener((event) => {
        // 该回调只执行一次
        this.fire(EventType.initialTilesLoaded, event);
      });
      this._tileset.allTilesLoaded.addEventListener((event) => {
        // 该回调会执行多次，视角变化后重新加载一次完成后都会回调
        this.fire(EventType.allTilesLoaded, event);
      });
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this._tilesetClip) {
        this._map.removeThing(this._tilesetClip, true);
        delete this._tilesetClip;
      }
      if (this._tilesetFlat) {
        this._map.removeThing(this._tilesetFlat, true);
        delete this._tilesetFlat;
      }
      if (this._tilesetFlood) {
        this._map.removeThing(this._tilesetFlood, true);
        delete this._tilesetFlood;
      }
      if (this._tilesetPlanClip) {
        this._map.removeThing(this._tilesetPlanClip, true);
        delete this._tilesetPlanClip;
      }

      super._removedHook();

      if (Cesium__namespace.defined(this.options.visibleDistanceMax)) {
        this._map.off(EventType.cameraChanged, this.updateVisibleDistance, this);
      }

      if (this._tileset) {
        this._map.scene.primitives.remove(this._tileset);
        delete this._tileset;
      }
    }

    /**
     * 重新加载模型
     * @return {void}
     * @memberof TilesetLayer
     */
    reload() {
      this._removedHook();
      this._addedHook();
    }

    _mergePostion(configCenter) {
      if (configCenter) {
        if (!this._center) {
          this._center = new LngLatPoint();
        }
        if (Cesium__namespace.defined(configCenter.lat)) {
          this.center.lat = configCenter.lat;
        }
        if (Cesium__namespace.defined(configCenter.lng)) {
          this.center.lng = configCenter.lng;
        }
        if (Cesium__namespace.defined(configCenter.alt)) {
          this.center.alt = configCenter.alt;
        }
      }
    }

    _setOptionsHook(options) {
      if (!this._tileset) {
        return
      }
      super._setOptionsHook(options);

      if (Cesium__namespace.defined(options.opacity)) {
        this.opacity = options.opacity;
      }
      if (options.maximumScreenSpaceError) {
        for (const key in options) {
          if (Cesium__namespace.defined(this.tileset[key])) {
            this.tileset[key] = options[key];
          }
        }
      }

      // 设置新的中心点
      this._mergePostion(this.options.position);
      this.updateMatrix();
    }

    _initModel() {
      this.fire(EventType.loadBefore, { tileset: this._tileset });

      //= ===============模型中心点相关处理===============
      // 记录模型原始的中心点
      this._orginCenterPosition = Cesium__namespace.clone(this._tileset.boundingSphere.center);

      // 是否存在世界矩阵 _root.transform
      const tmp = this._tileset.root?.transform;

      /**
       * 是否存在世界矩阵
       * @type {Boolean}
       * @readonly
       */
      this.transform = this.options.transform ?? Boolean(tmp && !tmp.equals(Cesium__namespace.Matrix4.IDENTITY));

      if (this.transform) {
        /**
         * 模型原始矩阵
         * @type {Cesium.Matrix4}
         * @readonly
         */
        this.orginMatrix = Cesium__namespace.Matrix4.inverse(Cesium__namespace.Matrix4.fromArray(this._tileset._root.transform), new Cesium__namespace.Matrix4());

        // 获取transform中的中心点
        const matrix = Cesium__namespace.Matrix4.fromArray(this._tileset._root.transform);
        const position = Cesium__namespace.Matrix4.getTranslation(matrix, new Cesium__namespace.Cartesian3());
        if (Cesium__namespace.defined(position) && Cesium__namespace.Cartographic.fromCartesian(position)) {
          this._orginCenterPosition = position;

          // 计算 orginRotation
          // 取旋转矩阵
          const rotmat = Cesium__namespace.Matrix4.getMatrix3(matrix, new Cesium__namespace.Matrix3());
          // 默认的旋转矩阵
          const defrotmat = Cesium__namespace.Matrix4.getMatrix3(Cesium__namespace.Transforms.eastNorthUpToFixedFrame(position), new Cesium__namespace.Matrix3());

          // 计算rotmat 的x轴，在defrotmat 上 旋转
          const xaxis = Cesium__namespace.Matrix3.getColumn(defrotmat, 0, new Cesium__namespace.Cartesian3());
          const yaxis = Cesium__namespace.Matrix3.getColumn(defrotmat, 1, new Cesium__namespace.Cartesian3());
          const zaxis = Cesium__namespace.Matrix3.getColumn(defrotmat, 2, new Cesium__namespace.Cartesian3());

          let dir = Cesium__namespace.Matrix3.getColumn(rotmat, 0, new Cesium__namespace.Cartesian3());

          dir = Cesium__namespace.Cartesian3.cross(dir, zaxis, dir);
          dir = Cesium__namespace.Cartesian3.cross(zaxis, dir, dir);
          dir = Cesium__namespace.Cartesian3.normalize(dir, dir);

          let heading = Cesium__namespace.Cartesian3.angleBetween(xaxis, dir);

          const ay = Cesium__namespace.Cartesian3.angleBetween(yaxis, dir);

          if (ay > Math.PI * 0.5) {
            heading = 2 * Math.PI - heading;
          }
          // 原始的旋转角度
          this.orginRotation = {
            x: 0,
            y: 0,
            z: Number(Cesium__namespace.Math.toDegrees(heading).toFixed(1))
          };
        } else {
          this.transform = false;
        }
      }
      this._orginCenterPoint = LngLatPoint.fromCartesian(this._orginCenterPosition);

      // 打印下
      logInfo(this.name + " 模型中心位置:" + this._orginCenterPoint.toString());

      //= ===============设置相关配置参数===============

      // 设置style
      if (Cesium__namespace.defined(this.options.style)) {
        this.style = this.options.style;
      }
      // 透明度
      if (this._opacity !== 1) {
        this.setOpacity(this._opacity);
      }

      // 当前中心点信息
      this._center = this._orginCenterPoint.clone();

      // 设置新的中心点
      this._mergePostion(this.options.position);

      // 有坐标系配置
      if (this.options.chinaCRS) {
        const crsCenter = this.transformCenter(this.center);
        this._mergePostion(crsCenter);
      }

      // 更新矩阵
      if (this._hasUpdateMater()) {
        this.updateMatrix();
      }

      // 设置最大视距后自动隐藏（不建议，效率一般）
      if (Cesium__namespace.defined(this.options.visibleDistanceMax)) {
        this.bindVisibleDistance();
      }

      if (this.options.clampToGround) {
        this.clampToGround();
      }

      if (this.options.flyTo) {
        this.flyToByAnimationEnd();
      }

      this.fire(EventType.load, { tileset: this._tileset });
    }

    /**
     * 模型自动贴地计算及处理,
     * 因为模型在设计或生产时，模型的视角中心位置不一定在0,0,0点，此方法不是唯一准确的。
     *
     * @param {number} [addHeight=1] 计算完成的贴地高度基础上增加的高度值。
     * @return {void}  无
     */
    clampToGround(addHeight = 1) {
      if (this._map && this._map.hasTerrain) {
        // 有地形时
        getSurfaceTerrainHeight(this._map.scene, this._orginCenterPosition).then((result) => {
          if (Cesium__namespace.defined(result.height)) {
            this.height = result.height - this._orginCenterPoint.alt + addHeight;
          }
        });
      } else {
        // 无地形时
        this.height = -this._orginCenterPoint.alt + addHeight;
      }
    }

    // 是否需要更新矩阵
    _hasUpdateMater() {
      if (!this.center.equals(this._orginCenterPoint)) {
        return true
      }

      if (this.options.rotation) {
        return true
      }

      if (this.options.scale > 0 && this.options.scale !== 1) {
        return true
      }

      if (Cesium__namespace.defined(this.options.axis)) {
        return true
      }

      return false
    }

    /**
     * 重新计算当前矩阵（需要是否存在世界矩阵时）
     * @return {Cesium.Matrix4|undefined} 计算完成的矩阵
     */
    updateMatrix() {
      if (!this._tileset) {
        return undefined
      }

      if (this.options.updateMatrix) {
        const matrix = this.options.updateMatrix(this.position, this);
        this._tileset.modelMatrix = matrix;
        return matrix
      }

      if (!this.transform) {
        return this.updateMatrix2()
      }

      let matrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(this.position);

      // 旋转
      if (this.options.rotation) {
        const mx = Cesium__namespace.Matrix3.fromRotationX(Cesium__namespace.Math.toRadians(this.rotation_x));
        const my = Cesium__namespace.Matrix3.fromRotationY(Cesium__namespace.Math.toRadians(this.rotation_y));
        const mz = Cesium__namespace.Matrix3.fromRotationZ(Cesium__namespace.Math.toRadians(360 - this.rotation_z));
        const rotationX = Cesium__namespace.Matrix4.fromRotationTranslation(mx);
        const rotationY = Cesium__namespace.Matrix4.fromRotationTranslation(my);
        const rotationZ = Cesium__namespace.Matrix4.fromRotationTranslation(mz);
        // 矩阵相乘
        Cesium__namespace.Matrix4.multiply(matrix, rotationX, matrix);
        Cesium__namespace.Matrix4.multiply(matrix, rotationY, matrix);
        Cesium__namespace.Matrix4.multiply(matrix, rotationZ, matrix);
      }

      // 缩放比例
      if (this.options.scale > 0 && this.options.scale !== 1) {
        Cesium__namespace.Matrix4.multiplyByUniformScale(matrix, this.options.scale, matrix);
      }

      // 垂直轴变换 ，兼容旧版本数据z轴方向不对的情况
      // 如果可以修改模型json源文件，可以在json文件里面加了一行来修正："gltfUpAxis" : "Z",
      if (Cesium__namespace.defined(this.options.axis)) {
        let rightaxis;
        if (isString(this.options.axis)) {
          switch (this.options.axis.toUpperCase()) {
            case "Y_UP_TO_Z_UP":
              rightaxis = Cesium__namespace.Axis.Y_UP_TO_Z_UP;
              break
            case "Z_UP_TO_Y_UP":
              rightaxis = Cesium__namespace.Axis.Z_UP_TO_Y_UP;
              break
            case "X_UP_TO_Z_UP":
              rightaxis = Cesium__namespace.Axis.X_UP_TO_Z_UP;
              break
            case "Z_UP_TO_X_UP":
              rightaxis = Cesium__namespace.Axis.Z_UP_TO_X_UP;
              break
            case "X_UP_TO_Y_UP":
              rightaxis = Cesium__namespace.Axis.X_UP_TO_Y_UP;
              break
            case "Y_UP_TO_X_UP":
              rightaxis = Cesium__namespace.Axis.Y_UP_TO_X_UP;
              break
          }
        } else if (this.options.axis instanceof Cesium__namespace.Axis) {
          rightaxis = this.options.axis;
        }
        if (rightaxis) {
          matrix = Cesium__namespace.Matrix4.multiplyTransformation(matrix, rightaxis, matrix);
        }
      }

      this._tileset._root.transform = matrix;

      this.fire(EventType.updatePosition, { position: this.position });

      return matrix
    }

    /**
     * 重新计算当前矩阵，普通方式, 此种方式[x，y不能多次更改]
     * @return {Cesium.Matrix4} 计算完成的矩阵
     */
    updateMatrix2() {
      if (!this._tileset || !this._tileset._root) {
        return
      }

      const catographic = Cesium__namespace.Cartographic.fromCartesian(this._tileset.boundingSphere.center);
      const surface = Cesium__namespace.Cartesian3.fromRadians(catographic.longitude, catographic.latitude, 0.0);
      const center = this.position;
      const translation = Cesium__namespace.Cartesian3.subtract(center, surface, new Cesium__namespace.Cartesian3());
      const matrix = Cesium__namespace.Matrix4.fromTranslation(translation);
      this._tileset.modelMatrix = matrix;

      this.fire(EventType.updatePosition, { position: this.position });

      return matrix
    }

    /**
     * 获取构件节点位置，现对于原始矩阵变化后的新位置
     *
     * @param {Cesium.Cartesian3} position 原始位置
     * @return {Cesium.Cartesian3} 新位置
     */
    getPositionByOrginMatrix(position) {
      if (this.orginMatrix) {
        const mat = Cesium__namespace.Matrix4.multiply(this._tileset._root.transform, this.orginMatrix, new Cesium__namespace.Matrix4());
        return Cesium__namespace.Matrix4.multiplyByPoint(mat, position, new Cesium__namespace.Cartesian3())
      }
      return position
    }

    /**
     * 设置透明度
     *
     * @param {Number} value 透明度
     * @return {void}  无
     */
    setOpacity(value) {
      if (this.options.onSetOpacity) {
        this.options.onSetOpacity(value); // 外部自定义处理
      } else {
        if (this._tileset) {
          this._tileset.style = new Cesium__namespace.Cesium3DTileStyle({
            color: "color() *vec4(1,1,1," + value + ")"
          });
        }
      }
    }

    // 定位至数据区域
    flyTo(options = {}) {
      if (!this._map) {
        return Promise.resolve(false)
      }
      this._map.cancelFlyTo();

      if (this.options.center) {
        return this._map.setCameraView(this.options.center, options)
      } else if (this.options.extent) {
        return this._map.flyToExtent(this.options.extent, options)
      } else if (this.loadOk && this._tileset._root) {
        return this._map.flyToPoint(this._tileset.boundingSphere.center, {
          radius: this._tileset.boundingSphere.radius * 2,
          maxPitch: -45,
          ...options
        })
      } else {
        return this.readyPromise.then((layer) => {
          return this._map.flyToPoint(this._tileset.boundingSphere.center, {
            radius: this._tileset.boundingSphere.radius * 2,
            maxPitch: -45,
            ...options
          })
        })
      }
    }

    /**
     * 设置属性信息到Feature上
     * @param {String} idField 数据中唯一标识的属性字段名称
     * @param {Object[]} properties 属性值数组
     * @returns {TilesetLayer} 当前图层本身图层
     */
    setProperties(idField, properties) {
      this._idField = idField;

      this._properties = {};
      properties.forEach((property) => {
        const id = property[idField];
        this._properties[id] = property;
      });

      this._bindVisibleEvent();
      return this
    }

    /**
     * 移除 设置属性信息到Feature上
     * @param {String} [idField] 数据中唯一标识的属性字段名称,为空时删除所有
     * @param {Object[]} [properties] 属性值数组,为空时删除所有
     * @returns {TilesetLayer} 当前图层本身图层
     */
    delProperties(idField, properties) {
      if (!idField || !properties) {
        delete this._properties;
        return
      }

      this._properties = {};
      properties.forEach((property) => {
        const id = property[idField];
        delete this._properties[id];
      });

      return this
    }

    _bindVisibleEvent() {
      if (!this._isBindTileVisible) {
        this._tileset.tileVisible.addEventListener(this._updateTile, this);
        this._isBindTileVisible = true;
      }
    }

    _updateTile(tile) {
      const content = tile.content;
      for (let i = 0; i < content.featuresLength; i++) {
        const feature = content.getFeature(i);

        // sets properties
        if (this._properties) {
          const id = feature.getProperty(this._idField);
          if (id) {
            this._setFeatureProperties(feature, this._properties[id]);
          }
        }

        // sets style
        if (this._styleCallback) {
          let oldAttr = feature._attr;
          if (!oldAttr) {
            oldAttr = feature._attr = get3DTileFeatureAttr(feature);
          }

          const color = this._styleCallback({ feature: feature, properties: oldAttr });
          if (color) {
            feature.color = getCesiumColor(color);
          }
        }
      }

      this.fire(EventType.update);
    }

    // 更新feature属性
    _setFeatureProperties(feature, newAttr) {
      if (!feature || !newAttr) {
        return
      }

      // if (newAttr instanceof Promise) {
      //   newAttr.then((reAttr) => {
      //     this._setFeatureProperties(feature, reAttr);
      //   });
      //   return;
      // }

      for (const key in newAttr) {
        const val = newAttr[key];
        if (feature.hasProperty(key) && feature.getProperty(key) === val) {
          continue
        }
        feature.setProperty(key, val);
      }
    }

    // 根据map及图层坐标系 转换中心点
    transformCenter(center) {
      if (!center) {
        return false
      }

      const dstCoordType = this._map.chinaCRS; // map地图的坐标系
      const srcCoordType = this.options.chinaCRS; // layer图层的坐标系（默认与地图一致）
      const TransFun = getTransFun(srcCoordType, dstCoordType);
      if (!TransFun) {
        return false
      }

      const pt = TransFun([center.lng, center.lat]);
      return { lng: pt[0], lat: pt[1], alt: center.alt }
    }

    // 绑定  设置最大视距后自动隐藏（不建议，效率一般）
    bindVisibleDistance() {
      this._map.on(EventType.cameraChanged, this.updateVisibleDistance, this);
    }

    updateVisibleDistance() {
      if (!this._show) {
        return
      }
      if (this._map.scene.mode !== Cesium__namespace.SceneMode.SCENE3D) {
        return
      }
      if (!this._tileset || !this.loadOk) {
        return
      }

      const camera_distance = Cesium__namespace.Cartesian3.distance(this.position, this._map.camera.positionWC);
      if (camera_distance > this.options.visibleDistanceMax + 100000) {
        // 在模型的外包围外
        this._tileset.show = false;
      } else {
        const target = this._map.getCenter(); // 取屏幕中心点坐标
        if (Cesium__namespace.defined(target)) {
          const distance = Cesium__namespace.Cartesian3.distance(target, this._map.camera.positionWC);
          this._tileset.show = distance < this.options.visibleDistanceMax;
        } else {
          this._tileset.show = true;
        }
      }
    }

    // Highlight 移入
    _highlight_mouseEventHandler(event) {
      this._map.closeHighlight(); // 需要关闭下

      const pickedFeature = event.pickedObject;
      if (pickedFeature || this._highlightOptions.all) {
        if (isFunction(this._highlightOptions.filter)) {
          if (this._highlightOptions.filter(event) === false) {
            return
          }
        }
        const allowDrillPickVal = this.allowDrillPick;
        if (isFunction(allowDrillPickVal)) {
          if (allowDrillPickVal(event) === true) {
            return // 允许穿透时不着色
          }
        }

        this._last_picked = { feature: pickedFeature, event: event };
        this._map.openHighlight(this, this._highlightOptions, event);
      } else {
        this._map.closeHighlight();
      }
    }

    /**
     * 高亮对象。
     * @param {Object} [highlightStyle] 高亮的样式，具体见各{@link GraphicType}矢量数据的style参数。
     * @param {Boolean} [closeLast=true] 是否清除地图上上一次的高亮对象
     * @param {Cesium.Cesium3DTileFeature} [pickedObject] 需要高亮的构件, 如果是mars3d的相关事件内时，可以取 event.pickedObject
     * @return {void}  无
     */
    openHighlight(highlightStyle, closeLast = true, pickedObject) {
      if (closeLast) {
        this._map.closeHighlight();
        this._map.last_highlighGraphic = this;
      }

      this._last_picked = this._last_picked || { event: { layer: this } };
      if (pickedObject) {
        this._last_picked.feature = pickedObject;
      }

      const style = highlightStyle || this._highlightOptions;
      if (style) {
        if (this._last_picked?.feature && !style.all) {
          const pickedFeature = this._last_picked.feature;

          if (pickedFeature?.color && style.color) {
            this._last_picked.originalColor = pickedFeature.color.clone(); // 记录历史值
            if (isFunction(style.color)) {
              pickedFeature.color = getCesiumColor(style.color(this._last_picked?.event));
            } else {
              pickedFeature.color = getColorByStyle(style);
            }
          }

          // 测试功能
          if (pickedFeature?.content?._model && style.model) {
            this._last_picked.originalStyle = ModelStyleConver.toJSON(pickedFeature.content._model); // 记录历史值
            ModelStyleConver.toCesiumVal(style.model, pickedFeature.content._model, false);
          }
        } else {
          const styleColor = Cesium__namespace.Color.fromCssColorString(style.color).toCssColorString();
          this._tileset.style = new Cesium__namespace.Cesium3DTileStyle({
            color: {
              conditions: [["true", styleColor]]
            }
          });
          this._highlightAll = true;
        }
        this.fire(EventType.highlightOpen, this._last_picked?.event, true);
      }
    }

    /**
     * 清除已选中的高亮，原有style的配置项需要与highlightStyle配置有一一对应关系，否则无法清除
     * @return {void}  无
     */
    closeHighlight() {
      if (!this._last_picked) {
        return
      }

      if (this._highlightAll) {
        this._highlightAll = false;
        this._tileset.style = this.style;
      } else if (this._last_picked?.feature) {
        const pickedFeature = this._last_picked.feature;

        if (this._last_picked.originalColor) {
          pickedFeature.color = this._last_picked.originalColor; // 还原颜色
        }

        // 测试功能
        if (pickedFeature?.content?._model && this._last_picked.originalStyle) {
          ModelStyleConver.toCesiumVal(this._last_picked.originalStyle, pickedFeature.content._model, false);
        }
      }

      this._map._clearLastHighlight();

      this.fire(EventType.highlightClose, this._last_picked?.event, true);
      delete this._last_picked;
    }

    //= ============= popup ======================

    /**
     *  是否存在Popup绑定
     * @return {Boolean} 是否存在Popup绑定
     */
    hasPopup() {
      if (this._popupConfig) {
        return true
      }
      return false
    }

    /**
     * 绑定鼠标单击对象后的弹窗。
     *
     * @param {String|Array|Function} content 弹窗内容html字符串，或者回调方法。
     * @param {Popup.StyleOptions} [options] 控制参数
     * @return {TilesetLayer} 当前对象本身，可以链式调用
     *
     */
    bindPopup(content, options) {
      this._popupConfig = {
        content: content,
        options: options,
        layer: this
      };
      this._bindControl();
      return this
    }

    /**
     * 解除绑定的鼠标单击对象后的弹窗。
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    unbindPopup() {
      this.closePopup();
      this._popupConfig = null;
      return this
    }

    /**
     * 关闭弹窗
     *
     * @return {BaseGraphicLayer} 当前对象本身，可以链式调用
     */
    closePopup() {
      if (this._map && this.hasPopup()) {
        this._map.popup.close(null, this);
      }
      return this
    }

    // 处理传递给 mars3d-cesium 内部的参数，下面命名无必要勿修改，与mars3d-cesium关联较大。
    _conventMarsOptions() {
      // 内置的建筑物特效
      if (this.marsJzwStyle) {
        this._marsOptions.updatePbrFsByJzw = (opts) => {
          return getJzwStyle({
            upz: this.upAxis === Cesium__namespace.Axis.Z,
            jzwStyle: this.marsJzwStyle
          })
        };
      } else {
        delete this._marsOptions.updatePbrFsByJzw;
      }
    }

    // 用于TilesetEditBase模型编辑的
    _initByEdit() {
      this._marsEditor = {
        IsYaPing: new Cesium__namespace.Cartesian4(false, false, false, false), // [是否开启编辑，是否开启压平，是否开启裁剪，是否开启淹没]
        editVar: new Cesium__namespace.Cartesian4(false, false, false, false), // [是否开启裁剪外部，是否开启淹没全局，]
        floodVar: new Cesium__namespace.Cartesian4(0, 0, 0, 0), // [基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]
        floodColor: new Cesium__namespace.Cartesian4(0.15, 0.7, 0.95, 0.5), // [淹没颜色的r(0-1之间)，淹没颜色的g，淹没颜色的b，淹没混合系数（建议取值范围0.3-0.7）]
        heightVar: new Cesium__namespace.Cartesian2(0, 0) // 基础压平高度，调整压平高度值
      };

      // UniformMap
      const b3dmOffset = this.options.b3dmOffset || new Cesium__namespace.Cartesian3(0.0, 0.0, 0.0);
      const defaultTexture = this._map.scene.context.defaultTexture;

      // 对应UniformMap在processPbrMaterials.js中使用
      this._marsOptions.updateModelUniformMap = {
        u_mars_polygonTexture: () => {
          return this._marsEditor.polygonTexture ?? defaultTexture
        },
        u_mars_polygonBounds: () => {
          return this._marsEditor.flatExtent ?? Cesium__namespace.Cartesian4.ZERO
        },
        u_mars_modelInverseMatrix: () => {
          return this.inverseMatrix ?? Cesium__namespace.Matrix4.ZERO
        },
        u_mars_tilesetMatrix: () => {
          return this.modelMatrix ?? Cesium__namespace.Cartesian4.ZERO
        },
        u_mars_modelUpZ: () => {
          return this.upAxis === Cesium__namespace.Axis.Z
        },
        u_mars_heightVar: () => {
          return this._marsEditor?.heightVar ?? Cesium__namespace.Cartesian2.ZERO
        },
        u_mars_IsYaPing: () => {
          return this._marsEditor?.IsYaPing ?? Cesium__namespace.Cartesian4.ZERO
        },
        u_mars_editVar: () => {
          return this._marsEditor?.editVar ?? Cesium__namespace.Cartesian4.ZERO
        },
        u_mars_floodVar: () => {
          return this._marsEditor?.floodVar ?? Cesium__namespace.Cartesian4.ZERO
        },
        u_mars_floodColor: () => {
          return this._marsEditor?.floodColor ?? Cesium__namespace.Cartesian4.ZERO
        },
        u_mars_offset: () => {
          return b3dmOffset // 有些模型会有偏移，此变量用来调整，一个模型只需调整一次
        }
      };
    }

    //= =================Draw编辑相关=================
    /**
     * 开始编辑对象
     * @return {void}  无
     */
    startEditing() {
      if (this._enabledEdit || !this.hasEdit) {
        return this
      }
      this._enabledEdit = true;

      if (!this._map) {
        throw new Error("编辑时_map不能为空,请将对象添加到Map")
      }

      this._map.mouseEvent.noPickEntity = this._entity;
      this._map.mouseEvent.enabledMoveTarget = false;

      if (!this.editing) {
        this.editing = new EditTileset(this);
      }

      if (this.editing.activate) {
        this.editing.activate();
      }
    }

    /**
     * 停止编辑，释放正在编辑的对象。
     * @return {void}  无
     */
    stopEditing() {
      if (!this._enabledEdit) {
        return this
      }

      if (this.editing?.disable) {
        this.editing.disable();
      }

      if (this._map) {
        this._map.closeSmallTooltip();
        this._map.mouseEvent.noPickEntity = null;
        this._map.mouseEvent.enabledMoveTarget = true;
      }
      this._enabledEdit = false;
    }
  }

  // 注册下
  register$2("tileset", TilesetLayer); // 备用
  register$2("3dtiles", TilesetLayer); // 主要

  // 内置的建筑物特效
  function getJzwStyle(options) {
    let fragmentShader = "  float marsJzwHeight = v_mars_vertex.z;";
    if (!options.upz) {
      // fragmentShader += "marsJzwHeight = (u_mars_modelInverseMatrix * czm_inverseView * vec4(v_mars_viewPos,1.0)).z;"
      fragmentShader += "marsJzwHeight = v_mars_vertex.y;";
    }

    if (typeof options.jzwStyle === "string") {
      fragmentShader += options.jzwStyle;
    } else {
      fragmentShader += `
      // 注意shader中写浮点数是，一定要带小数点，否则会报错，比如0需要写成0.0，1要写成1.0
      float _baseHeight = 0.0; // 物体的基础高度，需要修改成一个合适的建筑基础高度
      float _heightRange = 80.0; // 高亮的范围(_baseHeight ~ _baseHeight + _heightRange)
      float _glowRange = 100.0; // 光环的移动范围(高度)

      // 建筑基础色
      float mars_height = marsJzwHeight - _baseHeight;
      float mars_a11 = fract(czm_frameNumber / 120.0) * 3.14159265 * 2.0;
      float mars_a12 = mars_height / _heightRange + sin(mars_a11) * 0.1;

      // 底楼 亮度太暗了，那么把20%以内的底楼，都不再变暗
      if(mars_height/ 100.0 < 0.2) {
        gl_FragColor *= vec4(vec3(mars_height / 100.0 * 2.0), 1.0);
      }else{
        gl_FragColor *= vec4(vec3(mars_a12), 1.0);// 渐变
      }

      // 动态光环
      float time = fract(czm_frameNumber / 360.0);
      time = abs(time - 0.5) * 2.0;
      float mars_h = clamp(mars_height / _glowRange, 0.0, 1.0);
      float mars_diff = step(0.005, abs(mars_h - time));
      gl_FragColor.rgb += gl_FragColor.rgb * (1.0 - mars_diff);
    `;
    }
    return fragmentShader
  }

  /**
   * OSM在线 建筑物模型
   *
   * @param {Object} options 参数对象，参数包括以下：
   * @param {Number} [options.maximumScreenSpaceError=16] 用于驱动细化细节级别的最大屏幕空间错误。数值加大，能让最终成像变模糊
   * @param {Number} [options.maximumMemoryUsage=512] 数据集可以使用的最大内存量(以MB计)。这个参数默认是512，也即是当几何体和纹理资源大于512MB的时候，Cesium就会淘汰掉当前帧中没有visited的所有块，这个值其实很小，也是cesium为了避免资源占用过高的一个保障，不过上述我们也估算过最差情况下，没有做纹理crn压缩的情况下，这个值很容易被超过，导致很多人误以为cesium的淘汰没有效果。这个值如果设置的过小，导致cesium几乎每帧都在尝试淘汰数据，增加了遍历的时间，也同时增加了崩溃的风险。这个值如果设置的过大，cesium的淘汰机制失效，那么容易导致显存超过显卡内存，也会导致崩溃。 这个值应该处于最差视角下资源占用 和 显存最大量之间。结论：这个参数要根据当前显卡显存来配置，如果我们场景只显示这一个模型数据，这个可以设置到显存的50 % 左右，比如我的显存是6G，这个可以设置到3000左右。那么既保证不超过显存限制，又可以最大利用显存缓存，配合crn压缩之后，这个几乎可以保证你第二次查看模型同一位置的时候，看不到加载过程，非常棒。
   *
   * @param {Object|Cesium.Cesium3DTileStyle|Function} [options.style]  模型样式， 使用{@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.
   * @param {Boolean|String} [options.marsJzwStyle=false] 开启或设置建筑物特效样式。
   * @param {Cesium.CustomShader} [options.customShader] 自定义shader效果
   *
   * @param {Object|OutlineEffect.Options} [options.highlight]  高亮及其样式配置
   * @param {String} [options.highlight.type] 鼠标移入高亮 或 单击高亮(type:'click')
   * @param {Boolean} [options.highlight.all] 是否整体高亮， true:模型整体全部高亮，false:单个构件高亮
   * @param {String|function} [options.highlight.color='#FFFF00'] 颜色，支持rgba字符串
   * @param {Boolean} [options.highlight.outlineEffect=false] 默认为修改矢量对象本身的style高亮，true时采用{@link OutlineEffect}方式高亮。
   * @param {Function} [options.highlight.filter] 可以设置筛选排除一些构件, 排除的构件在filter方法内返回false
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   *
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑定，参数与popup属性完全相同。
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数,还包括：
   * @param {String} [options.tooltipOptions.title] 固定的标题名称
   * @param {String} [options.tooltipOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.tooltipOptions.noTitle] 不显示标题
   * @param {Object} [options.contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @class OsmBuildingsLayer
   * @extends {TilesetLayer}
   * @see [支持的事件类型]{@link TilesetLayer.EventType}
   */
  class OsmBuildingsLayer extends TilesetLayer {
    _createCesium3DTileset() {
      const tileset = Cesium__namespace.createOsmBuildings(this.options);
      tileset.enableModelExperimental = !!this.options.customShader;
      return tileset
    }
  }

  // 注册下
  register$2("osmBuildings", OsmBuildingsLayer);

  // 经纬网

  const mins = [
    Cesium__namespace.Math.toRadians(0.05),
    Cesium__namespace.Math.toRadians(0.1),
    Cesium__namespace.Math.toRadians(0.2),
    Cesium__namespace.Math.toRadians(0.5),
    Cesium__namespace.Math.toRadians(1.0),
    Cesium__namespace.Math.toRadians(2.0),
    Cesium__namespace.Math.toRadians(5.0),
    Cesium__namespace.Math.toRadians(10.0)
  ];

  function gridPrecision(dDeg) {
    if (dDeg < 0.01) {
      return 2
    }
    if (dDeg < 0.1) {
      return 1
    }
    if (dDeg < 1) {
      return 0
    }
    return 0
  }

  function GraticuleProvider(options) {
    this.options = options;
    this._tilingScheme = options.tilingScheme || new Cesium__namespace.GeographicTilingScheme();

    this._tileWidth = options.tileWidth || 256;
    this._tileHeight = options.tileHeight || 256;

    this._ready = true;

    // default to decimal intervals
    this._sexagesimal = options.sexagesimal || false;
    this._numLines = options.numLines || 50;

    this._scene = options.scene;
    this._ellipsoid = this._scene.globe.ellipsoid;

    this._labels = new Cesium__namespace.LabelCollection();
    this._scene.primitives.add(this._labels);
    this._polylines = new Cesium__namespace.PolylineCollection();
    this._scene.primitives.add(this._polylines);

    const canvas = document.createElement("canvas");
    canvas.width = 256;
    canvas.height = 256;
    this._canvas = canvas;

    const that = this;
    this._scene.camera.moveEnd.addEventListener(function () {
      if (!that._show) {
        return
      }

      that._polylines.removeAll();
      that._labels.removeAll();
      that._currentExtent = null;
      that._drawGrid(that._getExtentView());
    });
    this._scene.imageryLayers.addImageryProvider(this);
  }

  // let definePropertyWorks = (function () {
  //   try {
  //     return 'x' in Object.defineProperty({}, 'x', {})
  //   } catch (e) {
  //     return false
  //   }
  // })()

  /**
   * Defines properties on an object, using Object.defineProperties if available,
   * catch returns the object unchanged.  This function should be used in
   * setup code to prevent errors from completely halting JavaScript execution
   * in legacy browsers.
   * @private
   */

  Object.defineProperties(GraticuleProvider.prototype, {
    url: {
      get: function () {
        return undefined
      }
    },

    proxy: {
      get: function () {
        return undefined
      }
    },

    tileWidth: {
      get: function () {
        return this._tileWidth
      }
    },

    tileHeight: {
      get: function () {
        return this._tileHeight
      }
    },

    maximumLevel: {
      get: function () {
        return 18
      }
    },

    minimumLevel: {
      get: function () {
        return 0
      }
    },
    tilingScheme: {
      get: function () {
        return this._tilingScheme
      }
    },
    rectangle: {
      get: function () {
        return this._tilingScheme.rectangle
      }
    },
    tileDiscardPolicy: {
      get: function () {
        return undefined
      }
    },
    errorEvent: {
      get: function () {
        return this._errorEvent
      }
    },
    ready: {
      get: function () {
        return this._ready
      }
    },
    credit: {
      get: function () {
        return this._credit
      }
    },
    hasAlphaChannel: {
      get: function () {
        return true
      }
    }
  });

  GraticuleProvider.prototype.makeLabel = function (lng, lat, text, top, color) {
    const addAtrr = LabelStyleConver.toCesiumVal(this.options.labelStyle || {}, {
      style: Cesium__namespace.LabelStyle.FILL_AND_OUTLINE,
      fillColor: Cesium__namespace.Color.AZURE,
      outlineColor: Cesium__namespace.Color.BLACK,
      outlineWidth: 2,
      pixelOffset: new Cesium__namespace.Cartesian2(5, top ? 5 : -5),
      eyeOffset: Cesium__namespace.Cartesian3.ZERO,
      horizontalOrigin: Cesium__namespace.HorizontalOrigin.LEFT,
      verticalOrigin: top ? Cesium__namespace.VerticalOrigin.BOTTOM : Cesium__namespace.VerticalOrigin.TOP,
      scale: 1.0
    });
    addAtrr.position = this._ellipsoid.cartographicToCartesian(new Cesium__namespace.Cartographic(lng, lat, 10.0));
    addAtrr.text = text;

    this._labels.add(addAtrr);
  };

  GraticuleProvider.prototype._drawGrid = function (extent) {
    if (this._currentExtent && this._currentExtent.equals(extent)) {
      return
    }
    this._currentExtent = extent;

    this._polylines.removeAll();
    this._labels.removeAll();

    // let minPixel = 0
    // let maxPixel = this._canvasSize

    let dLat = 0;
    let dLng = 0;
    let index;
    // get the nearest to the calculated value
    for (index = 0; index < mins.length && dLat < (extent.north - extent.south) / 10; index++) {
      dLat = mins[index];
    }
    for (index = 0; index < mins.length && dLng < (extent.east - extent.west) / 10; index++) {
      dLng = mins[index];
    }

    // round iteration limits to the computed grid interval
    let minLng = (extent.west < 0 ? Math.ceil(extent.west / dLng) : Math.floor(extent.west / dLng)) * dLng;
    let minLat = (extent.south < 0 ? Math.ceil(extent.south / dLat) : Math.floor(extent.south / dLat)) * dLat;
    let maxLng = (extent.east < 0 ? Math.ceil(extent.east / dLat) : Math.floor(extent.east / dLat)) * dLat;
    let maxLat = (extent.north < 0 ? Math.ceil(extent.north / dLng) : Math.floor(extent.north / dLng)) * dLng;

    // extend to make sure we cover for non refresh of tiles
    minLng = Math.max(minLng - 2 * dLng, -Math.PI);
    maxLng = Math.min(maxLng + 2 * dLng, Math.PI);
    minLat = Math.max(minLat - 2 * dLat, -Math.PI / 2);
    maxLat = Math.min(maxLat + 2 * dLng, Math.PI / 2);

    const ellipsoid = this._ellipsoid;
    let lat;
    let lng;
    const granularity = Cesium__namespace.Math.toRadians(1);

    // labels positions
    const latitudeText = minLat + Math.floor((maxLat - minLat) / dLat / 2) * dLat;
    for (lng = minLng; lng < maxLng; lng += dLng) {
      // draw meridian
      const path = [];
      for (lat = minLat; lat < maxLat; lat += granularity) {
        path.push(new Cesium__namespace.Cartographic(lng, lat));
      }
      path.push(new Cesium__namespace.Cartographic(lng, maxLat));

      this._polylines.add(
        PolylineStyleConver.toCesiumVal(this.options.lineStyle || {}, {
          positions: ellipsoid.cartographicArrayToCartesianArray(path),
          width: 1
        })
      );

      const degLng = Cesium__namespace.Math.toDegrees(lng);
      this.makeLabel(lng, latitudeText, this._sexagesimal ? this._decToSex(degLng) : degLng.toFixed(gridPrecision(dLng)), false);
    }

    // lats
    const longitudeText = minLng + Math.floor((maxLng - minLng) / dLng / 2) * dLng;
    for (lat = minLat; lat < maxLat; lat += dLat) {
      // draw parallels
      const path = [];
      for (lng = minLng; lng < maxLng; lng += granularity) {
        path.push(new Cesium__namespace.Cartographic(lng, lat));
      }
      path.push(new Cesium__namespace.Cartographic(maxLng, lat));

      this._polylines.add(
        PolylineStyleConver.toCesiumVal(this.options.lineStyle || {}, {
          positions: ellipsoid.cartographicArrayToCartesianArray(path),
          width: 1
        })
      );

      const degLat = Cesium__namespace.Math.toDegrees(lat);
      this.makeLabel(longitudeText, lat, this._sexagesimal ? this._decToSex(degLat) : degLat.toFixed(gridPrecision(dLat)), true);
    }
  };

  GraticuleProvider.prototype.requestImage = function (x, y, level) {
    return new Promise((resolve, reject) => {
      if (this._show) {
        this._drawGrid(this._getExtentView());
      }
      resolve(this._canvas);
    })
  };

  GraticuleProvider.prototype.setVisible = function (show) {
    this._show = show;
    if (!show) {
      this._polylines.removeAll();
      this._labels.removeAll();
    } else {
      this._currentExtent = null;
      this._drawGrid(this._getExtentView());
    }
  };

  GraticuleProvider.prototype.isVisible = function () {
    return this._show
  };

  GraticuleProvider.prototype._decToSex = function (d) {
    let degs = Math.floor(d);
    let mins = ((Math.abs(d) - degs) * 60.0).toFixed(2);
    if (mins === "60.00") {
      degs += 1.0;
      mins = "0.00";
    }
    return [degs, ":", mins].join("")
  };

  GraticuleProvider.prototype._getExtentView = function () {
    const camera = this._scene.camera;
    const canvas = this._scene.canvas;
    const corners = [
      camera.pickEllipsoid(new Cesium__namespace.Cartesian2(0, 0), this._ellipsoid),
      camera.pickEllipsoid(new Cesium__namespace.Cartesian2(canvas.width, 0), this._ellipsoid),
      camera.pickEllipsoid(new Cesium__namespace.Cartesian2(0, canvas.height), this._ellipsoid),
      camera.pickEllipsoid(new Cesium__namespace.Cartesian2(canvas.width, canvas.height), this._ellipsoid)
    ];
    for (let index = 0; index < 4; index++) {
      if (corners[index] === undefined) {
        return Cesium__namespace.Rectangle.MAX_VALUE
      }
    }
    return Cesium__namespace.Rectangle.fromCartographicArray(this._ellipsoid.cartesianArrayToCartographicArray(corners))
  };

  /**
   * 经纬网
   *
   * @param {Object} [options] 参数对象，包括以下：
   *
   * @param {Number} [options.numLines=10] 网格数
   * @param {PolylinePrimitive.StyleOptions} [options.lineStyle] 线的样式
   * @param {LabelEntity.StyleOptions} [options.labelStyle] 文本的样式
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @class GraticuleLayer
   * @extends {BaseLayer}
   */
  class GraticuleLayer extends BaseLayer {
    get layer() {
      return this._graticuleProvider
    }

    _showHook(val) {
      if (this._graticuleProvider) {
        this._graticuleProvider.setVisible(val);
      }
    }

    // 创建图层对象的方法
    _mountedHook() {
      this._graticuleProvider = new GraticuleProvider({
        scene: this._map.scene,
        numLines: 10,
        ...this.options
      });
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._graticuleProvider.setVisible(true);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._graticuleProvider.setVisible(false);
    }
  }

  // 注册下
  register$2("graticule", GraticuleLayer);

  /**
   * @typedef {Object} LodGraphicLayer.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} add 添加对象
   * @property {String} remove 移除对象
   * @property {String} show 显示了对象
   * @property {String} hide 隐藏了对象
   *
   * @property {String} click 左键单击 鼠标事件
   * @property {String} rightClick 右键单击 鼠标事件
   * @property {String} mouseOver 鼠标移入 鼠标事件
   * @property {String} mouseOut 鼠标移出 鼠标事件
   *
   * @property {String} popupOpen popup弹窗打开后
   * @property {String} popupClose popup弹窗关闭
   * @property {String} tooltipOpen tooltip弹窗打开后
   * @property {String} tooltipClose tooltip弹窗关闭
   * @property {String} addGraphic 添加矢量数据时
   * @property {String} removeGraphic 移除矢量数据时
   *
   * @example
   * //绑定监听事件
   * layer.on(mars3d.EventType.addGraphic, function (event) {
   *   console.log('添加了矢量数据', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 矢量数据LOD分层分块加载类
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.IdField='id']  数据中唯一标识的属性字段名称
   * @param {Function} options.queryGridData  获取网格内对应数据的的外部处理回调方法
   * @param {Function} options.createGraphic  根据数据创建矢量对象的外部处理回调方法
   * @param {Function} options.updateGraphic  根据数据更新矢量对象的外部处理回调方法，一般动态数据时可以用
   * @param {Number} [options.minimumLevel=0] 图层所支持的最低层级，当地图小于该级别时，平台不去请求服务数据。【影响效率的重要参数】
   * @param {Number} [options.maximumLevel] 图层所支持的最大层级,当地图大于该级别时，平台不去请求服务数据。
   * @param {Object} options.rectangle 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Boolean} options.debuggerTileInfo  是否开启测试显示瓦片信息
   *
   * @param {Number} [options.opacity = 1.0] 透明度（部分图层），取值范围：0.0-1.0
   * @param {Number} [options.zIndex] 控制图层的叠加层次（部分图层），默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面。
   * @param {Object|Function} [options.symbol] 矢量数据的style样式,为Function时是完全自定义的回调处理 symbol(attr, style, feature)
   * @param {BillboardEntity.StyleOptions|PolylineEntity.StyleOptions|PolygonEntity.StyleOptions|*} options.symbol.styleOptions 数据的Style样式
   * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
   * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
   * @param {Boolean} [options.symbol.merge] 是否合并并覆盖json中已有的style，默认不合并。
   * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
   *
   * @param {Object} options.clustering 设置聚合相关参数：
   * @param {Boolean} [options.clustering.enabled=false] 是否开启聚合
   * @param {Number} [options.clustering.pixelRange=20] 多少像素矩形范围内聚合
   * @param {Boolean} [options.clustering.clampToGround=true] 是否贴地
   * @param {Number} [options.clustering.radius=28] 圆形图标的整体半径大小（单位：像素）
   * @param {Number} [options.clustering.radiusIn=radius-5] 圆形图标的内圆半径大小（单位：像素）
   * @param {String} [options.clustering.fontColor='#ffffff'] 数字的颜色
   * @param {String} [options.clustering.color='rgba(181, 226, 140, 0.6)'] 圆形图标的背景颜色，默认自动处理
   * @param {String} [options.clustering.colorIn='rgba(110, 204, 57, 0.5)'] 圆形图标的内圆背景颜色，默认自动处理
   *
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑定，参数与popup属性完全相同。
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数,还包括：
   * @param {String} [options.tooltipOptions.title] 固定的标题名称
   * @param {String} [options.tooltipOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.tooltipOptions.noTitle] 不显示标题
   * @param {Object} [options.contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   * @export
   * @class LodGraphicLayer
   * @extends {GraphicLayer}
   *
   * @see [支持的事件类型]{@link LodGraphicLayer.EventType}
   */
  class LodGraphicLayer extends GraphicLayer {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      if (!isMars3DCesium) {
        logError("该功能需要引入mars3d修改版Cesium库(mars3d-cesium库)才支持!", this);
      }

      if (this.options.debuggerTileInfo) {
        this.bindPopup(function (event) {
          const gridList = event?.graphic?.gridList || [];
          return gridList.join("<br/>")
        });
      }
      this._cacheGrid = {}; // 网格缓存,存放矢量对象id集合
      this._cacheGraphic = {}; // 矢量对象缓存,存放矢量对象的id唯一标识和其所对应的网格集合
    }

    get isLoading() {
      for (const i in this._cacheGrid) {
        const item = this._cacheGrid[i];
        if (!item || !item.grid) {
          continue
        }

        if (item.isLoading) {
          return true
        }
      }
      return false
    }

    //= ========= 方法==========
    _showHook(val) {
      super._showHook(val);
      if (this._tileLayer) {
        this._tileLayer.show = val;
      }
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      super._mountedHook();

      const tileOptions = { ...this.options, private: true };
      delete tileOptions.id;
      delete tileOptions.name;
      delete tileOptions.url;
      delete tileOptions.type;

      this._tileLayer = new EmptyTileLayer(tileOptions);
      this._tileLayer.readyPromise.then(() => {
        this._readyPromise.resolve(this);
      });
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      super._addedHook();

      this._tileLayer.on(EventType.addTile, this._tileLayer_addTileHandler, this);
      this._tileLayer.on(EventType.removeTile, this._tileLayer_removeTileHandler, this);
      this._map.addLayer(this._tileLayer);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      super._removedHook();

      this._tileLayer.off(EventType.addTile, this._tileLayer_addTileHandler, this);
      this._tileLayer.off(EventType.removeTile, this._tileLayer_removeTileHandler, this);
      this._map.removeLayer(this._tileLayer);

      this.clear();
    }

    getGridKey(grid) {
      return grid.level + "_x" + grid.x + "_y" + grid.y
    }

    checkHasBreak(cacheKey) {
      if (!this.show || !this._cacheGrid[cacheKey]) {
        return true
      }
      return false
    }

    // 加载了一个瓦片
    _tileLayer_addTileHandler(grid) {
      if (!this._tileLayer.isInRange(grid.level)) {
        return
      }
      const cacheKey = this.getGridKey(grid);
      grid.key = cacheKey;

      this._cacheGrid[cacheKey] = { grid: grid, isLoading: true };

      this.queryGridData(grid).then((result) => {
        if (this.show) {
          this._showData(result);
        }
      });
    }

    // 获取数据的唯一标识
    _getItemDataId(item) {
      if (item.id) {
        return item.id
      }

      if (item.type === "Feature") {
        item = item.properties;
      }
      if (item[this.options.IdField]) {
        return item[this.options.IdField]
      }
      return null
    }

    _showData(grid) {
      const arrdata = grid.list;
      const cacheKey = grid.key;
      if (this.checkHasBreak[cacheKey]) {
        // 异步请求结束时,如果已经卸载了网格就直接跳出。
        return
      }

      const arrIds = [];
      const arrGraphic = [];
      for (let i = 0, len = arrdata.length; i < len; i++) {
        const attr = arrdata[i];
        const id = this._getItemDataId(attr);
        if (!id) {
          logWarn("LodGraphicLayer: 数据的ID识别失败", attr);
        }

        const graphic = this._cacheGraphic[id];
        if (graphic) {
          // 已存在时，更新
          graphic.gridList.push(cacheKey);
          this.updateGraphic(graphic, attr);
        } else {
          // 不存在时，创建
          const graphic = this.createGraphic(grid, attr);
          if (!graphic) {
            continue
          }

          graphic.gridList = [cacheKey];
          this._cacheGraphic[id] = graphic;

          arrGraphic.push(graphic);
        }
        arrIds.push(id);
      }

      this._cacheGrid[cacheKey] = this._cacheGrid[cacheKey] || {};
      this._cacheGrid[cacheKey].ids = arrIds;
      this._cacheGrid[cacheKey].isLoading = false;

      this.fire(EventType.update, { graphics: arrGraphic });
    }

    // 卸载了一个瓦片
    _tileLayer_removeTileHandler(event) {
      if (this._tileLayer.isAllOutRange(event.level)) {
        this.clear();
        return
      }
      const cacheKey = this.getGridKey(event);

      const layers = this._cacheGrid[cacheKey];
      if (layers) {
        if (layers.ids) {
          for (let i = 0; i < layers.ids.length; i++) {
            const id = layers.ids[i];
            const graphic = this._cacheGraphic[id];
            if (!graphic) {
              continue
            }

            // 移除数组中的一项
            removeArrayItem(graphic.gridList, cacheKey);

            if (graphic.gridList.length === 0) {
              this.removeGraphic(graphic);
              delete this._cacheGraphic[id];
            }
          }
        }
        delete this._cacheGrid[cacheKey];
      }
    }

    /**
     * 根据LOD分块信息去请求对应的Tile瓦块内的数据
     * @param {Object} event 瓦片信息对象
     * @return {Promise<Object>} 异步计算完成的Promise
     * @abstract
     */
    queryGridData(event) {
      if (this.options.queryGridData) {
        return this.options.queryGridData(event)
      }
    }

    /**
     * 根据 attr属性 创建 矢量对象
     * @param {Object} grid 瓦片信息对象
     * @param {Object} attr 数据的属性信息
     * @return {BaseGraphic|*}  矢量对象
     * @abstract
     */
    createGraphic(grid, attr) {
      if (this.options.createGraphic) {
        // 传参方式
        return this.options.createGraphic(grid, attr)
      }
      return null
    }

    /**
     * 根据 attr属性 更新 矢量对象，主要是属性是动态变化的场景下使用。
     * @param {BaseGraphic|*} graphic 矢量对象
     * @param {Object} attr 数据的属性信息
     * @return {void}  无
     * @abstract
     */
    updateGraphic(graphic, attr) {
      if (this.options.updateGraphic) {
        // 传参方式
        this.options.updateGraphic(graphic, attr);
      }
    }

    /**
     * 清除图层内所有矢量数据
     *
     * @param {Boolean} [hasDestroy=false] 是否释放矢量对象
     * @return {void}  无
     */
    clear() {
      super.clear();
      this._cacheGraphic = {};
      this._cacheGrid = {};
    }

    /**
     * 重新加载数据
     * @return {void}  无
     */
    reload() {
      for (const i in this._cacheGrid) {
        const item = this._cacheGrid[i];
        if (!item || !item.grid || item.isLoading) {
          continue
        }

        this.queryGridData(item.grid).then((result) => {
          this._showData(result);
        });
      }
    }

    _toJsonEx(newData) {
      // 覆盖
    }
  }

  // 注册下
  register$2("lodGraphic", LodGraphicLayer);

  /**
   * 高德在线POI图层
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String[]} [options.key = mars3d.Token.gaodeArr] 高德KEY,在实际项目中请使用自己申请的高德KEY，因为我们的key不保证长期有效。
   * @param {Number} [options.minimumLevel=0] 图层所支持的最低层级，当地图小于该级别时，平台不去请求服务数据。【影响效率的重要参数】
   * @param {Number} [options.maximumLevel] 图层所支持的最大层级,当地图大于该级别时，平台不去请求服务数据。
   * @param {Object} options.rectangle 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Boolean} options.debuggerTileInfo  是否开启测试显示瓦片信息
   *
   * @param {Number} [options.zIndex] 控制图层的叠加层次（部分图层），默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面。
   * @param {Number} [options.opacity = 1.0] 透明度（部分图层），取值范围：0.0-1.0
   * @param {Object} [options.symbol] 矢量数据的style样式
   * @param {BillboardEntity.StyleOptions|PointEntity.StyleOptions} options.symbol.styleOptions 点的Style样式。
   * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
   * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
   *
   * @param {Object} options.clustering 设置聚合相关参数：
   * @param {Boolean} [options.clustering.enabled=false] 是否开启聚合
   * @param {Number} [options.clustering.pixelRange=20] 多少像素矩形范围内聚合
   * @param {Boolean} [options.clustering.clampToGround=true] 是否贴地
   * @param {Number} [options.clustering.radius=28] 圆形图标的整体半径大小（单位：像素）
   * @param {Number} [options.clustering.radiusIn=radius-5] 圆形图标的内圆半径大小（单位：像素）
   * @param {String} [options.clustering.fontColor='#ffffff'] 数字的颜色
   * @param {String} [options.clustering.color='rgba(181, 226, 140, 0.6)'] 圆形图标的背景颜色，默认自动处理
   * @param {String} [options.clustering.colorIn='rgba(110, 204, 57, 0.5)'] 圆形图标的内圆背景颜色，默认自动处理
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class GeodePoiLayer
   * @extends {LodGraphicLayer}
   * @see [支持的事件类型]{@link LodGraphicLayer.EventType}
   */
  class GeodePoiLayer extends LodGraphicLayer {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      this._key_index = 0;
      this._keys = this.options.key || gaodeArr;

      this.bindPopup(
        function (event) {
          const item = event?.graphic?.attr;
          if (!item) {
            return
          }
          const inHtml =
            "<div>名称：" +
            item.name +
            "</div>" +
            "<div>地址：" +
            item.address +
            "</div>" +
            "<div>区域：" +
            item.pname +
            item.cityname +
            item.adname +
            "</div>" +
            "<div>类别：" +
            item.type +
            "</div>";

          return inHtml
        },
        {
          anchor: [0, -10]
        }
      );
    }
    //= ========= 对外属性 ==========

    /**
     * 获取配置的高德Key（多个时轮询）
     *
     * @type {String}
     * @readonly
     */
    get key() {
      const thisidx = this._key_index++ % this._keys.length;
      return this._keys[thisidx]
    }

    /**
     * 根据LOD分块信息去请求对应的Tile瓦块内的数据
     * @param {Object} grid 瓦片信息对象
     * @return {Promise<Object>} 异步计算完成的Promise
     * @private
     */
    queryGridData(grid) {
      const jwd1 = wgs2gcj([grid.extent.xmin, grid.extent.ymax]); // 加偏
      const jwd2 = wgs2gcj([grid.extent.xmax, grid.extent.ymin]); // 加偏
      const polygon = jwd1[0] + "," + jwd1[1] + "|" + jwd2[0] + "," + jwd2[1];

      const filter = this.options.filter || {};
      filter.output = "json";
      filter.key = this.key;
      filter.polygon = polygon;
      if (!filter.offset) {
        filter.offset = 25;
      }
      if (!filter.types) {
        filter.types = "120000|130000|190000";
      }

      return new Promise((resolve, reject) => {
        // 查询POI服务
        fetchJson({
          url: "https://restapi.amap.com/v3/place/polygon",
          ...this.options,
          queryParameters: filter,
          proxy: this._proxy
        }).then((data) => {
          if (data.infocode !== "10000") {
            logError("POI 请求失败", data);
            grid.list = [];
            resolve(grid);
            return
          }
          grid.list = data.pois;
          resolve(grid);
        });
      })
    }

    /**
     * 根据 attr属性 创建 矢量对象
     * @param {Object} grid 瓦片信息对象
     * @param {Object} attr 数据的属性信息
     * @return {BaseGraphic|*}  矢量对象
     * @private
     */
    createGraphic(grid, attr) {
      let arrjwd = attr.location.split(",");
      arrjwd = gcj2wgs(arrjwd); // 纠偏

      const style = getSymbolStyle(this.options.symbol, attr);
      style.clampToGround = style.clampToGround ?? true;

      let graphic;
      if (this.options.clustering?.enabled) {
        // 当存在聚合时
        if (style.image) {
          graphic = new BillboardEntity({
            position: [arrjwd[0], arrjwd[1], this.options.height || 0],
            style: style,
            attr: attr
          });
        } else {
          graphic = new PointEntity({
            position: [arrjwd[0], arrjwd[1], this.options.height || 0],
            style: style,
            attr: attr
          });
        }
      } else {
        if (style.image) {
          graphic = new BillboardPrimitive({
            position: [arrjwd[0], arrjwd[1], this.options.height || 0],
            style: style,
            attr: attr
          });
        } else {
          graphic = new PointPrimitive({
            position: [arrjwd[0], arrjwd[1], this.options.height || 0],
            style: style,
            attr: attr
          });
        }
      }

      this.addGraphic(graphic);
      return graphic
    }
  }

  // 注册下
  register$2("gaodePOI", GeodePoiLayer);

  /**
   * WFS图层
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} options.url WFS服务地址
   * @param {Object} [options.parameters] 要在URL中 传递给WFS服务GetFeature请求的其他参数。
   * @param {Number} [options.parameters.maxFeatures] 返回结果最大数量
   * @param {String} [options.parameters.cql_filter] 筛选服务数据的[SQL语句]{@link https://docs.geoserver.org/2.12.2/user/services/wfs/vendor.html#wfs-vendor-parameters}
   * @param {String} [options.parameters.sortBy] 排序的属性名称，默认升序，降序时+D
   * @param {String} [options.parameters.service='WFS'] 服务类型
   * @param {String} [options.parameters.version='1.0.0'] 服务版本
   *
   * @param {String} [options.geometryName='the_geom'] geometry字段名称
   * @param {Object} [options.headers] 将被添加到HTTP请求头。
   * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
   * @param {String} options.layer 图层名称（命名空间:图层名称），多个图层名称用逗号隔开
   * @param {String} [options.IdField='id']  数据中唯一标识的属性字段名称
   * @param {Boolean} [options.getCapabilities=true] 是否通过服务本身的GetCapabilities来读取一些参数，减少options配置项
   *
   * @param {Number} [options.minimumLevel=0] 图层所支持的最低层级，当地图小于该级别时，平台不去请求服务数据。【影响效率的重要参数】
   * @param {Number} [options.maximumLevel] 图层所支持的最大层级,当地图大于该级别时，平台不去请求服务数据。
   * @param {Object} options.rectangle 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Boolean} options.debuggerTileInfo  是否开启测试显示瓦片信息
   *
   * @param {Number} [options.zIndex] 控制图层的叠加层次（部分图层），默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面。
   * @param {Object|Function} [options.symbol] 矢量数据的style样式,为Function时是完全自定义的回调处理 symbol(attr, style, feature)
   * @param {GraphicType|String} [options.symbol.type] 标识数据类型，默认是根据数据生成 point、polyline、polygon
   * @param {Object} options.symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
   * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
   * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
   * @param {Boolean} [options.symbol.merge] 是否合并并覆盖json中已有的style，默认不合并。
   * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
   * @param {Object} [options.graphicOptions] 默认的graphic的构造参数，每种不同类型数据都有不同的属性，具体见各{@link GraphicType}矢量数据的构造参数。
   * @param {ChinaCRS} [options.chinaCRS] 标识数据的国内坐标系（用于自动纠偏或加偏）
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   *
   * @param {Object} [options.buildings] 标识当前图层为建筑物白膜类型数据
   * @param {String} [options.buildings.bottomHeight] 建筑物底部高度（如:0） 属性字段名称（如:{bottomHeight}）
   * @param {String} [options.buildings.cloumn=1]  层数，楼的实际高度 = height*cloumn
   * @param {String|Number} [options.buildings.height=3.5]  层高的  固定层高数值（如:10） 或 属性字段名称（如:{height}）
   *
   * @param {Object} [options.clustering] Entity点数据时，设置聚合相关参数：
   * @param {Boolean} [options.clustering.enabled=false] 是否开启聚合
   * @param {Number} [options.clustering.pixelRange=20] 多少像素矩形范围内聚合
   * @param {Boolean} [options.clustering.clampToGround=true] 是否贴地
   * @param {Number} [options.clustering.radius=26] 内置样式时，圆形图标的半径大小（单位：像素）
   * @param {String} [options.clustering.fontColor='#ffffff'] 内置样式时，数字的颜色
   * @param {String} [options.clustering.color='rgba(181, 226, 140, 0.6)'] 内置样式时，圆形图标的背景颜色
   * @param {Number} [options.clustering.opacity=0.5] 内置样式时，圆形图标的透明度
   * @param {Number} [options.clustering.borderWidth=5] 圆形图标的边框宽度（单位：像素），0不显示
   * @param {String} [options.clustering.borderColor='rgba(110, 204, 57, 0.5)'] 内置样式时，圆形图标的边框颜色
   * @param {Number} [options.clustering.borderOpacity=0.6] 内置样式时，圆形图标边框的透明度
   * @param {Function} [options.clustering.getImage] 自定义聚合的图标样式，例如：getImage:function(count) { return image}
   *
   *
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑定，参数与popup属性完全相同。
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数,还包括：
   * @param {String} [options.tooltipOptions.title] 固定的标题名称
   * @param {String} [options.tooltipOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.tooltipOptions.noTitle] 不显示标题
   * @param {Object} [options.contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class WfsLayer
   * @extends {LodGraphicLayer}
   * @see [支持的事件类型]{@link LodGraphicLayer.EventType}
   */
  class WfsLayer extends LodGraphicLayer {
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this.options.geometryName = this.options.geometryName || "the_geom";
      super._mountedHook();

      if (Cesium__namespace.defaultValue(this.options.getCapabilities, true)) {
        this.getMetadata();
      }
    }

    getMetadata() {
      // 请求的wfs参数
      const parameters = {
        service: "WFS",
        request: "GetCapabilities",
        version: "1.0.0"
      };

      let url = this.options.url;
      if (this.options.templateValues) {
        url = template(url, this.options.templateValues);
      }

      Cesium__namespace.Resource.fetchXML({
        ...this.options,
        url: url,
        queryParameters: parameters,
        proxy: this._proxy
      })
        .then((data) => {
          if (!data || this.isDestroy) {
            return
          }
          this.capabilities = data;

          try {
            this._initByMetaData(data);
          } catch (e) {
            logInfo("解析GetCapabilities出错", e);
          }

          this.fire(EventType.loadConfig, { capabilities: data });
        })
        .catch((error) => {
          logInfo("wfs请求GetCapabilities出错", error);
        });
    }

    // 根据服务配置信息，加一些处理
    _initByMetaData(data) {
      const featureTypeList = this._readChildNode(data, "FeatureTypeList");
      const featureType = featureTypeList.getElementsByTagName("FeatureType");
      for (let i = 0, len = featureType.length; i < len; i++) {
        const item = featureType[i];
        const layerName = this._readChildNodeVal(item, "Name");
        if (layerName === this.options.layer) {
          const crs = this._readChildNodeVal(item, "SRS");
          if (!this.options.crs && crs) {
            this.options.crs = crs;
          }

          const bbox = this._readChildNode(item, "LatLongBoundingBox");
          if (!this.options.rectangle && bbox) {
            const xmin = Number(bbox.getAttribute("minx"));
            const ymin = Number(bbox.getAttribute("miny"));
            const xmax = Number(bbox.getAttribute("maxx"));
            const ymax = Number(bbox.getAttribute("maxy"));
            let _extent = { xmin: xmin, ymin: ymin, xmax: xmax, ymax: ymax };

            if (this.options.crs !== CRS.EPSG4326 && this.options.crs !== CRS.EPSG4490) {
              const ptMin = proj4Trans([_extent.xmin, _extent.ymin], this.options.crs);
              const ptMax = proj4Trans([_extent.xmax, _extent.ymax], this.options.crs);
              _extent = { xmin: ptMin[0], ymin: ptMin[1], xmax: ptMax[0], ymax: ptMax[1] };
            }

            this.options.extent = _extent;
            this._rectangle = Cesium__namespace.Rectangle.fromDegrees(_extent.xmin, _extent.ymin, _extent.xmax, _extent.ymax);

            if (this._tileLayer) {
              this._tileLayer.rectangle = this._rectangle;
            }
            if (this.options.flyTo) {
              this.flyToByAnimationEnd();
            }
          }
          break
        }
      }
    }

    _readChildNode(node, tagName) {
      const tagChildNodes = node.getElementsByTagName(tagName);
      if (tagChildNodes.length > 0) {
        return tagChildNodes[0]
      } else {
        return null
      }
    }

    _readChildNodeVal(node, tagName) {
      const childNode = this._readChildNode(node, tagName);
      if (childNode?.innerHTML) {
        return childNode.innerHTML
      } else if (childNode?.getInnerHTML) {
        return childNode.getInnerHTML()
      } else {
        return null
      }
    }

    /**
     * 根据LOD分块信息去请求对应的Tile瓦块内的数据
     * @param {Object} grid 瓦片信息对象
     * @return {Promise<Object>} 异步计算完成的Promise
     * @private
     */
    queryGridData(grid) {
      let bbox;
      if (this.options.crs !== CRS.EPSG4326 && this.options.crs !== CRS.EPSG4490) {
        const ptMin = proj4Trans([grid.extent.xmin, grid.extent.ymin], "EPSG:4326", this.options.crs);
        const ptMax = proj4Trans([grid.extent.xmax, grid.extent.ymax], "EPSG:4326", this.options.crs);
        bbox = ptMin[0] + "," + ptMin[1] + "," + ptMax[0] + "," + ptMax[1];
      } else {
        bbox = grid.extent.xmin + "," + grid.extent.ymin + "," + grid.extent.xmax + "," + grid.extent.ymax;
      }

      // 请求的wfs参数
      const parameters = {
        service: "WFS",
        request: "GetFeature",
        typeName: this.options.layer || this.options.typeName,
        version: "1.0.0",
        outputFormat: "application/json",
        srsName: this.options.crs || "EPSG:4326",
        bbox: bbox
      };

      // 其他可选参数
      if (Cesium__namespace.defined(this.options.parameters)) {
        for (const key in this.options.parameters) {
          if (key.toLowerCase() === "cql_filter") {
            delete parameters.bbox;
            parameters[key] = this.options.parameters[key] + " and BBOX(" + this.options.geometryName + ", " + bbox + ")";
          } else {
            parameters[key] = this.options.parameters[key];
          }
        }
      }

      let url = this.options.url;
      if (this.options.templateValues) {
        url = template(url, this.options.templateValues);
      }

      return new Promise((resolve, reject) => {
        fetchJson({
          ...this.options,
          url: url,
          queryParameters: parameters,
          proxy: this._proxy
        })
          .then((featureCollection) => {
            grid.list = [];
            if (!this._show || !this._cacheGrid[grid.key]) {
              resolve(grid);
              return // 异步请求结束时,如果已经卸载了网格就直接跳出。
            }

            if (featureCollection === undefined || featureCollection == null) {
              resolve(grid);
              return // 数据为空
            }

            if (featureCollection.type === "Feature") {
              featureCollection = { type: "FeatureCollection", features: [featureCollection] };
            }

            grid.list = featureCollection.features;
            resolve(grid);
          })
          .catch((error) => {
            logError("wfs请求GetFeature出错", error);
          });
      })
    }

    /**
     * 根据 attr属性 创建 矢量对象
     * @param {Object} grid 瓦片信息对象
     * @param {Object} item 数据的属性信息，当前是geojson
     * @return {BaseGraphic|*}  矢量对象
     * @private
     */
    createGraphic(grid, item) {
      const arr = this.loadGeoJSON(item, { clear: false, flyTo: false });

      if (arr?.length > 0) {
        return arr[0]
      } else {
        return null
      }
    }
  }

  // 注册下
  register$2("wfs", WfsLayer);

  /**
   * ArcGIS WFS服务图层，
   * 按瓦片网格分块分层加载。
   *
   * @param {Object} [options] 参数对象，包括以下：
   *
   * @param {String} options.url ArcGIS服务地址, 示例：'http://server.mars3d.cn/arcgis/rest/services/mars/hefei/MapServer/37',
   * @param {String} [options.token] 用于通过ArcGIS MapServer服务进行身份验证的ArcGIS令牌。
   * @param {String} [options.where] 用于筛选数据的where查询条件
   * @param {Number} [options.wkid] 当非标准EPSG标号时，可以指定wkid值。
   * @param {Object} [options.parameters] 要在URL中 传递给WFS服务GetFeature请求的其他参数。
   * @param {Object} [options.headers] 将被添加到HTTP请求头。
   * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
   * @param {String} [options.IdField='id']  数据中唯一标识的属性字段名称,默认读取 id或objectid或OBJECTID
   * @param {Number} [options.minimumLevel=0] 图层所支持的最低层级，当地图小于该级别时，平台不去请求服务数据。【影响效率的重要参数】
   * @param {Number} [options.maximumLevel] 图层所支持的最大层级,当地图大于该级别时，平台不去请求服务数据。
   *
   * @param {Object} options.rectangle 瓦片数据的矩形区域范围
   * @param {Number} options.rectangle.xmin 最小经度值, -180 至 180
   * @param {Number} options.rectangle.xmax 最大纬度值, -180 至 180
   * @param {Number} options.rectangle.ymin 最小纬度值, -90 至 90
   * @param {Number} options.rectangle.ymax 最大纬度值, -90 至 90
   * @param {Number[]} [options.bbox] bbox规范的瓦片数据的矩形区域范围,与rectangle二选一即可。
   * @param {Boolean} options.debuggerTileInfo  是否开启测试显示瓦片信息
   *
   * @param {Number} [options.opacity = 1.0] 透明度（部分图层），取值范围：0.0-1.0
   * @param {Number} [options.zIndex] 控制图层的叠加层次（部分图层），默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面。
   * @param {Object|Function} [options.symbol] 矢量数据的style样式,为Function时是完全自定义的回调处理 symbol(attr, style, feature)
   * @param {GraphicType|String} [options.symbol.type] 标识数据类型，默认是根据数据生成 point、polyline、polygon
   * @param {Object} options.symbol.styleOptions Style样式，每种不同类型数据都有不同的样式，具体见各矢量数据的style参数。{@link GraphicType}
   * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
   * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
   * @param {Boolean} [options.symbol.merge] 是否合并并覆盖json中已有的style，默认不合并。
   * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, styleOpt){  return { color: "#ff0000" };  }
   * @param {Object} [options.graphicOptions] 默认的graphic的构造参数，每种不同类型数据都有不同的属性，具体见各{@link GraphicType}矢量数据的构造参数。
   * @param {ChinaCRS} [options.chinaCRS] 标识数据的国内坐标系（用于自动纠偏或加偏）
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   *
   * @param {Object} [options.buildings] 标识当前图层为建筑物白膜类型数据
   * @param {String} [options.buildings.bottomHeight] 建筑物底部高度（如:0） 属性字段名称（如:{bottomHeight}）
   * @param {String} [options.buildings.cloumn=1]  层数，楼的实际高度 = height*cloumn
   * @param {String|Number} [options.buildings.height=3.5]  层高的  固定层高数值（如:10） 或 属性字段名称（如:{height}）
   *
   * @param {Object} options.clustering 设置聚合相关参数[entity点类型时]：
   * @param {Boolean} [options.clustering.enabled=false] 是否开启聚合
   * @param {Number} [options.clustering.pixelRange=20] 多少像素矩形范围内聚合
   * @param {Boolean} [options.clustering.clampToGround=true] 是否贴地
   * @param {Number} [options.clustering.radius=28] 圆形图标的整体半径大小（单位：像素）
   * @param {Number} [options.clustering.radiusIn=radius-5] 圆形图标的内圆半径大小（单位：像素）
   * @param {String} [options.clustering.fontColor='#ffffff'] 数字的颜色
   * @param {String} [options.clustering.color='rgba(181, 226, 140, 0.6)'] 圆形图标的背景颜色，默认自动处理
   * @param {String} [options.clustering.colorIn='rgba(110, 204, 57, 0.5)'] 圆形图标的内圆背景颜色，默认自动处理
   *
   *
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑定，参数与popup属性完全相同。
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数,还包括：
   * @param {String} [options.tooltipOptions.title] 固定的标题名称
   * @param {String} [options.tooltipOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.tooltipOptions.noTitle] 不显示标题
   * @param {Object} [options.contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class ArcGisWfsLayer
   * @extends {LodGraphicLayer}
   * @see [支持的事件类型]{@link LodGraphicLayer.EventType}
   * @see [支持的事件类型]{@link ArcGisLayer.EventType}
   */
  class ArcGisWfsLayer extends LodGraphicLayer {
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      super._mountedHook();
      this.getMetadata();
    }

    getMetadata() {
      let url = this.options.url;
      if (this.options.layers && this.options.layers.length > 0) {
        url += "/" + this.options.layers[0];
      }

      // 请求的wfs参数
      const parameters = {
        f: "json"
      };

      if (this.options.token) {
        parameters.token = this.options.token;
      }

      sendAjax({
        ...this.options,
        url: url,
        queryParameters: parameters,
        proxy: this._proxy
      })
        .then((data) => {
          if (!data || this.isDestroy) {
            return
          }

          this._initByMetaData(data);
          this.fire(EventType.loadConfig, data);
        })
        .catch((error) => {
          logInfo("wfs请求getMetadata出错", error);
        });
    }

    // 根据服务配置信息，加一些处理
    _initByMetaData(data) {
      this.metaData = data;

      let _extent = data.fullExtent || data.extent;
      if (!this.options.rectangle && _extent) {
        const wkid = _extent?.spatialReference?.wkid || this.options.wkid;
        if (wkid) {
          if (!this.options.wkid) {
            this.options.wkid = wkid;
          }
        }

        if (this.options.wkid) {
          const crs = "EPSG:" + this.options.wkid;
          if (crs !== CRS.EPSG4326 && crs !== CRS.EPSG4490) {
            const ptMin = proj4Trans([_extent.xmin, _extent.ymin], crs);
            const ptMax = proj4Trans([_extent.xmax, _extent.ymax], crs);
            _extent = { xmin: ptMin[0], ymin: ptMin[1], xmax: ptMax[0], ymax: ptMax[1] };
          }

          this.options.extent = _extent;
          this._rectangle = Cesium__namespace.Rectangle.fromDegrees(_extent.xmin, _extent.ymin, _extent.xmax, _extent.ymax);

          if (this._tileLayer) {
            this._tileLayer.rectangle = this._rectangle;
          }
          if (this.options.flyTo) {
            this.flyToByAnimationEnd();
          }
        }
      }
    }

    /**
     * 根据LOD分块信息去请求对应的Tile瓦块内的数据
     * @param {Object} grid 瓦片信息对象
     * @return {Promise<Object>} 异步计算完成的Promise
     * @private
     */
    queryGridData(grid) {
      let url = this.options.url;
      if (this.options.layers && this.options.layers.length > 0) {
        url += "/" + this.options.layers[0];
      }

      // 请求的wfs参数
      const parameters = {
        f: this.options.f || "json",
        inSr: 4326,
        outSR: 4326,
        outFields: "*",
        returnGeometry: true,
        where: this.options.where || "1=1",
        geometry: JSON.stringify({
          xmin: grid.extent.xmin,
          ymin: grid.extent.ymin,
          xmax: grid.extent.xmax,
          ymax: grid.extent.ymax,
          spatialReference: { wkid: 4326 }
        }),
        geometryType: "esriGeometryEnvelope", // 矩形边界
        spatialRel: "esriSpatialRelIntersects" // 包含或交叉关系
      };

      if (this.options.token) {
        parameters.token = this.options.token;
      }

      return new Promise((resolve, reject) => {
        sendAjax({
          ...this.options,
          url: url + "/query",
          queryParameters: parameters,
          proxy: this._proxy
        })
          .then((result) => {
            grid.list = [];
            if (!this.show || !this._cacheGrid[grid.key]) {
              resolve(grid);
              return // 异步请求结束时,如果已经卸载了网格就直接跳出。
            }

            if (result === undefined || result == null) {
              resolve(grid);
              return // 数据为空
            }

            let featureCollection = arcgisToGeoJSON$1(result);
            if (featureCollection.type === "Feature") {
              featureCollection = { type: "FeatureCollection", features: [featureCollection] };
            }
            grid.list = featureCollection.features;
            resolve(grid);
          })
          .catch((error) => {
            logError("wfs请求出错", error);
          });
      })
    }

    // 获取数据的唯一标识
    _getItemDataId(item) {
      if (item.id) {
        return item.id
      }

      if (item.type === "Feature") {
        item = item.properties;
      }
      if (item[this.options.IdField]) {
        return item[this.options.IdField]
      }
      if (item.OBJECTID) {
        return item.OBJECTID
      }
      if (item.objectid) {
        return item.objectid
      }

      if (this.metaData?.fields?.length > 0) {
        const IdField = this.metaData.fields[0].name;
        if (item[IdField]) {
          return item[IdField]
        }
      }

      return null
    }

    /**
     * 根据 attr属性 创建 矢量对象
     * @param {Object} grid 瓦片信息对象
     * @param {Object} item 数据的属性信息，当前是geojson
     * @return {BaseGraphic|*}  矢量对象
     * @private
     */
    createGraphic(grid, item) {
      if (this.options.createGraphic) {
        return this.options.createGraphic(grid, item) // 传参方式
      }

      const arr = this.loadGeoJSON(item, { clear: false, flyTo: false });

      if (arr?.length > 0) {
        return arr[0]
      } else {
        return null
      }
    }

    /**
     * 更新where条件后 刷新数据
     *
     * @param {String} where 筛选条件
     * @return {void}  无
     */
    setWhere(where) {
      this.options.where = where;
      this.reload();
    }
  }

  // 注册下
  register$2("arcgis_wfs", ArcGisWfsLayer);

  /**
   * ArcGIS WFS服务图层，
   * 一次性请求加载，适合少量数据时使用。
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} options.url ArcGIS服务地址, 示例：'http://server.mars3d.cn/arcgis/rest/services/mars/hefei/MapServer/37',
   * @param {String} [options.token] 用于通过ArcGIS MapServer服务进行身份验证的ArcGIS令牌。
   * @param {String} [options.where] 用于筛选数据的where查询条件
   * @param {Function} [options.format] 可以对加载的geojson数据进行格式化或转换操作
   *
   * @param {Number} [options.opacity = 1.0] 透明度（部分图层），取值范围：0.0-1.0
   * @param {Number} [options.zIndex] 控制图层的叠加层次（部分图层），默认按加载的顺序进行叠加，但也可以自定义叠加顺序，数字大的在上面。
   * @param {Object|Function} [options.symbol] 矢量数据的style样式,为Function时是完全自定义的回调处理 symbol(attr, style, feature)
   * @param {BillboardEntity.StyleOptions|PolylineEntity.StyleOptions|PolygonEntity.StyleOptions|*} options.symbol.styleOptions 数据的Style样式
   * @param {String} [options.symbol.styleField] 按 styleField 属性设置不同样式。
   * @param {Object} [options.symbol.styleFieldOptions] 按styleField值与对应style样式的键值对象。
   * @param {Function} [options.symbol.callback] 自定义判断处理返回style ，示例：callback: function (attr, entity, styleOpt){  return { color: "#ff0000" };  }
   * @param {Boolean|Function} [options.allowDrillPick]  是否允许鼠标穿透拾取
   *
   * @param {Object} [options.buildings] 标识当前图层为建筑物白膜类型数据
   * @param {String} [options.buildings.bottomHeight] 建筑物底部高度（如:0） 属性字段名称（如:{bottomHeight}）
   * @param {String} [options.buildings.cloumn=1]  层数，楼的实际高度 = height*cloumn
   * @param {String|Number} [options.buildings.height=3.5]  层高的  固定层高数值（如:10） 或 属性字段名称（如:{height}）
   *
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  绑定的popup弹窗值，也可以bindPopup方法绑定，支持：'all'、数组、字符串模板
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数,还包括：
   * @param {String} [options.popupOptions.title] 固定的标题名称
   * @param {String} [options.popupOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.popupOptions.noTitle] 不显示标题
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  绑定的tooltip弹窗值，也可以bindTooltip方法绑定，参数与popup属性完全相同。
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数,还包括：
   * @param {String} [options.tooltipOptions.title] 固定的标题名称
   * @param {String} [options.tooltipOptions.titleField] 标题对应的属性字段名称
   * @param {String} [options.tooltipOptions.noTitle] 不显示标题
   * @param {Object} [options.contextmenuItems] 绑定的右键菜单值，也可以bindContextMenu方法绑定
   *
   * @param {String|Number} [options.id = createGuid()] 图层id标识
   * @param {String|Number} [options.pid = -1] 图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 图层名称
   * @param {Boolean} [options.show = true] 图层是否显示
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为map对象，false时不冒泡
   * @param {Object} [options.center] 图层自定义定位视角 {@link Map#setCameraView}
   * @param {Number} options.center.lng 经度值, 180 - 180
   * @param {Number} options.center.lat 纬度值, -90 - 90
   * @param {Number} [options.center.alt] 高度值
   * @param {Number} [options.center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @param {Number} [options.center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @param {Number} [options.center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   * @param {Object} [options.extent] 图层自定义定位的矩形区域，与center二选一即可。 {@link Map#flyToExtent}
   * @param {Number} options.extent.xmin 最小经度值, -180 至 180
   * @param {Number} options.extent.xmax 最大经度值, -180 至 180
   * @param {Number} options.extent.ymin 最小纬度值, -90 至 90
   * @param {Number} options.extent.ymax 最大纬度值, -90 至 90
   * @param {Number} [options.extent.height=0] 矩形高度值
   * @param {Boolean} [options.flyTo] 加载完成数据后是否自动飞行定位到数据所在的区域。
   *
   * @export
   * @class ArcGisWfsSingleLayer
   * @extends {GeoJsonLayer}
   */
  class ArcGisWfsSingleLayer extends GeoJsonLayer {
    load(newOptions = {}) {
      this.options = {
        ...this.options,
        ...newOptions
      };

      let url = this.options.url;
      if (this.options.layers && this.options.layers.length > 0) {
        url += "/" + this.options.layers[0];
      }

      // 请求的wfs参数
      const parameters = {
        f: "json",
        inSr: 4326,
        outSR: 4326,
        outFields: "*",
        returnGeometry: true,
        where: this.options.where || "1=1"
      };

      if (this.options.token) {
        parameters.token = this.options.token;
      }

      fetchJson({
        ...this.options,
        url: url + "/query",
        queryParameters: parameters,
        proxy: this._proxy
      })
        .then((result) => {
          if (!result) {
            this.fire(EventType.load);
            return // 数据为空
          }

          const featureCollection = arcgisToGeoJSON$1(result);
          this._load_data(featureCollection);
        })
        .catch((error) => {
          logError("wfs请求出错", error);
        });
    }

    /**
     * 更新where条件后 刷新数据
     *
     * @param {String} where 筛选条件
     * @return {void}  无
     */
    setWhere(where) {
      this.load({ where: where });
    }
  }

  // 注册下
  register$2("arcgis_wfs_single", ArcGisWfsSingleLayer);

  var index$4 = {
    __proto__: null,
    BaseLayer: BaseLayer,
    GroupLayer: GroupLayer,
    BaseTileLayer: BaseTileLayer,
    BaseGraphicLayer: BaseGraphicLayer,
    TerrainLayer: TerrainLayer,
    ArcGisCacheLayer: ArcGisCacheLayer,
    ArcGisTileLayer: ArcGisTileLayer,
    ArcGisLayer: ArcGisLayer,
    BaiduLayer: BaiduLayer,
    BingLayer: BingLayer,
    GaodeLayer: GaodeLayer,
    GeeLayer: GeeLayer,
    GoogleLayer: GoogleLayer,
    ImageLayer: ImageLayer,
    IonLayer: IonLayer,
    MapboxLayer: MapboxLayer,
    OsmLayer: OsmLayer,
    TdtLayer: TdtLayer,
    TencentLayer: TencentLayer,
    TmsLayer: TmsLayer,
    WmsLayer: WmsLayer,
    WmtsLayer: WmtsLayer,
    XyzLayer: XyzLayer,
    GridLayer: GridLayer,
    TileInfoLayer: TileInfoLayer,
    EmptyTileLayer: EmptyTileLayer,
    CzmGeoJsonLayer: CzmGeoJsonLayer,
    KmlLayer: KmlLayer,
    CzmlLayer: CzmlLayer,
    GraphicLayer: GraphicLayer,
    DivLayer: GraphicLayer,
    GraphicGroupLayer: GraphicGroupLayer,
    GeoJsonLayer: GeoJsonLayer,
    TilesetLayer: TilesetLayer,
    OsmBuildingsLayer: OsmBuildingsLayer,
    GraticuleLayer: GraticuleLayer,
    LodGraphicLayer: LodGraphicLayer,
    GeodePoiLayer: GeodePoiLayer,
    WfsLayer: WfsLayer,
    ArcGisWfsLayer: ArcGisWfsLayer,
    ArcGisWfsSingleLayer: ArcGisWfsSingleLayer,
    register: register$2,
    create: create$2,
    createTerrainProvider: createTerrainProvider,
    createImageryProvider: createImageryProvider$k
  };

  /**
   * 地下模式类
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Number} [options.alpha = 0.5] 透明度  0.0-1.0
   * @param {Cesium.Color} [options.color = Cesium.Color.BLAC] 当相机在地下或球体是半透明时，渲染球体背面的颜色
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class Underground
   * @extends {BaseThing}
   */
  class Underground extends BaseThing {
    /**
     * 控制球体透明度的Cesium内部对象
     * @type {Cesium.GlobeTranslucency}
     * @readonly
     */
    get translucency() {
      return this._map.scene.globe.translucency
    }

    /**
     * 透明度
     * @type {Number}
     */
    get alpha() {
      return this._alpha
    }

    set alpha(val) {
      this._alpha = val;

      if (!this._map) {
        return
      }

      this.translucency.frontFaceAlphaByDistance.nearValue = this._alpha;
      this.translucency.frontFaceAlphaByDistance.farValue = this._alpha;
    }

    /**
     * 当相机在地下或球体是半透明时，渲染球体背面的颜色，将根据相机的距离与地球颜色混合。
     * 禁用地下着色时，可以设置为undefined。
     *
     * @type {Cesium.Color}
     */
    get color() {
      return this._map.scene.globe.undergroundColor
    }

    set color(val) {
      this._map.scene.globe.undergroundColor = val;
    }

    /**
     * 获取或设置将color与Globe颜色混合的远近距离。
     * alpha将插值在{@link Cesium.NearFarScalar#nearValue}和{@linkCesium.NearFarScalar#farValue}之间，
     * 同时摄像机距离在指定的{@link Cesium.NearFarScalar#near}和{@link Cesium.NearFarScalar#far}的上下边界内。
     * 在这些范围之外，alpha仍然被限制在最近的范围内。如果未定义，地下颜色将不会与地球颜色混合。
     * 当相机在椭球上方时，距离计算从椭球上最近的点而不是相机的位置。
     *
     * @type {Cesium.NearFarScalar}
     */
    get colorAlphaByDistance() {
      return this._map.scene.globe.undergroundColorAlphaByDistance
    }

    set colorAlphaByDistance(val) {
      this._map.scene.globe.undergroundColorAlphaByDistance = val;
    }

    _enabledHook(value) {
      if (!this._map) {
        return
      }
      this._map.scene.globe.depthTestAgainstTerrain = value ? true : this.depthTestOld;
      this._map.scene.screenSpaceCameraController.enableCollisionDetection = !value; // 相机对地形的碰撞检测状态

      this.translucency.enabled = value;
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this.translucency.frontFaceAlphaByDistance = new Cesium__namespace.NearFarScalar(100.0, 0.0, 900.0, 1.0);
      this.translucency.backFaceAlpha = 0;

      this.alpha = this.options.alpha ?? 0.5;
      this.color = this.options.color ?? Cesium__namespace.Color.BLACK;
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this.depthTestOld = Cesium__namespace.clone(this._map.scene.globe.depthTestAgainstTerrain);
      this._enabledHook(this.enabled);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.scene.globe.depthTestAgainstTerrain = this.depthTestOld;
      this._enabledHook(false);
    }
  }

  /**
   * @typedef {Object} Sightline.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} start 开始分析
   * @property {String} end  完成分析
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.end, function (event) {
   *   console.log('分析完成', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 通视分析
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.visibleColor =  new Cesium.Color(0, 1, 0, 1)] 可视区域颜色
   * @param {Cesium.Color} [options.hiddenColor =  new Cesium.Color(1, 0, 0, 1)] 不可视区域颜色
   * @param {Cesium.Color} [options.depthFailColor] 当线位于地形或被遮挡时的区域颜色
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class Sightline
   * @extends {BaseThing}
   * @see [支持的事件类型]{@link Sightline.EventType}
   */
  class Sightline extends BaseThing {
    constructor(options = {}) {
      super(options);

      this._visibleColor = options.visibleColor ?? new Cesium__namespace.Color(0, 1, 0, 0.5); // 可视区域
      this._hiddenColor = options.hiddenColor ?? new Cesium__namespace.Color(1, 0, 0, 0.5); // 不可视区域
      this._depthFailColor = options.depthFailColor;

      this.lines = [];
    }

    //= ========= 对外属性 ==========
    /**
     *  可视区域颜色
     * @type {Cesium.Color}
     */
    get visibleColor() {
      return this._visibleColor
    }

    set visibleColor(val) {
      this._visibleColor = val;
    }

    /**
     *  不可视区域颜色
     * @type {Cesium.Color}
     */
    get hiddenColor() {
      return this._hiddenColor
    }

    set hiddenColor(val) {
      this._hiddenColor = val;
    }

    /**
     *  当线位于地形或被遮挡时的区域颜色
     * @type {Cesium.Color}
     */
    get depthFailColor() {
      return this._depthFailColor
    }

    set depthFailColor(val) {
      this._depthFailColor = val;
    }

    //= ========= 方法 ==========

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {}

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {}

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {}

    /**
     * 添加通视分析
     *
     * @param { Cesium.Cartesian3} origin 起点（视点位置）
     * @param { Cesium.Cartesian3} target 终点（目标点位置）
     * @param {Object} [options={}] 控制参数，包括：
     * @param {Number} [options.offsetHeight=0] 在起点增加的高度值，比如加上人的身高
     * @return {Object} 分析结果
     */
    add(origin, target, options = {}) {
      if (options.offsetHeight) {
        origin = addPositionsHeight(origin, options.offsetHeight); // 加人的身高
      }
      this.fire(EventType.start);

      if (!this._map.scene.globe.depthTestAgainstTerrain) {
        this._map.scene.globe.depthTestAgainstTerrain = true;
        this.old_depthTestAgainstTerrain = this._map.scene.globe.depthTestAgainstTerrain;
      }
      this._map.scene.requestRender();

      const currDir = Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(target, origin, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3());
      const currRay = new Cesium__namespace.Ray(origin, currDir);
      const pickRes = this._map.scene.drillPickFromRay(currRay, 2, this.lines);

      if (Cesium__namespace.defined(pickRes) && pickRes.length > 0 && Cesium__namespace.defined(pickRes[0]) && Cesium__namespace.defined(pickRes[0].position)) {
        const position = pickRes[0].position;

        const distance = Cesium__namespace.Cartesian3.distance(origin, target);
        const distanceFx = Cesium__namespace.Cartesian3.distance(origin, position);
        if (distanceFx < distance) {
          // 存在正常分析结果
          const arrEentity = this._showPolyline(origin, target, position);

          const result = {
            block: true, // 存在遮挡
            position: position,
            entity: arrEentity
          };
          this.fire(EventType.end, result);
          return result
        }
      }

      const arrEentity = this._showPolyline(origin, target);
      const result = {
        block: false,
        entity: arrEentity
      };

      if (Cesium__namespace.defined(this.old_depthTestAgainstTerrain)) {
        this._map.scene.globe.depthTestAgainstTerrain = this.old_depthTestAgainstTerrain;
        delete this.old_depthTestAgainstTerrain;
      }

      this.fire(EventType.end, result);
      return result
    }

    /**
     * 添加通视分析，插值异步分析
     *
     * @param { Cesium.Cartesian3} origin 起点
     * @param { Cesium.Cartesian3} target 终点（目标点）
     * @param {Object} [options={}] 控制参数，包括：
     * @param {Number} [options.offsetHeight=0] 在起点增加的高度值，比如加上人的身高
     * @param {Number} [options.splitNum=50] 插值数，等比分割的个数
     * @param {Number} [options.minDistance] 插值时的最小间隔(单位：米)，优先级高于splitNum
     * @return {Promise<Object>} 分析结果完成的Promise
     */
    addAsync(origin, target, options = {}) {
      if (options.offsetHeight) {
        origin = addPositionsHeight(origin, options.offsetHeight); // 加人的身高
      }

      // 插值求新路线
      const positionsNew = interLine([origin, target], {
        splitNum: options.splitNum || 50,
        minDistance: options.minDistance
      });

      this.fire(EventType.start);

      return new Promise((resolve, reject) => {
        // 求对比的贴地地面高度
        computeSurfacePoints({
          map: this._map,
          positions: positionsNew // 需要计算的源路线坐标数组
        }).then((result) => {
          if (!result.noHeight) {
            for (let i = 0; i < positionsNew.length; i++) {
              const position = positionsNew[i];
              const xHeight = Cesium__namespace.Cartographic.fromCartesian(position).height; // 线高度
              const dHeight = Cesium__namespace.Cartographic.fromCartesian(result.positions[i]).height; // 地面高度

              if (xHeight <= dHeight) {
                const arrEentity = this._showPolyline(origin, target, position);

                const resultFx = {
                  block: true, // 存在遮挡
                  position: position,
                  entity: arrEentity
                };
                this.fire(EventType.end, resultFx);
                resolve(resultFx);
                return
              }
            }
          }
          const arrEentity2 = this._showPolyline(origin, target);
          const resultFx = {
            block: false,
            entity: arrEentity2
          };
          this.fire(EventType.end, resultFx);

          resolve(resultFx);
        });
      })
    }

    _showPolyline(origin, target, position) {
      if (position) {
        // 存在正常分析结果
        const entity1 = this._map.entities.add(
          new Cesium__namespace.Entity({
            polyline: {
              positions: [origin, position],
              width: 2,
              material: this._visibleColor,
              depthFailMaterial: this._depthFailColor
            }
          })
        );
        this.lines.push(entity1);

        const entity2 = this._map.entities.add(
          new Cesium__namespace.Entity({
            polyline: {
              positions: [position, target],
              width: 2,
              material: this._hiddenColor,
              depthFailMaterial: this._depthFailColor
            }
          })
        );
        this.lines.push(entity2);

        return [entity1, entity2]
      } else {
        // 无正确分析结果时，直接返回
        const entity = this._map.entities.add(
          new Cesium__namespace.Entity({
            polyline: {
              positions: [origin, target],
              width: 2,
              material: this._visibleColor,
              depthFailMaterial: this._depthFailColor
            }
          })
        );
        this.lines.push(entity);

        return [entity]
      }
    }

    /**
     *  清除分析
     * @return {void}  无
     */
    clear() {
      for (let i = 0, len = this.lines.length; i < len; i++) {
        this._map.entities.remove(this.lines[i]);
      }
      this.lines = [];
    }
  }

  var fragmentShaderSource = "#extension GL_OES_standard_derivatives : enable\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform float lineWidth;\nuniform float height;\nuniform bvec3 strokeType;\nuniform vec3 tjxColor;\nuniform vec3 bjColor;\nuniform vec3 cameraPos;\nuniform float mbDis;\nvarying vec2 v_textureCoordinates;\n\nvec4 toEye(in vec2 uv, in float depth) {\n  vec2 xy = vec2((uv.x * 2.0 - 1.0), (uv.y * 2.0 - 1.0));\n  vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0);\n  posInCamera = posInCamera / posInCamera.w;\n  return posInCamera;\n}\nfloat getDepth(in vec4 depth) {\n  float z_window = czm_unpackDepth(depth);\n  z_window = czm_reverseLogDepth(z_window);\n  float n_range = czm_depthRange.near;\n  float f_range = czm_depthRange.far;\n  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nbool isTJX(vec2 uv, float lw) {\n  vec2 pixelSize = lw / czm_viewport.zw;\n  float dx0 = -pixelSize.x;\n  float dy0 = -pixelSize.y;\n  float dx1 = pixelSize.x;\n  float dy1 = pixelSize.y;\n\n  vec2 currUV = uv + vec2(dx0, dy0);\n  vec4 currDepth = texture2D(depthTexture, currUV);\n  float depth = getDepth(currDepth);\n  if(depth >= 1.0)\n    return true;\n\n  currUV = uv + vec2(0.0, dy0);\n  currDepth = texture2D(depthTexture, currUV);\n  depth = getDepth(currDepth);\n  if(depth >= 1.0)\n    return true;\n\n  currUV = uv + vec2(dx1, dy0);\n  currDepth = texture2D(depthTexture, currUV);\n  depth = getDepth(currDepth);\n  if(depth >= 1.0)\n    return true;\n\n  currUV = uv + vec2(dx0, 0.0);\n  currDepth = texture2D(depthTexture, currUV);\n  depth = getDepth(currDepth);\n  if(depth >= 1.0)\n    return true;\n\n  currUV = uv + vec2(dx1, 0.0);\n  currDepth = texture2D(depthTexture, currUV);\n  depth = getDepth(currDepth);\n  if(depth >= 1.0)\n    return true;\n\n  currUV = uv + vec2(dx0, dy1);\n  currDepth = texture2D(depthTexture, currUV);\n  depth = getDepth(currDepth);\n  if(depth >= 1.0)\n    return true;\n\n  currUV = uv + vec2(0.0, dy1);\n  currDepth = texture2D(depthTexture, currUV);\n  depth = getDepth(currDepth);\n  if(depth >= 1.0)\n    return true;\n\n  currUV = uv + vec2(dx1, dy1);\n  currDepth = texture2D(depthTexture, currUV);\n  depth = getDepth(currDepth);\n  if(depth >= 1.0)\n    return true;\n\n  return false;\n}\n\nvoid main() {\n  vec4 color = texture2D(colorTexture, v_textureCoordinates);\n  if(height > 14102.0) {\n    gl_FragColor = color;\n    return;\n  }\n  vec4 currD = texture2D(depthTexture, v_textureCoordinates);\n  if(currD.r >= 1.0) {\n    gl_FragColor = color;\n    return;\n  }\n  float depth = getDepth(currD);\n  vec4 positionEC = toEye(v_textureCoordinates, depth);\n  vec3 dx = dFdx(positionEC.xyz);\n  vec3 dy = dFdy(positionEC.xyz);\n  vec3 normal = normalize(cross(dx, dy));\n\n  if(strokeType.y || strokeType.z) {\n    vec4 wp = czm_inverseView * positionEC;\n    if(distance(wp.xyz, cameraPos) > mbDis) {\n      gl_FragColor = color;\n    } else {\n      float dotNum = abs(dot(normal, normalize(positionEC.xyz)));\n      if(dotNum < 0.05) {\n        gl_FragColor = vec4(bjColor, 1.0);\n        return;\n      }\n    }\n  }\n  if(strokeType.x || strokeType.z) {\n    bool tjx = isTJX(v_textureCoordinates, lineWidth);\n    if(tjx) {\n      gl_FragColor = vec4(tjxColor, 1.0);\n      return;\n    }\n  }\n  gl_FragColor = color;\n}\n"; // eslint-disable-line

  /**
   * 天际线 描边
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Cesium.Color} [options.color =new Cesium.Color(1.0, 0.0, 0.0)] 边际线颜色
   * @param {Number} [options.width = 2] 天际线宽度
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class Skyline
   * @extends {BaseThing}
   */
  class Skyline extends BaseThing {
    constructor(options = {}) {
      super(options);
      /**
       * 边际线颜色
       * @type {Cesium.Color}
       */
      this.color = options.color ?? new Cesium__namespace.Color(1.0, 0.0, 0.0);
      /**
       * 天际线宽度
       * @type {Number}
       */
      this.width = options.width ?? 2;

      // 以下参数不常用，未公开
      this.strokeType = options.strokeType ?? new Cesium__namespace.Cartesian3(true, false, false); // 天际线，物体描边，全描边
      this.bjColor = options.bjColor ?? new Cesium__namespace.Color(0.0, 0.0, 1.0); // 物体描边颜色
      this.distance = options.distance ?? 500; // 物体描边距离
    }

    _enabledHook(val) {
      this.postProcessStage.enabled = val;
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      const that = this;
      const camera = this._map.camera;

      this.postProcessStage = new Cesium__namespace.PostProcessStage({
        fragmentShader: fragmentShaderSource,
        uniforms: {
          height: function () {
            return camera.positionCartographic.height
          },
          lineWidth: function () {
            return that.width
          },
          strokeType: function () {
            return that.strokeType
          },
          tjxColor: function () {
            return that.color
          },
          bjColor: function () {
            return that.bjColor
          },
          cameraPos: function () {
            return camera.position
          },
          mbDis: function () {
            return that.distance
          }
        },
        enabled: this.enabled
      });
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.scene.postProcessStages.add(this.postProcessStage);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.scene.postProcessStages.remove(this.postProcessStage);
    }

    destroy(noDel) {
      if (this.postProcessStage) {
        this.postProcessStage.destroy();
        delete this.postProcessStage;
      }
      super.destroy(noDel);
    }
  }

  /**
   * @typedef {Object} Shadows.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} change 变化了
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.change, function (event) {
   *   console.log('时间发送了变化', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 日照分析
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Number} [options.multiplier=1600] 时钟倍率，控制速度
   * @param {Date} [options.time] 当前时间
   * @param {Boolean} [options.terrain = true] 是否启用地形的阴影效果，在平原地区或无地形时可以关闭
   * @param {Boolean} [options.lighting = true]  是否显示晨昏线，可以看到地球的昼夜区域
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class Shadows
   * @extends {BaseThing}
   * @see [支持的事件类型]{@link Shadows.EventType}
   */
  class Shadows extends BaseThing {
    /**
     * 当前时间
     * @type {Date}
     */
    get time() {
      const currentTime = this._map.clock.currentTime;
      return Cesium__namespace.JulianDate.toDate(currentTime)
    }

    set time(date) {
      this._map.clock.currentTime = Cesium__namespace.JulianDate.fromDate(date);
      this.stop();
    }

    /**
     * 是否在播放
     * @type {Boolean}
     * @readonly
     */
    get isStart() {
      return this._map.clock.shouldAnimate
    }

    /**
     * 倍速,控制速率
     * @type {Number}
     */
    get multiplier() {
      return this._map?.clock.multiplier
    }

    set multiplier(val) {
      this.options.multiplier = val;
      if (this._map) {
        this._map.clock.multiplier = val;
      }
    }

    //= ========= 方法 ==========
    _enabledHook(val) {
      if (!this._map) {
        return
      }

      this._map.viewer.shadows = val;

      // 山体阴影
      if (this.options.terrain ?? true) {
        this._map.viewer.terrainShadows = val ? Cesium__namespace.ShadowMode.ENABLED : Cesium__namespace.ShadowMode.DISABLED;
      }

      if (this.options.lighting ?? true) {
        this._map.scene.globe.enableLighting = val;
      }
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {}

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      // 记录原始值
      this._last_startTime = this._map.clock.startTime;
      this._last_stopTime = this._map.clock.stopTime;
      this._last_shouldAnimate = this._map.clock.shouldAnimate;
      this._last_clockRange = this._map.clock.clockRange;
      this._last_multiplier = this._map.clock.multiplier;
      this._last_shadows = this._map.viewer.shadows;
      // 记录原始值 end

      this._enabledHook(this.enabled);

      this._map.clock.shouldAnimate = false;
      this._map.clock.clockRange = Cesium__namespace.ClockRange.LOOP_STOP;
      this._map.clock.multiplier = this.options.multiplier ?? 1600;
      if (this.options.time) {
        this.time = this.options.time;
      }

      this._map.on(EventType.clockTick, this._onClockTickHanlder, this);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.off(EventType.clockTick, this._onClockTickHanlder, this);

      this.clear();

      this._enabledHook(false);
      this._map.viewer.shadows = this._last_shadows;

      this._map.clock.clockRange = this._last_clockRange;
      this._map.clock.multiplier = this._last_multiplier;
      this._map.clock.shouldAnimate = this._last_shouldAnimate;
    }

    _onClockTickHanlder() {
      if (!this._map.clock.shouldAnimate) {
        return
      }
      this.fire(EventType.change);
    }

    /**
     * 开始播放日照分析效果
     *
     * @param {Date} startDate 开始时间
     * @param {Date} endDate 结束时间
     * @param {Date} [currentTime=startDate] 当前所在时间
     * @return {void}  无
     */
    start(startDate, endDate, currentTime) {
      if (!this._map) {
        return
      }

      if (!startDate || !endDate || startDate >= endDate) {
        return
      }

      this._map.clock.startTime = Cesium__namespace.JulianDate.fromDate(startDate);
      this._map.clock.currentTime = Cesium__namespace.JulianDate.fromDate(currentTime || startDate);
      this._map.clock.stopTime = Cesium__namespace.JulianDate.fromDate(endDate);

      this._map.clock.shouldAnimate = true;
    }

    /**
     *  暂停
     * @return {void}  无
     */
    pause() {
      if (this._map) {
        this._map.clock.shouldAnimate = false;
      }
    }

    /**
     *  继续
     * @return {void}  无
     */
    proceed() {
      if (this._map) {
        this._map.clock.shouldAnimate = true;
      }
    }

    /**
     *  停止
     * @return {void}  无
     */
    stop() {
      if (this._map) {
        this._map.clock.shouldAnimate = false;
      }
    }

    /**
     *  清除分析
     * @return {void}  无
     */
    clear() {
      this.stop();
      this.currentTime = new Date();

      this._map.clock.startTime = this._last_startTime;
      this._map.clock.stopTime = this._last_stopTime;
    }
  }

  /**
   * @typedef {Object} Measure.EventType
   *
   * @property {String} change 测量值变化了
   * @property {String} start 异步测量中，开始测量
   * @property {String} end 异步测量中，完成了测量后
   *
   * @property {String} add 添加对象
   * @property {String} remove 移除对象
   * @property {String} show 显示了对象
   * @property {String} hide 隐藏了对象
   *
   * @property {String} click 左键单击 鼠标事件
   * @property {String} rightClick 右键单击 鼠标事件
   * @property {String} mouseOver 鼠标移入 鼠标事件
   * @property {String} mouseOut 鼠标移出 鼠标事件
   *
   * @property {String} popupOpen popup弹窗打开后
   * @property {String} popupClose popup弹窗关闭
   * @property {String} tooltipOpen tooltip弹窗打开后
   * @property {String} tooltipClose tooltip弹窗关闭
   * @property {String} contextMenuOpen 右键菜单 打开后
   * @property {String} contextMenuClose 右键菜单 关闭
   * @property {String} contextMenuClick 右键菜单 单击某一项后
   *
   * @property {String} drawStart 开始绘制 标绘事件
   * @property {String} drawMouseMove 正在移动鼠标中，绘制过程中鼠标移动了点 标绘事件
   * @property {String} drawAddPoint 绘制过程中增加了点 标绘事件
   * @property {String} drawRemovePoint 绘制过程中删除了最后一个点 标绘事件
   * @property {String} drawCreated 创建完成 标绘事件
   * @property {String} editStart 开始编辑 标绘事件
   * @property {String} editMouseDown 移动鼠标按下左键（LEFT_DOWN）标绘事件
   * @property {String} editMouseMove 正在移动鼠标中，正在编辑拖拽修改点中（MOUSE_MOVE） 标绘事件
   * @property {String} editMovePoint 编辑修改了点（LEFT_UP）标绘事件
   * @property {String} editRemovePoint 编辑删除了点 标绘事件
   * @property {String} editStyle 图上编辑修改了相关style属性 标绘事件
   * @property {String} editStop 停止编辑 标绘事件
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.change, function (event) {
   *   console.log('发送了变化', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 图上量算
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.hasEdit=false] 是否可编辑
   * @param {Boolean} [options.isAutoEditing=true] 完成测量时是否自动启动编辑(需要hasEdit:true时)
   * @param {Boolean} [options.isContinued=false] 是否连续测量
   * @param {LabelEntity.StyleOptions} [options.label] 测量结果文本的样式
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @param {String|Number} [options.pid = -1] 量算对应的图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 量算对应的图层名称
   *
   * @export
   * @class Measure
   * @extends {BaseThing}
   * @see [支持的事件类型]{@link Measure.EventType}
   */
  class Measure extends BaseThing {
    /**
     * 对应的矢量图层
     * @type {GraphicLayer}
     * @readonly
     */
    get graphicLayer() {
      return this._graphicLayer
    }

    /**
     * 图层内的Graphic集合对象
     *
     * @type {BaseGraphic[]}
     * @readonly
     */
    get graphics() {
      return this._graphicLayer.graphics
    }

    /**
     * 是否有进行量算
     *
     * @type {Boolean}
     * @readonly
     */
    get hasMeasure() {
      return this._graphicLayer.length > 0
    }

    _enabledHook(val) {}

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      // 标绘对象类
      this._graphicLayer = new GraphicLayer({
        hasEdit: true,
        eventParent: this,
        ...this.options,
        isContinued: false,
        isAutoEditing: !this.options.isContinued,
        private: true
      });

      if (this._graphicLayer.hasEdit) {
        this._graphicLayer.bindContextMenu([
          {
            text: this._map.getLangText("_删除测量"),
            icon: Icon.Delete,
            show: (event) => {
              const graphic = event.graphic;
              if (graphic?.inProgress && !graphic.editing) {
                return false
              } else {
                return true
              }
            },
            callback: (event) => {
              const graphic = event.graphic;
              if (!graphic) {
                return
              }

              const parent = graphic.parent; // 右击是编辑点时
              this._graphicLayer.removeGraphic(graphic);
              if (parent) {
                this._graphicLayer.removeGraphic(parent);
              }

              this.fire(EventType.remove, {
                mtype: this._measureType,
                graphic: graphic
              });
            }
          }
        ]);
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.addLayer(this._graphicLayer);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.removeLayer(this._graphicLayer);
    }

    /**
     * 测量 空间长度
     * @param {Object} [options] 控制参数
     * @param {PolylineEntity.StyleOptions} [options.style] 路线的样式
     * @param {String} [options.unit='auto'] 计量单位,{@link MeasureUtil#formatDistance}可选值：auto、m、km、mile、zhang 。auto时根据距离值自动选用k或km
     * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
     * @param {Number} [options.addHeight] 在绘制时，在绘制点的基础上增加的高度值
     * @param {Boolean} [options.showAddText=true] 是否显示每一段的增加部分距离，如（+10.1km）
     * @param {Number} [options.decimal = 2]  显示的文本中保留的小数位
     * @return {Promise<DistanceMeasure|*>} 绘制创建完成的Promise，返回 长度测量控制类 对象
     */
    distance(options = {}) {
      this.stopDraw();

      options.type = "distanceMeasure";
      return this._graphicLayer.startDraw(options)
    }

    /**
     * 测量 贴地长度
     * @param {Object} [options] 控制参数
     * @param {PolylineEntity.StyleOptions} [options.style] 路线的样式
     * @param {String} [options.unit='auto'] 计量单位,{@link MeasureUtil#formatDistance}可选值：auto、m、km、mile、zhang 。auto时根据距离值自动选用k或km
     * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
     * @param {Number} [options.addHeight] 在绘制时，在绘制点的基础上增加的高度值
     * @param {Boolean} [options.showAddText=true] 是否显示每一段的增加部分距离，如（+10.1km）
     * @param {Number} [options.splitNum=100]  插值数，将线段分割的个数
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Number} [options.decimal = 2]  显示的文本中保留的小数位
     * @return {Promise<DistanceSurfaceMeasure|*>} 绘制创建完成的Promise，返回 贴地长度测量控制类 对象
     */
    distanceSurface(options = {}) {
      this.stopDraw();

      options.type = "distanceSurfaceMeasure";
      return this._graphicLayer.startDraw(options)
    }

    /**
     * 剖面分析，测量线插值点的高程数据
     * @param {Object} [options] 控制参数
     * @param {PolylineEntity.StyleOptions} [options.style] 路线的样式
     * @param {String} [options.unit='auto'] 计量单位,{@link MeasureUtil#formatDistance}可选值：auto、m、km、mile、zhang 。auto时根据距离值自动选用k或km
     * @param {Number} [options.maxPointNum=9999] 绘制时，最多允许点的个数
     * @param {Number} [options.addHeight] 在绘制时，在绘制点的基础上增加的高度值
     * @param {Number} [options.splitNum=200]  插值数，将线段分割的个数
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Number} [options.decimal = 2]  显示的文本中保留的小数位
     * @return {Promise<SectionMeasure|*>} 绘制创建完成的Promise，返回 剖面分析控制类矢量对象
     */
    section(options = {}) {
      this.stopDraw();

      options.type = "sectionMeasure";
      return this._graphicLayer.startDraw(options)
    }

    /**
     * 面积测量（水平面）
     * @param {Object} [options] 控制参数
     * @param {PolygonEntity.StyleOptions} [options.style] 面的样式
     * @param {String} [options.unit='auto'] 计量单位,{@link MeasureUtil#formatArea}可选值：auto、m、km、mu、ha 。auto时根据面积值自动选用k或km
     * @param {Number} [options.decimal = 2]  显示的文本中保留的小数位
     * @return {Promise<AreaMeasure|*>} 绘制创建完成的Promise，返回 面积测量控制类 对象
     */
    area(options = {}) {
      this.stopDraw();

      options.type = "areaMeasure";
      return this._graphicLayer.startDraw(options)
    }

    /**
     * 贴地面积测量
     * @param {Object} [options] 控制参数
     * @param {PolygonEntity.StyleOptions} [options.style] 面的样式
     * @param {String} [options.unit='auto'] 计量单位,{@link MeasureUtil#formatArea}可选值：auto、m、km、mu、ha 。auto时根据面积值自动选用k或km
     * @param {Number} [options.splitNum=10]  插值数，将面分割的网格数
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @param {Number} [options.decimal = 2]  显示的文本中保留的小数位
     * @return {Promise<AreaSurfaceMeasure|*>} 绘制创建完成的Promise，返回 面积测量控制类 对象
     */
    areaSurface(options = {}) {
      this.stopDraw();

      options.type = "areaSurfaceMeasure";
      return this._graphicLayer.startDraw(options)
    }

    /**
     * 体积测量（方量分析）
     * @param {Object} [options] 控制参数
     * @param {PolygonEntity.StyleOptions} [options.style] 基准面的样式
     * @param {String} [options.unit='auto'] 计量单位,{@link MeasureUtil#formatArea}可选值：auto、m、km、mu、ha 。auto时根据面积值自动选用k或km
     * @param {Number} [options.splitNum=10]  插值数，将面分割的网格数
     * @param {Boolean} [options.has3dtiles]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     *
     * @param {Number} [options.minHeight]  可以指定最低高度（单位：米）
     * @param {Number} [options.maxHeight]  可以指定最高高度（单位：米）
     * @param {Number} [options.height]  可以指定基准面高度（单位：米），默认是绘制后的最低高度值
     *
     * @param {Boolean} [options.heightLabel=true] 是否显示各边界点高度值文本
     * @param {Boolean} [options.offsetLabel=false] 是否显示各边界点高度差文本
     * @param {Boolean} [options.showArea=true] 是否显示横切面积
     *
     * @param {PolygonEntity.StyleOptions} [options.polygonWall] 围合的墙样式
     * @param {LabelEntity.StyleOptions} [options.labelHeight] 各边界点高度结果文本的样式
     * @param {Number} [options.decimal = 2]  显示的文本中保留的小数位
     *
     * @return {Promise<VolumeMeasure|*>} 绘制创建完成的Promise，返回 体积测量控制类 对象
     */
    volume(options = {}) {
      this.stopDraw();

      options.type = "volumeMeasure";
      return this._graphicLayer.startDraw(options)
    }

    /**
     * 高度测量
     * @param {Object} [options] 控制参数
     * @param {PolylineEntity.StyleOptions} [options.style] 路线的样式
     * @param {String} [options.unit='auto'] 计量单位,{@link MeasureUtil#formatDistance}可选值：auto、m、km、mile、zhang 。auto时根据距离值自动选用k或km
     * @param {Number} [options.decimal = 2]  显示的文本中保留的小数位
     * @return {Promise<HeightMeasure|*>} 绘制创建完成的Promise，返回 高度测量 对象
     */
    height(options = {}) {
      this.stopDraw();

      options.type = "heightMeasure";
      return this._graphicLayer.startDraw(options)
    }

    /**
     * 三角高度测量，
     * 包括水平距离、空间距离、高度差。
     *
     * @param {Object} [options] 控制参数
     * @param {PolylineEntity.StyleOptions} [options.style] 路线的样式
     * @param {String} [options.unit='auto'] 计量单位,{@link MeasureUtil#formatDistance}可选值：auto、m、km、mile、zhang 。auto时根据距离值自动选用k或km
     * @param {Number} [options.decimal = 2]  显示的文本中保留的小数位
     * @return {Promise<HeightTriangleMeasure|*>} 绘制创建完成的Promise，返回 三角高度测量控制类 对象
     */
    heightTriangle(options = {}) {
      this.stopDraw();

      options.type = "heightTriangleMeasure";
      return this._graphicLayer.startDraw(options)
    }

    /**
     * 角度测量
     *
     * @param {Object} [options] 控制参数
     * @param {PolylineEntity.StyleOptions} [options.style] 路线的样式，默认为箭头线
     * @param {Number} [options.angleDecimal = 1]  显示的 角度值 文本中保留的小数位
     * @param {Number} [options.decimal = 2]  显示的 距离值 文本中保留的小数位
     * @return {Promise<AngleMeasure|*>} 绘制创建完成的Promise，返回 角度测量控制类 对象
     */
    angle(options = {}) {
      this.stopDraw();

      options.type = "angleMeasure";
      return this._graphicLayer.startDraw(options)
    }

    /**
     * 坐标测量
     *
     * @param {Object} [options] 控制参数
     * @param {PointEntity.StyleOptions} [options.style] 点的样式
     *
     * @return {Promise<PointMeasure|*>} 绘制创建完成的Promise，返回 坐标测量控制类 对象
     */
    point(options = {}) {
      this.stopDraw();

      options.type = "pointMeasure";
      return this._graphicLayer.startDraw(options)
    }

    /**
     * 停止绘制，如有未完成的绘制会自动删除
     * @return {boolean}  是否清除了未完成的对象
     */
    stopDraw() {
      return this._graphicLayer.stopDraw()
    }

    /**
     * 清除正在绘制
     * @return {boolean}  是否清除了对象
     */
    clearDrawing() {
      return this._graphicLayer.clearDrawing()
    }

    /**
     * 完成绘制和编辑，如有未完成的绘制会自动完成。
     * 在移动端需要调用此方法来类似PC端双击结束。
     * @return {boolean}  是否正常结束了矢量对象绘制
     */
    endDraw() {
      return this._graphicLayer.endDraw() // 会触发drawCreated
    }

    /**
     * 清除测量
     * @return {void}  无
     */
    clear() {
      return this._graphicLayer.clear()
    }

    /**
     * 更新量测结果的单位
     *
     * @param {String} unit 计量单位,{@link MeasureUtil#formatDistance}{@link MeasureUtil#formatArea} 可选值：auto、m、km、mile、zhang 等。auto时根据距离值自动选用k或km
     * @return {void}  无
     */
    updateUnit(unit) {
      this._graphicLayer.eachGraphic((graphic) => {
        graphic.options.unit = unit;
        if (graphic.showText) {
          graphic.showText(unit);
        }
      });
    }

    // 销毁
    destroy(noDel) {
      this._graphicLayer.destroy(noDel);
      super.destroy(noDel);
    }
  }

  /**
   * @typedef {Object} FloodByGraphic.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} start 开始分析
   * @property {String} change 变化了
   * @property {String} end  完成分析
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.end, function (event) {
   *   console.log('分析完成', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 淹没分析，
   * 基于polygon矢量面抬高模拟，只支持单个区域
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]} [options.positions] 区域位置，坐标位置数组
   * @param {boolean} [options.perPositionHeight=false] 指定是否使用每个位置的高度，true时不改变传入坐标的高度值，适合有坡度的水域,并且true时涉及的高度值均是至偏移值，0代表原始高度。
   * @param {PolygonEntity.StyleOptions} [options.style] 淹没区域的样式
   * @param {Number} [options.speed] 淹没速度
   * @param {Number} [options.minHeight] 淹没起始的海拔高度（单位：米）
   * @param {Number} [options.maxHeight] 淹没结束的海拔高度（单位：米）
   * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准），未设置时根据坐标自动判断（判断可能不准确）
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class FloodByGraphic
   * @extends {BaseThing}
   * @see [支持的事件类型]{@link FloodByGraphic.EventType}
   */
  class FloodByGraphic extends BaseThing {
    /**
     * 淹没区域 坐标位置数组
     * @type {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]}
     */
    get positions() {
      return this.options.positions
    }

    set positions(val) {
      this.options.positions = val;

      if (val) {
        const positions = [];
        const poinst = [];
        // let maxHeight = -9999
        val.forEach((item) => {
          const _point = LngLatPoint.parse(item);
          if (!_point || !_point.valid()) {
            return
          }
          _point._alt_bak = _point.alt;
          // maxHeight = Math.max(_point.alt, maxHeight)

          poinst.push(_point);
          positions.push(_point.toCartesian(true));
        });

        this._poinst = poinst;
        this._hierarchyPositions = positions;
        // this._maxHeightByPositions = maxHeight

        if (this._map) {
          const _has3dtiles = this.options.has3dtiles ?? Cesium__namespace.defined(this._map.pick3DTileset(positions)); // 是否在3ditiles上面
          if (!_has3dtiles) {
            if (!Cesium__namespace.defined(this._last_depthTestAgainstTerrain)) {
              this._last_depthTestAgainstTerrain = this._map.scene.globe.depthTestAgainstTerrain;
            }
            this._map.scene.globe.depthTestAgainstTerrain = true;
          }
        }
      } else {
        this._hierarchyPositions = null;
      }
    }

    /**
     * 淹没平面高度（单位：米）
     * @type {Number}
     */
    get height() {
      return this._extrudedHeight ?? this.options.minHeight
    }

    set height(val) {
      this._extrudedHeight = val;

      if (this.options.perPositionHeight) {
        if (!this._poinst && this.options.positions) {
          this.positions = this.options.positions;
        }
        if (this._poinst) {
          const positions = [];
          this._poinst.forEach((item) => {
            const _point = LngLatPoint.parse(item);
            if (!_point || !_point.valid()) {
              return
            }
            // _point.alt = _point._alt_bak + (val - this._maxHeightByPositions)
            _point.alt = _point._alt_bak + val;
            positions.push(_point.toCartesian(true));
          });

          this._hierarchyPositions = positions;
        }
      }

      this.fire(EventType.change, {
        height: this._extrudedHeight
      });
    }

    /**
     * 淹没速度
     * @type {Number}
     */
    get speed() {
      return this.options.speed
    }

    set speed(val) {
      this.options.speed = val;
    }
    //= ========= 方法 ==========

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this.graphicLayer = new GraphicLayer({
        name: "淹没分析",
        private: true
      });

      this._extrudedHeight = 0;

      const polygonHierarchy = new Cesium__namespace.PolygonHierarchy();
      const style = {
        color: "#007be6",
        opacity: 0.5,
        outline: false,
        ...(this.options.style || {}),
        perPositionHeight: true
      };

      if (!this.options.perPositionHeight) {
        style.height = this._extrudedHeight;
        style.extrudedHeight = new Cesium__namespace.CallbackProperty((time) => {
          return this._extrudedHeight
        }, false);
      }

      const graphic = new PolygonEntity({
        positions: new Cesium__namespace.CallbackProperty((time) => {
          if (!this._hierarchyPositions) {
            return null
          }
          polygonHierarchy.positions = this._hierarchyPositions;
          return polygonHierarchy
        }, false),
        style: style
      });
      this.graphic = graphic;

      if (Cesium__namespace.defined(this.options.minHeight) && Cesium__namespace.defined(this.options.maxHeight) && Cesium__namespace.defined(this.options.positions)) {
        this.setOptions();
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.addLayer(this.graphicLayer);
      this.graphicLayer.addGraphic(this.graphic);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.removeLayer(this.graphicLayer);
      this.clear();
    }

    /**
     * 重新赋值参数，同构造方法参数一致。
     * @param {Object} options 参数,与类的构造方法参数相同
     * @return {FloodByGraphic} 当前对象本身，可以链式调用
     */
    setOptions(options) {
      if (options) {
        this.options = {
          ...this.options,
          ...options
        };
      }
      this.stop();

      let minHeight = this.options.minHeight;
      let maxHeight = this.options.maxHeight;

      // 检查参数
      if (!Cesium__namespace.defined(minHeight)) {
        logError("minHeight 请传入有效数值！", minHeight);
        return
      }
      if (!Cesium__namespace.defined(maxHeight)) {
        logError("maxHeight 请传入有效数值！", maxHeight);
        return
      }
      if (minHeight > maxHeight) {
        const temp = minHeight; // 互相交换数据
        minHeight = maxHeight;
        maxHeight = temp;
      }
      this._extrudedHeight = minHeight;
      this._maxHeight = maxHeight;

      this.positions = this.options.positions;

      return this
    }

    /**
     * 开始播放淹没动画效果
     * @return {void}  无
     */
    start() {
      if (!this._hierarchyPositions) {
        logError("请传入淹没区域才能开始分析");
        return
      }

      this.stop();

      this.isStart = true;
      this.fire(EventType.start);

      this._timeTik = setInterval(() => {
        if (this._extrudedHeight >= this._maxHeight) {
          this.stop();
          return
        }
        const newHeight = this._extrudedHeight + this.speed;
        if (newHeight > this._maxHeight) {
          this.height = this._maxHeight;
        } else {
          this.height = newHeight;
        }
      }, 100);
    }

    /**
     * 停止播放淹没动画效果
     * @return {void}  无
     */
    stop() {
      if (!this.isStart) {
        return
      }

      if (this._timeTik) {
        clearInterval(this._timeTik);
        delete this._timeTik;
      }

      this.isStart = false;
      this.fire(EventType.end);
    }

    /**
     * 重新开始播放淹没动画效果
     * @return {void}  无
     */
    restart() {
      this.setOptions();
      this.start();
    }

    /**
     * 清除分析
     * @return {void}  无
     */
    clear() {
      this.positions = null;
      if (this._last_depthTestAgainstTerrain != null) {
        this._map.scene.globe.depthTestAgainstTerrain = this._last_depthTestAgainstTerrain;
        delete this._last_depthTestAgainstTerrain;
      }
      this.stop();
    }

    destroy(noDel) {
      if (this.graphicLayer) {
        this.graphicLayer.destroy(noDel);
      }
      super.destroy(noDel);
    }
  }

  /**
   * @typedef {Object} Slope.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} endItem 多个数据异步分析时，完成其中一个时的回调事件
   * @property {String} end 多个数据异步分析时，完成所有的回调事件
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.change, function (event) {
   *   console.log('发送了变化', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 坡度坡向分析
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]} [options.positions] 分析区域 坐标位置数组
   *
   * @param {PolylinePrimitive.StyleOptions|Object} [options.arrow] 箭头线的样式，包括以下：
   * @param {Boolean} [options.arrow.show=true] 是否显示箭头线
   * @param {Cesium.Color} [options.arrow.color=Cesium.Color.YELLOW] 颜色
   * @param {Number} [options.arrow.width=15] 箭头宽度值
   * @param {Number} [options.arrow.scale=0.3] 箭头长度的比例（网格大小），根据绘制区域的大小和插值数来计算实际长度值。
   * @param {Number} [options.arrow.length] 箭头长度固定值,将覆盖scale参数
   *
   * @param {Function} [options.tooltip] 可以指定绑定tooltip
   * @param {Tooltip.StyleOptions} [options.tooltipOptions] tooltip弹窗时的配置参数，也支持如pointerEvents等{@link Tooltip}构造参数
   * @param {Function} [options.popup] 可以指定绑定popup
   * @param {Popup.StyleOptions} [options.popupOptions] popup弹窗时的配置参数，也支持如pointerEvents等{@link Popup}构造参数
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class Slope
   * @extends {BaseThing}
   * @see [支持的事件类型]{@link Slope.EventType}
   */
  class Slope extends BaseThing {
    constructor(options = {}) {
      super(options);

      // 箭头
      this.options.arrow = this.options.arrow || {};
      this.options.arrow.show = this.options.arrow.show ?? true;
      this.options.arrow.color = this.options.arrow.color ?? Cesium__namespace.Color.YELLOW;
      this.options.arrow.width = this.options.arrow.width ?? 15; // 箭头宽度
      this.options.arrow.scale = this.options.arrow.scale ?? 0.3; // 箭头长度的比例
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this.graphicLayer = new GraphicLayer({
        name: "坡度坡向",
        tooltip: function (event) {
          const attr = event.graphic?.attr;
          if (!attr) {
            return
          }
          return `坡度: ${attr.slopeStr1}  (${attr.slopeStr2})<br />坡向: ${attr.direction}°`
        },
        ...this.options,
        private: true
      });
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.addLayer(this.graphicLayer);

      if (this.options.positions && this.options.positions.length > 0) {
        this.add(this.options.positions, this.options);
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.removeLayer(this.graphicLayer);
      this.clear();
    }

    /**
     * 添加计算的 位置
     *
     * @param {Array[]|LngLatPoint[]|Cesium.Cartesian3[]|LngLatPoint|Cesium.Cartesian3} positions 坐标数组 或 单个坐标
     * @param {Object} [options={}] 控制参数，包括：
     * @param {Number} [options.splitNum=8] 插值数，横纵等比分割的网格个数
     * @param {Number} [options.radius=2]  取样分析，点周边半径（单位：米）
     * @param {Number} [options.count=4] 取样分析，点周边象限内点的数量，共计算 count*4 个点
     * @param {Boolean} [options.has3dtiles=auto]  是否在3dtiles模型上分析（模型分析较慢，按需开启）,默认内部根据点的位置自动判断（但可能不准）
     * @return {void}  无，计算结果在 end事件中返回
     */
    add(positions, options = {}) {
      if (!positions || positions.length < 1) {
        return
      }
      positions = LngLatArray.toCartesians(positions);

      this._eventResult = { positions: positions };

      this._stateOkIndex = 0;
      this._arrowInstances = [];
      this._arrData = [];

      const splitNum = options.splitNum ?? 8;
      if (positions.length > 2 && splitNum > 1) {
        // 传入面边界时
        interPolygon({
          scene: this._map.scene,
          positions: positions,
          has3dtiles: false,
          onlyPoint: true, // true时只返回点，不返回三角网
          splitNum: splitNum // splitNum插值分割的个数
        }).then((resultInter) => {
          if (this.options.arrow.length) {
            this._arrowLength = this.options.arrow.length;
          } else {
            this._arrowLength =
              Cesium__namespace.Math.chordLength(resultInter.granularity, this._map.scene.globe.ellipsoid.maximumRadius) * this.options.arrow.scale;
          }

          this._eventResult.maxHeight = resultInter.maxHeight;
          this._eventResult.minHeight = resultInter.minHeight;

          positions = [];
          for (let k = 0; k < resultInter.list.length; k++) {
            positions.push(resultInter.list[k].pointDM);
          }

          this._stateAll = positions.length;
          for (let i = 0; i < this._stateAll; i++) {
            this._fxOnePoint(positions[i], options);
          }
        });
      } else {
        this._arrowLength = this.options.arrow.length ?? 40;

        this._stateAll = positions.length;
        for (let i = 0; i < this._stateAll; i++) {
          this._fxOnePoint(positions[i], options);
        }
      }
    }

    // 分析单个点的对应坡度
    _fxOnePoint(position, options) {
      if (!position) {
        return
      }

      // 返回该点的周边2米圆上的8个点
      const arcPoint = getEllipseOuterPositions({
        position: position,
        radius: options.radius ?? 2, // 半径
        count: options.count ?? 4 // 共返回 count*4 个点
      });
      arcPoint.push(position);

      const ellipsoid = this._map.scene.globe.ellipsoid;

      // 求出点的详细高度
      computeSurfacePoints({
        scene: this._map.scene,
        positions: arcPoint,
        has3dtiles: options.has3dtiles
      }).then((result) => {
        if (this._stateAll === 0) {
          return
        }

        if (result.noHeight) {
          logWarn("未获取到高度值，贴地高度计算存在误差");
        }

        const cartographicArray = ellipsoid.cartesianArrayToCartographicArray(result.positions);

        // 中心点
        const center = cartographicArray.pop();

        // 其余圆上点
        let maxIndex = 0;
        let maxHeight = cartographicArray[0].height;
        let minIndex = 0;
        let minHeight = cartographicArray[0].height;
        for (let i = 1; i < cartographicArray.length - 1; i++) {
          const item = cartographicArray[i];
          if (item.height > maxHeight) {
            maxHeight = item.height;
            maxIndex = i;
          }
          if (item.height < minHeight) {
            minHeight = item.height;
            minIndex = i;
          }
        }

        const maxPoint = cartographicArray[maxIndex]; // 周边最高点
        const minPoint = cartographicArray[minIndex]; // 周边最低点

        const slopeVal1 = this.getSlope(center, maxPoint);
        const slopeVal2 = this.getSlope(center, minPoint);

        if (slopeVal1 > slopeVal2) {
          this._fxOnePointOk(position, center, maxPoint, slopeVal1);
        } else {
          this._fxOnePointOk(position, center, minPoint, slopeVal2);
        }
      });
    }

    // 分析单个点的对应坡度完成后添加显示的箭头等
    _fxOnePointOk(position, center, maxPoint, slopeVal) {
      const centerCar = Cesium__namespace.Cartographic.toCartesian(center);
      let maxPointCar = Cesium__namespace.Cartographic.toCartesian(maxPoint);
      maxPointCar = getOnLinePointByLen(centerCar, maxPointCar, this._arrowLength);

      // 计算圆上的最高点和中心点的高度 判断箭头方向
      let arrArrowPt;
      if (center.height > maxPoint.height) {
        // 中心点高于四周情况下
        arrArrowPt = [centerCar, maxPointCar];
      } else {
        // 边缘指向中心
        arrArrowPt = [maxPointCar, centerCar];
      }

      // 求方位角
      const slopeAngle = getAngle(arrArrowPt[0], arrArrowPt[1], true);

      let slopeValDou = (Math.atan(slopeVal) * 180) / Math.PI;
      slopeValDou = Number(slopeValDou.toFixed(2));

      // 度数法 【 α(坡度)=arc tan (高程差/水平距离)】 eg: 45°
      const text1 = slopeValDou + "°";
      // 百分比法 【 坡度 = (高程差/水平距离)x100%】 eg:30%
      const text2 = (slopeVal * 100).toFixed(2) + "%";

      const itemData = {
        position: position, // 坐标位置
        slope: slopeValDou, // 度数法值【 α(坡度)=arc tan (高程差/水平距离)】
        slopeStr1: text1, // 度数法值字符串
        slopeStr2: text2, // 百分比法值字符串【 坡度 = (高程差/水平距离)x100%】
        direction: slopeAngle // 坡向值（0-360度）
      };
      if (!this._arrData) {
        this._arrData = [];
      }
      this._arrData.push(itemData);

      this.fire(EventType.endItem, {
        data: itemData,
        index: this._stateOkIndex
      });

      // 构建箭头
      if (this.options.arrow.show) {
        this._arrowInstances.push({
          positions: arrArrowPt,
          attr: itemData
        });
      }

      // 全部计算完成
      this._stateOkIndex++;
      if (this._stateOkIndex >= this._stateAll) {
        if (this.options.arrow.show && this._arrowInstances.length > 0) {
          // 多个线对象的合并渲染。
          const primitive = new PolylineCombine({
            instances: this._arrowInstances,
            style: {
              material: createMaterial(PolylineArrow, {
                color: this.options.arrow.color
              }),
              ...this.options.arrow
            }
          });
          this.graphicLayer.addGraphic(primitive);
        }

        this.fire(EventType.end, {
          ...(this._eventResult || {}),
          data: this._arrData
        });
      }
    }

    /**
     * 计算两点之间的坡度
     *
     * @param { Cesium.Cartesian3} c1 点1
     * @param { Cesium.Cartesian3} c2 点2
     * @return {Number} 坡度值
     */
    getSlope(c1, c2) {
      if (!c1 || !c2) {
        return
      }
      const differH = Math.abs(c1.height - c2.height); // 高度差
      const differV = Cesium__namespace.Cartesian3.distance(
        Cesium__namespace.Cartographic.toCartesian(c1),
        Cesium__namespace.Cartesian3.fromRadians(c2.longitude, c2.latitude, c1.height)
      ); // 水平距离
      const value = differH / differV;
      return value
    }

    /**
     * 清除分析
     * @return {void}  无
     */
    clear() {
      this.graphicLayer.clear();
      this._arrowInstances = [];
      this._arrData = [];
      this._stateAll = 0;
      this._stateOkIndex = 0;
    }

    /**
     * 异步计算完成所有点的坡度坡向后 的回调方法
     * @callback getSlope_callback
     * @param {Object} event 参数对象，具有以下属性:
     * @param {Object[]} event.data 数组对象，数组中每一个值，具有以下属性:
     * @param {Cesium.Cartesian3} event.data.position  坐标位置
     * @param {Number} event.data.slope 度数法值【 α(坡度)=arc tan (高程差/水平距离)】
     * @param {String} event.data.slopeStr1 度数法值字符串
     * @param {String} event.data.slopeStr2 百分比法值字符串【 坡度 = (高程差/水平距离)x100%】
     * @param {Number} event.data.direction 坡向值（0-360度）
     */

    /**
     * 异步计算中，每计算完成1个点的坡度坡向后 的回调方法
     * @callback getSlope_endItem
     * @param {Object} event 参数对象，具有以下属性:
     * @param {Number} event.index 数组点中的index顺序
     * @param {Object} event.data 数据对象，具有以下属性:
     * @param {Cesium.Cartesian3} event.data.position  坐标位置
     * @param {Number} event.data.slope 度数法值【 α(坡度)=arc tan (高程差/水平距离)】
     * @param {String} event.data.slopeStr1 度数法值字符串
     * @param {String} event.data.slopeStr2 百分比法值字符串【 坡度 = (高程差/水平距离)x100%】
     * @param {Number} event.data.direction 坡向值（0-360度）
     */

    /**
     * 异步计算点的坡度坡向
     * @param {Object} options 参数对象，具有以下属性:
     * @param {Map} options.map  Map地图对象
     * @param {Cesium.Cartesian3[]} options.positions 坐标数组
     * @param {Number} options.radius  缓冲半径（影响坡度坡向的精度）
     * @param {Number} options.count  缓冲的数量（影响坡度坡向的精度）会求周边(count*4)个点
     * @param {Boolean} options.has3dtiles  是否在3dtiles模型上分析（模型分析较慢，按需开启）
     * @param {getSlope_endItem} options.endItem  异步计算中，每计算完成1个点的坡度坡向后 的回调方法
     * @return {Promise<Object>} 异步计算完成的Promise
     */
    static getSlope(options) {
      return new Promise((resolve, reject) => {
        const slope = new Slope({
          positions: options.positions,
          splitNum: 1,
          radius: options.radius, // 缓冲半径（影响坡度坡向的精度）
          count: options.count, // 缓冲的数量（影响坡度坡向的精度）会求周边(count*4)个点
          has3dtiles: options.has3dtiles,
          point: { show: false },
          arrow: { show: false }
        });
        slope.addTo(options.map);

        if (options.endItem) {
          slope.on(EventType.endItem, options.endItem);
        }
        slope.on(EventType.end, (e) => {
          slope.destroy();

          if (options.callback) {
            options.callback(e); // 兼容v3.4之前版本callback
          }
          resolve(e);
        });
      })
    }
  }

  /**
   * 地形开挖 ，
   * 基于clippingPlanes接口，只支持单个开挖。
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]} [options.positions] 开挖区域的 坐标位置数组
   * @param {Boolean} [options.clipOutSide = false] 是否外切开挖
   * @param {String} [options.image]  开挖区域的井墙面贴图URL。未传入该值时，不显示开挖区域的井。
   * @param {String} [options.imageBottom] 当显示开挖区域的井时，井底面贴图URL
   * @param {Number} [options.diffHeight]  当显示开挖区域的井时，设置区域的挖掘深度（单位：米）
   * @param {Number} [splitNum = 30] 当显示开挖区域的井时，井墙面每两点之间插值个数
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class TerrainPlanClip
   * @extends {BaseThing}
   */
  class TerrainPlanClip extends BaseThing {
    //= ========= 对外属性 ==========
    /**
     * 开挖区域的 坐标位置数组
     * @type {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]}
     */
    get positions() {
      return this._positions
    }

    set positions(val) {
      this.clear();

      this._positions = val;
      this.setPositions(val);
    }

    /**
     * 设置所有区域的挖掘深度（单位：米）
     * @type {Number}
     */
    get diffHeight() {
      return this.options.diffHeight
    }

    set diffHeight(val) {
      this.options.diffHeight = val;

      if (this._graphicLayer) {
        this._graphicLayer.eachGraphic((pitPrimitive) => {
          pitPrimitive.diffHeight = val;
        });
      }
    }

    /**
     * 是否外切开挖
     * @type {Boolean}
     */
    get clipOutSide() {
      return this.options.clipOutSide
    }

    set clipOutSide(val) {
      this.options.clipOutSide = val;

      if (this._map && this._positions) {
        this.setPositions(this._positions);
      }
    }

    //= ========= 方法 ==========
    _enabledHook(val) {
      if (this._map.scene.globe.clippingPlanes) {
        this._map.scene.globe.clippingPlanes.enabled = val;
      }

      if (this._graphicLayer) {
        this._graphicLayer.show = val;
      }
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {}

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      // 开挖对应的井对象
      this._graphicLayer = new GraphicLayer({
        ...this.options,
        private: true
      });
      this._map.addLayer(this._graphicLayer);

      if (this.options.positions && this.options.positions.length > 0) {
        this.setPositions(this.options.positions);
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.clear();

      // 开挖对应的井对象
      if (this._graphicLayer) {
        this._map.removeLayer(this._graphicLayer);
        delete this._graphicLayer;
      }
    }

    // 创建开挖面
    setPositions(positions) {
      this.clear();

      if (!positions || positions.length < 3) {
        logError("挖地坐标数据存在问题！", positions);
        return
      }

      positions = LngLatArray.toCartesians(positions);

      this._positions = positions;

      const clippingPlanes = [];
      const pointsLength = positions.length;

      // 是否顺时针
      let direction;
      const startAngle = formatNum$1(getAngle(positions[0], positions[1]), 2);
      if (startAngle > -0.02 && startAngle < 0.02) {
        direction = false;
      } else {
        const endAngle = formatNum$1(getAngle(positions[0], positions[2]), 2);
        direction = startAngle < endAngle;
      }

      if (this.clipOutSide) {
        direction = !direction;
      }

      for (let i = 0; i < pointsLength; ++i) {
        const nextIndex = (i + 1) % pointsLength;
        const midpoint = Cesium__namespace.Cartesian3.midpoint(positions[i], positions[nextIndex], new Cesium__namespace.Cartesian3());

        const up = Cesium__namespace.Cartesian3.normalize(midpoint, new Cesium__namespace.Cartesian3());
        let right;
        if (direction) {
          right = Cesium__namespace.Cartesian3.subtract(positions[i], midpoint, new Cesium__namespace.Cartesian3()); // 顺时针
        } else {
          right = Cesium__namespace.Cartesian3.subtract(positions[nextIndex], midpoint, new Cesium__namespace.Cartesian3());
        }
        right = Cesium__namespace.Cartesian3.normalize(right, right);
        let normal = Cesium__namespace.Cartesian3.cross(right, up, new Cesium__namespace.Cartesian3());
        normal = Cesium__namespace.Cartesian3.normalize(normal, normal);
        const originCenteredPlane = new Cesium__namespace.Plane(normal, 0.0);
        const distance = Cesium__namespace.Plane.getPointDistance(originCenteredPlane, midpoint);
        clippingPlanes.push(new Cesium__namespace.ClippingPlane(normal, distance));
      }

      this._map.scene.globe.clippingPlanes = new Cesium__namespace.ClippingPlaneCollection({
        planes: clippingPlanes,
        edgeWidth: this.options.edgeWidth ?? 1.0,
        edgeColor: this.options.edgeColor ?? Cesium__namespace.Color.WHITE,
        unionClippingRegions: this.clipOutSide,
        enabled: true
      });

      if (this.options.image) {
        const pitPrimitive = new Pit({
          style: this.options,
          positions: positions
        });
        this._graphicLayer.addGraphic(pitPrimitive);
      }
    }

    /**
     * 清除开挖
     * @return {void}  无
     */
    clear() {
      if (!this._map) {
        return
      }
      this._positions = null;
      if (this._graphicLayer) {
        this._graphicLayer.clear();
      }

      if (this._map.scene.globe?.clippingPlanes?.enabled) {
        this._map.scene.globe.clippingPlanes.enabled = false;
      }
      this._map.scene.globe.clippingPlanes = undefined;
    }
  }

  var TerrainEditVS = "attribute vec3 position;\n\nvoid main() {\n  vec4 pos = vec4(position.xyz, 1.0);\n  gl_Position = czm_projection * pos;\n}\n"; // eslint-disable-line

  var TerrainEditFS = "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvoid main() {\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n"; // eslint-disable-line

  /**
   * 地形开挖、淹没等分析 基础类
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]} [options.positions] 坐标位置数组，只显示单个区域【单个区域场景时使用】
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class TerrainEditBase
   * @extends {BaseThing}
   */
  class TerrainEditBase extends BaseThing {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);
      if (!isMars3DCesium) {
        logError("该功能需要引入mars3d修改版Cesium库(mars3d-cesium库)才支持!", this);
      }

      // 裁剪区域相关
      this.heightVal = options.heightVal ?? new Cesium__namespace.Cartesian4(0, 0, 0, 500); // [基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]

      this._maxCanvasSize = options.maxCanvasSize ?? 4096; // 数值越大，剪裁越精确，占用显存越高
      this._areaList = []; // 区域数组
    }

    //= ========= 对外属性 ==========

    // 分析参数
    get analysisOptions() {
      return this._map?.scene?.globe?._surface?.tileProvider?.marsOptions?.flood
    }

    /**
     * 区域 列表
     * @type {Object[]}
     * @readonly
     */
    get list() {
      return this._areaList
    }

    /**
     * 是否显示区域外的地图
     * @type {Boolean}
     */
    get showElseArea() {
      return this.analysisOptions?.showElseArea ?? true
    }

    set showElseArea(val) {
      this.analysisOptions.showElseArea = val;
    }

    /**
     * 坐标位置数组，只显示单个区域【单个区域场景时使用】
     * @type {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]}
     */
    get positions() {
      if (this.length > 0) {
        return this._areaList[0].positions
      } else {
        return null
      }
    }

    set positions(val) {
      this.clear();
      this.addArea(val);
    }

    /**
     * 已添加的区域个数
     * @type {Number}
     * @readonly
     */
    get length() {
      if (this._areaList) {
        return this._areaList?.length
      } else {
        return 0
      }
    }

    //= ========= 方法 ==========

    _enabledHook(val) {
      this.analysisOptions.enabled = val;
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this.analysisOptions.showElseArea = this.options.showElseArea ?? true;

      if (this.options.positions) {
        this.addArea(this.options.positions);
      }

      if (this.options.dynamicView) {
        this._scopeIds_last = [];
        this._map.on(EventType.preUpdate, this._map_preUpdateHandler, this);
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this.options.dynamicView) {
        this._map.off(EventType.preUpdate, this._map_preUpdateHandler, this);
        this._scopeIds_last = [];
      }

      this.clear();

      this.analysisOptions.enabled = false;
      this.analysisOptions.inverMatrix = Cesium__namespace.Matrix4.IDENTITY;
      this.analysisOptions.polygonTexture = undefined;
    }

    /**
     * 清除所有区域
     * @return {void}  无
     */
    clear() {
      this._areaList = [];
      this._clearDraw();

      this._map.scene.globe.material = null;
      this._map.scene.globe._surface.tileProvider.marsOptions.resetValue();
    }

    _clearDraw() {
      this.analysisOptions.inverMatrix = Cesium__namespace.Matrix4.IDENTITY;
      this.analysisOptions.polygonTexture = undefined;

      if (this._polygonTexture) {
        this._polygonTexture.destroy();
        delete this._polygonTexture;
      }
      if (this._framebuffer) {
        this._framebuffer.destroy();
        delete this._framebuffer;
      }
    }

    /**
     * 根据id获取区域对象
     *
     * @param {Number} id id值
     * @return {Object} 区域对象
     */
    getAreaById(id) {
      if (!isNumber(id)) {
        return id
      }

      for (let i = 0; i < this._areaList.length; i++) {
        const item = this._areaList[i];
        if (item.id === id) {
          return item
        }
      }
      return null
    }

    /**
     * 隐藏单个区域
     * @param {Number} id 区域id值
     * @return {void}  无
     */
    hideArea(id) {
      const areaObj = this.getAreaById(id);
      if (areaObj) {
        areaObj.show = false;
        if (areaObj.pitPrimitive) {
          areaObj.pitPrimitive.show = false;
        }

        this._update();
      }
    }

    /**
     * 显示单个区域
     * @param {Number} id 区域id值
     * @return {void}  无
     */
    showArea(id) {
      const areaObj = this.getAreaById(id);
      if (areaObj) {
        areaObj.show = true;
        if (areaObj.pitPrimitive) {
          areaObj.pitPrimitive.show = true;
        }

        this._update();
      }
    }

    // 移除单个区域后的钩子方法
    _removeAreaHook(areaObj) {}

    /**
     * 移除单个区域
     * @param {Number|Object} item 区域的id值，或 addArea返回的区域对象
     * @return {void}  无
     */
    removeArea(item) {
      if (isNumber(item)) {
        item = this.getAreaById(item);
      }
      if (!item) {
        return
      }

      this._removeAreaHook(item);
      removeArrayItem(this._areaList, item);

      this._update();
    }

    // 添加单个区域后的钩子方法
    _addAreaHook(areaObj) {}

    /**
     * 添加单个区域
     *
     * @param {String[]|Array[]|LngLatPoint[]|Cesium.Cartesian3[]} positions 坐标位置数组
     * @param {Object} [options={}] 控制的参数
     * @param {Object} [options.diffHeight] 开挖深度（地形开挖时，可以控制单个区域的开挖深度）
     * @return {Object} 添加区域的记录对象
     */
    addArea(positions, options) {
      if (!positions || positions.length === 0) {
        return
      }

      const areaObj = {
        show: true,
        scope: true, // 是否视域内
        id: getGlobalId(),
        positions_original: positions, // 原始的，用于井
        positions: LngLatArray.toCartesians(positions, true)
      };

      this._areaList.push(areaObj);

      logInfo("添加地形处理区域", LngLatArray.toArray(positions)); // 打印下边界

      this._addAreaHook(areaObj, options);

      this._update();

      return areaObj
    }

    _update() {
      this._clearDraw();

      const total = new Cesium__namespace.Cartesian3();
      const arrAreaSelect = []; // 当前需要渲染的area
      this._areaList.forEach((areaObj) => {
        if (!areaObj.show || !areaObj.scope || !areaObj.positions) {
          return
        }

        const boundingSphere = Cesium__namespace.BoundingSphere.fromPoints(areaObj.positions);
        Cesium__namespace.Cartesian3.add(total, boundingSphere.center, total);
        arrAreaSelect.push(areaObj);
      });

      const context = this._map.scene.context;

      if (arrAreaSelect.length === 0) {
        return
      }

      const totalCenter = Cesium__namespace.Cartesian3.multiplyByScalar(total, 1 / arrAreaSelect.length, new Cesium__namespace.Cartesian3());
      const trans = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(totalCenter);
      this._inverMatrix = Cesium__namespace.Matrix4.inverse(trans, new Cesium__namespace.Matrix4());

      let minX = 99999999;
      let minY = 99999999;
      let maxX = -99999999;
      let maxY = -99999999;
      arrAreaSelect.forEach((areaObj) => {
        let polygon = new Cesium__namespace.PolygonGeometry({
          polygonHierarchy: new Cesium__namespace.PolygonHierarchy(areaObj.positions)
        });
        polygon = Cesium__namespace.PolygonGeometry.createGeometry(polygon);
        const indexs = polygon.indices;
        const positionVal = polygon.attributes.position.values;
        const lenV = positionVal.length;

        const localPos = [];
        const localVertex = [];
        for (let i = 0; i < lenV; i += 3) {
          const currCar = new Cesium__namespace.Cartesian3(positionVal[i], positionVal[i + 1], positionVal[i + 2]);
          const localp = Cesium__namespace.Matrix4.multiplyByPoint(this._inverMatrix, currCar, new Cesium__namespace.Cartesian3());
          localp.z = 0;
          localPos.push(localp);
          localVertex.push(localp.x);
          localVertex.push(localp.y);
          localVertex.push(localp.z);

          if (minX >= localp.x) {
            minX = localp.x;
          }
          if (minY >= localp.y) {
            minY = localp.y;
          }
          if (maxX <= localp.x) {
            maxX = localp.x;
          }
          if (maxY <= localp.y) {
            maxY = localp.y;
          }
        }
        areaObj.localPos = localPos;

        const lps = new Float64Array(localVertex);
        const bs = Cesium__namespace.BoundingSphere.fromVertices(lps);
        const localGeo = new Cesium__namespace.Geometry({
          attributes: {
            position: new Cesium__namespace.GeometryAttribute({
              componentDatatype: Cesium__namespace.ComponentDatatype.DOUBLE,
              componentsPerAttribute: 3,
              values: lps
            })
          },
          indices: indexs,
          primitiveType: Cesium__namespace.PrimitiveType.TRIANGLES,
          boundingSphere: bs
        });

        const sp = Cesium__namespace.ShaderProgram.fromCache({
          context,
          vertexShaderSource: TerrainEditVS,
          fragmentShaderSource: TerrainEditFS,
          attributeLocations: {
            position: 0
          }
        });
        const vao = Cesium__namespace.VertexArray.fromGeometry({
          context,
          geometry: localGeo,
          attributeLocations: sp._attributeLocations,
          bufferUsage: Cesium__namespace.BufferUsage.STATIC_DRAW,
          interleave: true
        });

        const rs = new Cesium__namespace.RenderState();
        rs.depthRange.near = -1000000.0;
        rs.depthRange.far = 1000000.0;

        areaObj.drawAreaCommand = new Cesium__namespace.DrawCommand({
          boundingVolume: bs,
          primitiveType: Cesium__namespace.PrimitiveType.TRIANGLES,
          vertexArray: vao,
          shaderProgram: sp,
          renderState: rs,
          pass: Cesium__namespace.Pass.TRANSLUCENT
        });
      });

      const ratio = (maxY - minY) / (maxX - minX);
      const totalRect = [minX, minY, maxX, maxY];

      const maxDis = 120000;
      const ortCamera = {
        viewMatrix: Cesium__namespace.Matrix4.IDENTITY,
        inverseViewMatrix: Cesium__namespace.Matrix4.IDENTITY,
        frustum: new Cesium__namespace.OrthographicOffCenterFrustum(),
        positionCartographic: { height: 0, latitude: 0, longitude: 0 },
        positionWC: new Cesium__namespace.Cartesian3(0, 0, maxDis / 2),
        directionWC: new Cesium__namespace.Cartesian3(0, 0, -1),
        upWC: new Cesium__namespace.Cartesian3(0, 1, 0),
        rightWC: new Cesium__namespace.Cartesian3(1, 0, 0),
        viewProjectionMatrix: Cesium__namespace.Matrix4.IDENTITY
      };

      ortCamera.frustum.left = totalRect[0];
      ortCamera.frustum.top = totalRect[3];
      ortCamera.frustum.right = totalRect[2];
      ortCamera.frustum.bottom = totalRect[1];
      ortCamera.frustum.near = 0.1;
      ortCamera.frustum.far = -maxDis;

      this._tailorRect = new Cesium__namespace.Cartesian4(totalRect[0], totalRect[1], totalRect[2] - totalRect[0], totalRect[3] - totalRect[1]);

      let width;
      let height;
      if (ratio > 1) {
        width = this._maxCanvasSize / ratio;
        height = this._maxCanvasSize;
      } else {
        width = this._maxCanvasSize;
        height = width * ratio;
      }

      const polygonTexture = new Cesium__namespace.Texture({
        context,
        width: width,
        height: height,
        pixelFormat: Cesium__namespace.PixelFormat.RGBA,
        pixelDatatype: Cesium__namespace.PixelDatatype.HALF_FLOAT,
        flipY: false
      });
      this._polygonTexture = polygonTexture;
      this.analysisOptions.polygonTexture = this._polygonTexture;

      this._framebuffer = new Cesium__namespace.Framebuffer({
        context,
        colorTextures: [polygonTexture],
        destroyAttachments: false
      });

      const fboClearCommand = new Cesium__namespace.ClearCommand({
        color: new Cesium__namespace.Color(0.0, 0.0, 0.0, 0.0),
        framebuffer: this._framebuffer
      });
      const passState = new Cesium__namespace.PassState(context);
      passState.viewport = new Cesium__namespace.BoundingRectangle(0, 0, width, height);
      const us = context.uniformState;
      us.updateCamera(ortCamera);
      fboClearCommand.execute(context);

      arrAreaSelect.forEach((areaObj) => {
        const command = areaObj.drawAreaCommand;
        if (command) {
          us.updatePass(command.pass);
          command.framebuffer = this._framebuffer;
          command.execute(context, passState);
        }
      });

      this._beginAnalysis();
    }

    _beginAnalysis() {
      this.analysisOptions.inverMatrix = this._inverMatrix;
      this.analysisOptions.polygonTexture = this._polygonTexture;
      this.analysisOptions.enabled = true;
      this.analysisOptions.floodRect = this._tailorRect;
      this.analysisOptions.globe = false;
    }

    // 设置高度
    _setFloodVar() {
      this.heightVal = new Cesium__namespace.Cartesian4(this.minHeight, this.minHeight, this.maxHeight, this.maxHeight - this.minHeight);
    }

    // 根据视角动态计算变化（目前开挖有使用）
    _map_preUpdateHandler() {
      if (!this._map || (this._areaList.length === 0 && this._scopeIds_last.length === 0)) {
        return
      }

      const scopeIds = [];
      this._areaList.forEach((areaObj) => {
        if (!areaObj.show) {
          return
        }
        areaObj.scope = this._isInSceneCamera(areaObj.positions);
        if (areaObj.scope) {
          scopeIds.push(areaObj.id);
        }
      });

      let areaChange = scopeIds.length !== this._scopeIds_last.length;
      if (!areaChange) {
        for (let j = 0; j < scopeIds.length; j++) {
          if (this._scopeIds_last[j] !== scopeIds[j]) {
            areaChange = true;
            break
          }
        }
      }

      if (areaChange) {
        this._update();
        this._scopeIds_last = Cesium__namespace.clone(scopeIds);
      }
    }

    _isInSceneCamera(arr) {
      const scene = this._map.scene;
      const center = this._map.getCenter();
      const cameraPosition = scene.camera.positionWC;

      for (let i = 0; i < arr.length; i++) {
        const position = arr[i];
        const winPt = Cesium__namespace.SceneTransforms.wgs84ToWindowCoordinates(scene, position, new Cesium__namespace.Cartesian2());
        if (winPt && winPt.x >= 0 && winPt.x <= scene.context.drawingBufferWidth && winPt.y >= 0 && winPt.y <= scene.context.drawingBufferHeight) {
          return true
        }

        if (Cesium__namespace.Cartesian3.distance(position, cameraPosition) < 200000) {
          return true
        }
        if (Cesium__namespace.Cartesian3.distance(position, center) < 200000) {
          return true
        }
      }
      return false
    }
  }

  var GlobeFlodByMaterial = "uniform vec4 u_mars_flood_val;//（基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)）\nuniform vec4 u_mars_flood_color;\n\nczm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  material.alpha = (materialInput.height < u_mars_flood_val.y) ? u_mars_flood_color.a : 0.0;\n  material.diffuse = u_mars_flood_color.rgb;\n  return material;\n}\n"; // eslint-disable-line

  const FloodByMaterialType = "FlodByMaterial";

  /**
   * @typedef {Object} FloodByMaterial.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} start 开始分析
   * @property {String} change 变化了
   * @property {String} end  完成分析
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.end, function (event) {
   *   console.log('分析完成', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 淹没分析 ，
   * 基于地球材质，可以多个区域
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]} [options.positions] 坐标位置数组，只显示单个区域【单个区域场景时使用】
   * @param {Number} [options.speed] 淹没速度
   * @param {Cesium.Color|String} [options.color=new Cesium.Color(0.15, 0.7, 0.95, 0.5)] 淹没颜色
   * @param {Number} [options.minHeight] 淹没起始的海拔高度（单位：米）
   * @param {Number} [options.maxHeight] 淹没结束的海拔高度（单位：米）
   * @param {Boolean} [options.showElseArea = true] 是否显示区域外的地图
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class FloodByMaterial
   * @extends {TerrainEditBase}
   * @see [支持的事件类型]{@link FloodByMaterial.EventType}
   */
  class FloodByMaterial extends TerrainEditBase {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      this.color = this.options.color ?? new Cesium__namespace.Color(0.15, 0.7, 0.95, 0.5);
    }

    /**
     * 淹没高度（单位：米）
     * @type {Number}
     */
    get height() {
      return this.heightVal.y ?? this.minHeight
    }

    set height(val) {
      this.heightVal.y = val;
      this.analysisOptions.heightVal.y = val;
    }

    /**
     * 淹没速度
     * @type {Number}
     */
    get speed() {
      return this.options.speed || 1
    }

    set speed(val) {
      this.options.speed = Number(val);
    }

    /**
     * 淹没颜色
     * @type {Cesium.Color}
     */
    get color() {
      return this._color
    }

    set color(val) {
      this._color = getCesiumColor(val);

      if (this.analysisOptions) {
        this.analysisOptions.color = this._color;
      }
    }

    //= ========= 方法 ==========

    /**
     * 重新赋值参数，同构造方法参数一致。
     * @param {Object} options 参数,与类的构造方法参数相同
     * @return {FloodByMaterial} 当前对象本身，可以链式调用
     */
    setOptions(options) {
      if (options) {
        this.options = {
          ...this.options,
          ...options
        };
      }
      this.stop();

      let minHeight = this.options.minHeight;
      let maxHeight = this.options.maxHeight;

      // 检查参数
      if (!Cesium__namespace.defined(minHeight)) {
        logError("minHeight 请传入有效数值！", minHeight);
        return
      }
      if (!Cesium__namespace.defined(maxHeight)) {
        logError("maxHeight 请传入有效数值！", maxHeight);
        return
      }
      if (minHeight > maxHeight) {
        // 互相交换数据
        const temp = minHeight;
        minHeight = maxHeight;
        maxHeight = temp;
      }
      this.minHeight = minHeight;
      this.maxHeight = maxHeight;

      // 设置淹没高度
      this._setFloodVar();

      // 开始淹没
      this.analysisOptions.heightVal.x = this.heightVal.x;
      this.analysisOptions.heightVal.y = this.heightVal.y;
      this.analysisOptions.color = this.color;
      this.analysisOptions.globe = false;
      this.analysisOptions.showElseArea = this.options.showElseArea ?? true;

      this._map.scene.globe.material = Cesium__namespace.Material.fromType(FloodByMaterialType);

      return this
    }

    _enabledHook(val) {
      super._enabledHook(val);

      if (val) {
        this._map.scene.globe.material = Cesium__namespace.Material.fromType(FloodByMaterialType);
      } else {
        this._map.scene.globe.material = null;
      }
    }

    /**
     * 开始播放淹没动画效果
     * @return {void}  无
     */
    start() {
      this.stop();

      this.isStart = true;
      this.fire(EventType.start);

      this._map.on(EventType.clockTick, this._onClockTickHandler, this);
    }

    _onClockTickHandler(event) {
      this.heightVal.y += this.speed / 50; // 50帧每秒

      if (this.heightVal.y > this.heightVal.z) {
        this.heightVal.y = this.heightVal.z;
        this.stop();
        return
      }
      if (this.heightVal.y < this.heightVal.x) {
        this.heightVal.y = this.heightVal.x;
        this.stop();
        return
      }

      this.analysisOptions.heightVal.y = this.heightVal.y;

      this.fire(EventType.change, {
        height: this.heightVal.y
      });
    }

    /**
     * 暂停播放淹没动画效果
     * @return {void}  无
     */
    stop() {
      if (!this.isStart) {
        return
      }

      this._map.off(EventType.clockTick, this._onClockTickHandler, this);

      this.isStart = false;
      this.fire(EventType.end);
    }

    /**
     * 重新开始播放淹没动画效果
     * @return {void}  无
     */
    restart() {
      this.setOptions();
      this.start();
    }

    /**
     * 清除分析
     * @return {void}  无
     */
    clear() {
      this.stop();
      super.clear();
    }
  }

  Cesium__namespace.Material.FloodByMaterialType = FloodByMaterialType;
  Cesium__namespace.Material._materialCache.addMaterial(FloodByMaterialType, {
    fabric: {
      type: FloodByMaterialType,
      source: GlobeFlodByMaterial
    },
    translucent: false
  });

  var GlobeTerrainClipMaterial = "czm_material czm_getMaterial(czm_materialInput materialInput) {\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  return material;\n}\n"; // eslint-disable-line

  const TerrainClipType = "TerrainClip";

  /**
   * 地形开挖，
   * 基于地球材质，可以多个区域开挖。
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]} [options.positions] 坐标位置数组，只显示单个区域【单个区域场景时使用】
   * @param {Boolean} [options.clipOutSide = false] 是否外切开挖
   * @param {String} [options.image]  开挖区域的井墙面贴图URL。未传入该值时，不显示开挖区域的井。
   * @param {String} [options.imageBottom] 当显示开挖区域的井时，井底面贴图URL
   * @param {Number} [options.diffHeight]  当显示开挖区域的井时，设置所有区域的挖掘深度（单位：米）
   * @param {Number} [options.splitNum = 30] 当显示开挖区域的井时，井墙面每两点之间插值个数
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class TerrainClip
   * @extends {TerrainEditBase}
   */
  class TerrainClip extends TerrainEditBase {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      options.dynamicView = options.dynamicView ?? true;
      super(options);

      this._clipOutSide = options.clipOutSide ?? false;
    }

    //= ========= 对外属性 ==========
    // 分析参数
    get analysisOptions() {
      return this._map?.scene?.globe?._surface?.tileProvider?.marsOptions?.clip
    }

    /**
     * 是否外切开挖
     * @type {Boolean}
     */
    get clipOutSide() {
      return this.analysisOptions?.clipOutSide
    }

    set clipOutSide(val) {
      this._map.scene.globe.material = null; // 此代码如果没有，需要缩放地球才生效

      this.analysisOptions.clipOutSide = val;

      this._map.scene.globe.material = Cesium__namespace.Material.fromType(TerrainClipType); // 恢复材质
    }

    /**
     * 设置所有区域的挖掘深度（单位：米）
     * @type {Number}
     */
    get diffHeight() {
      return this.options.diffHeight
    }

    set diffHeight(val) {
      this.options.diffHeight = val;

      if (this._graphicLayer) {
        this._graphicLayer.eachGraphic((pitPrimitive) => {
          pitPrimitive.diffHeight = val;
        });
      }
    }

    //= ========= 方法 ==========
    _enabledHook(val) {
      this.analysisOptions.enabled = val;

      if (this._graphicLayer) {
        this._graphicLayer.show = val;
      }

      if (val) {
        this._map.scene.globe.material = Cesium__namespace.Material.fromType(TerrainClipType);
      } else {
        this._map.scene.globe.material = null;
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      if (!this._map.scene.highDynamicRange) {
        this._map.scene.highDynamicRange = true;
        this._hasChangeHighDynamicRange = true;
      }
      if (!this._map.scene.globe.depthTestAgainstTerrain) {
        this._map.scene.globe.depthTestAgainstTerrain = true;
        this._hasChangeDepthTestAgainstTerrain = true;
      }

      // 开挖对应的井对象
      this._graphicLayer = new GraphicLayer({
        ...this.options,
        private: true
      });
      this._map.addLayer(this._graphicLayer);

      super._addedHook();
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.clear();

      this.analysisOptions.enabled = false;
      this.analysisOptions.inverMatrix = Cesium__namespace.Matrix4.IDENTITY;
      this.analysisOptions.polygonTexture = undefined;

      // 开挖对应的井对象
      this._map.removeLayer(this._graphicLayer);
      delete this._graphicLayer;

      if (this._hasChangeHighDynamicRange) {
        this._map.scene.highDynamicRange = false;
        this._hasChangeHighDynamicRange = false;
      }
      if (this._hasChangeDepthTestAgainstTerrain) {
        this._map.scene.globe.depthTestAgainstTerrain = false;
        this._hasChangeDepthTestAgainstTerrain = false;
      }
    }

    /**
     * 清除开挖
     * @return {void}  无
     */
    clear() {
      super.clear();
      this._graphicLayer.clear();
    }

    // 添加区域后的钩子方法
    _addAreaHook(areaObj, options) {
      if (this.options.image) {
        areaObj.pitPrimitive = new Pit({
          style: {
            ...this.options,
            ...options
          },
          positions: areaObj.positions_original
        });
        this._graphicLayer.addGraphic(areaObj.pitPrimitive);
      }
    }

    // 移除单个区域后的钩子方法
    _removeAreaHook(areaObj) {
      if (areaObj?.pitPrimitive) {
        this._graphicLayer.removeGraphic(areaObj.pitPrimitive, true);
        delete areaObj.pitPrimitive;
      }
    }

    _beginAnalysis() {
      this.analysisOptions.enabled = true;
      this.analysisOptions.inverMatrix = this._inverMatrix;
      this.analysisOptions.polygonTexture = this._polygonTexture;
      this.analysisOptions.tailorRect = this._tailorRect;
    }
  }

  // 地形开挖 Globe 材质
  Cesium__namespace.Material.TerrainClipType = TerrainClipType;
  Cesium__namespace.Material._materialCache.addMaterial(TerrainClipType, {
    fabric: {
      type: TerrainClipType,
      source: GlobeTerrainClipMaterial
    },
    translucent: false
  });

  /**
   * 等高线
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]} [options.positions] 坐标位置数组，只显示单个区域【单个区域场景时使用】
   * @param {Boolean} [options.contourShow = true] 是否显示等高线
   * @param {Number} [options.spacing = 100.0] 等高线 间隔（单位：米）
   * @param {Number} [options.width = 1.5] 等高线 线宽（单位：像素）
   * @param {Cesium.Color|String} [options.color = Cesium.Color.RED] 等高线 颜色
   * @param {String} [options.shadingType = 'none'] 地表渲染效果，可选值: 无none, 高程 elevation, 坡度slope, 坡向aspect
   * @param {Number} [options.shadingAlpha = 0.6] 地表渲染透明度，0.0-1.0
   * @param {Object} [options.colorScheme ] 地表渲染配色方案,默认值为：
   * {
        elevation: {
          step: [0.0, 0.045, 0.1, 0.15, 0.37, 0.54, 1.0],
          color: ['#000000', '#2747E0', '#D33B7D', '#D33038', '#FF9742', '#FF9742', '#ffd700'],
        },
        slope: {
          step: [0.0, 0.29, 0.5, Math.sqrt(2) / 2, 0.87, 0.91, 1.0],
          color: ['#000000', '#2747E0', '#D33B7D', '#D33038', '#FF9742', '#FF9742', '#ffd700'],
        },
        aspect: {
          step: [0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0],
          color: ['#000000', '#2747E0', '#D33B7D', '#D33038', '#FF9742', '#FF9742', '#ffd700'],
        },
     }
   * @param {Boolean} [options.showElseArea = true] 是否显示区域外的地图
   * @param {Number} [options.minHeight = -414.0] 地表渲染配色方案中的 最低海拔高度
   * @param {Number} [options.maxHeight = 8777] 地表渲染配色方案中的 最高海拔高度
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class ContourLine
   * @extends {TerrainEditBase}
   */
  class ContourLine extends TerrainEditBase {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      this._contourShow = options.contourShow ?? true;
      this._contourSpacing = options.spacing ?? 100.0;
      this._contourWidth = options.width ?? 1.5;
      this._contourColor = getCesiumColor(options.color, Cesium__namespace.Color.RED);

      this._shadingType = options.shadingType ?? "none";
      this._shadingAlpha = options.shadingAlpha ?? 0.6;

      // 配色方案
      this.colorScheme = options.colorScheme || {
        elevation: {
          step: [0.0, 0.045, 0.1, 0.15, 0.37, 0.54, 1.0],
          color: ["#000000", "#2747E0", "#D33B7D", "#D33038", "#FF9742", "#FF9742", "#ffd700"]
        },
        slope: {
          step: [0.0, 0.29, 0.5, Math.sqrt(2) / 2, 0.87, 0.91, 1.0],
          color: ["#000000", "#2747E0", "#D33B7D", "#D33038", "#FF9742", "#FF9742", "#ffd700"]
        },
        aspect: {
          step: [0.0, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0],
          color: ["#000000", "#2747E0", "#D33B7D", "#D33038", "#FF9742", "#FF9742", "#ffd700"]
        }
      };

      this.minHeight = options.minHeight ?? -414.0; // approximate dead sea elevation
      this.maxHeight = options.maxHeight ?? 8777.0; // approximate everest elevation
    }

    //= ========= 对外属性 ==========

    /**
     * 是否显示等高线
     * @type {Boolean}
     */
    get contourShow() {
      return this._contourShow
    }

    set contourShow(val) {
      this._contourShow = val;
      this.updateMaterial();
    }

    /**
     * 地表渲染效果，可选值: 无none, 高程 elevation, 坡度slope, 坡向aspect
     * @type {String}
     */
    get shadingType() {
      return this._shadingType
    }

    set shadingType(val) {
      this._shadingType = val;
      this.updateMaterial();
    }

    /**
     * 地表渲染透明度，0.0-1.0
     * @type {Number}
     */
    get shadingAlpha() {
      return this._shadingAlpha
    }

    set shadingAlpha(val) {
      this._shadingAlpha = val;
      this.updateMaterial();
    }

    /**
     * 等高线 线宽（单位：像素）
     * @type {Number}
     */
    get width() {
      return this._contourWidth
    }

    set width(val) {
      this._contourWidth = val;
      if (this.contourUniforms) {
        this.contourUniforms.width = val;
      }
    }

    /**
     * 等高线 间隔（单位：米）
     * @type {Number}
     */
    get spacing() {
      return this._contourSpacing
    }

    set spacing(val) {
      this._contourSpacing = val;
      if (this.contourUniforms) {
        this.contourUniforms.spacing = val;
      }
    }

    /**
     * 等高线 颜色
     * @type {Cesium.Color|String}
     */
    get color() {
      return this._contourColor
    }

    set color(val) {
      this._contourColor = getCesiumColor(val);
      if (this.contourUniforms) {
        this.contourUniforms.color = val;
      }
    }

    //= ========= 方法 ==========
    _enabledHook(val) {
      super._enabledHook(val);

      this.updateMaterial();
    }

    /**
     * 清除数据
     * @return {void}  无
     */
    clear() {
      super.clear();

      this._map.scene.globe.material = null;
      this.contourUniforms = null;

      if (this._hasResetEnableLighting) {
        this._map.scene.globe.enableLighting = false;
        this._map.clock.currentTime = Cesium__namespace.JulianDate.now();
        delete this._hasResetEnableLighting;
      }
    }

    // 添加区域后的钩子方法
    _addAreaHook() {
      this._setFloodVar();
      this.updateMaterial();
    }

    //= ========地球渲染材质相关==========
    updateMaterial() {
      let material;
      let contourUniforms;
      let shadingUniforms;

      const _shadingType = this._shadingType;
      if (this.contourShow) {
        if (_shadingType === "elevation") {
          material = this.getElevationContourMaterial();
          shadingUniforms = material.materials.elevationRampMaterial.uniforms;
          shadingUniforms.minimumHeight = this.minHeight;
          shadingUniforms.maximumHeight = this.maxHeight;
          contourUniforms = material.materials.contourMaterial.uniforms;
        } else if (_shadingType === "slope") {
          material = this.getSlopeContourMaterial();
          shadingUniforms = material.materials.slopeRampMaterial.uniforms;
          contourUniforms = material.materials.contourMaterial.uniforms;
        } else if (_shadingType === "aspect") {
          material = this.getAspectContourMaterial();
          shadingUniforms = material.materials.aspectRampMaterial.uniforms;
          contourUniforms = material.materials.contourMaterial.uniforms;
        } else {
          material = Cesium__namespace.Material.fromType("ElevationContour");
          contourUniforms = material.uniforms;
        }
        contourUniforms.width = this._contourWidth;
        contourUniforms.spacing = this._contourSpacing;
        contourUniforms.color = this._contourColor;
      } else if (_shadingType === "elevation") {
        material = Cesium__namespace.Material.fromType("ElevationRamp");
        shadingUniforms = material.uniforms;
        shadingUniforms.minimumHeight = this.minHeight;
        shadingUniforms.maximumHeight = this.maxHeight;
      } else if (_shadingType === "slope") {
        material = Cesium__namespace.Material.fromType("SlopeRamp");
        shadingUniforms = material.uniforms;
      } else if (_shadingType === "aspect") {
        material = Cesium__namespace.Material.fromType("AspectRamp");
        shadingUniforms = material.uniforms;
      }
      if (_shadingType !== "none") {
        shadingUniforms.image = this.getColorRamp(_shadingType);
      }

      if (_shadingType === "slope" || _shadingType === "aspect") {
        if (!this._map.scene.globe.enableLighting) {
          this._map.scene.globe.enableLighting = true;
          const now = new Date();
          now.setHours(10);
          this._map.clock.currentTime = Cesium__namespace.JulianDate.fromDate(new Date(now));
          this._hasResetEnableLighting = true;
        }
      } else if (this._hasResetEnableLighting) {
        this._map.scene.globe.enableLighting = false;
        this._map.clock.currentTime = Cesium__namespace.JulianDate.now();
        delete this._hasResetEnableLighting;
      }

      this.contourUniforms = contourUniforms;
      this._map.scene.globe.material = material;
    }

    getColorRamp(_shadingType) {
      const ramp = document.createElement("canvas");
      ramp.width = 100;
      ramp.height = 1;

      const ctx = ramp.getContext("2d");
      ctx.globalAlpha = this.shadingAlpha;

      const grd = ctx.createLinearGradient(0, 0, 100, 0);

      const colorScheme = this.colorScheme[_shadingType];
      if (colorScheme?.step?.length > 0) {
        for (let i = 0, len = colorScheme.step.length; i < len; i++) {
          grd.addColorStop(colorScheme.step[i], colorScheme.color[i]);
        }
      }

      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, 100, 1);

      return ramp
    }

    getElevationContourMaterial() {
      // Creates a composite material with both elevation shading and contour lines
      return new Cesium__namespace.Material({
        fabric: {
          type: "ElevationColorContour",
          materials: {
            contourMaterial: {
              type: "ElevationContour"
            },
            elevationRampMaterial: {
              type: "ElevationRamp"
            }
          },
          components: {
            diffuse: "contourMaterial.alpha == 0.0 ? elevationRampMaterial.diffuse : contourMaterial.diffuse",
            alpha: "max(contourMaterial.alpha, elevationRampMaterial.alpha)"
          }
        },
        translucent: false
      })
    }

    getSlopeContourMaterial() {
      // Creates a composite material with both slope shading and contour lines
      return new Cesium__namespace.Material({
        fabric: {
          type: "SlopeColorContour",
          materials: {
            contourMaterial: {
              type: "ElevationContour"
            },
            slopeRampMaterial: {
              type: "SlopeRamp"
            }
          },
          components: {
            diffuse: "contourMaterial.alpha == 0.0 ? slopeRampMaterial.diffuse : contourMaterial.diffuse",
            alpha: "max(contourMaterial.alpha, slopeRampMaterial.alpha)"
          }
        },
        translucent: false
      })
    }

    getAspectContourMaterial() {
      // Creates a composite material with both aspect shading and contour lines
      return new Cesium__namespace.Material({
        fabric: {
          type: "AspectColorContour",
          materials: {
            contourMaterial: {
              type: "ElevationContour"
            },
            aspectRampMaterial: {
              type: "AspectRamp"
            }
          },
          components: {
            diffuse: "contourMaterial.alpha == 0.0 ? aspectRampMaterial.diffuse : contourMaterial.diffuse",
            alpha: "max(contourMaterial.alpha, aspectRampMaterial.alpha)"
          }
        },
        translucent: false
      })
    }
  }

  /**
   * 限高分析
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]} [options.positions] 限高区域坐标数组
   * @param {Number} [options.height] 限高高度（单位米）,相对于bottomHeight模型地面的海拔高度的相对高度。
   * @param {Number} [options.bottomHeight] 模型地面的海拔高度（单位米）
   * @param {String|Cesium.Color} [options.color = "#3388ff"] 颜色
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class LimitHeight
   * @extends {BaseThing}
   */
  class LimitHeight extends BaseThing {
    /**
     * 矢量数据图层
     * @type {GraphicLayer}
     * @readonly
     */
    get layer() {
      return this._layer
    }

    /**
     * 分析区域坐标数组
     * @type {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]}
     */
    get positions() {
      return this.options.positions
    }

    set positions(val) {
      this.options.positions = val;
      this._createGraphic();
    }

    /**
     * 限高高度（单位米）,相对于bottomHeight模型地面的海拔高度的相对高度。
     * @type {Number}
     */
    get height() {
      return this.options.height || 0
    }

    set height(val) {
      this.options.height = val;
      this._createGraphic();
    }

    /**
     * 模型地面的海拔高度（单位：米）
     * @type {Number}
     */
    get bottomHeight() {
      return this.options.bottomHeight || 0
    }

    set bottomHeight(val) {
      this.options.bottomHeight = val;
      this._createGraphic();
    }

    //= ========= 方法 ==========
    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._layer = new GraphicLayer({
        private: true
      });
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.addLayer(this._layer);
      if (this.options.positions) {
        this.positions = this.options.positions;
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this._graphic) {
        this._layer.removeGraphic(this._graphic);
        delete this._graphic;
      }
      this._map.removeLayer(this._layer);
    }

    //
    _createGraphic() {
      if (this._graphic) {
        this._layer.removeGraphic(this._graphic);
        delete this._graphic;
      }

      if (!this.options.positions) {
        return
      }

      const positions = LngLatArray.toCartesians(this.options.positions);

      this._graphic = new PolygonPrimitive({
        positions: positions,
        style: {
          ...this.options,
          height: this.bottomHeight + this.height,
          diffHeight: 10000,
          perPositionHeight: false,
          classification: true,
          classificationType: Cesium__namespace.ClassificationType.CESIUM_3D_TILE
        },
        asynchronous: false
      });
      this._layer.addGraphic(this._graphic);
    }

    /**
     *  清除限高分析
     * @return {void}  无
     */
    clear() {
      this.options.positions = null;
      if (this._graphic) {
        this._layer.removeGraphic(this._graphic);
        delete this._graphic;
      }
    }
  }

  /**
   * Gltf模型剖切，
   * 基于clippingPlanes接口，只支持单个开挖。
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {ModelEntity} options.graphic 需要裁剪的对象（gltf模型）
   * @param {Array[]|String[]|LngLatPoint[]|Cesium.Cartesian3[]} [options.positions] 裁剪区域坐标数组(按面或线裁剪)
   * @param {Number} [options.height] 当有裁剪区域挖时，底面的高度（单位米），未设置时不显示底面。
   *
   * @param {ClipType} [options.type]  裁剪类型（按方向类型正方向单面裁剪）
   * @param {Number} [options.distance=0] 裁剪的距离
   *
   * @param {Boolean} [options.clipOutSide = false] 是否外裁剪
   * @param {Number} [options.edgeWidth=0] 裁剪区域边线宽度，0时不显示
   * @param {Cesium.Color} [options.edgeColor=Cesium.Color.WHITE] 裁剪区域边线颜色
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class ModelPlanClip
   * @extends {TilesetPlanClip}
   */
  class ModelPlanClip extends TilesetPlanClip {
    //= ========= 对外属性 ==========
    /**
     * 裁剪的对象模型 对应的Entity对象
     * @type {Cesium.Entity}
     * @private
     */
    get clipTarget() {
      return this._model
    }

    set clipTarget(val) {
      this._model = val;
      this._inverseMatrix = null;

      if (this.clippingPlanes) {
        this._model.clippingPlanes = this.clippingPlanes;
      }
    }

    /**
     * 需要裁剪的对象（gltf模型）
     * @type {ModelEntity}
     */
    get graphic() {
      return this._graphic
    }

    set graphic(value) {
      this._graphic = value;

      if (value.entity) {
        this._model = value.entity.model;
        this._modelMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(getPositionValue(value.position));
      } else if (value instanceof Cesium__namespace.Entity) {
        this._model = value.model;
        this._modelMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(getPositionValue(value.position));
      } else if (value.primitive) {
        this._model = value.primitive;
        this._modelMatrix = value.modelMatrix;
      } else if (value instanceof Cesium__namespace.Model) {
        this._model = value;
        this._modelMatrix = value.modelMatrix;
      }
    }

    /**
     * 获取当前转换计算模型逆矩阵，
     * 用于 局部坐标系 与 世界坐标系 的转换。
     * @type {Cesium.Matrix4}
     * @readonly
     */
    get inverseMatrix() {
      if (!this._inverseMatrix && this._modelMatrix) {
        this._inverseMatrix = Cesium__namespace.Matrix4.inverseTransformation(this._modelMatrix, new Cesium__namespace.Matrix4());
      }
      return this._inverseMatrix
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      if (this.options.graphic) {
        this.graphic = this.options.graphic; // mars3d.graphic.ModelEntity时
      }
    }
  }
  /**
   * 裁剪模型 类型 枚举 同{@link ClipType}
   * @enum {Number}
   */
  ModelPlanClip.Type = ClipType;

  /**
   * 3dtiles模型box盒子裁剪，
   * 基于clippingPlanes接口，只支持单个开挖。
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {TilesetLayer} options.layer 需要裁剪的对象（3dtiles图层）
   *
   * @param {LngLatPoint|Cesium.Cartesian3} options.position 裁剪盒子中心坐标位置
   * @param {Cesium.Cartesian3} options.dimensions 裁剪盒子区域的长度、宽度和高度
   * @param {Boolean} [options.showBox = false] 是否显示box盒子
   * @param {BoxEntity.StyleOptions} [options.boxStyle] box盒子显示时的样式
   *
   * @param {Boolean} [options.clipOutSide = false] 是否外裁剪
   * @param {Number} [options.edgeWidth=0] 裁剪区域边线宽度，0时不显示
   * @param {Cesium.Color} [options.edgeColor=Cesium.Color.WHITE] 裁剪区域边线颜色
   *
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class TilesetBoxClip
   * @extends {BaseThing}
   */
  class TilesetBoxClip extends BaseThing {
    /**
     * 裁剪的对象模型 对应的 Cesium3DTileset 对象
     * @type {Cesium.Cesium3DTileset}
     * @private
     */
    get clipTarget() {
      return this._tileset
    }

    set clipTarget(val) {
      this._tileset = val;
      this._inverseMatrix = null;

      if (Cesium__namespace.defined(this.options.position)) {
        this.position = this.options.position;
      }
    }

    /**
     * 需要裁剪的对象（3dtiles图层）
     * @type {TilesetLayer}
     */
    get layer() {
      return this._layer
    }

    set layer(tilesetLayer) {
      this._layer = tilesetLayer;

      if (tilesetLayer.loadOk) {
        this.clipTarget = tilesetLayer.tileset;
      } else {
        tilesetLayer.on(EventType.load, (e) => {
          this.clipTarget = tilesetLayer.tileset;
        });
      }
    }

    /**
     * 裁剪面集合
     * @type {Cesium.ClippingPlaneCollection}
     * @readonly
     */
    get planes() {
      return this.clippingPlanes
    }

    /**
     * 获取当前转换计算模型逆矩阵，
     * 用于 局部坐标系 与 世界坐标系 的转换。
     * @type {Cesium.Matrix4}
     * @readonly
     */
    get inverseMatrix() {
      if (!this._inverseMatrix) {
        let transform;
        const tmp = this._tileset.root.transform;
        if ((tmp && tmp.equals(Cesium__namespace.Matrix4.IDENTITY)) || !tmp) {
          // 如果root.transform不存在，则3DTiles的原点变成了boundingSphere.center
          transform = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(this._tileset.boundingSphere.center);
        } else {
          transform = Cesium__namespace.Matrix4.fromArray(this._tileset.root.transform);
        }
        this._inverseMatrix = Cesium__namespace.Matrix4.inverseTransformation(transform, new Cesium__namespace.Matrix4());
      }
      return this._inverseMatrix
    }

    /**
     * 模型当前中心点坐标
     * @type {Cesium.Cartesian3}
     * @readonly
     */
    get center() {
      if (this._layer) {
        return this._layer.position
      }
      return this._tileset.boundingSphere.center
    }

    /**
     * 裁剪box中心点坐标
     * @type {Number[]|LngLatPoint|Cesium.Cartesian3}
     */
    get position() {
      return this._position
    }

    set position(val) {
      this._position = LngLatPoint.toCartesian(val);
      this.redraw();
    }

    /**
     * 裁剪box的长宽高
     * @type {Cesium.Cartesian3}
     */
    get dimensions() {
      return this.options.dimensions
    }

    set dimensions(val) {
      this.options.dimensions = val;
      this.redraw();
    }

    /**
     * 是否显示box盒子
     * @type {Boolean}
     */
    get showBox() {
      return this.options.showBox
    }

    set showBox(val) {
      this.options.showBox = val;

      if (this.options.showBox) {
        if (!this._graphicLayer) {
          this._graphicLayer = new GraphicLayer({
            ...this.options,
            private: true
          });
        }
        this._graphicLayer.show = true;
      } else {
        if (this._graphicLayer) {
          this._graphicLayer.show = false;
        }
      }
      this.redraw();
    }

    //= ========= 方法 ==========

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      if (this.options.showBox) {
        this._graphicLayer = new GraphicLayer({
          ...this.options,
          private: true
        });
      }

      if (this.options.layer) {
        this.layer = this.options.layer; // mars3d.layer.TilesetLayer 时
      } else if (this.options.tileset) {
        this.clipTarget = this.options.tileset; // Cesium.Cesium3DTileset 时
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      if (this._graphicLayer) {
        this._map.addLayer(this._graphicLayer);
      }

      if (this.clipTarget) {
        if (Cesium__namespace.defined(this.options.position)) {
          this.position = this.options.position;
        }
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.clear();

      if (this._graphicLayer) {
        this._map.removeLayer(this._graphicLayer);
      }
    }

    /**
     * 重新绘制
     * @return {void}  无
     * @memberof TilesetBoxClip
     */
    redraw() {
      if (!this.position || !this.dimensions) {
        return
      }

      const x = this.dimensions.x / 2;
      const y = this.dimensions.y / 2;
      const z = this.dimensions.z / 2;

      // 记录差值
      const inverseMatrix = this.inverseMatrix;
      const p1C3 = Cesium__namespace.Matrix4.multiplyByPoint(inverseMatrix, this.center, new Cesium__namespace.Cartesian3());
      const p2C3 = Cesium__namespace.Matrix4.multiplyByPoint(inverseMatrix, this.position, new Cesium__namespace.Cartesian3());
      const offx = p1C3.x - p2C3.x;
      const offy = p1C3.y - p2C3.y;
      const offz = p1C3.z - p2C3.z;

      const planes = [
        new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(0, 0, 1), -z + offz), // 底部
        new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(0, 0, -1), -z - offz), // 顶部

        new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(1, 0, 0), -x + offx), // x垂直面
        new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(-1, 0, 0), -x - offx), // x垂直面

        new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(0, 1, 0), -y + offy), // y垂直面
        new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(0, -1, 0), -y - offy) // y垂直面
      ];

      const clippingPlanes = new Cesium__namespace.ClippingPlaneCollection({
        planes: planes,
        edgeWidth: this.options.edgeWidth ?? 0.0,
        edgeColor: this.options.edgeColor ?? Cesium__namespace.Color.WHITE,
        unionClippingRegions: this.options.clipOutSide ?? false
      });
      this.clippingPlanes = clippingPlanes;

      if (this.clipTarget) {
        this.clipTarget.clippingPlanes = clippingPlanes;
      }

      // 将绘制的裁剪平面绘制到场景中。
      if (this.options.showBox) {
        this._graphicLayer.clear();

        const graphic = new BoxEntity({
          position: this.position,
          style: {
            dimensions: this.options.dimensions,
            color: Cesium__namespace.Color.WHITE.withAlpha(0.2),
            ...(this.options.boxStyle || {})
          }
        });
        this._graphicLayer.addGraphic(graphic);
      }
    }

    /**
     *  清除裁剪面
     * @return {void}  无
     */
    clear() {
      if (this._graphicLayer) {
        this._graphicLayer.clear();
      }

      if (this.clippingPlanes) {
        delete this.clippingPlanes;
      }
      if (this.clipTarget?.clippingPlanes?.enabled) {
        this.clipTarget.clippingPlanes.enabled = false;
      }
      this.clipTarget.clippingPlanes = undefined;
    }
  }

  const scratchCurrentDirection = new Cesium__namespace.Cartesian3();
  const scratchDeltaPosition = new Cesium__namespace.Cartesian3();
  const scratchNextPosition = new Cesium__namespace.Cartesian3();
  const scratchTerrainConsideredNextPosition = new Cesium__namespace.Cartesian3();
  const scratchNextCartographic = new Cesium__namespace.Cartographic();

  const RoamType = {
    DIRECTION_NONE: 0,
    DIRECTION_FORWARD: 1,
    DIRECTION_BACKWARD: 2,
    DIRECTION_LEFT: 3,
    DIRECTION_RIGHT: 4
  };

  /**
   * 第一人称贴地漫游，
   * 键盘漫游时，先单击地图激活后 按 W前进、 S后退、A左移、D右移
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Number} [options.speed = 1.5] 速度
   * @param {Number} [options.rotateSpeed = -5] 旋转速度
   * @param {Number} [options.height = 10] 高度
   * @param {Number} [options.maxPitch = 88] 最大pitch角度（度数值）
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class FirstPersonRoam
   * @extends {BaseThing}
   */
  class FirstPersonRoam extends BaseThing {
    constructor(options = {}) {
      super(options);

      /**
       * 速度
       * @type {Number}
       */
      this.speed = this.options.speed ?? 1.5; // 速度

      /**
       * 旋转速度
       * @type {Number}
       */
      this.rotateSpeed = this.options.rotateSpeed ?? -5;

      /**
       * 高度（单位：米）
       * @type {Number}
       */
      this.height = this.options.height ?? 10;

      /**
       * 最大pitch角度（度数值）
       * @type {Number}
       */
      this.maxPitch = this.options.maxPitch ?? 88;
    }

    //= ========= 方法 ==========

    _enabledHook(val) {
      if (val) {
        this.activate();
      } else {
        this.disable();
      }
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {}

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      if (this.enabled) {
        this.activate();
      }

      this._map.on(EventType.leftDown, this._onLeftDownHandler, this);
      this._map.on(EventType.leftUp, this._onLeftUpHandler, this);
      this._map.on(EventType.mouseMove, this._onMouseMoveHandler, this);
      this._map.on(EventType.dblClick, this._onDbClickHandler, this);
      this._map.on(EventType.keydown, this._onKeyDown, this);
      this._map.on(EventType.keyup, this._onKeyUp, this);
      this._map.on(EventType.clockTick, this._onClockTick, this);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.disable();

      this._map.off(EventType.leftDown, this._onLeftDownHandler, this);
      this._map.off(EventType.leftUp, this._onLeftUpHandler, this);
      this._map.off(EventType.mouseMove, this._onMouseMoveHandler, this);
      this._map.off(EventType.dblClick, this._onDbClickHandler, this);
      this._map.off(EventType.keydown, this._onKeyDown, this);
      this._map.off(EventType.keyup, this._onKeyUp, this);
      this._map.off(EventType.clockTick, this._onClockTick, this);
    }

    _onLeftDownHandler(event) {
      if (!this.enabled) {
        return
      }
      this._looking = true;
      this._startMousePosition = Cesium__namespace.Cartesian3.clone(event.position);
      this._mousePosition = this._startMousePosition;
    }

    _onDbClickHandler(event) {
      if (!this.enabled) {
        return
      }
      this._looking = true;
      this._startMousePosition = Cesium__namespace.Cartesian3.clone(event.position);
      this._mousePosition = this._startMousePosition;
    }

    _onLeftUpHandler(event) {
      this._looking = false;
    }

    _onMouseMoveHandler(event) {
      this._mousePosition = event.endPosition;
    }

    _onKeyDown(event) {
      if (!this.enabled) {
        return
      }

      const keyCode = event.keyCode;
      this._direction = RoamType.DIRECTION_NONE;

      switch (keyCode) {
        case "W".charCodeAt(0):
          this._direction = RoamType.DIRECTION_FORWARD;
          break
        case "S".charCodeAt(0):
          this._direction = RoamType.DIRECTION_BACKWARD;
          break
        case "D".charCodeAt(0):
          this._direction = RoamType.DIRECTION_RIGHT;
          break
        case "A".charCodeAt(0):
          this._direction = RoamType.DIRECTION_LEFT;
          break
      }
    }

    _onKeyUp() {
      if (!this.enabled) {
        return
      }
      this._direction = RoamType.DIRECTION_NONE;
    }

    _onClockTick(clock) {
      if (!this.enabled) {
        return
      }

      const dt = clock._clockStep;

      if (this._looking) {
        this._changeHeadingPitch(dt);
      }

      if (this._direction === RoamType.DIRECTION_NONE) {
        return
      }

      const distance = this.speed * dt;

      if (this._direction === RoamType.DIRECTION_FORWARD) {
        Cesium__namespace.Cartesian3.multiplyByScalar(this._map.camera.direction, 1, scratchCurrentDirection);
      } else if (this._direction === RoamType.DIRECTION_BACKWARD) {
        Cesium__namespace.Cartesian3.multiplyByScalar(this._map.camera.direction, -1, scratchCurrentDirection);
      } else if (this._direction === RoamType.DIRECTION_LEFT) {
        Cesium__namespace.Cartesian3.multiplyByScalar(this._map.camera.right, -1, scratchCurrentDirection);
      } else if (this._direction === RoamType.DIRECTION_RIGHT) {
        Cesium__namespace.Cartesian3.multiplyByScalar(this._map.camera.right, 1, scratchCurrentDirection);
      }

      Cesium__namespace.Cartesian3.multiplyByScalar(scratchCurrentDirection, distance, scratchDeltaPosition);

      const currentCameraPosition = this._map.camera.position;

      Cesium__namespace.Cartesian3.add(currentCameraPosition, scratchDeltaPosition, scratchNextPosition);

      // consider terrain height

      const globe = this._map.scene.globe;
      const ellipsoid = globe.ellipsoid;

      // get height for next update position
      ellipsoid.cartesianToCartographic(scratchNextPosition, scratchNextCartographic);

      const height = globe.getHeight(scratchNextCartographic);

      if (height === undefined) {
        // console.warn('height is undefined!');
        return
      }

      scratchNextCartographic.height = height + this.height;

      ellipsoid.cartographicToCartesian(scratchNextCartographic, scratchTerrainConsideredNextPosition);

      this._map.camera.setView({
        destination: scratchTerrainConsideredNextPosition,
        orientation: new Cesium__namespace.HeadingPitchRoll(this._map.camera.heading, this._map.camera.pitch, this._map.camera.roll),
        endTransform: Cesium__namespace.Matrix4.IDENTITY
      });
    }

    _changeHeadingPitch(dt) {
      const width = this._map.canvas.clientWidth;
      const height = this._map.canvas.clientHeight;

      // Coordinate (0.0, 0.0) will be where the mouse was clicked.
      const deltaX = (this._mousePosition.x - this._startMousePosition.x) / width;
      const deltaY = -(this._mousePosition.y - this._startMousePosition.y) / height;

      const currentHeadingInDegree = Cesium__namespace.Math.toDegrees(this._map.camera.heading);
      const deltaHeadingInDegree = deltaX * this.rotateSpeed;
      const newHeadingInDegree = currentHeadingInDegree + deltaHeadingInDegree;

      const currentPitchInDegree = Cesium__namespace.Math.toDegrees(this._map.camera.pitch);
      const deltaPitchInDegree = deltaY * this.rotateSpeed;
      let newPitchInDegree = currentPitchInDegree + deltaPitchInDegree;

      // console.log("rotationSpeed: " + this.rotateSpeed + " deltaY: " + deltaY + " deltaPitchInDegree" + deltaPitchInDegree);

      if (newPitchInDegree > this.maxPitch * 2 && newPitchInDegree < 360 - this.maxPitch) {
        newPitchInDegree = 360 - this.maxPitch;
      } else {
        if (newPitchInDegree > this.maxPitch && newPitchInDegree < 360 - this.maxPitch) {
          newPitchInDegree = this.maxPitch;
        }
      }

      this._map.camera.setView({
        orientation: {
          heading: Cesium__namespace.Math.toRadians(newHeadingInDegree),
          pitch: Cesium__namespace.Math.toRadians(newPitchInDegree),
          roll: this._map.camera.roll
        }
      });
    }

    _enableScreenSpaceCameraController(enabled) {
      const scene = this._map.scene;
      scene.screenSpaceCameraController.enableRotate = enabled;
      scene.screenSpaceCameraController.enableTranslate = enabled;
      scene.screenSpaceCameraController.enableZoom = enabled;
      scene.screenSpaceCameraController.enableTilt = enabled;
      scene.screenSpaceCameraController.enableLook = enabled;
    }

    activate() {
      this._enabled = true;
      this._enableScreenSpaceCameraController(false);

      const currentCameraPosition = this._map.camera.position;
      const cartographic = new Cesium__namespace.Cartographic();
      const globe = this._map.scene.globe;

      globe.ellipsoid.cartesianToCartographic(currentCameraPosition, cartographic);

      const height = globe.getHeight(cartographic);

      if (height === undefined) {
        return false
      }

      cartographic.height = height + this.height;

      const newCameraPosition = new Cesium__namespace.Cartesian3();

      globe.ellipsoid.cartographicToCartesian(cartographic, newCameraPosition);

      const currentCameraHeading = this._map.camera.heading;
      this._heading = currentCameraHeading;
      this._map.camera.flyTo({
        destination: newCameraPosition,
        orientation: {
          heading: currentCameraHeading,
          pitch: Cesium__namespace.Math.toRadians(0),
          roll: 0.0
        }
      });

      return true
    }

    disable() {
      this._enabled = false;
      this._enableScreenSpaceCameraController(true);
    }

    /**
     * 开始自动前进漫游
     * @return {void}  无
     */
    startAutoForward() {
      if (!this.enabled) {
        this.activate();
      }
      this._direction = RoamType.DIRECTION_FORWARD;
    }

    /**
     * 停止自动前进漫游
     * @return {void}  无
     */
    stopAutoForward() {
      this._direction = RoamType.DIRECTION_NONE;
    }
  }

  /**
   * @typedef {Object} RotatePoint.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} start 开始旋转
   * @property {String} change 变化了角度
   * @property {String} stop 停止了旋转
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.stop, function (event) {
   *   console.log('停止了旋转', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 相机绕 固定中心点 旋转
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.direction=false] 旋转方向, true逆时针，false顺时针
   * @param {Number} [options.time=60] 飞行一周所需时间(单位 秒)，控制速度
   * @param {Number} [options.autoStopAngle]  自动停止的角度值（0-360度），未设置时不自动停止
   * @param {Number} [options.distance] 可以指定旋转时相机到中心点的距离，默认不改变相对距离。
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class RotatePoint
   * @extends {BaseThing}
   * @see [支持的事件类型]{@link RotatePoint.EventType}
   */
  class RotatePoint extends BaseThing {
    constructor(options = {}) {
      super(options);

      this._direction = this.options.direction ? 1 : -1;
      this._angle = 360 / (60 * (this.options.time || 60));
      this._autoStopAngle = this.options.autoStopAngle;
    }

    /**
     * 是否在旋转中
     * @type {Boolean}
     * @readonly
     */
    get isStart() {
      return this._isStart
    }

    //= ========= 方法 ==========
    _enabledHook(val) {
      if (val) {
        this.start();
      } else {
        this.stop();
      }
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {}

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.on(EventType.mouseDown, this._map_mouseDownHandler, this);
      this._map.on(EventType.mouseUp, this._map_mouseUpHandler, this);
      this._mouseDown = false;
    }

    _map_mouseDownHandler(event) {
      this._mouseDown = true;
    }

    _map_mouseUpHandler(event) {
      this._mouseDown = false;

      const center = this._map.getCenter();
      if (!center || center.alt > 500000) {
        return
      }

      this._tikRender = 0;
      this._center = center.toCartesian();
      this._startHeading = this._map.camera.heading; // 相机的当前heading
      this._startPitch = this._map.camera.pitch;
      this._distance = Cesium__namespace.Cartesian3.distance(this._center, this._map.camera.positionWC); // 给定相机距离点多少距离飞行
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.off(EventType.mouseDown, this._map_mouseDownHandler, this);
      this._map.off(EventType.mouseUp, this._map_mouseUpHandler, this);
      this.stop();
    }

    /**
     * 开始旋转
     * @param {LngLatPoint|Cesium.Cartesian3|Number[]} [point] 旋转的中心点
     * @return {void}  无
     */
    start(point) {
      if (this._isStart) {
        this.stop();
      }
      this._isStart = true;

      const _mapcenter = this._map.getCenter()?.toCartesian();

      if (!point) {
        this._center = _mapcenter;
      } else if (point instanceof Cesium__namespace.Cartesian3) {
        this._center = point;
      } else {
        this._center = LngLatPoint.parse(point).toCartesian();
      }

      this._distance = this.options.distance || Cesium__namespace.Cartesian3.distance(this._center, this._map.camera.positionWC); // 给定相机距离点多少距离飞行

      this._startHeading = this._map.camera.heading; // 相机的当前heading
      this._startPitch = this._map.camera.pitch;

      let duration = 2;
      if (Cesium__namespace.Cartesian3.distance(_mapcenter, this._center) < this._distance * 0.01) {
        duration = 0;
      }

      this.fire(EventType.start);
      this._map.flyToPoint(this._center, {
        radius: this._distance,
        duration: duration,
        complete: (e) => {
          this._isStart = true;
          this._tikRender = 0;
          this._map.on(EventType.preRender, this._onPreRenderHandler, this);
        }
      });
    }

    _onPreRenderHandler(event) {
      if (this._mouseDown) {
        return
      }
      this._tikRender++;

      const angle = this._tikRender * this._angle;
      if (this._autoStopAngle && angle >= this._autoStopAngle) {
        this.stop();
      }

      const heading = Cesium__namespace.Math.toRadians(angle * this._direction) + this._startHeading;

      this._map.scene.camera.setView({
        destination: this._center, // 点的坐标
        orientation: {
          heading: heading,
          pitch: this._startPitch
        }
      });
      this._map.scene.camera.moveBackward(this._distance);
      this.fire(EventType.change);
    }

    /**
     * 停止旋转
     * @return {void}  无
     */
    stop() {
      if (!this._isStart) {
        return
      }
      this._isStart = false;

      this._map.off(EventType.preRender, this._onPreRenderHandler, this);
      this.fire(EventType.stop);
    }
  }

  const MAX_PITCH_IN_DEGREE = 88;

  /**
   * 街景视角模式控制,
   * 1、右键拖拽，以相机视角为中心进行旋转;
   * 2、中键拖拽，可以升高或降低相机高度;
   * 3、左键双击，飞行定位到该点;
   * 4、右键双击，围绕该点旋转。
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Number} [options.rotateSpeed=30] 右键拖拽时，旋转速度，正负控制方向。
   * @param {Number} [options.heightStep=0.2]  中键拖拽时，高度移动比例，控制升高或降低相机高度的速度
   * @param {Number} [options.moveStep=0.1] 双击定位到点时，距离目标点的距离的移动比例 0.0-1.0
   * @param {Number} [options.moveDuration] 双击定位到点时，飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
   * @param {Object} [options.rotatePoint] 右键双击，围绕该点旋转时的参考，具体同{@link RotatePoint}类的构造参数。
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class StreetView
   * @extends {BaseThing}
   */
  class StreetView extends BaseThing {
    constructor(options = {}) {
      super(options);

      /**
       * 右键拖拽时，旋转速度，正负控制方向。
       * @type {Number}
       */
      this.rotateSpeed = options.rotateSpeed ?? 30;

      /**
       * 中键拖拽时，高度移动比例，控制升高或降低相机高度的速度
       * @type {Number}
       */
      this.heightStep = options.heightStep ?? 0.2;

      /**
       * 双击定位到点时，距离目标点的距离的移动比例 0.0-1.0
       * @type {Number}
       */
      this.moveStep = options.moveStep ?? 0.1;
    }

    //= ========= 方法 ==========
    _enabledHook(value) {
      if (this._map.mouseZoom) {
        this._map.mouseZoom.enabled = !value;
      }

      if (value) {
        this._default_zoomEventTypes = this._map.scene.screenSpaceCameraController.zoomEventTypes;
        this._default_tiltEventTypes = this._map.scene.screenSpaceCameraController.tiltEventTypes;

        // 去掉Cesium默认的中右键的操作
        this._map.scene.screenSpaceCameraController.zoomEventTypes = [
          Cesium__namespace.CameraEventType.WHEEL,
          Cesium__namespace.CameraEventType.PINCH,
          {
            eventType: Cesium__namespace.CameraEventType.RIGHT_DRAG,
            modifier: Cesium__namespace.KeyboardEventModifier.CTRL
          }
        ];
        this._map.scene.screenSpaceCameraController.tiltEventTypes = [
          {
            eventType: Cesium__namespace.CameraEventType.MIDDLE_DRAG,
            modifier: Cesium__namespace.KeyboardEventModifier.CTRL
          }
        ];
      } else {
        // 还原Cesium默认的中右键的操作
        if (this._default_zoomEventTypes) {
          this._map.scene.screenSpaceCameraController.zoomEventTypes = this._default_zoomEventTypes;
          delete this._default_zoomEventTypes;
        }
        if (this._default_tiltEventTypes) {
          this._map.scene.screenSpaceCameraController.tiltEventTypes = this._default_tiltEventTypes;
          delete this._default_tiltEventTypes;
        }
      }
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {}

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._enabledHook(this.enabled);

      // 按住右键不松手，拖拽，就可以以当前相机为中心旋转角度
      this._map.on(EventType.rightDown, this._onRightDownHandler, this);
      this._map.on(EventType.mouseMove, this._onMouseMove, this);
      this._map.on(EventType.rightUp, this._onRightUpHandler, this);

      // 按住中键不松手，上下拖拽，可以“升高或降低”相机高度
      this._map.on(EventType.middleDown, this._onMiddleDownHandler, this);
      this._map.on(EventType.middleUp, this._onMiddleUpHandler, this);

      // 左键双击一个点，就飞过去
      this._map.on(EventType.click, this._onClickHandler, this);
      this._map.on(EventType.dblClick, this._onDbClickHandler, this);

      // 右键双击一个点，就围绕这个点旋转
      this._map.on(EventType.rightClick, this._onRightClickHandler, this);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._enabledHook(false);

      // 按住右键不松手，拖拽，就可以以当前相机为中心旋转角度
      this._map.off(EventType.rightDown, this._onRightDownHandler, this);
      this._map.off(EventType.mouseMove, this._onMouseMove, this);
      this._map.off(EventType.rightUp, this._onRightUpHandler, this);

      // 按住中键不松手，上下拖拽，可以“升高或降低”相机高度
      this._map.off(EventType.middleDown, this._onMiddleDownHandler, this);
      this._map.off(EventType.middleUp, this._onMiddleUpHandler, this);

      // 左键双击一个点，就飞过去
      this._map.off(EventType.click, this._onClickHandler, this);
      this._map.off(EventType.dblClick, this._onDbClickHandler, this);

      // 右键双击一个点，就围绕这个点旋转
      this._map.off(EventType.rightClick, this._onRightClickHandler, this);

      if (this.rotatePoint) {
        this._map.removeThing(this.rotatePoint, true);
        delete this.rotatePoint;
      }
    }

    // 按住右键不松手，拖拽，就可以以当前相机为中心旋转角度
    _onRightDownHandler(event) {
      if (!this.enabled) {
        return
      }
      if (this.rotatePoint) {
        this.rotatePoint.stop();
      }

      this._isMouseLeftButtonPressed = true;
      this._mousePosition = this._startMousePosition = Cesium__namespace.Cartesian3.clone(event.position);

      this._headingWhenLeftClicked = Cesium__namespace.Math.toDegrees(this._map.camera.heading);
      this._pitchWhenLeftClicked = Cesium__namespace.Math.toDegrees(this._map.camera.pitch);
    }

    _onMouseMove(event) {
      if (!this.enabled) {
        return
      }
      this._mousePosition = event.endPosition;

      if (this._isMouseLeftButtonPressed) {
        const width = this._map.canvas.clientWidth;
        const height = this._map.canvas.clientHeight;

        // Coordinate (0.0, 0.0) will be where the mouse was clicked.
        const deltaX = (this._mousePosition.x - this._startMousePosition.x) / width;
        const deltaY = -(this._mousePosition.y - this._startMousePosition.y) / height;

        if (Cesium__namespace.Math.equalsEpsilon(deltaX, 0, Cesium__namespace.Math.EPSILON6) && Cesium__namespace.Math.equalsEpsilon(deltaY, 0, Cesium__namespace.Math.EPSILON6)) {
          return
        }

        const deltaHeadingInDegree = deltaX * this.rotateSpeed;
        const newHeadingInDegree = this._headingWhenLeftClicked + deltaHeadingInDegree;

        const deltaPitchInDegree = deltaY * this.rotateSpeed;
        let newPitchInDegree = this._pitchWhenLeftClicked + deltaPitchInDegree;

        if (newPitchInDegree > MAX_PITCH_IN_DEGREE * 2 && newPitchInDegree < 360 - MAX_PITCH_IN_DEGREE) {
          newPitchInDegree = 360 - MAX_PITCH_IN_DEGREE;
        } else {
          if (newPitchInDegree > MAX_PITCH_IN_DEGREE && newPitchInDegree < 360 - MAX_PITCH_IN_DEGREE) {
            newPitchInDegree = MAX_PITCH_IN_DEGREE;
          }
        }

        this._map.camera.setView({
          orientation: {
            heading: Cesium__namespace.Math.toRadians(newHeadingInDegree),
            pitch: Cesium__namespace.Math.toRadians(newPitchInDegree),
            roll: this._map.camera.roll
          }
        });
      } else if (this._isMouseUpdownPressed) {
        const deltaHei = -(this._mousePosition.y - this._startMousePosition.y) / this._map.canvas.clientHeight;

        const lookFactor = this._map.camera.positionCartographic.height * this.heightStep;

        this._map.camera.moveDown(deltaHei * lookFactor);
      }
    }

    _onRightUpHandler(event) {
      this._isMouseLeftButtonPressed = false;
    }

    _onMiddleDownHandler(event) {
      if (!this.enabled) {
        return
      }
      if (this.rotatePoint) {
        this.rotatePoint.stop();
      }

      this._isMouseUpdownPressed = true;
      this._startMousePosition = Cesium__namespace.Cartesian3.clone(event.position);
      this._mousePosition = this._startMousePosition;
    }

    _onMiddleUpHandler(event) {
      this._isMouseUpdownPressed = false;
    }

    _onClickHandler(event) {
      if (!this.enabled) {
        return
      }
      if (this.rotatePoint) {
        this.rotatePoint.stop();
      }
    }

    _onDbClickHandler(event) {
      if (!this.enabled) {
        return
      }
      if (this.rotatePoint) {
        this.rotatePoint.stop();
      }

      const position = getCurrentMousePosition(this._map.scene, event.position);
      if (position) {
        const camera_distance = Cesium__namespace.Cartesian3.distance(position, this._map.camera.positionWC) * this.moveStep;
        // if (camera_distance > 5000) camera_distance = 5000;

        this._map.flyToPoint(position, {
          radius: camera_distance, // 距离目标点的距离
          maximumHeight: this._map.camera.positionCartographic.height,
          duration: this.options.moveDuration
        });
      }
    }

    _onRightClickHandler(event) {
      if (!this.enabled) {
        return
      }
      if (this.time) {
        const delTime = Cesium__namespace.JulianDate.secondsDifference(this._map.clock.currentTime, this.time);
        if (delTime < 0.5) {
          this._map.closeContextMenu();

          if (!this.rotatePoint) {
            this.rotatePoint = new RotatePoint(this.options.rotatePoint);
            this._map.addThing(this.rotatePoint);
          }
          this.rotatePoint.start(event.cartesian);
        }
      }
      this.time = this._map.clock.currentTime.clone();
    }
  }

  /**
   * @typedef {Object} CameraHistory.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} change 变化了
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.change, function (event) {
   *   console.log('记录发送了变化', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 相机视角记录及处理类，含 上一视图 下一视图 等
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Number} [options.maxCacheCount = 99] 保留的历史记录最多个数
   * @param {Object} [options.limit] 限定视角范围参数，包括以下：
   * @param {Cesium.Cartesian3} options.limit.position 中心点坐标
   * @param {Number} options.limit.radius 半径（单位：米）
   * @param {Boolean} [options.limit.debugExtent] 是否显示限定范围的边界
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class CameraHistory
   * @extends {BaseThing}
   * @see [支持的事件类型]{@link CameraHistory.EventType}
   */
  class CameraHistory extends BaseThing {
    constructor(options = {}) {
      super(options);

      this.step = 0; // 记录当前的视角在数组中的位置
      this.views = []; // 保存视角
      this.maxCacheCount = this.options.maxCacheCount ?? 99; // 最多记录数
    }
    //= ========= 对外属性 ==========

    /**
     * 是否显示限定范围的边界
     * @type {Boolean}
     */
    get debugExtent() {
      return this.options.limit && this.options.limit.debugExtent
    }

    set debugExtent(val) {
      if (!this.options.limit) {
        return
      }
      this.options.limit.debugExtent = val;

      if (!this.debugExtentEntity) {
        const radius = this.options.limit.radius;
        const position = this.options.limit.position;
        this.debugExtentEntity = this._map.entities.add({
          name: "限定的范围",
          position: position,
          ellipsoid: {
            radii: new Cesium__namespace.Cartesian3(radius, radius, radius),
            maximumCone: Cesium__namespace.Math.PI_OVER_TWO,
            slicePartitions: 45,
            stackPartitions: 45,
            material: new Cesium__namespace.Color(0.0, 1.0, 1.0, 0),
            outline: true,
            outlineColor: new Cesium__namespace.Color(0.0, 1.0, 1.0, 1.0)
          }
        });
      }
      this.debugExtentEntity.show = val;
    }

    //= ========= 方法 ==========

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      // 显示限定范围的边界
      if (this.options.limit && this.options.limit.debugExtent) {
        this.debugExtent = this.options.limit.debugExtent;
      }
      this._limitGlobe();
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      // 绑定相机事件
      this._map.on(EventType.cameraMoveStart, this._cameraMoveStartHandler, this);
      this._map.on(EventType.cameraMoveEnd, this._cameraMoveEndHandler, this);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      // 解除绑定相机事件
      this._map.off(EventType.cameraMoveStart, this._cameraMoveStartHandler, this);
      this._map.off(EventType.cameraMoveEnd, this._cameraMoveEndHandler, this);

      this.views = [];

      if (this.debugExtentEntity) {
        this._map.entities.remove(this.debugExtentEntity);
        delete this.debugExtentEntity;
      }
    }

    _cameraMoveStartHandler() {
      if (this._map) {
        this.isInPush = true;
        this.lastCameraView = this._map.getCameraView();
      }
    }

    _cameraMoveEndHandler() {
      this._limitGlobe();
      if (!this.isInPush) {
        return
      }
      this._addCameraView();
    }

    _limitGlobe() {
      if (!this.options.limit) {
        return
      }

      const position = this.options.limit.position;
      const radius = this.options.limit.radius;

      const camera_distance = Cesium__namespace.Cartesian3.distance(position, this._map.camera.position);
      if (this.options.limit.debugExtent) ;

      if (camera_distance <= radius) {
        return
      }

      this.isInPush = false;
      if (this.lastCameraView) {
        this._map.setCameraView(this.lastCameraView, {
          duration: 0.5,
          complete: () => {
            this.lastCameraView = null;
            this.isInPush = true;
          }
        });
      } else {
        this._map.flyToPoint(position, {
          radius: radius * 0.6, // 距离目标点的距离
          pitch: -60, // 相机方向
          duration: 0.5,
          complete: () => {
            this.lastCameraView = null;
            this.isInPush = true;
          }
        });
      }
    }

    _addCameraView() {
      // console.log("添加新的视角记录");
      const cameraV = this._map.getCameraView();
      this.views.push(cameraV);

      if (this.views.length > this.maxCacheCount) {
        this.views.splice(0, 1);
      }

      this.step = this.views.length - 1;

      this.fire(EventType.change, {
        index: this.step,
        count: this.views.length
      });
    }

    _goHistoryView() {
      // console.log("开始切换历史视角");

      this._map.camera.moveStart.removeEventListener(this._cameraMoveStartHandler, this);
      this._map.camera.moveEnd.removeEventListener(this._cameraMoveEndHandler, this);

      this.isInPush = false;
      this._map.setCameraView(this.views[this.step], {
        complete: () => {
          // console.log("完成切换历史视角");

          this._map.camera.moveStart.addEventListener(this._cameraMoveStartHandler, this);
          this._map.camera.moveEnd.addEventListener(this._cameraMoveEndHandler, this);

          this.fire(EventType.change, {
            index: this.step,
            count: this.views.length
          });
        }
      });
    }

    /**
     * 切换到 下一视角
     * @return {Boolean}  是否成功切换
     */
    goNext() {
      if (this.step >= this.views.length - 1) {
        // 当前已是最后一页了
        return false
      } else {
        this.step++;
        this._goHistoryView();
        return true
      }
    }

    /**
     * 切换到 上一视角
     * @return {Boolean}  是否成功切换
     */
    goLast() {
      if (this.step <= 0) {
        // 当前已是第一页了
        return false
      } else {
        this.step--;
        this._goHistoryView();
        return true
      }
    }

    /**
     * 回到当前视角（记录的最后一个视角）
     * @return {Boolean}  是否成功切换
     */
    goNow() {
      if (this.step === this.views.length - 1) {
        // 当前已是最后一页了
        return false
      } else {
        this.step = this.views.length - 1;
        this._goHistoryView();
        return true
      }
    }

    /**
     * 回到记录的第一个视角
     * @return {Boolean}  是否成功切换
     */
    goFirst() {
      if (this.step <= 0) {
        // 当前已是第一页了
        return false
      } else {
        this.step = 0;
        this._goHistoryView();
        return true
      }
    }
  }

  /**
   * @typedef {Object} RotateOut.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} start 开始旋转
   * @property {String} change 变化了角度
   * @property {String} stop 停止了旋转
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.stop, function (event) {
   *   console.log('停止了旋转', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 相机位置不动，对外四周旋转
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.direction=false] 旋转方向, true逆时针，false顺时针
   * @param {Number} [options.time=60] 飞行一周所需时间(单位 秒)，控制速度
   * @param {Number} [options.autoStopAngle]  自动停止的角度值（0-360度），未设置时不自动停止
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class RotateOut
   * @extends {BaseThing}
   * @see [支持的事件类型]{@link RotateOut.EventType}

   */
  class RotateOut extends BaseThing {
    constructor(options = {}) {
      super(options);

      this._angle = 360 / (60 * this.options.time || 60);
      this._direction = this.options.direction ? -1 : 1; // 控制方向, true逆时针，false顺时针
      this._autoStopAngle = this.options.autoStopAngle; // 自动停止
    }

    /**
     * 是否在旋转中
     * @type {Boolean}
     * @readonly
     */
    get isStart() {
      return this._isStart
    }

    //= ========= 方法 ==========

    _enabledHook(val) {
      if (val) {
        this.start();
      } else {
        this.stop();
      }
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {}

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {}

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.stop();
    }

    /**
     * 开始旋转
     * @return {void}  无
     */
    start() {
      if (this._isStart) {
        this.stop();
      }
      this._isStart = true;

      this._tikRender = 0;
      this._startHeading = this._map.camera.heading; // 相机的当前heading
      this._startPitch = this._map.camera.pitch;

      this._map.on(EventType.preRender, this._onPreRenderHandler, this);
      this.fire(EventType.start);
    }

    _onPreRenderHandler(event) {
      // 当前已经过去的时间，单位s
      this._tikRender++;
      const angle = this._tikRender * this._angle;
      if (this._autoStopAngle && angle >= this._autoStopAngle) {
        this.stop();
      }

      const heading = Cesium__namespace.Math.toRadians(angle * this._direction) + this._startHeading;

      this._map.scene.camera.setView({
        orientation: {
          heading: heading,
          pitch: this._startPitch
        }
      });
      this.fire(EventType.change);
    }

    /**
     * 停止旋转
     * @return {void}  无
     */
    stop() {
      if (!this._isStart) {
        return
      }
      this._isStart = false;

      this._map.off(EventType.preRender, this._onPreRenderHandler, this);
      this.fire(EventType.stop);
    }
  }

  var index$3 = {
    __proto__: null,
    Underground: Underground,
    Sightline: Sightline,
    Skyline: Skyline,
    Shadows: Shadows,
    Measure: Measure,
    FloodByGraphic: FloodByGraphic,
    Slope: Slope,
    TerrainPlanClip: TerrainPlanClip,
    FloodByMaterial: FloodByMaterial,
    TerrainClip: TerrainClip,
    ContourLine: ContourLine,
    LimitHeight: LimitHeight,
    TilesetPlanClip: TilesetPlanClip,
    ModelPlanClip: ModelPlanClip,
    TilesetBoxClip: TilesetBoxClip,
    TilesetClip: TilesetClip,
    TilesetFlood: TilesetFlood,
    TilesetFlatOld: TilesetFlatOld,
    TilesetFlat: TilesetFlat,
    FirstPersonRoam: FirstPersonRoam,
    StreetView: StreetView,
    CameraHistory: CameraHistory,
    RotatePoint: RotatePoint,
    RotateOut: RotateOut,
    MatrixMove: MatrixMove,
    MatrixRotate: MatrixRotate
  };

  /**
   * 特效 基类
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @export
   * @class BaseEffect
   * @extends {BaseThing}
   */
  class BaseEffect extends BaseThing {
    /**
     * 特效类型
     *
     * @type {String}
     * @readonly
     */
    get type() {
      return this._type
    }

    /**
     * 特效对象
     * @type {Cesium.PostProcessStage}
     * @readonly
     */
    get target() {
      return this._postProcessStage
    }

    /**
     * 特效对象的uniforms
     * 一个对象，它的属性被用来设置片段着色器shader。
     * <p>
     * 对象属性值可以是常量或函数。这个函数将在每一帧后处理阶段执行之前被调用。
     * </p>
     * <p>
     *  常量值也可以是图像的URI、数据URI，或者可以用作纹理的HTML元素，如HTMLImageElement或HTMLCanvasElement。
     * </p>
     * <p>
     * 如果这个后处理阶段是{@link Cesium.PostProcessStageComposite}中不串行执行的部分，那么常量值也可以是复合程序中另一个阶段的名称。这将设置统一的输出纹理与该名称的舞台。
     * </p>
     * @type {Object}
     * @readonly
     */
    get uniforms() {
      return this._postProcessStage?.uniforms
    }

    /**
     * 添加到地图上，同 map.addEffect
     *
     * @param {Map} map 地图对象
     * @return {BaseEffect} 当前对象本身，可以链式调用
     *
     */
    addTo(map) {
      if (map && map.addEffect) {
        map.addEffect(this);
      }
      return this
    }

    /**
     * 从地图上移除，同map.removeEffect
     *
     * @param {Boolean} [destroy] 是否调用destroy释放
     * @return {void}  无
     */
    remove(destroy) {
      if (this._map) {
        this._map.removeEffect(this, destroy);
      }
    }

    _enabledHook(val) {
      if (this._postProcessStage) {
        this._postProcessStage.enabled = val;
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedBaseHook() {
      if (!this._postProcessStage) {
        this._mountedHook();
      }

      this._enabledHook(this.enabled);
      this._map.scene.postProcessStages.add(this._postProcessStage);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedBaseHook() {
      if (this._postProcessStage) {
        this._map.scene.postProcessStages.remove(this._postProcessStage);

        if (this._postProcessStage.isDestroyed()) {
          delete this._postProcessStage;
        }
      }
    }

    fire(type, data = {}, propagate) {
      if (!data.effect) {
        data.effect = this;
      }
      return super.fire(type, data, propagate)
    }
  }

  var FogFS = "float getDistance(sampler2D depthTexture, vec2 texCoords) {\n  float depth = czm_unpackDepth(texture2D(depthTexture, texCoords));\n  if(depth == 0.0) {\n    return czm_infinity;\n  }\n  vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth);\n  return -eyeCoordinate.z / eyeCoordinate.w;\n}\nfloat interpolateByDistance(vec4 nearFarScalar, float distance) {\n  float startDistance = nearFarScalar.x;\n  float startValue = nearFarScalar.y;\n  float endDistance = nearFarScalar.z;\n  float endValue = nearFarScalar.w;\n  float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);\n  return mix(startValue, endValue, t);\n}\nvec4 alphaBlend(vec4 sourceColor, vec4 destinationColor) {\n  return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a);\n}\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform vec4 fogByDistance;\nuniform vec4 fogColor;\nvarying vec2 v_textureCoordinates;\nvoid main(void) {\n  float distance = getDistance(depthTexture, v_textureCoordinates);\n  vec4 sceneColor = texture2D(colorTexture, v_textureCoordinates);\n  float blendAmount = interpolateByDistance(fogByDistance, distance);\n  vec4 finalFogColor = vec4(fogColor.rgb, fogColor.a * blendAmount);\n  gl_FragColor = alphaBlend(finalFogColor, sceneColor);\n}\n"; // eslint-disable-line

  /**
   * 雾场景效果
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {Cesium.Cartesian4} [options.fogByDistance = new Cesium.Cartesian4(10, 0.0, 1000, 0.9)] 雾强度
   * @param {Number} [options.fogByDistance_near]  最近距离，可以与fogByDistance二选一
   * @param {Number} [options.fogByDistance_nearValue]  最近强度，可以与fogByDistance二选一
   * @param {Number} [options.fogByDistance_far]  最远距离，可以与fogByDistance二选一
   * @param {Number} [options.fogByDistance_farValue]  最远强度，可以与fogByDistance二选一
   * @param {Cesium.Color} [options.color =  Cesium.Color.WHITE]  雾颜色
   * @param {Number} [options.maxHeight = 9000]  最大高度，限定超出该高度不显示雾场景效果
   *
   * @export
   * @class FogEffect
   * @extends {BaseEffect}
   */
  class FogEffect extends BaseEffect {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 雾强度
       * @type {Cesium.Cartesian4}
       */
      this.fogByDistance = options.fogByDistance ?? new Cesium__namespace.Cartesian4(10, 0.0, 1000, 0.9);

      if (Cesium__namespace.defined(options.fogByDistance_near)) {
        this.fogByDistance.x = options.fogByDistance_near;
      }
      if (Cesium__namespace.defined(options.fogByDistance_nearValue)) {
        this.fogByDistance.y = options.fogByDistance_nearValue;
      }
      if (Cesium__namespace.defined(options.fogByDistance_far)) {
        this.fogByDistance.z = options.fogByDistance_far;
      }
      if (Cesium__namespace.defined(options.fogByDistance_farValue)) {
        this.fogByDistance.w = options.fogByDistance_farValue;
      }

      /**
       * 雾颜色
       * @type {Cesium.Color}
       */
      this.color = options.color ?? Cesium__namespace.Color.WHITE;
      /**
       * 最高限定高度，超出该高度不显示雾场景效果
       * @type {Number}
       */
      this.maxHeight = options.maxHeight ?? 9000;
    }

    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._postProcessStage = new Cesium__namespace.PostProcessStage({
        name: this._id,
        fragmentShader: FogFS,
        uniforms: {
          fogByDistance: () => {
            return this.fogByDistance
          },
          fogColor: () => {
            return this.color
          }
        },
        enabled: this.enabled
      });
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.scene.camera.changed.addEventListener(this.camera_changedHandler, this);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.scene.camera.changed.removeEventListener(this.camera_changedHandler, this);
    }

    // 加控制，只在相机高度低于一定高度时才开启本效果
    camera_changedHandler(event) {
      if (this._map.camera.positionCartographic.height < this.maxHeight) {
        this._postProcessStage.enabled = this.enabled;
      } else {
        this._postProcessStage.enabled = false;
      }
    }
  }

  // 注册下
  register("fog", FogEffect);

  var RainShader = "uniform sampler2D colorTexture;//下雨前输入的场景渲染照片\nvarying vec2 v_textureCoordinates;\nuniform float speed;\nuniform float size;\nuniform float direction;\n\nfloat hash(float x) {\n  return fract(sin(x * 23.3) * 13.13);\n}\n\nvoid main(void) {\n\n  float time = czm_frameNumber * speed / 1000.0;\n  vec2 resolution = czm_viewport.zw;\n\n  vec2 uv = (gl_FragCoord.xy * 2. - resolution.xy) / min(resolution.x, resolution.y);\n  vec3 finalColor = vec3(0.1, 0.2, 0.3);//粒子的颜色\n\n  float si = sin(direction), co = cos(direction);\n  uv *= mat2(co, -si, si, co);\n  uv *= length(uv + vec2(0, 4.9)) * 0.3 + 1.0;\n\n  float v = 1. - sin(hash(floor(uv.x * 100.0)) * 2.0);\n  float b = clamp(abs(sin(20.0 * time * v + uv.y * (5. / (2.0 + v)))) - .95, 0.0, 1.0) * size;\n  finalColor *= v * b; //屏幕上雨的颜色\n\n  gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor, 1.0), 0.5); //将雨和三维场景融合\n}\n"; // eslint-disable-line

  /**
   * 雨天气 效果
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {Number} [options.size = 20]  粒子大小
   * @param {Number} [options.speed = 10]  速度
   * @param {Number} [options.direction = -30]  方向（度），0度垂直向下
   * @export
   * @class RainEffect
   * @extends {BaseEffect}
   */
  class RainEffect extends BaseEffect {
    /**
     * 速度
     * @type {Number}
     */
    get speed() {
      return this._postProcessStage?.uniforms.speed
    }

    set speed(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.speed = value;
      }
    }

    /**
     * 雨粒子大小
     * @type {Number}
     */
    get size() {
      return this._postProcessStage?.uniforms.size
    }

    set size(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.size = value;
      }
    }

    /**
     * 雨的方向（度），0度垂直向下
     * @type {Number}
     */
    get direction() {
      return this._postProcessStage?.uniforms.direction
    }

    set direction(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.direction = Cesium__namespace.Math.toRadians(value);
      }
    }

    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._postProcessStage = new Cesium__namespace.PostProcessStage({
        fragmentShader: RainShader,
        uniforms: {
          speed: this.options.speed ?? 10.0,
          size: this.options.size ?? 20.0,
          direction: Cesium__namespace.Math.toRadians(this.options.direction ?? -30)
        },
        enabled: this.enabled
      });
    }
  }

  // 注册下
  register("rain", RainEffect);

  var SnowShader = "uniform sampler2D colorTexture; //输入的场景渲染照片\nvarying vec2 v_textureCoordinates;\nuniform float speed;\n\nfloat snow(vec2 uv, float scale) {\n  float time = czm_frameNumber * speed / 1000.0;\n  float w = smoothstep(1.0, 0.0, -uv.y * (scale / 10.0));\n  if(w < 0.1)\n    return 0.0;\n  uv += time / scale;\n  uv.y += time * 2.0 / scale;\n  uv.x += sin(uv.y + time * 0.5) / scale;\n  uv *= scale;\n\n  vec2 s = floor(uv), f = fract(uv), p;\n  float k = 3.0, d;\n  p = 0.5 + 0.35 * sin(11.0 * fract(sin((s + p + scale) * mat2(7, 3, 6, 5)) * 5.0)) - f;\n  d = length(p);\n  k = min(d, k);\n  k = smoothstep(0.0, k, sin(f.x + f.y) * 0.01);\n  return k * w;\n}\n\nvoid main(void) {\n  vec2 resolution = czm_viewport.zw;\n  vec2 uv = (gl_FragCoord.xy * 2. - resolution.xy) / min(resolution.x, resolution.y);\n\n  float c = 0.0;\n  c += snow(uv, 15.);\n  c += snow(uv, 10.);\n  c += snow(uv, 9.);\n  c += snow(uv, 8.);\n  c += snow(uv, 7.);\n  c += snow(uv, 6.);\n  c += snow(uv, 5.);\n  c += snow(uv, 4.);\n\n  vec3 finalColor = (vec3(c)); //屏幕上雪的颜色\n\n  gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor, 1.0), 0.5);  //将雪和三维场景融合\n\n}\n"; // eslint-disable-line

  /**
   * 雪天气 效果
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {Number} [options.speed = 10]  速度
   * @export
   * @class SnowEffect
   * @extends {BaseEffect}
   */
  class SnowEffect extends BaseEffect {
    /**
     * 速度
     * @type {Number}
     */
    get speed() {
      return this._postProcessStage?.uniforms.speed
    }

    set speed(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.speed = value;
      }
    }

    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._postProcessStage = new Cesium__namespace.PostProcessStage({
        fragmentShader: SnowShader,
        uniforms: {
          speed: this.options.speed ?? 10
        },
        enabled: this.enabled
      });
    }
  }

  // 注册下
  register("snow", SnowEffect);

  var SnowCoverFS = "#extension GL_OES_standard_derivatives : enable\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform float alpha;\nvarying vec2 v_textureCoordinates;\n\nvec4 toEye(in vec2 uv, in float depth) {\n  vec2 xy = vec2((uv.x * 2.0 - 1.0), (uv.y * 2.0 - 1.0));\n  vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0);\n  posInCamera = posInCamera / posInCamera.w;\n  return posInCamera;\n}\nfloat getDepth(in vec4 depth) {\n  float z_window = czm_unpackDepth(depth);\n  z_window = czm_reverseLogDepth(z_window);\n  float n_range = czm_depthRange.near;\n  float f_range = czm_depthRange.far;\n  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\n\nvoid main() {\n  vec4 color = texture2D(colorTexture, v_textureCoordinates);\n  vec4 currD = texture2D(depthTexture, v_textureCoordinates);\n  if(currD.r >= 1.0) {\n    gl_FragColor = color;\n    return;\n  }\n  float depth = getDepth(currD);\n  vec4 positionEC = toEye(v_textureCoordinates, depth);\n  vec3 dx = dFdx(positionEC.xyz);\n  vec3 dy = dFdy(positionEC.xyz);\n  vec3 nor = normalize(cross(dx, dy));\n\n  vec4 positionWC = normalize(czm_inverseView * positionEC);\n  vec3 normalWC = normalize(czm_inverseViewRotation * nor);\n  float dotNumWC = dot(positionWC.xyz, normalWC);\n  if(dotNumWC <= 0.3) {\n    gl_FragColor = mix(color, vec4(1.0), alpha * 0.3);\n    return;\n  }\n  gl_FragColor = mix(color, vec4(1.0), dotNumWC * alpha);\n}\n"; // eslint-disable-line

  // 原理：法线越垂直与地面越白

  /**
   * 地面积雪 效果
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {Number} [options.alpha =  1.0]  覆盖强度  0-1
   * @param {Number} [options.maxHeight = 9000]  最大高度，限定超出该高度不显示积雪效果
   * @export
   * @class SnowCoverEffect
   * @extends {BaseEffect}
   */
  class SnowCoverEffect extends BaseEffect {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      /**
       * 最高限定高度，超出该高度不显示积雪效果
       * @type {Number}
       */
      this.maxHeight = options.maxHeight ?? 9000;
    }

    /**
     * 覆盖强度  0-1
     * @type {Number}
     */
    get alpha() {
      return this._postProcessStage?.uniforms.alpha
    }

    set alpha(alpha) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.alpha = alpha;
      }
    }

    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._postProcessStage = new Cesium__namespace.PostProcessStage({
        name: this._id,
        fragmentShader: SnowCoverFS,
        uniforms: {
          alpha: this.options.alpha ?? 1.0 // 覆盖强度  0-1
        },
        enabled: this.enabled
      });
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.scene.camera.changed.addEventListener(this.camera_changedHandler, this);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.scene.camera.changed.removeEventListener(this.camera_changedHandler, this);
    }

    // 加控制，只在相机高度低于一定高度时才开启本效果
    camera_changedHandler(event) {
      if (this._map.camera.positionCartographic.height < this.maxHeight) {
        this._postProcessStage.enabled = this.enabled;
      } else {
        this._postProcessStage.enabled = false;
      }
    }
  }

  // 注册下
  register("snowCover", SnowCoverEffect);

  var InvertedSceneFS = "#extension GL_OES_standard_derivatives : enable\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\nvec4 toEye(in vec2 uv, in float depth) {\n  vec2 xy = vec2((uv.x * 2.0 - 1.0), (uv.y * 2.0 - 1.0));\n  vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0);\n  posInCamera = posInCamera / posInCamera.w;\n  return posInCamera;\n}\nfloat getDepth(in vec4 depth) {\n  float z_window = czm_unpackDepth(depth);\n  z_window = czm_reverseLogDepth(z_window);\n  float n_range = czm_depthRange.near;\n  float f_range = czm_depthRange.far;\n  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nvec3 guussColor(vec2 uv) {\n  vec2 pixelSize = 1.0 / czm_viewport.zw;\n  float dx0 = -pixelSize.x;\n  float dy0 = -pixelSize.y;\n  float dx1 = pixelSize.x;\n  float dy1 = pixelSize.y;\n  vec4 gc = (texture2D(colorTexture, uv) +\n    texture2D(colorTexture, uv + vec2(dx0, dy0)) +\n    texture2D(colorTexture, uv + vec2(0.0, dy0)) +\n    texture2D(colorTexture, uv + vec2(dx1, dy0)) +\n    texture2D(colorTexture, uv + vec2(dx0, 0.0)) +\n    texture2D(colorTexture, uv + vec2(dx1, 0.0)) +\n    texture2D(colorTexture, uv + vec2(dx0, dy1)) +\n    texture2D(colorTexture, uv + vec2(0.0, dy1)) +\n    texture2D(colorTexture, uv + vec2(dx1, dy1))) * (1.0 / 9.0);\n  return gc.rgb;\n}\nvoid main() {\n    // mat4 dither = mat4(\n    //     0,       0.5,    0.125,  0.625,\n    //     0.75,    0.25,   0.875,  0.375,\n    //     0.1875,  0.6875, 0.0625, 0.5625,\n    //     0.9375,  0.4375, 0.8125, 0.3125\n    // );\n    // int sampleCoordX = int(mod((gl_FragCoord.x * v_textureCoordinates.x),4.0));\n    // int sampleCoordY = int(mod((gl_FragCoord.y * v_textureCoordinates.y),4.0));\n  float offset = 0.0;\n\n  vec4 color = texture2D(colorTexture, v_textureCoordinates);\n  vec4 currD = texture2D(depthTexture, v_textureCoordinates);\n    // gl_FragColor = currD;\n    // return;\n  if(currD.r >= 1.0) {\n    gl_FragColor = color;\n    return;\n  }\n  float depth = getDepth(currD);\n    // gl_FragColor = vec4(depth,0.0,0.0,1.0);\n    // return;\n\n  vec4 positionEC = toEye(v_textureCoordinates, depth);\n  vec3 dx = dFdx(positionEC.xyz);\n  vec3 dy = dFdy(positionEC.xyz);\n  vec3 normal = normalize(cross(dx, dy));\n\n  vec4 positionWC = normalize(czm_inverseView * positionEC);\n  vec3 normalWC = normalize(czm_inverseViewRotation * normal);\n  float fotNumWC = dot(positionWC.xyz, normalWC);\n  if(fotNumWC <= 0.5) {\n    gl_FragColor = color;\n    return;\n  }\n\n    // float dotNum = dot(normal,vec3(0.0,1.0,0.0));\n    // gl_FragColor = mix(color,vec4(1.0),dotNum*0.8);\n    // return;\n\n  vec3 viewDir = normalize(positionEC.xyz);\n  vec3 reflectDir = reflect(viewDir, normal);\n    // vec3 viewReflectDir = czm_viewRotation * reflectDir;\n  vec3 viewReflectDir = reflectDir;\n\n  float step = 0.05;\n  int stepNum = int(20.0 / step);\n  vec3 pos;\n  vec3 albedo;\n  bool jd = false;\n  for(int i = 1; i <= 400; i++) {\n    float delta = step * float(i) + offset;\n    pos = positionEC.xyz + viewReflectDir * delta;\n    float d = -pos.z;\n\n    vec4 tmp = czm_projection * vec4(pos, 1.0);\n    vec3 screenPos = tmp.xyz / tmp.w;\n    vec2 uv = vec2(screenPos.x, screenPos.y) * 0.5 + vec2(0.5, 0.5);\n\n    if(uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0) {\n      float dd = getDepth(texture2D(depthTexture, uv));\n      vec4 jzc = toEye(uv, dd);\n      dd = -jzc.z;\n      if(d > dd) {\n        if(abs(abs(d) - abs(dd)) <= step) {\n          jd = true;\n                    // albedo = texture2D(colorTexture, uv).rgb;\n          albedo = guussColor(uv);\n        }\n        break;\n      }\n    }\n  }\n  if(jd) {\n    gl_FragColor = vec4(mix(color.xyz, albedo, 0.5), 1.0);\n  } else {\n    gl_FragColor = color;\n  }\n}\n"; // eslint-disable-line

  // 原理：利用空间镜面反射技术，计算倒影射线的UV进行采样

  /**
   * 倒影效果
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @export
   * @class InvertedEffect
   * @extends {BaseEffect}
   */
  class InvertedEffect extends BaseEffect {
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._postProcessStage = new Cesium__namespace.PostProcessStage({
        fragmentShader: InvertedSceneFS,
        enabled: this.enabled
      });
    }
  }

  // 注册下
  register("inverted", InvertedEffect);

  /**
   * 夜视效果
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @export
   * @class NightVisionEffect
   * @extends {BaseEffect}
   */
  class NightVisionEffect extends BaseEffect {
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._postProcessStage = Cesium__namespace.PostProcessStageLibrary.createNightVisionStage();
    }
  }

  // 注册下
  register("nightVision", NightVisionEffect);

  /**
   * 泛光效果, 使明亮的区域更亮，黑暗的区域更暗。
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {Number} [options.contrast = 128]  对比度,取值范围[-255.0,255.0]
   * @param {Number} [options.brightness = -0.3]  亮度, 将输入纹理的RGB值转换为色相、饱和度和亮度(HSB)，然后将该值添加到亮度中。
   * @param {Number} [options.delta =  1.0]  增量权值
   * @param {Number} [options.sigma =  3.78]  滤波权值，delta和sigma用于计算高斯滤波器的权值。方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
   * @param {Number} [options.stepSize = 5.0]  步长,是下一个texel的距离
   *
   *
   * @export
   * @class BloomEffect
   * @extends {BaseEffect}
   */
  class BloomEffect extends BaseEffect {
    /**
     * 对比度,取值范围[-255.0,255.0]
     * @type {Number}
     */
    get contrast() {
      return this._postProcessStage?.uniforms.contrast
    }

    set contrast(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.contrast = value;
      }
    }

    /**
     * 亮度, 将输入纹理的RGB值转换为色相、饱和度和亮度(HSB)，然后将该值添加到亮度中
     * @type {Number}
     */
    get brightness() {
      return this._postProcessStage?.uniforms.brightness
    }

    set brightness(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.brightness = value;
      }
    }

    /**
     * 增量.方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
     * @type {Number}
     */
    get delta() {
      return this._postProcessStage?.uniforms.delta
    }

    set delta(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.delta = value;
      }
    }

    /**
     *delta和sigma用于计算高斯滤波器的权值。方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
     * @type {Number}
     */
    get sigma() {
      return this._postProcessStage?.uniforms.sigma
    }

    set sigma(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.sigma = value;
      }
    }

    /**
     * 步长,是下一个texel的距离
     * @type {Number}
     */
    get stepSize() {
      return this._postProcessStage?.uniforms.stepSize
    }

    set stepSize(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.stepSize = value;
      }
    }

    //= ========= 方法 ==========
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._postProcessStage = this._map.scene.postProcessStages.bloom;
      this._postProcessStage.uniforms.glowOnly = false;
      this._postProcessStage.uniforms.contrast = this.options.contrast ?? 128; // 对比度
      this._postProcessStage.uniforms.brightness = this.options.brightness ?? -0.3; // 亮度
      this._postProcessStage.uniforms.delta = this.options.delta ?? 1.0; // 增量
      this._postProcessStage.uniforms.sigma = this.options.sigma ?? 3.78;
      this._postProcessStage.uniforms.stepSize = this.options.stepSize ?? 5.0; // 步长
    }

    _addedBaseHook(map) {
      // 不能删除，覆盖父类的
      this._postProcessStage.enabled = this.enabled;
    }

    _removedBaseHook() {
      // 不能删除，覆盖父类的
      this._postProcessStage.enabled = false;
    }
  }
  // 注册下
  register("bloom", BloomEffect);

  /**
   * 高亮特效
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {Number} [options.brightness = 2.0]  亮度值
   *
   * @export
   * @class BrightnessEffect
   * @extends {BaseEffect}
   */
  class BrightnessEffect extends BaseEffect {
    /**
     * 亮度, 将输入纹理的RGB值转换为色相、饱和度和亮度(HSB)，然后将该值添加到亮度中
     * @type {Number}
     */
    get brightness() {
      return this._postProcessStage?.uniforms.brightness
    }

    set brightness(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.brightness = value;
      }
    }

    //= ========= 方法 ==========
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._postProcessStage = Cesium__namespace.PostProcessStageLibrary.createBrightnessStage();
      this._postProcessStage.uniforms.brightness = this.options.brightness ?? 2.0;
    }
  }

  // 注册下
  register("brightness", BrightnessEffect);

  /**
   * 黑白效果
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {Number} [options.gradations = 4.0]  渐变
   *
   * @export
   * @class BlackAndWhiteEffect
   * @extends {BaseEffect}
   */
  class BlackAndWhiteEffect extends BaseEffect {
    /**
     * 渐变
     * @type {Number}
     */
    get gradations() {
      return this._postProcessStage?.uniforms.gradations
    }

    set gradations(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.gradations = value;
      }
    }

    //= ========= 方法 ==========
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._postProcessStage = Cesium__namespace.PostProcessStageLibrary.createBlackAndWhiteStage();
      this._postProcessStage.uniforms.gradations = this.options.gradations ?? 4.0;
    }
  }

  // 注册下
  register("blackAndWhite", BlackAndWhiteEffect);

  var MosaicShader = "uniform sampler2D colorTexture;\nvarying vec2 v_textureCoordinates;\nconst int KERNEL_WIDTH = 16;\nvoid main(void) {\n  vec2 step = 1.0 / czm_viewport.zw;\n  vec2 integralPos = v_textureCoordinates - mod(v_textureCoordinates, 8.0 * step);\n  vec3 averageValue = vec3(0.0);\n  for(int i = 0; i < KERNEL_WIDTH; i++) {\n    for(int j = 0; j < KERNEL_WIDTH; j++) {\n      averageValue += texture2D(colorTexture, integralPos + step * vec2(i, j)).rgb;\n    }\n  }\n  averageValue /= float(KERNEL_WIDTH * KERNEL_WIDTH);\n  gl_FragColor = vec4(averageValue, 1.0);\n}\n"; // eslint-disable-line

  /**
   * 马赛克效果
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @export
   * @class MosaicEffect
   * @extends {BaseEffect}
   */
  class MosaicEffect extends BaseEffect {
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._postProcessStage = new Cesium__namespace.PostProcessStage({
        fragmentShader: MosaicShader,
        enabled: this.enabled
      });
    }
  }
  // 注册下
  register("mosaic", MosaicEffect);

  /**
   * 景深
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {Number} [options.focalDistance = 87]  焦距，是以米为单位的距离来设定相机的焦距。
   * @param {Number} [options.delta =  1.0]  增量
   * @param {Number} [options.sigma =  3.78]  delta和sigma用于计算高斯滤波器的权值。方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
   * @param {Number} [options.stepSize = 5.0]  步长,是下一个texel的距离
   *
   * @export
   * @class DepthOfFieldEffect
   * @extends {BaseEffect}
   */
  class DepthOfFieldEffect extends BaseEffect {
    /**
     * 焦距，是以米为单位的距离来设定相机的焦距。
     * @type {Number}
     */
    get focalDistance() {
      return this._postProcessStage?.uniforms.focalDistance
    }

    set focalDistance(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.focalDistance = value;
      }
    }

    /**
     * 增量.方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
     * @type {Number}
     */
    get delta() {
      return this._postProcessStage?.uniforms.delta
    }

    set delta(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.delta = value;
      }
    }

    /**
     *delta和sigma用于计算高斯滤波器的权值。方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
     * @type {Number}
     */
    get sigma() {
      return this._postProcessStage?.uniforms.sigma
    }

    set sigma(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.sigma = value;
      }
    }

    /**
     * 步长,是下一个texel的距离
     * @type {Number}
     */
    get stepSize() {
      return this._postProcessStage?.uniforms.stepSize
    }

    set stepSize(value) {
      if (this._postProcessStage) {
        this._postProcessStage.uniforms.stepSize = value;
      }
    }

    //= ========= 方法 ==========
    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._postProcessStage = Cesium__namespace.PostProcessStageLibrary.createDepthOfFieldStage();

      this._postProcessStage.uniforms.focalDistance = this.options.focalDistance ?? 87; // 焦距
      this._postProcessStage.uniforms.delta = this.options.delta ?? 1;
      this._postProcessStage.uniforms.sigma = this.options.sigma ?? 3.78;
      this._postProcessStage.uniforms.stepSize = this.options.stepSize ?? 2.46; // 步长
    }
  }

  // 注册下
  register("depthOfField", DepthOfFieldEffect);

  // /**
  //  * 后期渲染通道，实现功能：
  //  *      在Cesium主渲染流程完成后，指定后期处理节点（stage）开始前，
  //  * 将选中的对象或者没有被选中的对象（在fragmentShader中调用内置的czm_selected()方法识别）渲染到缓冲区，
  //  * 然后在该后期处理节点通过texture属性获取当前通道的颜色数据，通过depthTexture获取深度数据。
  //  * @example
  //  *
  //  *
  //  * //1.创建后期渲染通道
  //     const maskPass = new CesiumRenderPass({
  //         name:  'colorMask',
  //         fragmentShader: `
  //         void main(){
  //             if(!czm_selected())discard;
  //         }
  //         `
  //     })
  //     //2.创建后期处理节点
  //     const stage = new Cesium.PostProcessStage({
  //         name: name,
  //         uniforms: {
  //             //传递颜色
  //             maskTexture() {
  //                 return maskPass.texture
  //             },
  //             //传递深度
  //             maskDepthTexture() {
  //                 return maskPass.depthTexture
  //             }
  //         },
  //         fragmentShader: `
  // uniform sampler2D maskDepthTexture;
  // uniform sampler2D maskTexture;
  // //cesium内置的uv变量
  // varying vec2 v_textureCoordinates;

  // void main(void)
  // {
  //     //读取颜色缓冲区数据
  //     vec4 color = texture2D(colorTexture, v_textureCoordinates);
  //     //按rgba读取深度缓冲区数据
  //     vec4 depthColor = texture2D(maskDepthTexture, v_textureCoordinates);
  //     //读取深度值
  //     float depth=czm_readDepth(maskDepthTexture, v_textureCoordinates);
  //     gl_FragColor =color;
  // }
  //  `
  //     })

  //     //3.绑定后期处理节点
  //     depthPass.stage = stage

  //     //4.在cesium场景中使用
  //     stage.selected = [xxx];//设置选中对象，实际项目中可以通过监听鼠标点击事件pick到对象再赋值
  //     viewer.postProcessStages.add(stage)
  //  */
  function executeDerivedCommand(command, nameDerived, commandName, scene, context, passState) {
    const defined = Cesium__namespace.defined;
    const frameState = scene._frameState;
    let derivedCommands = command.derivedCommands;
    if (!defined(derivedCommands)) {
      return
    }

    if (frameState.useLogDepth && defined(derivedCommands.logDepth)) {
      command = derivedCommands.logDepth.command;
    }

    derivedCommands = command.derivedCommands;
    if (defined(derivedCommands[nameDerived])) {
      command = derivedCommands[nameDerived][commandName];
      command.execute(context, passState);
    }
  }
  let scratchPerspectiveFrustum, scratchPerspectiveOffCenterFrustum, scratchOrthographicFrustum, scratchOrthographicOffCenterFrustum;

  function executeDerivedCommandList(context, targetFramebuffer, passState, nameDerived, commandName, filter) {
    const { Pass, defined, PerspectiveFrustum, PerspectiveOffCenterFrustum, OrthographicFrustum, OrthographicOffCenterFrustum } = Cesium__namespace;

    scratchPerspectiveFrustum = scratchPerspectiveFrustum || new PerspectiveFrustum();
    scratchPerspectiveOffCenterFrustum = scratchPerspectiveOffCenterFrustum || new PerspectiveOffCenterFrustum();
    scratchOrthographicFrustum = scratchOrthographicFrustum || new OrthographicFrustum();
    scratchOrthographicOffCenterFrustum = scratchOrthographicOffCenterFrustum || new OrthographicOffCenterFrustum();

    const us = context._us;
      const frameState = us._frameState;
      const camera = frameState.camera;
      const scene = camera._scene;
      const view = scene._view;
      const frustumCommandsList = view.frustumCommandsList;
      const numFrustums = frustumCommandsList.length;

    const globeTranslucencyState = scene._globeTranslucencyState;
    const globeTranslucent = globeTranslucencyState.translucent;
    const globeTranslucencyFramebuffer = scene._view.globeTranslucencyFramebuffer;

    // Create a working frustum from the original camera frustum.
    let frustum;
    if (defined(camera.frustum.fov)) {
      frustum = camera.frustum.clone(scratchPerspectiveFrustum);
    } else if (defined(camera.frustum.infiniteProjectionMatrix)) {
      frustum = camera.frustum.clone(scratchPerspectiveOffCenterFrustum);
    } else if (defined(camera.frustum.width)) {
      frustum = camera.frustum.clone(scratchOrthographicFrustum);
    } else {
      frustum = camera.frustum.clone(scratchOrthographicOffCenterFrustum);
    }

    function executeCommand(command, scene, context, passState) {
      const show = filter ? filter(command, scene) : true;
      if (show) {
        if (nameDerived && commandName) {
          executeDerivedCommand(command, nameDerived, commandName, scene, context, passState);
        } else {
          command.execute(context, passState);
        }
      }
    }

    let j, length, commands;
    for (let i = 0; i < numFrustums; ++i) {
      const index = numFrustums - i - 1;
      const frustumCommands = frustumCommandsList[index];

      const originalFramebuffer = passState.framebuffer;
      passState.framebuffer = targetFramebuffer;

      // reset frustum
      frustum.near = index !== 0 ? frustumCommands.near * scene.opaqueFrustumNearOffset : frustumCommands.near;
      frustum.far = frustumCommands.far;
      us.updateFrustum(frustum);

      us.updatePass(Pass.GLOBE);
      commands = frustumCommands.commands[Pass.GLOBE];
      length = frustumCommands.indices[Pass.GLOBE];

      if (globeTranslucent) {
        globeTranslucencyState.executeGlobeCommands(frustumCommands, executeCommand, globeTranslucencyFramebuffer, scene, passState);
      } else {
        for (j = 0; j < length; ++j) {
          executeCommand(commands[j], scene, context, passState);
        }
      }

      // if (clearGlobeDepth) {
      //     clearDepth.framebuffer = passState.framebuffer;
      //     clearDepth.execute(context, passState);
      //     clearDepth.framebuffer = undefined;
      // }

      // if (clearGlobeDepth && useDepthPlane) {
      //     depthPlane.execute(context, passState);
      // }

      us.updatePass(Pass.CESIUM_3D_TILE);
      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE];
      length = frustumCommands.indices[Pass.CESIUM_3D_TILE];
      for (j = 0; j < length; ++j) {
        executeCommand(commands[j], scene, context, passState);
      }

      us.updatePass(Pass.OPAQUE);
      commands = frustumCommands.commands[Pass.OPAQUE];
      length = frustumCommands.indices[Pass.OPAQUE];
      for (j = 0; j < length; ++j) {
        executeCommand(commands[j], scene, context, passState);
      }

      us.updatePass(Pass.TRANSLUCENT);
      commands = frustumCommands.commands[Pass.TRANSLUCENT];
      length = frustumCommands.indices[Pass.TRANSLUCENT];
      for (j = 0; j < length; ++j) {
        executeCommand(commands[j], scene, context, passState);
      }

      passState.framebuffer = originalFramebuffer;
    }
  }

  const packing = `
vec3 packNormalToRGB( const in vec3 normal ) {
 return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
 return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
 vec4 r = vec4( fract( v * PackFactors ), v );
 r.yzw -= r.xyz * ShiftRight8; // tidy overflow
 return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
 return dot( v, UnpackFactors );
}

vec4 pack2HalfToRGBA( vec2 v ) {
 vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
 return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
 return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
 return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
 return linearClipZ * ( near - far ) - near;
}

// NOTE: https://twitter.com/gonnavis/status/1377183786949959682

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
 return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
 return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`;

  const cmz_selected_glsl =
    "uniform sampler2D czm_selectedIdTexture; \n" +
    "uniform float czm_selectedIdTextureStep; \n" +
    "uniform float czm_selectedIdTextureWidth; \n" +
    "bool czm_selected(vec4 id) \n" +
    "{ \n" +
    "    bool selected = false;\n" +
    "    for (int i = 0; i < 1024000; i++) \n" +
    "    { \n" +
    "        vec4 selectedId = texture2D(czm_selectedIdTexture, vec2((float(i) + 0.5) * czm_selectedIdTextureStep, 0.5)); \n" +
    "        if (all(equal(id, selectedId))) \n" +
    "        { \n" +
    "            return true; \n" +
    "        } \n" +
    "       if(float(i)>czm_selectedIdTextureWidth)break;\n" +
    "    } \n" +
    "    return false; \n" +
    "} \n\n";

  function CesiumRenderPass(options) {
    const {
      defaultValue,
      BoundingRectangle,
      Pass,
      Sampler,
      DrawCommand,
      Color,
      ShaderSource,
      defined,
      ClearCommand,
      RenderState,
      Texture,
      PixelDatatype,
      PixelFormat,
      Framebuffer
    } = Cesium__namespace;

    this._selectedIdTexture = null;

    let {
        name,
        vertexShader,
        fragmentShader,
        uniforms,
        renderStateProcess,
        beforeUpdate,
        renderType,
        textureScale,
        pixelFormat,
        pixelDatatype,
        sampler,
        viewportScale,
        shaderRedefine,
        overrideViewport
      } = options;
      // eslint-disable-next-line no-useless-escape
      const passName = "renderPass_" + name.replace(/[\.\\\/\-]/g, "_");
      const nonMainName = `czm_non_${passName}_main`;
      const mainName = `czm_${passName}_main`;
      const rsCacheName = `_cache_${passName}`;
      const commandName = passName + "Command";
      let framebuffer = null;
      let colorTexture = null;
      let depthTexture = null;
      let stage = null;
      let useHdr;
      const clearCommand = new ClearCommand({
        color: Color.TRANSPARENT,
        depth: 1
      });
      let viewport = new BoundingRectangle();
      const scope = this;

    if (overrideViewport) {
      BoundingRectangle.clone(overrideViewport, viewport);
    }
    shaderRedefine = shaderRedefine || "add";
    renderType = renderType || "all";
    textureScale = textureScale || 1;

    if (textureScale < 0 || textureScale > 8) {
      throw new Cesium__namespace.DeveloperError("CesiumRenderPass：textureScale必须大于0小于等于8")
    }

    function getShaderProgram(context, shaderProgram, pickId, pickIdQualifier) {
      let shader = context.shaderCache.getDerivedShaderProgram(shaderProgram, passName);
      if (!defined(shader)) {
        const attributeLocations = shaderProgram._attributeLocations;
        let fs = shaderProgram.fragmentShaderSource;
        let vs = shaderProgram.vertexShaderSource;
        const vsStr = shaderProgram._vertexShaderText;

        //

        let sources = fs.sources;
        let length = sources.length;

        let hasSelected = !!stage && getSelected();

        let czm_selectedFS = cmz_selected_glsl;
        const is3dtiles = /texture2D\s?\(\s?tile_pickTexture\s?,\s?tile_featureSt\s?\)/.test(pickId);
        if (pickIdQualifier === "varying" && !is3dtiles) {
          czm_selectedFS += `
varying float me_isSelected;
bool czm_selected(){
    bool isSelected= me_isSelected>0.0000001;
    if(!isSelected){
        isSelected= czm_selected(${pickId});
    }
    return isSelected;
}
    `;
        } else {
          czm_selectedFS += `
bool czm_selected(){
    return czm_selected(${pickId});
}`;
        }

        const czm_selectedVS =
          cmz_selected_glsl +
          `
varying float me_isSelected;
bool czm_selected(){
    return czm_selected(${pickId});
}
`;

        let hasNormal = false;
          let hasVNormal = false;
        if (/attribute\s?vec3\s?normal\s?;/.test(vsStr) || /\n\s?vec3\s?normal\s?;/.test(vsStr)) {
          hasNormal = true;
        } else if (/varying\s?vec3\s?v_normal\s?;/.test(vsStr)) {
          hasVNormal = true;
        }

        if (fragmentShader) {
          let hasPacking = false;
          for (let i = 0; i < length; ++i) {
            if (/vec4\s?packDepthToRGBA\s?\(/.test(sources[i])) {
              hasPacking = true;
              break
            }
          }

          const newMain =
            (hasPacking ? "" : packing) +
            (hasSelected ? czm_selectedFS : "") +
            ShaderSource.replaceMain(fragmentShader, mainName) +
            "void main() \n" +
            "{ \n" +
            (shaderRedefine !== "replace" ? `    ${nonMainName}(); \n` : "") +
            `    ${mainName}(); \n` +
            "} \n";
          const newSources = new Array(length + 1);
          for (let i = 0; i < length; ++i) {
            newSources[i] = ShaderSource.replaceMain(sources[i], nonMainName);
          }
          newSources[length] = newMain;

          if (hasNormal) {
            fs.defines.push("HAS_NORMAL");
          } else if (hasVNormal) {
            fs.defines.push("HAS_V_NORMAL");
          }

          fs = new ShaderSource({
            sources: newSources,
            defines: fs.defines
          });
        }

        //
        if (vertexShader || fragmentShader) {
          sources = vs.sources;
          length = sources.length;

          let hasPacking = false;
          for (let i = 0; i < length; ++i) {
            if (/vec4\s?packDepthToRGBA\s?\(/.test(sources[i])) {
              hasPacking = true;
              break
            }
          }

          hasSelected = hasSelected && pickIdQualifier === "varying" && !is3dtiles;

          if (hasNormal) {
            vs.defines.push("HAS_NORMAL");
          } else if (hasVNormal) {
            vs.defines.push("HAS_V_NORMAL");
          }

          const newMain =
            (hasPacking ? "" : packing) +
            (hasSelected ? czm_selectedVS : "") +
            ShaderSource.replaceMain(vertexShader || "void main(){}", mainName) +
            "void main() \n" +
            "{ \n" +
            (shaderRedefine !== "replace" ? `    ${nonMainName}(); \n` : "") +
            (hasSelected ? "    me_isSelected=czm_selected()?1.:0.;\n" : "") +
            `    ${mainName}(); \n` +
            "} \n";

          const newSources = new Array(length + 1);
          for (let i = 0; i < length; ++i) {
            newSources[i] = ShaderSource.replaceMain(sources[i], nonMainName);
          }
          newSources[length] = newMain;

          vs = new ShaderSource({
            sources: newSources,
            defines: vs.defines
          });
        }

        shader = context.shaderCache.createDerivedShaderProgram(shaderProgram, passName, {
          vertexShaderSource: vs,
          fragmentShaderSource: fs,
          attributeLocations: attributeLocations
        });
      }

      return shader
    }
    function getRenderState(scene, renderState) {
      scene._renderPassCache = scene._renderPassCache || {};
      scene._renderPassCache[rsCacheName] = scene._renderPassCache[rsCacheName] || {};

      const cache = scene._renderPassCache[rsCacheName];
      let cacheRenderState = cache[renderState.id];
      if (!defined(cacheRenderState)) {
        const rs = RenderState.getState(renderState);
        if (typeof renderStateProcess === "function") {
          renderStateProcess.call(scope, rs);
        }
        cacheRenderState = RenderState.fromCache(rs);
        cache[renderState.id] = cacheRenderState;
      }

      return cacheRenderState
    }
    function createDerivedCommand(command, scene, context) {
      const originalCommand = command;
      const frameState = scene._frameState;
      let derivedCommands = command.derivedCommands;
      if (!defined(derivedCommands)) {
        return
      }

      if (frameState.useLogDepth && defined(derivedCommands.logDepth)) {
        command = derivedCommands.logDepth.command;
      }

      derivedCommands = command.derivedCommands;
      let result = derivedCommands.renderPass;
      if (!defined(derivedCommands.renderPass)) {
        result = derivedCommands.renderPass = {};
      }

      let shader;
      let renderState;
      if (defined(result[commandName])) {
        shader = result[commandName].shaderProgram;
        renderState = result[commandName].renderState;
      }

      result[commandName] = DrawCommand.shallowClone(command, result[commandName]);

      if (!defined(shader) || result.shaderProgramId !== command.shaderProgram.id) {
        const originalSp = command.shaderProgram;
        const pickIdQualifier = (originalCommand._pickIdQualifier = new RegExp(`uniform\\s?vec4\\s?${command.pickId}`, "g").test(
          originalSp._fragmentShaderText
        )
          ? "uniform"
          : "varying");

        result[commandName].shaderProgram = getShaderProgram(context, originalSp, command.pickId, pickIdQualifier);
        result[commandName].renderState = getRenderState(scene, command.renderState);
        result.shaderProgramId = command.shaderProgram.id;
      } else {
        result[commandName].shaderProgram = shader;
        result[commandName].renderState = renderState;
      }

      // uniformMap
      const uniformMap = result[commandName].uniformMap;
      updateUniformMap(uniformMap);
    }
    function getUniformMapFunction(name) {
      return function () {
        const value = uniforms[name];
        if (typeof value === "function") {
          return value()
        }
        return value
      }
    }
    function getUniformMapDimensionsFunction(uniformMap, name) {
      return function () {
        const texture = uniformMap[name]();
        if (defined(texture)) {
          return texture.dimensions
        }
        return undefined
      }
    }

    function updateUniformMap(uniformMap) {
      if (uniformMap.__created) {
        return
      }

      uniformMap.czm_selectedIdTexture = function () {
        return stage._selectedIdTexture
      };

      uniformMap.czm_selectedIdTextureWidth = function () {
        return stage._selectedIdTexture ? stage._selectedIdTexture.width : 0
      };

      uniformMap.czm_selectedIdTextureStep = function () {
        return stage._selectedIdTexture ? 1.0 / stage._selectedIdTexture.width : -1
      };

      if (!uniforms) {
        return
      }
      uniformMap.__created = true;

      for (const name in uniforms) {
        if (uniforms.hasOwnProperty(name)) {
          if (typeof uniforms[name] !== "function") {
            uniformMap[name] = getUniformMapFunction(name);
          } else {
            uniformMap[name] = uniforms[name];
          }

          const value = uniformMap[name]();
          if (
            typeof value === "string" ||
            value instanceof Texture ||
            value instanceof HTMLImageElement ||
            value instanceof HTMLCanvasElement ||
            value instanceof HTMLVideoElement
          ) {
            uniformMap[name + "Dimensions"] = getUniformMapDimensionsFunction(uniformMap, name);
          }
        }
      }
    }

    function udpateDerivedCommands(scene) {
      const view = scene._view;
        const frustumCommandsList = view.frustumCommandsList;
        const numFrustums = frustumCommandsList.length;

      let j, pass, length;
      for (let i = 0; i < numFrustums; ++i) {
        const index = numFrustums - i - 1;
        const frustumCommands = frustumCommandsList[index];

        for (pass = 0; pass < frustumCommands.commands.length; pass++) {
          const commands = frustumCommands.commands[pass];
          length = frustumCommands.indices[pass];
          if (stage && pass === Pass.GLOBE) {
            continue
          }

          for (j = 0; j < length; ++j) {
            const command = commands[j]; // @type {Cesium.DrawCommand}
            createDerivedCommand(command, scene, scene._context);
          }
        }
      }
    }
    function releaseResources() {
      if (colorTexture) {
        colorTexture.destroy();
        framebuffer.destroy();
        framebuffer = undefined;
        colorTexture = undefined;
      }
      if (depthTexture) {
        depthTexture.destroy();
        depthTexture = undefined;
      }
    }
    function updateFramebuffer(context, viewport, hdr, sceneFramebuffer) {
      const width = viewport.width;
      const height = viewport.height;

      if (colorTexture && colorTexture.width === width && colorTexture.height === height && hdr === useHdr) {
        return
      }
      useHdr = hdr;

      releaseResources();

      colorTexture = new Texture({
        context: context,
        width: width,
        height: height,
        pixelFormat: defaultValue(pixelFormat, PixelFormat.RGBA),
        pixelDatatype: defaultValue(pixelDatatype, PixelDatatype.FLOAT),
        sampler: defaultValue(sampler, Sampler.NEAREST)
      });
      depthTexture = new Texture({
        context: context,
        width: width,
        height: height,
        pixelFormat: PixelFormat.DEPTH_COMPONENT,
        pixelDatatype: PixelDatatype.UNSIGNED_SHORT,
        sampler: Sampler.NEAREST
      });

      framebuffer = new Framebuffer({
        colorTextures: [colorTexture],
        context: context,
        destroyAttachments: false,
        depthTexture: depthTexture
        // , depthStencilTexture: sceneFramebuffer._depthStencilTexture,
        // depthStencilRenderbuffer: sceneFramebuffer._depthStencilRenderbuffer
      });
    }

    function getPassState(view) {
      if (!overrideViewport) {
        viewport = BoundingRectangle.clone(view.viewport, viewport);
        if (viewportScale) {
          viewport.x = viewport.width * viewportScale.x;
          viewport.y = viewport.height * viewportScale.y;
          viewport.width *= viewportScale.width;
          viewport.height *= viewportScale.height;
        } else {
          viewport.width *= textureScale;
          viewport.height *= textureScale;
        }
      }

      const passState = Object.assign({}, view.passState);
      passState.viewport = viewport;
      return passState
    }

    function update(context, useLogDepth) {
      const frameState = context._us._frameState;
        const camera = frameState.camera;
        const scene = camera._scene;
        const view = scene._view;

      try {
        if (!vertexShader && !fragmentShader) {
          const passState = getPassState(view);
          if (typeof beforeUpdate === "function") {
            beforeUpdate.call(scope, scene, useLogDepth);
          }
          updateFramebuffer(context, viewport, scene.hdr, view.sceneFramebuffer);
          executeDerivedCommandList(context, framebuffer, passState);
        } else {
          const passState = getPassState(view);
          if (typeof beforeUpdate === "function") {
            beforeUpdate.call(scope, scene, useLogDepth);
          }
          updateFramebuffer(context, viewport, scene.hdr, view.sceneFramebuffer);
          udpateDerivedCommands(scene);
          executeDerivedCommandList(
            context,
            framebuffer,
            passState,
            "renderPass",
            commandName,
            renderType === "all" || !stage || !stage._selectedIdTexture ? null : commandFilter
          );
        }
      } catch (err) {
        console.error(err);
      }
    }

    function getSelected() {
      if (!stage) {
        return
      }
      const selectedFeatures = stage.selected || stage.parentSelected;
      if (selectedFeatures.length) {
        return selectedFeatures
      }
    }

    // 根据stage.selected(被选中的对象)过滤绘图命令，可以减少渲染通道不必要的渲染批次
    function commandFilter(command, scene) {
      const selectedFeatures = stage && (stage.selected || stage.parentSelected);

      if (!stage || !selectedFeatures || !selectedFeatures.length) {
        return false
      }
      if (!command.pickId || command._pickIdQualifier !== "uniform") {
        return true
      }

      let show = true;
        const owner = command.owner;

      const renderSelected = renderType === "selected";

      if (owner && owner.isObject3D) {
        for (let i = 0; i < selectedFeatures.length; i++) {
          const feature = selectedFeatures[i];
          if (feature === owner) {
            return renderSelected
          }
        }
        return !renderSelected
      }

      const uniformMap = command.uniformMap;
      if (uniformMap[command.pickId]) {
        const id = uniformMap[command.pickId]();

        show = !renderSelected;
        for (let i = 0; i < selectedFeatures.length; i++) {
          const feature = selectedFeatures[i];
          const pickIds = feature.pickId ? [feature.pickId] : feature.pickIds || feature._pickIds;
          for (let j = 0; j < pickIds.length; j++) {
            const pickId = pickIds[j];
            if (pickId.color === id || Color.equals(pickId.color, id)) {
              return renderSelected
            }
          }
        }
      }

      return show
    }

    function clear(context) {
      if (framebuffer) {
        const view = context._us._frameState.camera._scene._view;
        clearCommand.framebuffer = framebuffer;
        clearCommand.execute(context, view.passState);
        clearCommand.framebuffer = undefined;
      }
    }

    function bindStage(pStage) {
      if (stage && scope.prevStageUpdate) {
        stage.update = scope.prevStageUpdate;
        scope.prevStageUpdate = null;
        scope.prevStageExecute = null;
      }

      stage = pStage;
      if (!stage) {
        return
      }

      const oldUpdate = stage.update;
      scope.prevStageUpdate = oldUpdate;

      stage.update = function (context, useLogDepth) {
        clear(context);
        oldUpdate.call(stage, context, useLogDepth);

        if (!stage.enabled) {
          return
        }

        if (!vertexShader && !fragmentShader) {
          update(context, useLogDepth);
        } else {
          const selectedFeatures = stage.selected || stage.parentSelected;
          if (selectedFeatures && selectedFeatures.length) {
            update(context, useLogDepth);
          }
        }
      };
    }

    this.update = update;
    this.clear = clear;

    Object.defineProperties(this, {
      texture: {
        get() {
          return colorTexture
        }
      },
      depthTexture: {
        get() {
          return depthTexture
        }
      },
      stage: {
        get() {
          return stage
        },
        set(val) {
          if (stage !== val) {
            bindStage(val);
          }
        }
      }
    });
  }

  const _shadersSeparableBlur = `
    varying vec2 v_textureCoordinates;
    uniform sampler2D colorTexture;
    uniform vec2 colorTextureDimensions;
    uniform vec2 direction;
    uniform float kernelRadius;

    float gaussianPdf(in float x, in float sigma) {
        return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
    }
    void main() {
        vec2 vUv=v_textureCoordinates;
        vec2 invSize = 1.0 / colorTextureDimensions;
        float weightSum = gaussianPdf(0.0, kernelRadius);
        vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
        vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
        vec2 uvOffset = delta;
        for( int i = 1; i <= MAX_RADIUS; i ++ ) {
            float w = gaussianPdf(uvOffset.x, kernelRadius);
            vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
            vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
            diffuseSum += ((sample1 + sample2) * w);
            weightSum += (2.0 * w);
            uvOffset += delta;
        }\
        gl_FragColor = diffuseSum/weightSum;
    }`;

  // 创建高斯模糊后期处理节点（返回结果已包含x、y两个方向）
  function createBlurStage(name, maxRadius, kernelRadius, textureScale) {
    const { Cartesian2, PostProcessStage, PostProcessStageComposite, PostProcessStageSampleMode } = Cesium__namespace;

    const blurDirectionX = new Cartesian2(1.0, 0.0);
    const blurDirectionY = new Cartesian2(0.0, 1.0);

    const separableBlurShader = {
      defines: {
        MAX_RADIUS: maxRadius
      },
      fragmentShader: _shadersSeparableBlur
    };
    parseDefines(separableBlurShader);

    const blurX = new PostProcessStage({
      name: name + "_x_direction",
      fragmentShader: separableBlurShader.fragmentShader,
      textureScale: textureScale,
      forcePowerOfTwo: true,
      uniforms: {
        kernelRadius: kernelRadius,
        direction: blurDirectionX
      },
      sampleMode: PostProcessStageSampleMode.LINEAR
    });

    const blurY = new PostProcessStage({
      name: name + "_y_direction",
      fragmentShader: separableBlurShader.fragmentShader,
      textureScale: textureScale,
      forcePowerOfTwo: true,
      uniforms: {
        kernelRadius: kernelRadius,
        direction: blurDirectionY
      },
      sampleMode: PostProcessStageSampleMode.LINEAR
    });

    const separableBlur = new PostProcessStageComposite({
      name: name,
      stages: [blurX, blurY],
      inputPreviousStageTexture: true
    });
    return separableBlur
  }

  function parseDefines(shader) {
    let defines = [];
    for (const key in shader.defines) {
      if (shader.defines.hasOwnProperty(key)) {
        const val = shader.defines[key];
        defines.push("#define " + key + " " + val);
      }
    }
    defines = defines.join("\n") + "\n";
    if (shader.fragmentShader) {
      shader.fragmentShader = defines + shader.fragmentShader;
    }
    if (shader.vertexShader) {
      shader.vertexShader = defines + shader.vertexShader;
    }
    return shader
  }

  /**
   * 对象轮廓描边效果 支持的参数信息
   *
   * @typedef {Object} OutlineEffect.Options
   *
   * @property {Number} [width = 6] 线宽，单位：像素px
   * @property {String|Cesium.Color} [color = Cesium.Color.WHITE] 轮廓线 颜色
   * @property {String|Cesium.Color} [colorHidden = color] 被遮挡的轮廓线 颜色
   * @property {Boolean} [showPlane = false]  是否显示边缘同一个平面（按thresholdAngle属性定义）
   * @property {Number} [planeAngle = 10]  如果两个三角面的法线间夹角小于该值 则标记为同一个平面。该值的单位：角度
   * @property {Boolean} [glow = false]  是否显示发光
   * @property {Number} [glowPower = 1] 发光强度
   * @property {Number} [glowStrength = 3] 发光的增量
   * @property {Boolean} [onlySelected = false] 只显示选中构件
   */

  /**
   * 对象轮廓描边效果
   *
   * @param {OutlineEffect.Options} [options] 参数对象
   * @param {EventType|Boolean} [options.eventType = "click"] 高亮触发的事件类型，默认为单击。可选值：单击、鼠标移入,false时不内部控制
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @export
   * @class OutlineEffect
   * @extends {BaseEffect}
   */
  class OutlineEffect extends BaseEffect {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);
      this.setOptions(options);
    }

    /**
     * 选中对象
     * @type {Object|Object[]|undefined}
     */
    get selected() {
      return this._postProcessStage?.selected
    }

    set selected(value) {
      let pickIds = [];
      if (value) {
        if (!Array.isArray(value)) {
          pickIds = [{ pickId: value }];
        } else {
          value.forEach((item) => {
            pickIds.push({ pickId: item });
          });
        }
      }

      if (this._postProcessStage) {
        this._postProcessStage.selected = pickIds;
        this._postProcessStage.enabled = this.enabled && this.selected.length > 0;
      }
    }

    /**
     * 轮廓线 颜色
     * @type {String|Cesium.Color}
     */
    get color() {
      return this._color
    }

    set color(value) {
      this._color = getCesiumColor(value);
      this._useSingleColor = !this._colorHidden || this._color.equals(this._colorHidden);
    }

    /**
     * 被遮挡的轮廓线 颜色
     * @type {String|Cesium.Color}
     */
    get colorHidden() {
      if (Cesium__namespace.defined(this._colorHidden)) {
        return this._colorHidden
      } else {
        return this._color
      }
    }

    set colorHidden(value) {
      this._colorHidden = getCesiumColor(value);
      this._useSingleColor = !this._colorHidden || this._color.equals(this._colorHidden);
    }

    /**
     * 如果两个三角面的法线间夹角小于该值 则标记为同一个平面。该值的单位：角度
     * @type {Number}
     * @default 5
     */
    get planeAngle() {
      return this._planeAngle
    }

    set planeAngle(value) {
      this._planeAngle = value;
      this._planeAngleRadians = Cesium__namespace.Math.toRadians(value);
    }

    _enabledHook(val) {
      if (this._postProcessStage) {
        this._postProcessStage.enabled = val && this.selected.length > 0;
      }
    }

    /**
     * 重新赋值参数，同构造方法参数一致。
     * @param {Object} options 参数,与类的构造方法参数相同
     * @return {OutlineEffect} 当前对象本身，可以链式调用
     */
    setOptions(options) {
      /**
       * 高亮触发的事件类型，默认为单击。
       * @type {EventType|String}
       * @default 'click'
       */
      this.eventType = options.eventType ?? EventType.click;

      /**
       * 轮廓线 宽度，单位：像素px
       * @type {Number}
       * @default 3
       */
      this.width = options.width ?? 6;

      this.color = getCesiumColor(options.color, Cesium__namespace.Color.WHITE);

      this.colorHidden = options.colorHidden;

      /**
       * 是否显示边缘同一个平面（按thresholdAngle属性定义）
       * @type {boolean}
       * @default false
       */
      this.showPlane = options.showPlane ?? false;

      this.planeAngle = options.planeAngle ?? 10;

      /**
       * 是否显示发光
       * @type {boolean}
       * @default false
       */
      this.glow = options.glow ?? false;

      /**
       * 发光强度
       * @type {Number}
       * @default 1
       */
      this.glowPower = options.glowPower ?? 1;
      /**
       * 发光的增量
       * @type {Number}
       * @default 3
       */
      this.glowStrength = options.glowStrength ?? 3;

      /**
       * 只显示选中构件
       * @type {boolean}
       * @default false
       */
      this.onlySelected = options.onlySelected ?? false;
    }

    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      const that = this;
      const normalDepthPass = new CesiumRenderPass({
        name: this.name + "Pass",
        vertexShader: `
          varying vec3 vOutlineNormal;
          void main(){
              #ifdef HAS_NORMAL
                  vOutlineNormal = normal;
              #else
                  #ifdef HAS_V_NORMAL
                      vOutlineNormal = v_normal;
                  #else
                      vOutlineNormal=vec3(0.);
                  #endif
              #endif
          } `,
        fragmentShader: `
        varying vec3 vOutlineNormal;
        void main(){
            if(!czm_selected())discard;
            if(length(vOutlineNormal)>0.)gl_FragColor=vec4( vOutlineNormal ,gl_FragColor.a);
        }`,
        sampler: new Cesium__namespace.Sampler({
          minificationFilter: Cesium__namespace.TextureMinificationFilter.LINEAR,
          magnificationFilter: Cesium__namespace.TextureMagnificationFilter.LINEAR
        })
      });

      const maskStage = new Cesium__namespace.PostProcessStage({
        name: this.name + "Mask",
        uniforms: {
          outlineWidth() {
            return that.width
          },
          devicePixelRatio: devicePixelRatio,
          thresholdAngle: function () {
            return that._planeAngleRadians
          },
          // true则遮挡和未被遮挡的轮廓线都使用同一个颜色，这样可以提升一小部分性能
          useSingleColor: function () {
            return that._useSingleColor
          },
          showOutlineOnly: function () {
            return !that.showPlane
          },
          visibleEdgeColor: function () {
            return that.color
          },
          hiddenEdgeColor: function () {
            return that.colorHidden
          },
          maskTexture() {
            return normalDepthPass.texture
          },
          maskDepthTexture() {
            return normalDepthPass.depthTexture
          }
        },
        fragmentShader: `
    uniform sampler2D colorTexture;
    uniform vec2 colorTextureDimensions;
    uniform sampler2D depthTexture;

    uniform sampler2D maskTexture;
    uniform sampler2D maskDepthTexture;
    uniform float thresholdAngle;
    uniform bool showOutlineOnly;

    uniform float outlineWidth;
    uniform float devicePixelRatio;
    uniform vec3 visibleEdgeColor;
    uniform vec3 hiddenEdgeColor;
    uniform bool useSingleColor;

    varying vec2 v_textureCoordinates;

    float lengthSq(vec3 v){
        return v.x * v.x + v.y * v.y + v.z * v.z;
    }
    float normal_angleTo(vec3 a,vec3 b){
        float denominator =  sqrt(  lengthSq(a) * lengthSq(b) );
        if ( denominator == 0. ) return czm_pi / 2.;
        float theta = dot(a, b ) / denominator;
        // clamp, to handle numerical problems
        return  acos(  clamp( theta, - 1., 1. ) );
    }

    float compareNormal(vec4 n1,vec4 n2){
          if(  abs (  normal_angleTo( n1.xyz , n2.xyz ) ) < thresholdAngle ){
              return 0.;
          }else{
              return 1.;
          }
    }

    float compareDepth(const in vec2 uv){
        float maskDepth = czm_readDepth( maskDepthTexture, uv);
        float nonDepth = czm_readDepth( depthTexture, uv);
        return maskDepth>nonDepth?1.:0.;
    }

    void main(){

        vec2 vUv=v_textureCoordinates;

        // vec4 color = texture2D( colorTexture, vUv);
        vec4 maskColor = texture2D( maskTexture, vUv);

        if( maskColor.a < 0.0001){
            // gl_FragColor =color;
            discard;
            return;
        }

        vec2 invSize = outlineWidth / colorTextureDimensions;
        vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);

        vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
        vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
        vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
        vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);

        float d;
        if(showOutlineOnly){
            float diff1 = (c1.a - c2.a)*0.5;
            float diff2 = (c3.a - c4.a)*0.5;
            d = length( vec2(diff1, diff2) );
        }
        else{
            float diff1 = compareNormal(c1,c2)*0.5;
            float diff2 = compareNormal(c3,c4)*0.5;
            d = length( vec2(diff1, diff2) );
        }

        if(useSingleColor==false){
            float dp1 = compareDepth( vUv + uvOffset.xy);
            float dp2 = compareDepth( vUv - uvOffset.xy);
            float dp3 = compareDepth( vUv + uvOffset.yw);
            float dp4 = compareDepth( vUv - uvOffset.yw);

            float a1 = min(dp1, dp2);
            float a2 = min(dp3, dp4);
            float visibilityFactor = min(a1, a2);
            vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;

            // gl_FragColor =color+ vec4( edgeColor , 1. ) * vec4(d);
            gl_FragColor = vec4( edgeColor , 1. ) * vec4(d);
        }else{
            // gl_FragColor =color+ vec4( visibleEdgeColor , 1. ) * vec4(d);
            gl_FragColor =  vec4( visibleEdgeColor , 1. ) * vec4(d);
        }
    }
    `
      });
      normalDepthPass.stage = maskStage;

      const blurStage1 = createBlurStage(this.name + "Blur1", 4, 1, 0.75);
      const blurStage2 = createBlurStage(this.name + "Blur2", 4, 4, 0.5);

      const blurCompositeStage = new Cesium__namespace.PostProcessStageComposite({
        name: this.name + "BlurComposite",
        stages: [maskStage, blurStage1, blurStage2],
        inputPreviousStageTexture: true
      });

      const addStage = new Cesium__namespace.PostProcessStage({
        name: this.name + "Additive",
        uniforms: {
          showGlow: function () {
            return that.glow
          },
          edgeGlow: function () {
            return that.glowPower
          },
          edgeStrength: function () {
            return that.glowStrength
          },
          edgeOnly() {
            return that.onlySelected
          },
          maskTexture() {
            return normalDepthPass.texture
          },
          lineTexture: maskStage.name,
          edgeTexture1: blurStage1.name,
          edgeTexture2: blurCompositeStage.name
        },
        fragmentShader: `
    uniform sampler2D colorTexture;
    uniform sampler2D edgeTexture1;
    uniform sampler2D edgeTexture2;
    uniform sampler2D lineTexture;
    uniform sampler2D maskTexture;
    uniform bool showGlow;
    uniform float edgeGlow;
    uniform bool edgeOnly;
    uniform float edgeStrength;

    varying vec2 v_textureCoordinates;
    void main(){

        vec2 vUv =v_textureCoordinates;
        vec4 edgeColor=texture2D( lineTexture, vUv);
        vec4 color=texture2D( colorTexture, vUv);
        float opacity=1.;
        if(edgeOnly){
            vec4 maskColor=texture2D( maskTexture, vUv);
            opacity=1.-maskColor.a;
            gl_FragColor = maskColor;
            return;
        }

        if(showGlow){
            float visFactor= czm_selected()?1.:0.;
            vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
            vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
            vec4 glowColor = edgeValue1 + edgeValue2 * edgeGlow;
            gl_FragColor = opacity * color + edgeColor + edgeStrength * (1. - edgeColor.r) * glowColor;
        }
        else{
            gl_FragColor = opacity * color + edgeColor;
        }
    }
    `
      });

      const compositeStage = new Cesium__namespace.PostProcessStageComposite({
        name: this.name + "Composite",
        stages: [blurCompositeStage, addStage],
        inputPreviousStageTexture: false
      });

      function defUniforms(obj) {
        Object.defineProperties(obj, {
          showGlow: {
            get() {
              return that.glow
            },
            set(val) {
              that.glow = val;
            }
          },
          edgeGlow: {
            get() {
              return that.glowPower
            },
            set(val) {
              that.glowPower = val;
            }
          },
          edgeStrength: {
            get() {
              return that.glowStrength
            },
            set(val) {
              that.glowStrength = val;
            }
          },
          thresholdAngle: {
            get() {
              return that._planeAngleRadians
            },
            set(val) {
              that._planeAngleRadians = val;
            }
          },
          showOutlineOnly: {
            get() {
              return !that.showPlane
            },
            set(val) {
              that.showPlane = !val;
            }
          },
          edgeOnly: {
            get() {
              return that.onlySelected
            },
            set(val) {
              that.onlySelected = val;
            }
          },
          useSingleColor: {
            get() {
              return that._useSingleColor
            }
          },
          outlineWidth: {
            get() {
              return that.width
            },
            set(val) {
              that.width = val;
            }
          },
          visibleEdgeColor: {
            get() {
              return that.color
            },
            set(val) {
              that.color = val;
            }
          },
          hiddenEdgeColor: {
            get() {
              return that.colorHidden
            },
            set(val) {
              that.colorHidden = val;
            }
          }
        });
      }

      defUniforms(compositeStage);
      compositeStage._uniforms = compositeStage._uniforms || {};
      defUniforms(compositeStage._uniforms);

      compositeStage.selected = [];
      compositeStage.enabled = false;

      this._postProcessStage = compositeStage;
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      if (this.eventType) {
        this._map.on(this.eventType, this._map_clickHandler, this);
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this.eventType) {
        this._map.off(this.eventType, this._map_clickHandler, this);
      }
    }

    _map_clickHandler(event) {
      const picked = this._map.mouseEvent.getPicked(event);
      // console.log("拾取的对象", picked);
      this.selected = picked;
    }
  }

  // 注册下
  register("outline", OutlineEffect);

  /**
   * 选中对象的 泛光效果。
   *
   * @param {BloomTargetEffect.Options} [options] 参数对象
   * @param {EventType|Boolean} [options.eventType = "click"] 高亮触发的事件类型，默认为单击。可选值：单击、鼠标移入,false时不内部控制
   *
   * @param {Cesium.Color} [options.color = Cesium.Color.WHITE] 泛光颜色
   * @param {Number} [options.contrast = 128]  对比度,取值范围[-255.0,255.0]
   * @param {Number} [options.brightness = -0.3]  亮度, 将输入纹理的RGB值转换为色相、饱和度和亮度(HSB)，然后将该值添加到亮度中。
   * @param {Number} [options.blurSamples = 32] 模糊样本
   * @param {Number} [options.delta =  1.0]  增量
   * @param {Number} [options.sigma =  3.78]  delta和sigma用于计算高斯滤波器的权值。方程是 <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>。
   * @param {Number} [options.stepSize = 5.0]  步长,是下一个texel的距离
   * @param {Number} [options.ratio = 2.0] 亮度增强比例
   * @param {Number} [options.threshold = 0.0] 亮度阈值
   * @param {Number} [options.smoothWidth = 0.01]  亮度光滑的宽度
   *
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @export
   * @class BloomTargetEffect
   * @extends {BaseEffect}
   */
  class BloomTargetEffect extends BaseEffect {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      options = {
        contrast: 128.0,
        brightness: -0.3,
        blurSamples: 32,
        delta: 1.0,
        sigma: 3.78,
        stepSize: 5.0,

        ratio: 2.0,
        threshold: 0.0,
        smoothWidth: 0.01,

        ...options
      };
      super(options);

      /**
       * 发光颜色
       * @type {Cesium.Color}
       * @default Cesium.Color.WHITE
       */
      this.color = getCesiumColor(options.color, Cesium__namespace.Color.WHITE);

      /**
       * 高亮触发的事件类型，默认为单击。
       * @type {EventType|String}
       * @default 'click'
       */
      this.eventType = options.eventType ?? EventType.click;
    }

    /**
     * 选中对象
     * @type {Object|Object[]|undefined}
     */
    get selected() {
      return this._postProcessStage?.selected
    }

    set selected(value) {
      let pickIds = [];
      if (value) {
        if (!Array.isArray(value)) {
          pickIds = [{ pickId: value }];
        } else {
          value.forEach((item) => {
            pickIds.push({ pickId: item });
          });
        }
      }

      if (this._postProcessStage) {
        this._postProcessStage.selected = pickIds;
        this._postProcessStage.enabled = this.enabled && this.selected.length > 0;
      }
    }

    _enabledHook(val) {
      if (this._postProcessStage) {
        this._postProcessStage.enabled = val && this.selected.length > 0;
      }
    }

    /**
     * 创建_postProcessStage效果对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {

      // 创建高亮后处理
      const highPass = new Cesium__namespace.PostProcessStage({
        name: this.name + "high",
        fragmentShader: `
        uniform sampler2D colorTexture;
        uniform vec3 marsColor;
        uniform float marsOpacity;
        uniform float threshold;
        uniform float smoothWidth;

        varying vec2 v_textureCoordinates;
        void main() {
          vec4 marstexel = texture2D( colorTexture, v_textureCoordinates );

          #ifdef CZM_SELECTED_FEATURE
            if (!czm_selected()) {
                marstexel = vec4(0.);
            }
          #endif

          vec3 luma = vec3( 0.299, 0.587, 0.114 );
          float marsv = dot( marstexel.xyz, luma );
          vec4 outputColor = vec4(marsColor.rgb,marsOpacity);
          float alpha = smoothstep(threshold, threshold + smoothWidth, marsv);
          gl_FragColor = mix( outputColor, marstexel, alpha );
        }`,
        uniforms: {
          marsColor: Cesium__namespace.Color.BLACK, // 场景颜色
          marsOpacity: 1,
          smoothWidth: () => {
            return this.options.smoothWidth
          },
          threshold: () => {
            return this.options.threshold
          }
        }
      });

      const gaussianBlur1DFS = `
    #define SAMPLES ${this.options.blurSamples}
    uniform sampler2D colorTexture;
    uniform float direction;

    uniform float delta;
    uniform float sigma;
    uniform float stepSize;

    varying vec2 v_textureCoordinates;
    void main()
    {
      vec2 st = v_textureCoordinates;
      vec2 dir = vec2(1.0 - direction, direction);
      vec2 step = vec2(stepSize * (czm_pixelRatio / czm_viewport.zw));

      vec3 g;
      g.x = 1.0 / (sqrt(czm_twoPi) * sigma);
      g.y = exp((-0.5 * delta * delta) / (sigma * sigma));
      g.z = g.y * g.y;
      vec4 result = texture2D(colorTexture, st) * g.x;

      for (int i = 1; i < SAMPLES; ++i)
      {
        g.xy *= g.yz;
        vec2 offset = float(i) * dir * step;
        result += texture2D(colorTexture, st - offset) * g.x;
        result += texture2D(colorTexture, st + offset) * g.x;
      }
      gl_FragColor = result;
    }
    `;

      const blurX = new Cesium__namespace.PostProcessStage({
        name: this.name + "blur_x",
        fragmentShader: gaussianBlur1DFS,
        uniforms: {
          delta: () => {
            return this.options.delta
          },
          sigma: () => {
            return this.options.sigma
          },
          stepSize: () => {
            return this.options.stepSize
          },
          direction: 0.0
        },
        sampleMode: Cesium__namespace.PostProcessStageSampleMode.LINEAR
      });
      const blurY = new Cesium__namespace.PostProcessStage({
        name: this.name + "blur_y",
        fragmentShader: gaussianBlur1DFS,
        uniforms: {
          delta: () => {
            return this.options.delta
          },
          sigma: () => {
            return this.options.sigma
          },
          stepSize: () => {
            return this.options.stepSize
          },
          direction: 1.0
        },
        sampleMode: Cesium__namespace.PostProcessStageSampleMode.LINEAR
      });

      const blurPass = new Cesium__namespace.PostProcessStageComposite({
        name: this.name + "blur",
        stages: [blurX, blurY]
      });
      const blurComposite = new Cesium__namespace.PostProcessStageComposite({
        name: this.name + "_blur_comp",
        stages: [highPass, blurPass],
        inputPreviousStageTexture: true
      });

      const contrastBias = new Cesium__namespace.PostProcessStage({
        name: this.name + "contrast_bias",
        fragmentShader: `
        uniform sampler2D colorTexture;
        varying vec2 v_textureCoordinates;
        uniform float contrast;
        uniform float brightness;
        void main(void)
        {
            vec3 sceneColor = texture2D(colorTexture, v_textureCoordinates).xyz;
            sceneColor = czm_RGBToHSB(sceneColor);
            sceneColor.z += brightness;
            sceneColor = czm_HSBToRGB(sceneColor);
            float factor = (259.0 * (contrast + 255.0)) / (255.0 * (259.0 - contrast));
            sceneColor = factor * (sceneColor - vec3(0.5)) + vec3(0.5);
            gl_FragColor = vec4(sceneColor, 1.0);
        }`,
        uniforms: {
          contrast: () => {
            return this.options.contrast
          },
          brightness: () => {
            return this.options.brightness
          }
        }
      });

      const generateComposite = new Cesium__namespace.PostProcessStageComposite({
        name: this.name + "contrast_bias_blur",
        stages: [contrastBias, blurComposite]
      });

      const bloomComposite = new Cesium__namespace.PostProcessStage({
        name: this.name + "generate_composite",
        fragmentShader: `
      uniform sampler2D colorTexture;
      uniform sampler2D bloomTexture;
      uniform float ratio;
      uniform vec4 color;
      varying vec2 v_textureCoordinates;
      void main(void)
      {
        vec4 color1 = texture2D(colorTexture, v_textureCoordinates);
        vec4 bloom = texture2D(bloomTexture, v_textureCoordinates);
        bloom *= color ;
        #ifdef CZM_SELECTED_FEATURE
          if (czm_selected()) {
            bloom *= ratio;
          }
        #endif
        gl_FragColor = bloom + color1;
      }`,
        uniforms: {
          bloomTexture: generateComposite.name,
          ratio: () => {
            return this.options.ratio
          },
          color: () => {
            return this.color
          }
        }
      });

      this._postProcessStage = new Cesium__namespace.PostProcessStageComposite({
        name: this.name,
        stages: [generateComposite, bloomComposite],
        inputPreviousStageTexture: false
      });
      this._postProcessStage.selected = [];
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      if (this.eventType) {
        this._map.on(this.eventType, this._map_clickHandler, this);
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this.eventType) {
        this._map.off(this.eventType, this._map_clickHandler, this);
      }
    }

    _map_clickHandler(event) {
      const picked = this._map.mouseEvent.getPicked(event);
      // console.log("拾取的对象", picked);
      this.selected = picked;
    }
  }

  // 注册下
  register("bloomTarget", BloomTargetEffect);

  var index$2 = {
    __proto__: null,
    BaseEffect: BaseEffect,
    FogEffect: FogEffect,
    RainEffect: RainEffect,
    SnowEffect: SnowEffect,
    SnowCoverEffect: SnowCoverEffect,
    InvertedEffect: InvertedEffect,
    NightVisionEffect: NightVisionEffect,
    BloomEffect: BloomEffect,
    BrightnessEffect: BrightnessEffect,
    BlackAndWhiteEffect: BlackAndWhiteEffect,
    MosaicEffect: MosaicEffect,
    DepthOfFieldEffect: DepthOfFieldEffect,
    OutlineEffect: OutlineEffect,
    BloomTargetEffect: BloomTargetEffect
  };

  /**
   * 控件 基类
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class BaseControl
   * @extends {BaseThing}
   */
  class BaseControl extends BaseThing {
    /**
     *  设置DOM容器的显示隐藏
     * @type {Boolean}
     *
     */
    get show() {
      return this._show
    }

    set show(show) {
      if (this._show === show) {
        return
      }
      this._show = show;

      if (this._container) {
        this._container.style.display = show ? "block" : "none";
      }
      this._showHook && this._showHook(show);
    }

    /**
     * 控件类型
     *
     * @type {String}
     * @readonly
     */
    get type() {
      return this._type
    }

    /**
     *  当前控件的DOM对象
     * @type {HTMLElement}
     * @readonly
     */
    get container() {
      return this._container
    }

    /**
     *  父容器DOM对象
     * @type {HTMLElement}
     * @readonly
     */
    get parentContainer() {
      if (this.options.parentContainer) {
        return this.options.parentContainer
      }
      return this._map?.container
    }

    /**
     *  父容器DOM对象的ID
     * @type {String}
     * @readonly
     */
    get parentContainerId() {
      return this.parentContainer?.id
    }

    /**
     * 添加到地图上，同 map.addControl
     *
     * @param {Map} map 地图对象
     * @return {BaseControl} 当前对象本身，可以链式调用
     */
    addTo(map) {
      if (map && map.addControl) {
        map.addControl(this);
      }
      return this
    }

    /**
     * 从地图上移除，同map.removeControl
     *
     * @param {Boolean} [destroy] 是否调用destroy释放
     * @return {void}  无
     */
    remove(destroy) {
      if (this._map) {
        this._map.removeControl(this, destroy);
      }
    }

    /**
     * 添加到地图上的钩子方法
     *
     * @param {Map} map 地图对象
     * @return {void}  无
     * @private
     */
    _onAdd(map) {
      if (this._state === State.ADDED) {
        return
      }
      this._map = map;

      if (this._container) {
        if (!this._container.parentNode) {
          this._addChildContainer(this._container);
        }
      } else {
        this._mountedHook && this._mountedHook();
        if (this._container) {
          this._addChildContainer(this._container);
        }
      }
      this._addedHook && this._addedHook();

      this._state = State.ADDED;
    }

    _addChildContainer(container) {
      if (this.options.insertBefore) {
        this.parentContainer.insertBefore(container, this.options.insertBefore);
      } else if (Cesium__namespace.defined(this.options.insertIndex)) {
        const childNodes = this.parentContainer.childNodes;
        if (childNodes.length < this.options.insertIndex) {
          this.options.insertIndex = 0;
        }
        this.parentContainer.insertBefore(container, childNodes[this.options.insertIndex]);
      } else {
        this.parentContainer.appendChild(container);
      }
    }

    /**
     * 从地图上移除的钩子方法
     *
     * @return {void}  无
     * @private
     */
    _onRemove() {
      if (this._state !== State.ADDED) {
        return
      }

      if (!this._map) {
        return
      }
      if (this._container && this._container.parentNode) {
        this.parentContainer.removeChild(this._container);
      }
      this._removedHook && this._removedHook();

      this._map = null;

      this._state = State.REMOVED;
    }

    /**
     * 对象添加到地图前创建一些对象的钩子方法，
     * 只会调用一次
     *
     * @abstract
     * @return {void}  无
     */
    _mountedHook() {}

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */
    _addedHook() {}

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     *
     * @abstract
     * @return {void}  无
     *
     */
    _removedHook() {}

    /**
     * 设置新的css样式信息
     *
     * @param {Object} style css样式
     * @return {void}  无
     */
    setStyle(style) {
      merge(this._container.style, style);
      return this
    }

    _createIcon(icon, container, className = "") {
      if (!icon) {
        return ""
      }

      if (!container) {
        container = create$3("div");
      }

      icon = trim(icon);

      if (icon.startsWith("<?xml") || icon.startsWith("<svg")) {
        // 支持svg
        container.appendChild(parseDom(icon, true, className));
      } else if (icon.startsWith("data:image") || icon.endsWith(".svg") || icon.endsWith(".png") || icon.endsWith(".jpg")) {
        // 支持base64或url图片
        const image = create$3("img", className, container);
        image.setAttribute("src", icon);
      } else {
        // 支持 font-class 的字体方式图标
        create$3("i", className + " " + icon, container);
      }
      return container.innerHTML
    }

    _getTimeline() {
      return this._map.controls.timeline || this._map.viewer.timeline
    }

    fire(type, data = {}, propagate) {
      if (!data.control) {
        data.control = this;
      }
      return super.fire(type, data, propagate)
    }

    // 销毁
    destroy(noDel) {
      this.enabled = false;
      super.destroy(noDel);
    }
  }

  /**
   * @typedef {Object} LocationBar.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} change 数据变化了
   *
   * @example
   * //绑定监听事件
   * thing.on(mars3d.EventType.change, function (event) {
   *   console.log('数据变化了', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 信息状态栏, 一般在页面下侧区域，包括鼠标经纬度等信息
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|String[]} [options.template] 展示的内容格式化字符串, 为数组时按多语言顺序定义，如[中文、繁体、英文]
   * 支持以下模版配置：
   * 【鼠标所在位置】 经度:{lng}， 纬度:{lat}， 海拔：{alt}米， 横{crsx}  纵{crsy}
   * 【相机的】 方向角度：{heading}， 俯仰角度：{pitch}， 视高：{cameraHeight}米，
   * 【地图的】 层级：{level}
   * @param {Number} [options.latDecimal = LngLatPoint.FormatLength]  保留的{lat}和{lng}的小数位
   *
   * @param {String|CRS|Boolean} [options.crs] 按指定坐标系显示坐标值,true时取值CRS.CGCS2000_GK_Zone_3，配置后template可以加模板：【鼠标所在位置对应的crs坐标系】 X或经度值：{crsx}， Y或纬度值：{crsy}
   * @param {Number} [options.crsDecimal = 1]  保留的{crsx}和{crsy}的小数位
   *
   *
   * @param {Object} [options.style] 可以CSS样式，如:
   * @param {String} [options.style.top]   css定位top位置, 如 top: '10px'
   * @param {String} [options.style.bottom]   css定位bottom位置
   * @param {String} [options.style.left]   css定位left位置
   * @param {String} [options.style.right]   css定位right位置
   * @param {Boolean} [options.fps = false] 是否显示实时FPS帧率
   * @param {Number} [options.cacheTime = 50]  鼠标移动的缓存时间
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @export
   * @class LocationBar
   * @extends {BaseControl}
   *
   * @see [支持的事件类型]{@link LocationBar.EventType}
   */
  class LocationBar extends BaseControl {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      // 默认值
      this.options.cacheTime = this.options.cacheTime ?? 50;

      /**
       * 显示的数据
       * @type {Object}
       * @readonly
       */
      this.locationData = {};
    }

    //= ========= 方法 ==========

    /**
     * 创建_container控件容器对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      if (this.options.template) {
        if (Array.isArray(this.options.template)) {
          this.template = this.options.template[this._map.lang];
        } else {
          this.template = this.options.template;
        }
      } else {
        this.template =
          "<div>经度:{lng}</div> <div>纬度:{lat}</div><div>海拔：{alt}米</div> <div class='hide700'>层级：{level}</div><div>方向：{heading}°</div> <div>俯仰角：{pitch}°</div><div class='hide700'>视高：{cameraHeight}米</div>";
      }
      if (Cesium__namespace.defined(this.options.crs)) {
        if (isString(this.options.crs)) {
          this._crs = this.options.crs;
        } else if (this.options.crs) {
          this._crs = CRS.CGCS2000_GK_Zone_3;
        }
      } else if (isString(this.template) && this.template.indexOf("{crsx}") !== -1) {
        this._crs = CRS.CGCS2000_GK_Zone_3; // 横{crsx}  纵{crsy}
      }

      this._container = create$3("div", "mars3d-locationbar no-print");
      this._containerCon = create$3("div", "mars3d-locationbar-content", this._container);

      if (this.options.style) {
        this.setStyle(this.options.style);
      } else {
        this.setStyle({
          left: this._map.viewer.animation ? "170px" : "0",
          right: "0",
          bottom: this._getTimeline() ? "25px" : "0"
        });
      }

      this.locationData.cameraHeight = this._map.camera.positionCartographic.height.toFixed(1);
      this.locationData.heading = Cesium__namespace.Math.toDegrees(this._map.camera.heading).toFixed(0);
      this.locationData.pitch = Cesium__namespace.Math.toDegrees(this._map.camera.pitch).toFixed(0);

      // 帧率
      if (this.options.fps) {
        // 帧率的计算借助了Cesium中的东西，需要开启debugShowFramesPerSecond
        this._map.scene.debugShowFramesPerSecond = true;

        const timeTik = setInterval(() => {
          if (!this._map || !this._map.scene._performanceDisplay) {
            return
          }
          clearInterval(timeTik);
          this.timeTik = null;

          const domFPS = this._map.container.querySelector(".cesium-performanceDisplay");

          // 修改样式
          addClass(domFPS, "mars3d-locationbar-content");
          removeClass(domFPS, "cesium-performanceDisplay");

          // 移除空节点
          const throttled = domFPS.querySelector(".cesium-performanceDisplay-throttled");
          remove(throttled);

          // 添加到状态栏
          domFPS.parentNode.removeChild(domFPS);
          this._container.insertBefore(domFPS, this._containerCon);
        }, 500);
        this.timeTik = timeTik;
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.on(EventType.mouseMove, this._mouseMoveHandler, this);
      this._map.on(EventType.cameraMoveEnd, this._cameraHandler, this);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.off(EventType.mouseMove, this._mouseMoveHandler, this);
      this._map.off(EventType.cameraMoveEnd, this._cameraHandler, this);

      if (this.options.fps) {
        this._map.scene.debugShowFramesPerSecond = false;
      }
      if (this.timeTik) {
        clearInterval(this.timeTik);
        this.timeTik = null;
      }
    }

    //= ========= 内部方法 ==========
    _cameraHandler() {
      if (!this.enabled) {
        return
      }

      this.locationData.cameraHeight = this._map.camera.positionCartographic.height.toFixed(1);
      this.locationData.heading = Cesium__namespace.Math.toDegrees(this._map.camera.heading).toFixed(0);
      this.locationData.pitch = Cesium__namespace.Math.toDegrees(this._map.camera.pitch).toFixed(0);
      this.locationData.level = this._map.level;

      if (!Cesium__namespace.defined(this.locationData.lat)) {
        return
      }
      this._templateHtml();
    }

    // 鼠标移动事件，setTimeout是为了优化效率
    _mouseMoveHandler(event) {
      if (this.moveTimer) {
        clearTimeout(this.moveTimer);
        delete this.moveTimer;
      }
      this.moveTimer = setTimeout(() => {
        delete this.moveTimer;
        this._updateHtml(event);
      }, this.options.cacheTime);
    }

    _updateHtml(event) {
      if (!this.enabled) {
        return
      }

      const cartesian = event.cartesian;
      if (!cartesian) {
        return
      }

      this.locationData.cameraHeight = this._map.camera.positionCartographic.height.toFixed(LngLatPoint.FormatAltLength);
      this.locationData.heading = Cesium__namespace.Math.toDegrees(this._map.camera.heading).toFixed(0);
      this.locationData.pitch = Cesium__namespace.Math.toDegrees(this._map.camera.pitch).toFixed(0);
      this.locationData.level = this._map.level;

      const cartographic = Cesium__namespace.Cartographic.fromCartesian(cartesian);
      this.locationData.alt = formatNum$1(this._map.getRealAlt(cartographic.height), LngLatPoint.FormatAltLength);

      const jd = Cesium__namespace.Math.toDegrees(cartographic.longitude);
      const wd = Cesium__namespace.Math.toDegrees(cartographic.latitude);

      const fixedLen = this.options.latDecimal ?? LngLatPoint.FormatLength;
      this.locationData.lng = jd.toFixed(fixedLen);
      this.locationData.lat = wd.toFixed(fixedLen);

      if (this._crs) {
        // 其他坐标系
        const fixedLen = this.options.crsDecimal ?? 1;

        const ptNew = proj4Trans([jd, wd], "EPSG:4326", this._crs);
        if (ptNew[0] === jd) {
          this.locationData.crsx = "";
        } else {
          this.locationData.crsx = ptNew[0].toFixed(fixedLen);
        }
        if (ptNew[1] === wd) {
          this.locationData.crsy = "";
        } else {
          this.locationData.crsy = ptNew[1].toFixed(fixedLen);
        }
      }

      this._templateHtml();
    }

    _templateHtml() {
      let inhtml;
      if (typeof this.template === "function") {
        // 回调方法
        inhtml = this.template(this.locationData);
      } else {
        if (this.options.formatData) {
          this.locationData = this.options.formatData(this.locationData);
        }

        inhtml = template(this.template, this.locationData);
      }
      this._containerCon.innerHTML = inhtml;
      this.fire(EventType.change);
    }
  }
  // 注册下
  register$1("locationBar", LocationBar);

  /**
   * 鼠标滚轮缩放美化样式(指示图标)控件
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @export
   * @class MouseDownView
   * @extends {BaseControl}
   */
  class MouseDownView extends BaseControl {
    //= ========= 方法 ==========
    /**
     * 创建_container控件容器对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._container = create$3("div", "mars3d-mousedownview");
      this._container.id = this.parentContainerId + "-mars3d-mousedownview";

      create$3("div", "mars3d-mousedownview-img", this._container);
    }

    // 改变鼠标操作后调用
    changeMouseModel() {
      if (this.isAdded) {
        this._removedHook();
        this._addedHook();
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      if (!isPCBroswer()) {
        return
      }

      this._map.on(EventType.wheel, this._mousWheelHandler, this);
      if (this._map._hasRightTilt) {
        this._map.on(EventType.rightDown, this._mousMiddleDownHandler, this);
        this._map.on(EventType.rightUp, this._mousMiddleUpHandler, this);
      } else {
        this._map.on(EventType.middleDown, this._mousMiddleDownHandler, this);
        this._map.on(EventType.middleUp, this._mousMiddleUpHandler, this);
      }
      this._mousMiddleUpHandler();
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (!isPCBroswer()) {
        return
      }

      this._map.off(EventType.wheel, this._mousWheelHandler, this);
      if (this._map._hasRightTilt) {
        this._map.off(EventType.rightDown, this._mousMiddleDownHandler, this);
        this._map.off(EventType.rightUp, this._mousMiddleUpHandler, this);
      } else {
        this._map.off(EventType.middleDown, this._mousMiddleDownHandler, this);
        this._map.off(EventType.middleUp, this._mousMiddleUpHandler, this);
      }
    }

    _mousWheelHandler(evnet) {
      if (!this.enabled) {
        return
      }

      addClass(this._container, "mars3d-mousedownview-show");
      clearTimeout(this.timetik);
      this.timetik = setTimeout(() => {
        removeClass(this._container, "mars3d-mousedownview-show");
      }, 200);
    }

    _mousMiddleDownHandler(evnet) {
      if (!this.enabled) {
        return
      }
      const position = getCurrentMousePosition(this._map.scene, evnet.position);
      if (!position) {
        return
      }

      if (this._map.camera.positionCartographic.height > this._map.scene.screenSpaceCameraController.minimumCollisionTerrainHeight) {
        return
      }

      this._map.off(EventType.mouseMove, this._mouseMoveHandler, this);
      clearTimeout(this.timetik);

      this._container.style.top = evnet.position.y + "px";
      this._container.style.left = evnet.position.x + "px";

      addClass(this._container, "mars3d-mousedownview-show");
    }

    _mousMiddleUpHandler(evnet) {
      removeClass(this._container, "mars3d-mousedownview-show");
      this._map.on(EventType.mouseMove, this._mouseMoveHandler, this);
    }

    _mouseMoveHandler(evnet) {
      this._container.style.top = evnet.endPosition.y + "px";
      this._container.style.left = evnet.endPosition.x + "px";
    }
  }

  // 注册下
  register$1("mouseDownView", MouseDownView);

  const icon$7 = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="48" height="48" fill="white" fill-opacity="0.01"/>
  <path d="M24.0607 10L24.024 38" stroke="#ffffff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M10 24L38 24" stroke="#ffffff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;

  const icon$6 = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="48" height="48" fill="white" fill-opacity="0.01"/>
  <path d="M10.5 24L38.5 24" stroke="#ffffff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;

  /**
   * 放大缩小按钮控件
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.relativeAmount=2] 放大缩小的相对量（调整步长）
   * @param {String} [options.zoomOutIcon] 缩小按钮 图片url路径 或 字体图标class名
   * @param {String} [options.zoomInIcon] 放大按钮 图片url路径 或 字体图标class名
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @export
   * @class Zoom
   * @extends {BaseControl}
   */
  class Zoom extends BaseControl {
    get parentContainer() {
      if (this._map) {
        return this._map.toolbar
      } else {
        return document.getElementsByClassName("cesium-viewer-toolbar")[0]
      }
    }

    _showHook(show) {
      if (this._container2) {
        this._container2.style.display = show ? "block" : "none";
      }
    }

    /**
     * 创建_container控件容器对象的方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      // 缩小
      this._container = create$3("div", "cesium-button cesium-toolbar-button mar3d-toolButton");
      this._container.style.display = "inline-block";
      this._container.setAttribute("title", this._map.getLangText("_缩小"));
      this._createIcon(this.options.zoomOutIcon || icon$6, this._container);
      this._container.addEventListener("click", (e) => {
        if (!this.enabled) {
          return
        }
        this._map.zoomOut(this.options.relativeAmount);
      });

      // 放大
      this._container2 = create$3("div", "cesium-button cesium-toolbar-button mar3d-toolButton");
      this._container2.style.display = "inline-block";
      this._container2.setAttribute("title", this._map.getLangText("_放大"));
      this._createIcon(this.options.zoomInIcon || icon$7, this._container2);
      this._container2.addEventListener("click", (e) => {
        if (!this.enabled) {
          return
        }
        this._map.zoomIn(this.options.relativeAmount);
      });
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this.parentContainer.insertBefore(this._container2, this._container);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this.parentContainer.removeChild(this._container2);
    }
  }

  // 注册下
  register$1("zoom", Zoom);

  /**
   * @typedef {Object} ToolButton.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} click 单击了按钮
   *
   * @example
   * //绑定监听事件
   * control.on(mars3d.EventType.click, function (event) {
   *   console.log('单击了按钮', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 工具栏 单个按钮控件
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.title=''] 按钮标题
   * @param {String} [options.icon] 按钮图标,可以是：图片url路径、base64字符串、svg字符串、字体图标class名
   * @param {Function} [options.click] 按钮单击后的回调方法
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @export
   * @class ToolButton
   * @extends {BaseControl}
   *
   * @see [支持的事件类型]{@link ToolButton.EventType}
   */
  class ToolButton extends BaseControl {
    constructor(options = {}) {
      super(options);
      this._type = "toolButton" + getGlobalId();
    }

    get parentContainer() {
      if (this._map) {
        return this._map.toolbar
      } else {
        return document.getElementsByClassName("cesium-viewer-toolbar")[0]
      }
    }

    /**
     * 创建_container控件容器对象的方法，
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      // 缩小
      this._container = create$3("div", "cesium-button cesium-toolbar-button mar3d-toolButton");
      this._container.id = this.id;
      this._container.style.display = "inline-block";
      this._container.setAttribute("title", this.options.title || "");

      this._createIcon(this.options.icon, this._container);

      // 单击事件
      this._container.addEventListener("click", (e) => {
        if (!this.enabled) {
          return
        }

        if (this.options.click) {
          this.options.click(this.options);
        }
        this.fire(EventType.click, { ...this.options });
      });

      // 鼠标移入移出
      let cacheTarget;
      this._container.addEventListener("mouseover", (e) => {
        if (!this.enabled) {
          return
        }
        // 缓存，提高效率
        if (cacheTarget === this.id) {
          return
        }
        cacheTarget = this.id;

        if (this.options.mouseOver) {
          this.options.mouseOver(this.options);
        }
        this.fire(EventType.mouseOver, { ...this.options });
      });
      this._container.addEventListener("mouseout", (e) => {
        // 缓存，提高效率
        cacheTarget = null;

        if (!this.enabled) {
          return
        }
        if (this.options.mouseOut) {
          this.options.mouseOut(this.options);
        }
        this.fire(EventType.mouseOut, { ...this.options });
      });
    }
  }

  // 注册下
  register$1("toolButton", ToolButton);

  const icon$5 = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="162px" height="162px" viewBox="0 0 162 162" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>拖拽调整四周方向角，双击回正北</title>
    <desc>mars3d.cn</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill-rule="evenodd">
        <g id="compass-outer" fill-rule="nonzero">
            <path d="M80.8410544,161.682109 C36.1937731,161.682109 0,125.488336 0,80.8410544 C0,36.1937731 36.1937731,0 80.8410544,0 C125.488336,0 161.682109,36.1937731 161.682109,80.8410544 C161.682109,125.488336 125.488336,161.682109 80.8410544,161.682109 Z M81.1836011,134.620909 C110.696211,134.620909 134.620909,110.696211 134.620909,81.1836011 C134.620909,51.6709916 110.696211,27.7462941 81.1836011,27.7462941 C51.6709916,27.7462941 27.7462941,51.6709916 27.7462941,81.1836011 C27.7462941,110.696211 51.6709916,134.620909 81.1836011,134.620909 Z" id="Oval-108"></path>
            <circle id="Oval-74" fill="#FFFFFF" cx="129.493683" cy="127.952092" r="1.54159147"></circle>
            <circle id="Oval-74-Copy-3" fill="#FFFFFF" cx="129.493683" cy="35.4566038" r="1.54159147"></circle>
            <circle id="Oval-74-Copy-5" fill="#FFFFFF" cx="30.8318294" cy="127.952092" r="1.54159147"></circle>
            <circle id="Oval-74-Copy-4" fill="#FFFFFF" cx="30.8318294" cy="35.4566038" r="1.54159147"></circle>
            <polygon id="N" fill="#FFFFFF" points="84.9318072 23.1238721 84.9318072 13.1321362 82.5623385 13.1321362 82.5623385 19.2984646 77.951866 13.1321362 75.7108625 13.1321362 75.7108625 23.1238721 78.0946053 23.1238721 78.0946053 16.9718176 82.6908037 23.1238721"></polygon>
            <polygon id="Line" fill="#FFFFFF" points="143.368007 82.1093476 152.617555 82.1093476 152.617555 81.2993476 143.368007 81.2993476"></polygon>
            <polygon id="Line-Copy-8" fill="#FFFFFF" points="9.24954884 82.1093476 18.4990976 82.1093476 18.4990976 81.2993476 9.24954884 81.2993476"></polygon>
            <polygon id="Line" fill="#FFFFFF" points="81.2993476 143.368007 81.2993476 152.617555 82.1093476 152.617555 82.1093476 143.368007"></polygon>
        </g>
    </g>
</svg>
`;

  const icon$4 = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="17px" height="17px" viewBox="0 0 17 17" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>拖拽调整俯仰角</title>
    <desc>mars3d.cn</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill-rule="evenodd">
        <g id="compass-inner" fill-rule="nonzero">
            <path d="M8.5,16.5 C4.081722,16.5 0.5,12.918278 0.5,8.5 C0.5,4.081722 4.081722,0.5 8.5,0.5 C12.918278,0.5 16.5,4.081722 16.5,8.5 C16.5,12.918278 12.918278,16.5 8.5,16.5 Z M8.5,15.5 C12.3659932,15.5 15.5,12.3659932 15.5,8.5 C15.5,4.63400675 12.3659932,1.5 8.5,1.5 C4.63400675,1.5 1.5,4.63400675 1.5,8.5 C1.5,12.3659932 4.63400675,15.5 8.5,15.5 Z" id="Oval-96"></path>
            <path d="M9.92599835,7.09066832 C12.7122872,9.87695712 14.3709388,12.5452228 13.4497471,13.4664145 C12.5285555,14.3876061 9.86028979,12.7289545 7.074001,9.94266568 C4.2877122,7.15637688 2.62906055,4.48811119 3.55025221,3.56691953 C4.47144386,2.64572788 7.13970955,4.30437952 9.92599835,7.09066832 Z M9.21889157,7.7977751 C6.92836458,5.50724811 4.52075769,4.01062761 4.25735899,4.27402631 C3.99396029,4.53742501 5.49058078,6.9450319 7.78110778,9.2355589 C10.0716348,11.5260859 12.4792417,13.0227064 12.7426404,12.7593077 C13.0060391,12.495909 11.5094186,10.0883021 9.21889157,7.7977751 Z" id="Oval-96-Copy-2"></path>
            <path d="M9.92599835,9.94266568 C7.13970955,12.7289545 4.47144386,14.3876061 3.55025221,13.4664145 C2.62906055,12.5452228 4.2877122,9.87695712 7.074001,7.09066832 C9.86028979,4.30437952 12.5285555,2.64572788 13.4497471,3.56691953 C14.3709388,4.48811119 12.7122872,7.15637688 9.92599835,9.94266568 Z M9.21889157,9.2355589 C11.5094186,6.9450319 13.0060391,4.53742501 12.7426404,4.27402631 C12.4792417,4.01062761 10.0716348,5.50724811 7.78110778,7.7977751 C5.49058078,10.0883021 3.99396029,12.495909 4.25735899,12.7593077 C4.52075769,13.0227064 6.92836458,11.5260859 9.21889157,9.2355589 Z" id="Oval-96-Copy-3"></path>
            <path d="M15.1464466,1.1464466 L14.3453364,1.94755684 L13.9608692,2.33202401 L14.667976,3.03913077 L15.0524431,2.65466362 L15.8535534,1.8535534 L15.1464466,1.1464466 Z M2.29760014,13.995293 L1.85311902,14.4397742 L1.004311,15.2885822 L1.71141776,15.995689 L2.56022581,15.146881 L3.00470698,14.7023998 L2.29760014,13.995293 Z" id="Line"></path>
            <circle id="Oval-432" cx="16" cy="1" r="1"></circle>
            <circle id="Oval-432-Copy" cx="1" cy="16" r="1"></circle>
        </g>
    </g>
</svg>
`;

  const icon$3 = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="53px" height="53px" viewBox="0 0 53 53" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
    <title>导航球</title>
    <desc>mars3d.cn</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="compass-rotation-marker">
            <path d="M52.4399986,26.2199993 C52.4399986,11.7390936 40.7009051,0 26.2199993,0 C11.7390936,0 0,11.7390936 0,26.2199993 C0,40.7009051 11.7390936,52.4399986 26.2199993,52.4399986 C40.7009051,52.4399986 52.4399986,40.7009051 52.4399986,26.2199993 Z" id="rotator" stroke-opacity="0.135841259" stroke="#E2A549" stroke-width="9" opacity="0.201434235"></path>
            <path d="M0,26.2199993 C0,11.7390936 11.7390936,0 26.2199993,0 L26.2199993,9 C16.7096563,9 9,16.7096563 9,26.2199993" id="Shape" opacity="0.634561567" fill="#4990E2"></path>
        </g>
    </g>
</svg>
`;

  /**
   * 导航球控件
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.rotation = true] 是否启用调整俯仰角（按中间区域往四周拖拽）
   *
   * @param {String} [options.className='mars3d-compass']  样式名称，可以外部自定义样式。
   * @param {String} [options.top]   css定位top位置, 如 top: '10px'
   * @param {String} [options.bottom]   css定位bottom位置，支持配置'toolbar'自动跟随cesium-viewer-toolbar
   * @param {String} [options.left]   css定位left位置
   * @param {String} [options.right]   css定位right位置
   *
   * @param {String} [options.outerSvg]  外部圆环区域的SVG图片
   * @param {String} [options.innerSvg]  中心球区域的SVG图片
   * @param {String} [options.rotationArcSvg] rotation为true时，按中间区域往四周拖拽时，调整俯仰角的对外部圆环的半弧遮盖SVG图片
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @export
   * @class Compass
   * @extends {BaseControl}
   */
  class Compass extends BaseControl {
    constructor(options = {}) {
      super(options);

      this._orbitCursorAngle = 0;
      this._orbitCursorOpacity = 0.0;
      this._orbitLastTimestamp = 0;

      this.options.rotation = this.options.rotation ?? true;
    }

    // 获取css定位值
    _getCssText() {
      const css = {};
      if (Cesium__namespace.defined(this.options.top)) {
        css.top = this.options.top;
      } else if (Cesium__namespace.defined(this.options.bottom)) {
        css.bottom = this.options.bottom;
        // 跟随toolbar时
        if (css.bottom === "toolbar") {
          const domToolbar = this._map.toolbar;
          if (domToolbar) {
            const height = domToolbar.offsetHeight + 40;
            css.bottom = height + "px";
            this.domToolbar = domToolbar;
          }
        }
      }
      if (Cesium__namespace.defined(this.options.left)) {
        css.left = this.options.left;
      } else if (Cesium__namespace.defined(this.options.right)) {
        css.right = this.options.right;
      }

      let cssText = "";
      for (const key in css) {
        cssText += `${key}: ${css[key]};`;
      }
      return cssText || `top: 10px;right: 10px;`
    }

    updateSize() {
      if (this.domToolbar) {
        const height = this.domToolbar.offsetHeight + 40;
        this._container.style.bottom = height + "px";
      }
    }

    _mountedHook() {
      this._container = create$3("div", this.options.className || "mars3d-compass");
      this._container.style.cssText = this._getCssText();

      this._container.onmousedown = (e) => {
        this._handleMouseDown(e);
      };

      this._container_outer = parseDom(this.options.outerSvg || icon$5, true, "mars3d-compass-outer");
      this._container.appendChild(this._container_outer);
      this._container_outer.ondblclick = (e) => {
        this._map.camera.setView({
          orientation: {
            heading: 0
          }
        });
      };

      this._container_inner = parseDom(this.options.innerSvg || icon$4, true, "mars3d-compass-inner");
      this._container.appendChild(this._container_inner);
      this._container_inner.ondblclick = (e) => {
        this._map.flyHome();
      };

      if (this.options.rotation) {
        this._container_rotationArc = parseDom(this.options.rotationArcSvg || icon$3, true, "mars3d-compass-rotation-arc");
        this._container.appendChild(this._container_rotationArc);
        this._container_rotationArc.style.visibility = "hidden";
      }
    }

    /**
     * 更新 外部圆环区域的SVG图片
     * @param {String} svg SVG图片
     * @return {void}  无
     */
    setOuterSvg(svg) {
      this._container_outer.innerHTML = svg;
    }

    /**
     * 更新 中心球区域的SVG图片
     * @param {String} svg SVG图片
     * @return {void}  无
     */
    setInnerSvg(svg) {
      this._container_inner.innerHTML = svg;
    }

    /**
     * 更新 按中间区域往四周拖拽时，调整俯仰角的对外部圆环的半弧遮盖SVG图片，rotation为true时有效
     * @param {String} svg SVG图片
     * @return {void}  无
     */
    setRotationSvg(svg) {
      this._container_rotationArc.innerHTML = svg;
    }

    _addedHook() {
      this._map.on(EventType.postRender, this._postRenderHandler, this);
    }

    _removedHook() {
      this._map.off(EventType.postRender, this._postRenderHandler, this);
    }

    _postRenderHandler() {
      const heading = this._map.camera.heading;
      this._container_outer &&
        (this._container_outer.style.cssText = `
      transform : rotate(-${heading}rad);
      -webkit-transform : rotate(-${heading}rad);
      `);
    }

    _handleMouseDown(e) {
      const scene = this._map.scene;
      if (scene.mode === Cesium__namespace.SceneMode.MORPHING) {
        return true
      }
      this._compassRectangle = e.currentTarget.getBoundingClientRect();
      const maxDistance = this._compassRectangle.width / 2.0;
      const vector = this._getVector(e);
      const distanceFraction = Cesium__namespace.Cartesian2.magnitude(vector) / maxDistance;
      if (this.options.rotation && distanceFraction < 50 / 145) {
        this._orbit(vector);
      } else if (distanceFraction < 1.0) {
        this._rotate(vector);
      } else {
        return true
      }
    }



    _getCameraFocus(inWorldCoordinates) {
      let result = new Cesium__namespace.Cartesian3();
      const scene = this._map.scene;
      const camera = scene.camera;
      if (scene.mode === Cesium__namespace.SceneMode.MORPHING) {
        return undefined
      }
      if (this._map.trackedEntity) {
        result = this._map.trackedEntity.position.getValue(this._map.clock.currentTime);
      } else {
        const rayScratch = new Cesium__namespace.Ray();
        rayScratch.origin = camera.positionWC;
        rayScratch.direction = camera.directionWC;
        result = scene.globe.pick(rayScratch, scene);
      }
      if (!result) {
        return undefined
      }
      if (scene.mode === Cesium__namespace.SceneMode.SCENE2D || scene.mode === Cesium__namespace.SceneMode.COLUMBUS_VIEW) {
        result = camera.worldToCameraCoordinatesPoint(result);
        const unprojectedScratch = new Cesium__namespace.Cartographic();
        if (inWorldCoordinates) {
          result = scene.globe.ellipsoid.cartographicToCartesian(scene.mapProjection.unproject(result, unprojectedScratch));
        }
      } else {
        if (!inWorldCoordinates) {
          result = camera.worldToCameraCoordinatesPoint(result);
        }
      }
      return result
    }

    _orbit(vector) {
      const scene = this._map.scene;
      const sscc = scene.screenSpaceCameraController;
      const camera = scene.camera;
      if (scene.mode === Cesium__namespace.SceneMode.MORPHING || !sscc.enableInputs) {
        return
      }
      switch (scene.mode) {
        case Cesium__namespace.SceneMode.SCENE2D:
          if (!sscc.enableTranslate) {
            return
          }
          break
        case Cesium__namespace.SceneMode.COLUMBUS_VIEW:
          if (sscc.enableLook) {
            break
          }
          if (!sscc.enableTranslate || !sscc.enableTilt) {
            return
          }
          break
        case Cesium__namespace.SceneMode.SCENE3D:
        default:
          if (sscc.enableLook) {
            break
          }
          if (!sscc.enableTilt || !sscc.enableRotate) {
            return
          }
          break
      }

      this._mouseMoveHandle = (e) => {
        this._orbitMouseMoveFunction(e);
      };
      this._mouseUpHandle = () => {
        this._orbitMouseUpFunction();
      };

      document.removeEventListener("mousemove", this._mouseMoveHandle, false);
      document.removeEventListener("mouseup", this._mouseUpHandle, false);

      this._orbitLastTimestamp = Cesium__namespace.getTimestamp();

      if (this._map.trackedEntity) {
        this._orbitFrame = undefined;
        this._orbitIsLook = false;
      } else {
        const center = this._getCameraFocus(true);

        if (!center) {
          this._orbitFrame = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid);
          this._orbitIsLook = true;
        } else {
          this._orbitFrame = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(center, scene.globe.ellipsoid);
          this._orbitIsLook = false;
        }
      }

      this._container_rotationArc.style.visibility = "visible";
      this._container_inner.className += " compass-inner-active";
      document.addEventListener("mousemove", this._mouseMoveHandle, false);
      document.addEventListener("mouseup", this._mouseUpHandle, false);

      this._map.on(EventType.clockTick, this._orbitTickFunction, this);
      this._updateAngleAndOpacity(vector, this._compassRectangle.width);
    }

    _orbitTickFunction(e) {
      const scene = this._map.scene;
      const camera = this._map.camera;
      const timestamp = Cesium__namespace.getTimestamp();
      const deltaT = timestamp - this._orbitLastTimestamp;
      const rate = ((this._orbitCursorOpacity - 0.5) * 2.5) / 1000;
      const distance = deltaT * rate;
      const angle = this._orbitCursorAngle + Cesium__namespace.Math.PI_OVER_TWO;
      const x = Math.cos(angle) * distance;
      const y = Math.sin(angle) * distance;
      let oldTransform;

      if (this._orbitFrame) {
        oldTransform = Cesium__namespace.Matrix4.clone(camera.transform);
        camera.lookAtTransform(this._orbitFrame);
      }

      if (scene.mode === Cesium__namespace.SceneMode.SCENE2D) {
        camera.move(
          new Cesium__namespace.Cartesian3(x, y, 0),
          (Math.max(scene.canvas.clientWidth, scene.canvas.clientHeight) / 100) * camera.positionCartographic.height * distance
        );
      } else {
        if (this._orbitIsLook) {
          camera.look(Cesium__namespace.Cartesian3.UNIT_Z, -x);
          camera.look(camera.right, -y);
        } else {
          camera.rotateLeft(x);
          camera.rotateUp(y);
        }
      }
      if (this._orbitFrame && oldTransform) {
        camera.lookAtTransform(oldTransform);
      }
      this._orbitLastTimestamp = timestamp;
    }

    _updateAngleAndOpacity(vector, compassWidth) {
      const angle = Math.atan2(-vector.y, vector.x);
      this._orbitCursorAngle = Cesium__namespace.Math.zeroToTwoPi(angle - Cesium__namespace.Math.PI_OVER_TWO);
      const distance = Cesium__namespace.Cartesian2.magnitude(vector);
      const maxDistance = compassWidth / 2.0;
      const distanceFraction = Math.min(distance / maxDistance, 1.0);
      this._orbitCursorOpacity = 0.5 * distanceFraction * distanceFraction + 0.5;
      this._container_rotationArc.style.cssText = `
      transform: rotate(-${this._orbitCursorAngle}rad);
      opacity: ${this._orbitCursorOpacity}`;
    }

    _orbitMouseMoveFunction(e) {
      this._updateAngleAndOpacity(this._getVector(e), this._compassRectangle.width);
    }

    _orbitMouseUpFunction() {
      document.removeEventListener("mousemove", this._mouseMoveHandle, false);
      document.removeEventListener("mouseup", this._mouseUpHandle, false);
      this._map.off(EventType.clockTick, this._orbitTickFunction, this);

      this._mouseMoveHandle = undefined;
      this._mouseUpHandle = undefined;
      this._container_rotationArc.style.visibility = "hidden";
      this._container_inner.className = this._container_inner.className.replace("compass-inner-active", "");
    }

    _rotate(vector) {
      const scene = this._map.scene;
      const camera = scene.camera;
      const sscc = scene.screenSpaceCameraController;
      if (scene.mode === Cesium__namespace.SceneMode.MORPHING || scene.mode === Cesium__namespace.SceneMode.SCENE2D || !sscc.enableInputs) {
        return
      }
      if (!sscc.enableLook && (scene.mode === Cesium__namespace.SceneMode.COLUMBUS_VIEW || (scene.mode === Cesium__namespace.SceneMode.SCENE3D && !sscc.enableRotate))) {
        return
      }
      this._mouseMoveHandle = (e) => {
        this._rotateMouseMoveFunction(e);
      };
      this._mouseUpHandle = () => {
        this._rotateMouseUpFunction();
      };
      document.removeEventListener("mousemove", this._mouseMoveHandle, false);
      document.removeEventListener("mouseup", this._mouseUpHandle, false);

      this._rotateInitialCursorAngle = Math.atan2(-vector.y, vector.x);
      if (this._map.trackedEntity) {
        this._rotateFrame = undefined;
      } else {
        const center = this._getCameraFocus(true);
        if (!center || (scene.mode === Cesium__namespace.SceneMode.COLUMBUS_VIEW && !sscc.enableLook && !sscc.enableTranslate)) {
          this._rotateFrame = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid);
        } else {
          this._rotateFrame = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(center, scene.globe.ellipsoid);
        }
      }
      let oldTransform;
      if (this._rotateFrame) {
        oldTransform = Cesium__namespace.Matrix4.clone(camera.transform);
        camera.lookAtTransform(this._rotateFrame);
      }
      this._rotateInitialCameraAngle = -camera.heading;
      if (this._rotateFrame && oldTransform) {
        camera.lookAtTransform(oldTransform);
      }
      document.addEventListener("mousemove", this._mouseMoveHandle, false);
      document.addEventListener("mouseup", this._mouseUpHandle, false);
    }

    _rotateMouseMoveFunction(e) {
      const camera = this._map.camera;
      const vector = this._getVector(e);
      const angle = Math.atan2(-vector.y, vector.x);
      const angleDifference = angle - this._rotateInitialCursorAngle;
      const newCameraAngle = Cesium__namespace.Math.zeroToTwoPi(this._rotateInitialCameraAngle - angleDifference);
      let oldTransform;
      if (this._rotateFrame) {
        oldTransform = Cesium__namespace.Matrix4.clone(camera.transform);
        camera.lookAtTransform(this._rotateFrame);
      }
      const currentCameraAngle = -camera.heading;
      camera.rotateRight(newCameraAngle - currentCameraAngle);
      if (this._rotateFrame && oldTransform) {
        camera.lookAtTransform(oldTransform);
      }
    }

    _rotateMouseUpFunction() {
      document.removeEventListener("mousemove", this._mouseMoveHandle, false);
      document.removeEventListener("mouseup", this._mouseUpHandle, false);
      this._mouseMoveHandle = undefined;
      this._mouseUpHandle = undefined;
    }

    _getVector(e) {
      const compassRectangle = this._compassRectangle;
      const center = new Cesium__namespace.Cartesian2(
        (compassRectangle.right - compassRectangle.left) / 2.0,
        (compassRectangle.bottom - compassRectangle.top) / 2.0
      );
      const clickLocation = new Cesium__namespace.Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);
      const vector = new Cesium__namespace.Cartesian2();
      Cesium__namespace.Cartesian2.subtract(clickLocation, center, vector);
      return vector
    }
  }

  // 注册下
  register$1("compass", Compass);

  const geodesic = new Cesium__namespace.EllipsoidGeodesic();

  const BASE = [1, 2, 3, 5];
  const DIS = [
    ...BASE,
    ...BASE.map((item) => item * 10),
    ...BASE.map((item) => item * 100),
    ...BASE.map((item) => item * 1000),
    ...BASE.map((item) => item * 10000),
    ...BASE.map((item) => item * 100000),
    ...BASE.map((item) => item * 1000000)
  ];

  /**
   * @typedef {Object} DistanceLegend.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} change 比例尺发生变化
   *
   *
   * @example
   * //绑定监听事件
   * distanceLegend.on(mars3d.EventType.change, function (event) {
   *   console.log('比例尺发生变化', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   *
   * 比例尺 控件
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String} [options.top]   css定位top位置, 如 top: '10px'
   * @param {String} [options.bottom]   css定位bottom位置
   * @param {String} [options.left]   css定位left位置
   * @param {String} [options.right]   css定位right位置
   *
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @export
   * @class DistanceLegend
   * @extends {BaseControl}
   * @see [支持的事件类型]{@link DistanceLegend.EventType}
   */
  class DistanceLegend extends BaseControl {
    /**
     * 当前比例尺值（单位：米）
     * @type {Number}
     * @readonly
     */
    get distance() {
      return this._currDistance
    }

    _mountedHook() {
      this._container = create$3("div", "mars3d-distance-legend");
      this._container.style.cssText = this._getCssText();

      this._labelEl = create$3("div", "legend-label", this._container);
      this._scaleBarEl = create$3("div", "legend-scale-bar", this._container);
      this._container.style.visibility = "hidden";

      this._lastUpdate = Cesium__namespace.getTimestamp();
    }

    // 获取css定位值
    _getCssText() {
      const css = {};
      if (Cesium__namespace.defined(this.options.top)) {
        css.top = this.options.top;
      } else if (Cesium__namespace.defined(this.options.bottom)) {
        css.bottom = this.options.bottom;
      }
      if (Cesium__namespace.defined(this.options.left)) {
        css.left = this.options.left;
      } else if (Cesium__namespace.defined(this.options.right)) {
        css.right = this.options.right;
      }

      let cssText = "";
      for (const key in css) {
        cssText += `${key}: ${css[key]};`;
      }
      return cssText || `left: 120px; bottom: ${this._getTimeline() ? "27" : "2"}px;`
    }

    _addedHook() {
      this._map.on(EventType.postRender, this._updateContent, this);
    }

    _removedHook() {
      this._map.off(EventType.postRender, this._updateContent, this);
    }

    _updateContent(scene, time) {
      const now = Cesium__namespace.getTimestamp();
      if (now < this._lastUpdate + 250) {
        return
      }
      if (!this._labelEl || !this._scaleBarEl) {
        return
      }
      this._lastUpdate = now;
      const width = scene.canvas.width;
      const height = scene.canvas.height;
      const left = scene.camera.getPickRay(new Cesium__namespace.Cartesian2((width / 2) | 0, height - 1));
      const right = scene.camera.getPickRay(new Cesium__namespace.Cartesian2((1 + width / 2) | 0, height - 1));
      const leftPosition = scene.globe.pick(left, scene);
      const rightPosition = scene.globe.pick(right, scene);
      if (!leftPosition || !rightPosition) {
        return
      }
      geodesic.setEndPoints(scene.globe.ellipsoid.cartesianToCartographic(leftPosition), scene.globe.ellipsoid.cartesianToCartographic(rightPosition));
      const pixelDistance = geodesic.surfaceDistance;
      const maxBarWidth = 100;
      let distance = 0;
      for (let i = DIS.length - 1; i >= 0; --i) {
        if (DIS[i] / pixelDistance < maxBarWidth) {
          distance = DIS[i];
          break
        }
      }

      if (distance) {
        if (this._currDistance !== distance) {
          this._currDistance = distance;
          this.fire(EventType.change, { distance: distance });
        }

        this._container.style.visibility = "visible";
        this._labelEl.innerHTML = distance >= 1000 ? `${distance / 1000} km` : `${distance} m`;
        const barWidth = (distance / pixelDistance) | 0;
        this._scaleBarEl.style.cssText = `width: ${barWidth}px; left: ${(125 - barWidth) / 2}px;`;
      }
    }
  }

  // 注册下
  register$1("distanceLegend", DistanceLegend);

  const icon$2 = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="10px" height="20px" viewBox="0 0 19 28" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <path d="M0.6551724,2.3448276 L0.6551724,25.6551724 C0.6551724,26.6454761 1.4579722,27.4482759 2.4482759,27.4482759 C3.4385796,27.4482759 4.2413793,26.6454761 4.2413793,25.6551724 L4.2413793,2.3448276 C4.2413793,1.3545239 3.4385796,0.5517241 2.4482759,0.5517241 C1.4579722,0.5517241 0.6551724,1.3545239 0.6551724,2.3448276 L0.6551724,2.3448276 Z M7.6551724,2.3448276 L7.6551724,25.6551724 C7.6551724,26.6454761 8.4579722,27.4482759 9.4482759,27.4482759 C10.4385796,27.4482759 11.2413793,26.6454761 11.2413793,25.6551724 L11.2413793,2.3448276 C11.2413793,1.3545239 10.4385796,0.5517241 9.4482759,0.5517241 C8.4579722,0.5517241 7.6551724,1.3545239 7.6551724,2.3448276 L7.6551724,2.3448276 Z M14.6551724,2.3448276 L14.6551724,25.6551724 C14.6551724,26.6454761 15.4579722,27.4482759 16.4482759,27.4482759 C17.4385796,27.4482759 18.2413793,26.6454761 18.2413793,25.6551724 L18.2413793,2.3448276 C18.2413793,1.3545239 17.4385796,0.5517241 16.4482759,0.5517241 C15.4579722,0.5517241 14.6551724,1.3545239 14.6551724,2.3448276 L14.6551724,2.3448276 Z" id="splitter"></path>
</svg>
`;

  /**
   * 卷帘对比 控件
   * @param {Object} [options] 参数对象，包括以下：
   * @param {BaseTileLayer} [options.leftLayer] 左侧区域瓦片图层
   * @param {BaseTileLayer} [options.rightLayer] 右侧区域瓦片图层
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @export
   * @class MapSplit
   * @extends {BaseControl}
   */
  class MapSplit extends BaseControl {
    get type() {
      return "mapSplit"
    }

    /**
     * 左侧区域瓦片图层
     * @type {BaseTileLayer|BaseTileLayer[]|Object}
     */
    get leftLayer() {
      return this._leftLayer
    }

    set leftLayer(item) {
      if (this._leftLayer) {
        this._leftLayer.forEach((layer) => {
          if (layer._hasRemoveByMapSplit) {
            layer.remove();
          }
        });
        this._leftLayer = null;
      }

      if (item) {
        if (!Array.isArray(item)) {
          item = [item];
        }

        this._leftLayer = [];
        item.forEach((layer) => {
          layer = this.setLayerSplitDirection(layer, Cesium__namespace.SplitDirection.LEFT);
          this._leftLayer.push(layer);
        });
      }
    }

    /**
     * 右侧区域瓦片图层
     * @type {BaseTileLayer|BaseTileLayer[]|Object}
     */
    get rightLayer() {
      return this._rightLayer
    }

    set rightLayer(item) {
      if (this._rightLayer) {
        this._rightLayer.forEach((layer) => {
          if (layer._hasRemoveByMapSplit) {
            layer.remove();
          }
        });
        this._rightLayer = null;
      }

      if (item) {
        if (!Array.isArray(item)) {
          item = [item];
        }

        this._rightLayer = [];
        item.forEach((layer) => {
          layer = this.setLayerSplitDirection(layer, Cesium__namespace.SplitDirection.RIGHT);
          this._rightLayer.push(layer);
        });
      }
    }

    _mountedHook() {
      this._container = create$3("div", "mars3d-slider");
      const splitter = parseDom(icon$2, true, "slider-splitter");
      this._container.appendChild(splitter);

      const handler = new Cesium__namespace.ScreenSpaceEventHandler(splitter);
      const self = this;
      handler.setInputAction(() => {
        self._moveActive = true;
      }, Cesium__namespace.ScreenSpaceEventType.LEFT_DOWN);
      handler.setInputAction(() => {
        self._moveActive = true;
      }, Cesium__namespace.ScreenSpaceEventType.PINCH_START);

      handler.setInputAction((movement) => {
        self._moveHandler(movement);
      }, Cesium__namespace.ScreenSpaceEventType.MOUSE_MOVE);

      handler.setInputAction((movement) => {
        self._moveHandler(movement);
      }, Cesium__namespace.ScreenSpaceEventType.PINCH_MOVE);

      handler.setInputAction(() => {
        self._moveActive = false;
      }, Cesium__namespace.ScreenSpaceEventType.LEFT_UP);
      handler.setInputAction(() => {
        self._moveActive = false;
      }, Cesium__namespace.ScreenSpaceEventType.PINCH_END);
    }

    _addedHook() {
      this._map.scene.splitPosition = 0.5;
      this._container.style.left = "50%";

      this._moveHandler();

      if (this.options.leftLayer) {
        this.leftLayer = this.options.leftLayer;
      }
      if (this.options.rightLayer) {
        this.rightLayer = this.options.rightLayer;
      }
    }

    _removedHook() {
      this._map.scene.splitPosition = 0;

      this.leftLayer = null;
      this.rightLayer = null;
    }

    _moveHandler(movement) {
      if (!this._moveActive || !this.enabled) {
        return
      }
      const relativeOffset = movement ? movement.endPosition.x : 0;
      const splitPosition = (this._container.offsetLeft + relativeOffset) / this._container.parentElement.offsetWidth;
      if (splitPosition < 0 || splitPosition > 1) {
        return
      }

      this._container.style.left = 100.0 * splitPosition + "%";
      this._map.scene.splitPosition = splitPosition;
    }

    /**
     * 对瓦片图层设置卷帘方向
     * @param {BaseTileLayer|GroupLayer|Object} layer 图层 或图层构造参数
     * @param {Cesium.SplitDirection} [splitDirection] 图层显示的方向
     * @return {BaseTileLayer|GroupLayer} 图层对象
     */
    setLayerSplitDirection(layer, splitDirection) {
      if (!layer.isAdded && this._map) {
        if (layer.type && !layer._onAdd) {
          layer = create$2(layer);
        }
        this._map.addLayer(layer);
        layer._hasRemoveByMapSplit = true;
      }

      layer.readyPromise.then((layer) => {
        if (layer.hasChildLayer) {
          for (let i = 0; i < layer.arrLayer.length; i++) {
            const imageryLayer = layer.arrLayer[i].layer;
            if (imageryLayer) {
              imageryLayer.splitDirection = splitDirection;
            }
          }
        } else {
          const imageryLayer = layer.layer;
          if (imageryLayer) {
            imageryLayer.splitDirection = splitDirection;
          }
        }
      });

      return layer
    }
  }

  // 注册下
  register$1("mapSplit", MapSplit);

  class SceneEvent {
    constructor(map) {
      this._map = map;

      this._camera = map.camera;
      this._scene = map.scene;
      this._globe = map.scene.globe;
      this._clock = map.clock;
    }

    // 绑定事件
    on(type, callback, context) {
      if (!callback) {
        return
      }

      let removeCallback;
      switch (type) {
        case EventType.cameraMoveStart:
          removeCallback = this._camera.moveStart.addEventListener(callback, context || this);
          break
        case EventType.cameraMoveEnd:
          removeCallback = this._camera.moveEnd.addEventListener(callback, context || this);
          break
        case EventType.cameraChanged:
          removeCallback = this._camera.changed.addEventListener(callback, context || this);
          break
        case EventType.preUpdate:
          removeCallback = this._scene.preUpdate.addEventListener(callback, context || this);
          break
        case EventType.postUpdate:
          removeCallback = this._scene.postUpdate.addEventListener(callback, context || this);
          break
        case EventType.preRender:
          removeCallback = this._scene.preRender.addEventListener(callback, context || this);
          break
        case EventType.postRender:
          removeCallback = this._scene.postRender.addEventListener(callback, context || this);
          break
        case EventType.renderError:
          removeCallback = this._scene.renderError.addEventListener(callback, context || this);
          break
        case EventType.morphStart:
          removeCallback = this._scene.morphStart.addEventListener(callback, context || this);
          break
        case EventType.morphComplete:
          removeCallback = this._scene.morphComplete.addEventListener(callback, context || this);
          break
        case EventType.clockTick:
          removeCallback = this._clock.onTick.addEventListener(callback, context || this);
          break
        case EventType.terrainChange:
          removeCallback = this._globe.terrainProviderChanged.addEventListener(callback, context || this);
          break
        case EventType.tileLoadProgress:
          removeCallback = this._globe.tileLoadProgressEvent.addEventListener(callback, context || this);
          break
      }
      return removeCallback
    }

    // 移除释放事件
    off(type, callback, context) {
      let removed;

      switch (type) {
        case EventType.cameraMoveStart:
          removed = this._camera.moveStart.removeEventListener(callback, context || this);
          break
        case EventType.cameraMoveEnd:
          removed = this._camera.moveEnd.removeEventListener(callback, context || this);
          break
        case EventType.cameraChanged:
          removed = this._camera.changed.removeEventListener(callback, context || this);
          break
        case EventType.preUpdate:
          removed = this._scene.preUpdate.removeEventListener(callback, context || this);
          break
        case EventType.postUpdate:
          removed = this._scene.postUpdate.removeEventListener(callback, context || this);
          break
        case EventType.preRender:
          removed = this._scene.preRender.removeEventListener(callback, context || this);
          break
        case EventType.postRender:
          removed = this._scene.postRender.removeEventListener(callback, context || this);
          break
        case EventType.renderError:
          removed = this._scene.renderError.removeEventListener(callback, context || this);
          break
        case EventType.morphStart:
          removed = this._scene.morphStart.removeEventListener(callback, context || this);
          break
        case EventType.morphComplete:
          removed = this._scene.morphComplete.removeEventListener(callback, context || this);
          break
        case EventType.clockTick:
          removed = this._clock.onTick.removeEventListener(callback, context || this);
          break
        case EventType.terrainChange:
          removed = this._globe.terrainProviderChanged.removeEventListener(callback, context || this);
          break
        case EventType.tileLoadProgress:
          removed = this._globe.tileLoadProgressEvent.removeEventListener(callback, context || this);
          break
      }

      return removed
    }
  }

  // 默认值
  const DEF_OPTIONS = {
    enabledMoveTarget: true,
    moveDelay: 30,
    pickWidth: 4,
    pickHeight: 4,
    pickLimit: 9
  };

  /**
   * 地图鼠标事件 统一管理类，由Map内部创建
   *
   * @param {Map} map 地图对象
   * @param {Map.mouseOptions} options 控制参数
   *
   * @export
   * @class MouseEvent
   */
  class MouseEvent {
    constructor(map, options = {}) {
      options = {
        ...DEF_OPTIONS,
        ...options
      };
      this._map = map;
      this._viewer = map.viewer;
      this.options = options;

      /**
       * 鼠标移动事件的延迟毫秒数
       * @type {Number}
       * @default 30
       */
      this.moveDelay = options.moveDelay;
      this._enabledMoveTarget = options.enabledMoveTarget;
      this._selected = undefined;

      this._setInputAction();
    }

    /**
     * 是否开启鼠标移动事件的拾取矢量数据
     * @type {Boolean}
     */
    get enabledMoveTarget() {
      return this._enabledMoveTarget
    }

    set enabledMoveTarget(value) {
      this._enabledMoveTarget = value;
      this.clearMoveTargetDelay();
    }

    /**
     * 是否不拾取数据
     * @type {Boolean}
     */
    get noPickEntity() {
      return this._noPickEntity
    }

    set noPickEntity(value) {
      this._noPickEntity = value;
    }

    /**
     * 清除鼠标移动的clearTimeout延迟
     * @return {void}  无
     */
    clearMoveTargetDelay() {
      if (this._moveDelayTik) {
        clearTimeout(this._moveDelayTik);
        this._moveDelayTik = null;
      }
    }

    _setInputAction() {
      this.handler = new Cesium__namespace.ScreenSpaceEventHandler(this._viewer.canvas);

      // LEFT 左键
      this.handler.setInputAction((event) => {
        this._clickHandler(event); // 默认处理,用于单击选中矢量数据和popup等
      }, Cesium__namespace.ScreenSpaceEventType.LEFT_CLICK);

      this.handler.setInputAction((event) => {
        this._map.fire(EventType.dblClick, event);
      }, Cesium__namespace.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

      this.handler.setInputAction((event) => {
        this._globeMouseHandler(event, [EventType.leftDown, EventType.mouseDown]);
      }, Cesium__namespace.ScreenSpaceEventType.LEFT_DOWN);

      this.handler.setInputAction((event) => {
        this._globeMouseHandler(event, [EventType.leftUp, EventType.mouseUp]);
      }, Cesium__namespace.ScreenSpaceEventType.LEFT_UP);

      // 鼠标移动事件
      this.handler.setInputAction((event) => {
        const cartesian = getCurrentMousePosition(this._viewer.scene, event.endPosition, this.noPickEntity);
        event.cartesian = cartesian;

        // 拾取目标，并延迟处理
        if (this.enabledMoveTarget) {
          this.clearMoveTargetDelay();
          if (this.moveDelay > 0) {
            this._moveDelayTik = setTimeout((e) => {
              this._moveDelayTik = null;
              this._mouseMoveHandler(event); // 默认处理,用于鼠标移入高亮矢量数据和tooltip等
            }, this.moveDelay);
          } else {
            this._mouseMoveHandler(event); // 默认处理,用于鼠标移入高亮矢量数据和tooltip等
          }
        }

        // 直接抛出mouseMove
        this._map.fire(EventType.mouseMove, {
          ...event,
          cartesian: cartesian,
          windowPosition: event.endPosition
        });
      }, Cesium__namespace.ScreenSpaceEventType.MOUSE_MOVE);

      this.handler.setInputAction((event) => {
        this._map.fire(EventType.wheel, event);
      }, Cesium__namespace.ScreenSpaceEventType.WHEEL);

      // RIGHT 右键
      this.handler.setInputAction((event) => {
        this._globeMouseHandler(event, EventType.rightClick);
      }, Cesium__namespace.ScreenSpaceEventType.RIGHT_CLICK);

      this.handler.setInputAction((event) => {
        this._globeMouseHandler(event, [EventType.rightDown, EventType.mouseDown]);
      }, Cesium__namespace.ScreenSpaceEventType.RIGHT_DOWN);

      this.handler.setInputAction((event) => {
        this._globeMouseHandler(event, [EventType.rightUp, EventType.mouseUp]);
      }, Cesium__namespace.ScreenSpaceEventType.RIGHT_UP);

      // MIDDLE 中键
      this.handler.setInputAction((event) => {
        this._globeMouseHandler(event, EventType.middleClick);
      }, Cesium__namespace.ScreenSpaceEventType.MIDDLE_CLICK);

      this.handler.setInputAction((event) => {
        this._globeMouseHandler(event, [EventType.middleDown, EventType.mouseDown]);
      }, Cesium__namespace.ScreenSpaceEventType.MIDDLE_DOWN);

      this.handler.setInputAction((event) => {
        this._globeMouseHandler(event, [EventType.middleUp, EventType.mouseUp]);
      }, Cesium__namespace.ScreenSpaceEventType.MIDDLE_UP);

      // PINCH
      this.handler.setInputAction((event) => {
        this._globeMouseHandler(event, EventType.pinchStart);
      }, Cesium__namespace.ScreenSpaceEventType.PINCH_START);

      this.handler.setInputAction((event) => {
        this._globeMouseHandler(event, EventType.pinchEnd);
      }, Cesium__namespace.ScreenSpaceEventType.PINCH_END);

      this.handler.setInputAction((event) => {
        this._map.fire(EventType.pinchMove, event);
      }, Cesium__namespace.ScreenSpaceEventType.PINCH_MOVE);

      this._viewer.canvas.addEventListener("keydown", this._onKeyDown.bind(this));
      this._viewer.canvas.addEventListener("keyup", this._onKeyUp.bind(this));
    }

    _onKeyDown(event) {
      this._map.fire(EventType.keydown, {
        ctrlKey: event.ctrlKey,
        altKey: event.altKey,
        metaKey: event.metaKey,
        shiftKey: event.shiftKey,

        code: event.code,
        key: event.key,
        keyCode: event.keyCode
      });
    }

    _onKeyUp(event) {
      this._map.fire(EventType.keyup, {
        ctrlKey: event.ctrlKey,
        altKey: event.altKey,
        metaKey: event.metaKey,
        shiftKey: event.shiftKey,

        code: event.code,
        key: event.key,
        keyCode: event.keyCode
      });
    }

    // 获取单击到的矢量数据
    getPickTarget(windowPosition, event) {
      if (event?.graphic) {
        return event
      }

      let pickedObject;
      try {
        pickedObject = this._viewer.scene.pick(windowPosition, this.options.pickWidth, this.options.pickHeight);
      } catch (e) {
        //
      }

      let cartesian = event?.cartesian;
      if (!cartesian) {
        cartesian = getCurrentMousePosition(this._viewer.scene, windowPosition, this.noPickEntity);
      }

      if (this._lastPickedInfo && pickedObject && this._lastPickedInfo.pickedObject === pickedObject) {
        return {
          ...event,
          ...this._lastPickedInfo, // 使用缓存
          cartesian: cartesian,
          windowPosition: windowPosition
        }
      }

      let targetInfo = this._getTargetInfo(pickedObject);
      if (pickedObject && this._allowDrillPick(targetInfo)) {
        const pickedObjects = this._viewer.scene.drillPick(windowPosition, this.options.pickLimit, this.options.pickWidth, this.options.pickHeight); // 可拾取多个
        const graphics = [];

        if (pickedObjects && pickedObjects.length > 0) {
          for (let index = 0, len = pickedObjects.length; index < len; index++) {
            const drillPickItem = pickedObjects[index];
            if (pickedObject === drillPickItem) {
              graphics.push(targetInfo?.graphic);
              continue
            }

            const drillPickItemInfo = this._getTargetInfo(drillPickItem);
            graphics.push(drillPickItemInfo?.graphic);
            if (this._allowDrillPick(drillPickItemInfo) && index !== len - 1) {
              continue
            } else {
              targetInfo = drillPickItemInfo;
              targetInfo.pickedObjects = pickedObjects; // 事件中返回
              targetInfo.graphics = graphics; // 事件中返回
              break
            }
          }
        }
      } else {
        this._lastPickedInfo = targetInfo; // 记录缓存
      }

      return {
        ...event,
        ...targetInfo,
        cartesian: cartesian,
        windowPosition: windowPosition
      }
    }

    // 判断是否需要穿透拾取
    _allowDrillPick(targetInfo) {
      let allowDrillPickVal = targetInfo.graphic?.allowDrillPick;
      if (allowDrillPickVal) {
        if (isFunction(allowDrillPickVal)) {
          return allowDrillPickVal(targetInfo)
        } else {
          return true
        }
      }

      allowDrillPickVal = targetInfo.layer?.allowDrillPick;
      if (allowDrillPickVal) {
        if (isFunction(allowDrillPickVal)) {
          return allowDrillPickVal(targetInfo)
        } else {
          return true
        }
      }
      return false
    }

    _getTargetInfo(pickedObject) {
      if (!Cesium__namespace.defined(pickedObject)) {
        return {}
      }

      let sourceTarget; // cesium 本身的 entity、primitive对象
      let layer; // mars3d 的 BaseGraphicLayer 继承对象
      let graphic; // mars3d 的 BaseGraphic 继承对象

      let pickedId;

      // 存在单击的对象
      if (Cesium__namespace.defined(pickedObject.id) && pickedObject.id instanceof Cesium__namespace.Entity) {
        // 普通entity对象 && viewer.scene.pickPositionSupported
        sourceTarget = pickedObject.id;
        pickedId = sourceTarget.id;
      } else if (pickedObject instanceof Cesium__namespace.Cesium3DTileFeature) {
        // 单体化3dtiles数据的处理(如：BIM的构件，城市白膜建筑)
        sourceTarget = pickedObject;
        pickedId = "3dtile_feature_" + pickedObject._batchId;

        const tileset = pickedObject.tileset; // Cesium.Cesium3DTileset对象
        layer = this._map.getLayerById(tileset._mars3d_layerId);

        graphic = {
          attr: get3DTileFeatureAttr(pickedObject), // 取属性
          feature: pickedObject
          // allowDrillPick: pickedObject.color?.alpha && pickedObject.color.alpha !== 1,
        };
      } else if (pickedObject.content && pickedObject.content instanceof Cesium__namespace.PointCloud3DTileContent) {
        // 点云3dtiles数据的处理
        sourceTarget = pickedObject.content;
        pickedId = "3dtile_pnts_" + pickedObject.content?._pickId?.key || 0;

        const tileset = pickedObject.primitive; // Cesium.Cesium3DTileset对象
        layer = this._map.getLayerById(tileset._mars3d_layerId);

        if (pickedObject.batchTable) ;
      } else if (Cesium__namespace.defined(pickedObject.primitive)) {
        // primitive对象
        sourceTarget = pickedObject.primitive;
        pickedId = pickedObject.id;
      } else {
        // 未单击到矢量或模型数据时
        logInfo("getPickTarget:拾取到了对象，请确认是否要做处理", pickedObject);
      }

      if (sourceTarget) {
        layer = layer || this._map.getLayerById(sourceTarget._mars3d_layerId);
        if (layer && layer.getGraphicById) {
          graphic = graphic || layer.getGraphicById(sourceTarget._mars3d_graphicId);
          if (graphic) {
            pickedId = graphic.id;

            if (graphic.getPickedObject) {
              const instanceId = pickedObject.id || pickedObject.instanceId;
              if (instanceId) {
                pickedId = instanceId;
                pickedObject.data = graphic.getPickedObject(instanceId);
                graphic.attr = pickedObject.data?.attr;
              }
            }
          }
        }
      }

      return {
        id: pickedId,
        pickedObject: pickedObject,
        sourceTarget: sourceTarget, // 事件机制的属性名称
        czmObject: sourceTarget,
        layer: layer,
        graphic: graphic,

        hasClickEvent: function () {
          if (this.graphic) {
            if (isFunction(this.graphic.listens) && this.graphic.listens(EventType.click)) {
              return true
            }
            if (isFunction(this.graphic.hasPopup) && graphic.hasPopup()) {
              return true
            }
          }
          if (this.layer) {
            if (isFunction(this.layer.listens) && this.layer.listens(EventType.click)) {
              return true
            }
            if (isFunction(this.layer.hasPopup) && layer?.hasPopup()) {
              return true
            }
          }
          return false
        }
      }
    }

    /**
     * 获取拾取到的Cesium选中对象
     *
     * @param {Object} event 单击或鼠标移入事件对象
     * @return {Object|undefined} 获取拾取到的Cesium选中对象
     */
    getPicked(event) {
      if (!event || !event.pickedObject) {
        return undefined
      }

      const pickedObject = event.pickedObject;
      const czmObject = event.czmObject;

      if (czmObject instanceof Cesium__namespace.Entity) {
        const pickIds = pickedObject.primitive._pickIds; // Entity
        if (pickIds?.length > 0) {
          const pickId = pickIds.find((pickId) => {
            return pickId.object === pickedObject
          });
          return pickId
        }
      } else if (czmObject instanceof Cesium__namespace.Cesium3DTileFeature) {
        // 单体化3dtiles数据的处理(如：BIM的构件，城市白膜建筑)
        if (pickedObject.pickId) {
          return pickedObject.pickId
        }
      } else if (pickedObject.content && pickedObject.content instanceof Cesium__namespace.PointCloud3DTileContent) {
        // 点云3dtiles数据的处理
        return pickedObject.content?._pickId
      } else {
        if (pickedObject.primitive.pickId) {
          return pickedObject.primitive.pickId
        }
        if (pickedObject.primitive._pickIds) {
          return pickedObject.primitive._pickIds // Primitive
        }
        if (pickedObject.content?._model?._pickIds) {
          return pickedObject.content?._model?._pickIds // 未单体化的3D Tiles
        }
      }

      return undefined
    }

    // 瓦片图层上的矢量对象，动态获取
    pickImageryLayerFeatures(position, event) {
      const scene = this._viewer.scene;
      const pickRay = scene.camera.getPickRay(position); // position : Cesium.Cartesian2
      const imageryLayerFeaturePromise = scene.imageryLayers.pickImageryLayerFeatures(pickRay, scene);
      if (imageryLayerFeaturePromise && imageryLayerFeaturePromise.then) {
        imageryLayerFeaturePromise.then((features) => {
          this._clickTileGraphic(features, position, event);
        });
      }
    }

    _clickTileGraphic(features, position, event) {
      if (!Cesium__namespace.defined(features) || features.length === 0) {
        return
      }
      // 单击的要素对象
      const feature = features[0];
      const imageryLayer = feature.imageryLayer; // 所在的图层 ceiusm对象

      // 对应的mars3d图层 BaseTileLayer
      const tileLayer = this._map.getLayerById(imageryLayer._mars3d_layerId);
      const result = {
        sourceTarget: imageryLayer,
        layer: tileLayer,
        features: features,
        attr: feature.properties || feature.data?.properties,
        cartesian: event?.cartesian,
        windowPosition: position
      };

      // 解析矢量数据
      if (feature.data && tileLayer && (tileLayer.options?.highlight || tileLayer.listens(EventType.click))) {
        if (tileLayer.options.featureToGraphic) {
          const graphicsOptions = tileLayer.options.featureToGraphic(feature, result);
          if (graphicsOptions) {
            if (Array.isArray(graphicsOptions)) {
              result.graphic = graphicsOptions.length > 0 ? graphicsOptions[0] : null;
              result.graphics = graphicsOptions;
            } else {
              result.graphic = graphicsOptions;
              result.graphics = [graphicsOptions];
            }
            if (result.graphic?.attr) {
              result.attr = result.graphic.attr;
            }
          }
        } else {
          const hasToGraphic = tileLayer.options.hasToGraphic ?? 5000;

          let parsing = true; // 默认均解析
          if (isBoolean(hasToGraphic)) {
            parsing = hasToGraphic;
          } else if (isNumber(hasToGraphic)) {
            const thisLenght = JSON.stringify(feature.data?.geometry || {}).length;
            parsing = thisLenght < hasToGraphic; // 是数字时，代表字符串长度，小于限定长度就解析。
          } else if (isFunction(hasToGraphic)) {
            parsing = hasToGraphic(feature);
          }

          if (parsing) {
            const highlightStyle = tileLayer?.options?.highlight;
            const graphicsOptions = geoJsonToGraphics(feature.data, {
              type: highlightStyle?.type,
              crs: feature.crs || tileLayer?.crs,
              style: highlightStyle
            });
            result.graphic = graphicsOptions.length > 0 ? graphicsOptions[0] : null;
            result.graphics = graphicsOptions;
          } else {
            logInfo(
              `_clickTileGraphic: 当前数据太大，避免卡顿未进行解析，如需展示矢量对象，请在图层配置加 hasToGraphic:true 参数 `,
              tileLayer?.options,
              feature.data?.geometry
            );
          }
        }
      }

      // 1.图层上抛出事件
      if (tileLayer) {
        tileLayer.fire(EventType.click, result, false);
      }

      // 2.map上抛出事件
      this._map.fire(EventType.clickTileGraphic, result);
    }

    _clickHandler(event) {
      if (!event || !event.position) {
        return false
      }

      const position = event.position;
      const result = this.getPickTarget(position, event);

      // 关闭
      this._map.closeHighlight(result);

      if (result.sourceTarget) {
        this.fireTargetEvent(EventType.click, result);

        // 在map上抛出事件clickGraphic
        this._map.fire(EventType.clickGraphic, result);

        if (result.layer?.allowDrillPick) {
          this.pickImageryLayerFeatures(position, result); // 瓦片图层上的矢量对象去服务中动态获取
        }
      } else {
        // 在map上抛出事件click
        this._map.fire(EventType.click, result);

        // 单击地图空白（未单击到矢量或模型数据）时
        this._map.fire(EventType.clickMap, result);

        // 瓦片图层上的矢量对象去服务中动态获取
        this.pickImageryLayerFeatures(position, result);
      }
    }

    _mouseMoveHandler(event) {
      if (!event || !event.endPosition) {
        return false
      }

      const result = this.getPickTarget(event.endPosition, event);
      const target = result.sourceTarget;

      // noMouseMove用于排除标识了不处理其移入事件的对象 ，比如高亮对象本身
      if (target && !target.noMouseMove) {
        this.activateMouseOver(result);
      } else {
        this.activateMouseOut();
      }

      this._map.fire(EventType.mouseMoveTarget, {
        czmObject: target,
        ...event,
        ...result
      });
    }

    // 鼠标移入
    activateMouseOver(result) {
      if (this._lastMouseOverItem && result.id && result.id === this._lastMouseOverItem.id) {
        return
      }

      this.activateMouseOut();

      // 鼠标样式
      if (result.hasClickEvent && result.hasClickEvent()) {
        let cursorCSS = "pointer";
        if (result.graphic?.style?.cursorCSS) {
          cursorCSS = result.graphic.style.cursorCSS;
        }
        this._map.container.style.cursor = cursorCSS;
      }

      this.fireTargetEvent(EventType.mouseOver, result);

      this._lastMouseOverItem = result;
    }

    // 鼠标移出
    activateMouseOut() {
      if (this._lastMouseOverItem == null) {
        return
      }
      this._map._setEditCursor(false);

      this.fireTargetEvent(EventType.mouseOut, this._lastMouseOverItem);
      this._lastMouseOverItem = null;
    }

    _globeMouseHandler(event, eventType) {
      if (!event || !event.position) {
        return false
      }

      const position = event.position;
      const result = this.getPickTarget(position, event);

      if (Array.isArray(eventType)) {
        eventType.forEach((element) => {
          if (result.sourceTarget) {
            this.fireTargetEvent(element, result);
          } else {
            this._map.fire(element, result);
          }
        });
      } else {
        if (result.sourceTarget) {
          this.fireTargetEvent(eventType, result);
        } else {
          this._map.fire(eventType, result);
        }
      }
    }

    // 在鼠标拾取的相关对象抛出事件
    fireTargetEvent(eventType, pickTarget) {
      // 1.target上抛出事件
      const eventFun = pickTarget.sourceTarget[eventType];
      if (eventFun && typeof eventFun === "function") {
        eventFun(pickTarget); // target上如果直接有对应回调方法，直接调用
      }
      // target上如果有关联的事件类(基于BaseClass)，进行事件抛出。
      pickTarget.czmObject.eventTarget?.fire(eventType, pickTarget);

      if (pickTarget.graphic?.fire) {
        // 2.在graphic上抛出事件
        pickTarget.graphic.fire(eventType, pickTarget, true);
      } else if (pickTarget.layer?.fire) {
        // 3.在layer上抛出事件(会自动冒泡)
        pickTarget.layer.fire(eventType, pickTarget, true);
      } else {
        // 4.在map上抛出事件
        this._map.fire(eventType, pickTarget);
      }
    }

    // 销毁资源
    destroy() {
      if (!this._graphicLayer) {
        this._map.removeLayer(this._graphicLayer, true);
        delete this._graphicLayer;
      }

      this.handler.destroy();
      delete this.handler;

      this._map.canvas.removeEventListener("keydown", this._onKeyDown);
      this._map.canvas.removeEventListener("keyup", this._onKeyUp);
    }
  }

  new Cesium__namespace.Cartographic();
  const rayScratch = new Cesium__namespace.Ray();
  const cartesian3Scratch = new Cesium__namespace.Cartesian3();
  /**
   *  缩放控制类
   * @private
   */
  class ZoomNavigation {
    //= ========= 构造方法 ==========
    // is used for zooming in (true) or out (false)
    constructor(viewer) {
      this.viewer = viewer;
    }

    zoomIn(relativeAmount = 2) {
      relativeAmount = 1 / relativeAmount;

      return this.zoom(relativeAmount)
    }

    zoomOut(relativeAmount = 2) {
      return this.zoom(relativeAmount)
    }

    zoom(relativeAmount) {
      const scene = this.viewer.scene;

      const controller = scene.screenSpaceCameraController;
      if (!controller.enableInputs || !controller.enableZoom) {
        return false
      }

      const camera = scene.camera;
      let orientation;

      switch (scene.mode) {
        case Cesium__namespace.SceneMode.MORPHING:
          return false
        case Cesium__namespace.SceneMode.SCENE2D:
          camera.zoomIn(camera.positionCartographic.height * (1 - relativeAmount));
          return true
        default: {
          let focus;

          if (Cesium__namespace.defined(this.viewer.trackedEntity)) {
            focus = new Cesium__namespace.Cartesian3();
            // focus = this.viewer.trackedEntity.position.getValue(this.viewer.clock.currentTime);
          } else {
            // TODO bug when tracking: if entity moves the current position should be used and not only the one when starting orbiting/rotating
            // TODO bug when tracking: reset should reset to default view of tracked entity
            rayScratch.origin = camera.positionWC;
            rayScratch.direction = camera.directionWC;
            focus = scene.globe.pick(rayScratch, scene, new Cesium__namespace.Cartesian3());

            if (Cesium__namespace.defined(focus)) {
              focus = camera.worldToCameraCoordinatesPoint(focus, focus);
            }
          }

          if (!Cesium__namespace.defined(focus)) {
            // Camera direction is not pointing at the globe, so use the ellipsoid horizon point as
            // the focal point.
            const ray = new Cesium__namespace.Ray(
              camera.worldToCameraCoordinatesPoint(scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic)),
              camera.directionWC
            );
            focus = Cesium__namespace.IntersectionTests.grazingAltitudeLocation(ray, scene.globe.ellipsoid);
            if (!Cesium__namespace.defined(focus)) {
              return false
            }

            orientation = {
              heading: camera.heading,
              pitch: camera.pitch,
              roll: camera.roll
            };
          } else {
            orientation = {
              direction: camera.direction,
              up: camera.up
            };
          }

          const direction = Cesium__namespace.Cartesian3.subtract(camera.position, focus, cartesian3Scratch);
          const movementVector = Cesium__namespace.Cartesian3.multiplyByScalar(direction, relativeAmount, direction);
          const endPosition = Cesium__namespace.Cartesian3.add(focus, movementVector, focus);
          if (!Cesium__namespace.defined(endPosition)) {
            return false
          }

          const minHeight = controller.minimumZoomDistance;
          const maxHeight = controller.maximumZoomDistance;
          const endHeight = Cesium__namespace.Cartographic.fromCartesian(endPosition).height;
          if (endHeight < minHeight) {
            return false
          }
          if (endHeight < controller._minimumCollisionTerrainHeight) {
            const globeHeight = controller._scene.globeHeight;
            if (Cesium__namespace.defined(globeHeight) && endHeight <= globeHeight + minHeight) {
              return false
            }
          }
          if (maxHeight && endHeight > maxHeight) {
            return false
          }

          if (Cesium__namespace.defined(this.viewer.trackedEntity) || scene.mode === Cesium__namespace.SceneMode.COLUMBUS_VIEW) {
            // sometimes flyTo does not work (jumps to wrong position) so just set the position without any animation
            // do not use flyTo when tracking an entity because during animatiuon the position of the entity may change
            camera.position = endPosition;
          } else {
            camera.flyTo({
              destination: endPosition,
              orientation: orientation,
              duration: 0.5,
              convert: false
            });
          }
          return true
        }
      }
    }
  }

  class SceneOption {
    constructor(map) {
      this._map = map;
      this._viewer = map.viewer;

      this.options = {};

      this._init();
    }

    // 需要初始的设置（一次性）
    _init() {
      this._viewer.cesiumWidget.creditContainer.style.display = "none"; // 去cesium logo
      this._viewer.scene.screenSpaceCameraController.maximumZoomDistance = 50000000.0;
      this._viewer.scene.backgroundColor = Cesium__namespace.Color.TRANSPARENT;

      // 二三维切换不用动画
      if (this._viewer.sceneModePicker) {
        this._viewer.sceneModePicker.viewModel.duration = 0.0;
      }

      // 默认定位地点相关设置，默认home键和初始化镜头视角
      this._viewer?.homeButton?.viewModel.command.beforeExecute.addEventListener((commandInfo) => {
        this._map.flyHome();
        commandInfo.cancel = true;
      });

      // 解决Cesium显示画面模糊的问题 https://zhuanlan.zhihu.com/p/41794242 【1.63已修复，1.66又出现了】
      this._viewer._cesiumWidget._supportsImageRenderingPixelated = Cesium__namespace.FeatureDetection.supportsImageRenderingPixelated();
      this._viewer._cesiumWidget._forceResize = true;
      if (Cesium__namespace.FeatureDetection.supportsImageRenderingPixelated()) {
        let _dpr = window.devicePixelRatio;
        // 适度降低分辨率
        while (_dpr >= 2.0) {
          _dpr /= 2.0;
        }
        this._viewer.resolutionScale = _dpr;
      }
    }

    // 重新赋值参数，同构造方法参数一致。
    setOptions(optionsAll, optionsNew) {
      optionsAll = optionsAll || {};
      optionsNew = optionsNew || {};

      this.options = optionsAll;

      this._setViewerOption(optionsNew)
        ._setCanvasOption(optionsNew)
        ._setSceneOption(optionsNew)
        ._setGlobeOption(optionsNew)
        ._setCameraOption(optionsNew)
        ._setClockOption(optionsNew);
      return this
    }

    // 设置 Viewer 相关
    _setViewerOption(optionsNew) {
      // 定位到配置的默认视角
      if (optionsNew.center) {
        this._map.setCameraView(optionsNew.center, { duration: 0 });
      } else if (optionsNew.extent) {
        this._map.flyToExtent(optionsNew.extent, { duration: 0 });
      }

      this._viewer.shadows = this.options.shadows ?? false;
      if (this.options.resolutionScale) {
        this._viewer.resolutionScale = this.options.resolutionScale;
      }

      if (this.options.removeDblClick ?? true) {
        this._viewer.screenSpaceEventHandler.removeInputAction(Cesium__namespace.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
      }

      return this
    }

    // 设置 canvas 相关
    _setCanvasOption(optionsNew) {
      const canvas = this._viewer.canvas;

      canvas.setAttribute("tabindex", this.options.tabIndex ?? 0);
      canvas.onclick = (e) => {
        canvas.focus();
      };

      return this
    }

    // 设置 scene 相关
    _setSceneOption(optionsNew) {
      const scene = this._viewer.scene;
      const sceneOption = this.options;

      scene.sun.show = sceneOption.showSun ?? true; // 是否显示太阳
      scene.moon.show = sceneOption.showMoon ?? true; // 是否显示月亮
      scene.skyBox.show = sceneOption.showSkyBox ?? true; // 是否显示天空盒

      scene.skyAtmosphere.show = Boolean(sceneOption.showSkyAtmosphere ?? true); // 是否显示地球大气层外光圈

      scene.fog.enabled = sceneOption.fog ?? true; // 是否启用雾化效果
      scene.postProcessStages.fxaa.enabled = sceneOption.fxaa ?? true; // 快速抗锯齿
      scene.highDynamicRange = sceneOption.highDynamicRange ?? false; // 是否关闭高动态范围渲染(不关闭时地图会变暗)

      // 空间背景色
      if (sceneOption.backgroundColor) {
        scene.backgroundColor = Cesium__namespace.Color.fromCssColorString(sceneOption.backgroundColor);
      }

      if (Cesium__namespace.defined(sceneOption.orderIndependentTranslucency)) {
        scene._useOIT = sceneOption.orderIndependentTranslucency;
      }

      switch (sceneOption.sceneMode) {
        case Cesium__namespace.SceneMode.SCENE2D:
          scene.morphTo2D(0);
          break
        case Cesium__namespace.SceneMode.COLUMBUS_VIEW:
          scene.morphToColumbusView(0);
          break
        case Cesium__namespace.SceneMode.SCENE3D:
          scene.morphTo3D(0);
          break
      }
      return this
    }

    // 设置 globe 相关
    _setGlobeOption(optionsNew) {
      const globe = this._viewer.scene.globe;
      const globeOption = this.options.globe ?? {};

      merge(globe, {
        ...globeOption,
        show: globeOption.show ?? true,
        depthTestAgainstTerrain: globeOption.depthTestAgainstTerrain ?? false, // 是否启用深度监测
        baseColor: Cesium__namespace.Color.fromCssColorString(globeOption.baseColor || "#546a53"), // 地球默认背景色
        showGroundAtmosphere: globeOption.showGroundAtmosphere ?? true, // 在地球上绘制的地面大气
        enableLighting: globeOption.enableLighting ?? false // 是否显示昼夜区域
      });

      return this
    }

    // 设置 cameraController 相关
    _setCameraOption(optionsNew) {
      const screenSpaceCameraController = this._viewer.scene.screenSpaceCameraController;
      const cameraCrlOptions = this.options.cameraController ?? {};

      merge(screenSpaceCameraController, {
        ...cameraCrlOptions,
        _zoomFactor: cameraCrlOptions.zoomFactor || 3.0, // 鼠标滚轮放大的步长参数
        minimumZoomDistance: cameraCrlOptions.minimumZoomDistance ?? 1.0, // 变焦时相机位置的最小量级（以米为单位）。默认为1
        maximumZoomDistance: cameraCrlOptions.maximumZoomDistance ?? 50000000.0, // 变焦时相机位置的最大值（以米为单位）
        minimumCollisionTerrainHeight: cameraCrlOptions.minimumCollisionTerrainHeight ?? 15000, // 低于此高度时绕鼠标键绕圈，大于时绕视图中心点绕圈。

        enableRotate: cameraCrlOptions.enableRotate ?? true, // 2D和3D视图下，是否允许用户旋转相机
        enableTranslate: cameraCrlOptions.enableTranslate ?? true, // 2D和哥伦布视图下，是否允许用户平移地图
        enableTilt: cameraCrlOptions.enableTilt ?? true, // 3D和哥伦布视图下，是否允许用户倾斜相机
        enableZoom: cameraCrlOptions.enableZoom ?? true, // 是否允许 用户放大和缩小视图
        enableCollisionDetection: cameraCrlOptions.enableCollisionDetection ?? true // 是否允许 地形相机的碰撞检测
      });

      // 解除在南北极区域鼠标操作限制
      if (cameraCrlOptions.constrainedAxis === false) {
        this._viewer.camera.constrainedAxis = undefined;
      }

      return this
    }

    // 设置 clock 相关
    _setClockOption(optionsNew) {
      const clock = this._viewer.clock;
      const clockOptions = this.options.clock ?? {};
      clockOptions.shouldAnimate = clockOptions.shouldAnimate ?? this.options.shouldAnimate ?? true;

      clock.shouldAnimate = clockOptions.shouldAnimate;

      if (clockOptions.startTime) {
        clock.startTime = this._getJulianDate(clockOptions.startTime);
        clock.currentTime = clock.startTime;
      }
      if (clockOptions.stopTime) {
        clock.stopTime = this._getJulianDate(clockOptions.stopTime);
      }
      if (clockOptions.currentTime) {
        clock.currentTime = this._getJulianDate(clockOptions.currentTime);
        if (!clockOptions.startTime) {
          clock.startTime = clock.currentTime.clone();
        }
        if (!clockOptions.stopTime) {
          clock.stopTime = Cesium__namespace.JulianDate.addDays(clock.currentTime, 1.0, new Cesium__namespace.JulianDate());
        }
      }

      if (clockOptions.multiplier) {
        clock.multiplier = clockOptions.multiplier; // 速度
      }

      return this
    }

    _getJulianDate(time) {
      if (isString(time)) {
        if (time.indexOf("Z") === -1) {
          return Cesium__namespace.JulianDate.fromDate(new Date(time))
        } else {
          return Cesium__namespace.JulianDate.fromIso8601(time)
        }
      } else {
        return time
      }
    }
  }

  // 一些默认值的修改 （构造地图前传入）
  function initBeforeCreateDefaultValue(options) {
    Cesium__namespace.Ion.defaultAccessToken = options?.scene?.ionToken || ion;

    Cesium__namespace.AnimationViewModel.defaultTicks = options?.control?.animationTicks || [
      0.1, 0.25, 0.5, 1.0, 2.0, 5.0, 10.0, 15.0, 30.0, 60.0, 120.0, 300.0, 600.0, 900.0, 1800.0, 3600.0
    ];

    Cesium__namespace.Camera.DEFAULT_VIEW_RECTANGLE = Cesium__namespace.Rectangle.fromDegrees(89.5, 20.4, 110.4, 61.2); // 更改默认视域
  }

  // popup处理
  class PopupMgr extends BaseControl {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      this._depthTest = options.depthTest ?? true;
    }

    //= ========= 对外属性 ==========

    // 是否打开深度判断（true时判断是否在球背面）
    get depthTest() {
      return this._depthTest
    }

    set depthTest(value) {
      this._depthTest = value;
    }

    //= ========= 方法 ==========

    /**
     * 创建_container控件容器对象的方法，
     * 对象添加到地图前创建一些对象的钩子方法，只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._layer = new GraphicLayer({
        private: true
      });
      this._layer._closeAllControl = function () {};
    }

    _enabledHook(show) {
      this._layer.show = show;
      if (!show) {
        this._layer.clear();
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.addLayer(this._layer);
      this._bindEvent();
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._unbindEvent();
      this._map.removeLayer(this._layer);
    }

    _bindEvent() {
      this._map.on(EventType.click, this._mouseClickHandler, this);
      this._map.on(EventType.clickTileGraphic, this._mouseClickHandler, this); // wms等瓦片弹窗
    }

    _unbindEvent() {
      this._map.off(EventType.click, this._mouseClickHandler, this);
      this._map.off(EventType.clickTileGraphic, this._mouseClickHandler, this);
    }

    //= ========= 内部方法 ==========
    // 鼠标点击事件
    _mouseClickHandler(event) {
      if (!this.enabled) {
        return
      }

      // cesium 本身的 entity、primitive对象
      if (this._openByMouseEvent(event.czmObject, event)) {
        return
      }

      // mars3d 的 BaseGraphic 继承对象
      if (this._openByMouseEvent(event.graphic, event)) {
        return
      }

      // mars3d 的  primitive 编辑时
      if (this._openByMouseEvent(event.graphic?.parent, event)) {
        return
      }

      // mars3d 的 BaseGraphicLayer 继承对象
      if (this._openByMouseEvent(event.layer, event)) {
        return
      }

      // mars3d 的 GroupLayer
      if (this._openByMouseEvent(event.layer?.parent, event)) {
        return
      }

      // 清除
      const popups = this._layer.getGraphics();
      for (let i = 0, len = popups.length; i < len; i++) {
        const popup = popups[i];
        if (popup.options.closeOnClick !== false) {
          popup.remove(true); // 关闭对应的
        }
      }
    }

    _getConfig(target) {
      return target._popupConfig || (target.getPopupConfig && target.getPopupConfig())
    }

    _openByMouseEvent(target, event) {
      if (!target) {
        return false
      }

      let cfg = this._getConfig(target);
      if (cfg === false) {
        // false时关闭右键，不再往上冒泡
        return true
      }

      if (!cfg) {
        return false
      }

      cfg = {
        ...cfg,
        ...event
      };

      this.open(event.cartesian, cfg);

      return true
    }

    close(graphic, layer) {
      if (!this._layer) {
        return
      }

      if (graphic) {
        const popups = this._layer.getGraphics();
        for (let i = 0, len = popups.length; i < len; i++) {
          const popup = popups[i];
          if (graphic === popup.options?.event?.graphic) {
            popup.remove(true); // 关闭对应的
          }
        }
        return
      }
      if (layer) {
        // 关闭对应的
        const popups = this._layer.getGraphics();
        for (let i = 0, len = popups.length; i < len; i++) {
          const popup = popups[i];
          if (layer === popup.options?.event?.layer) {
            popup.remove(true); // 关闭对应的
          }
        }
        return
      }

      this._layer.clear();
    }

    // popup处理
    open(position, config = {}) {
      const options = config.options || {};
      if (options?.autoClose ?? true) {
        this.close(); // 在打开弹窗时，是否自动关闭之前的弹窗
      }

      let target = config.target;
      if (config.layer && config.layer.fire) {
        target = config.layer;
      }
      if (config.graphic && config.graphic.fire) {
        target = config.graphic;
      }

      // 贴地对象的特殊处理
      let heightReference = Cesium__namespace.HeightReference.NONE;
      if (config.czmObject) {
        const czmObject = config.czmObject;
        heightReference = this.getHeightReference(czmObject, heightReference);

        if (czmObject.billboard || czmObject.point) {
          position = czmObject.position;
        } else if (czmObject.position && !(czmObject.position instanceof Cesium__namespace.ConstantPositionProperty)) {
          position = czmObject.position; // 不是常量时，动态变化的坐标
        }
      }

      if (config.graphic) {
        if (config.graphic.isPoint) {
          heightReference = config.graphic.style?.heightReference;
          if (config.graphic.style?.clampToGround) {
            heightReference = Cesium__namespace.HeightReference.CLAMP_TO_GROUND;
          }
        }

        if (config.target && config.graphic.property) {
          position = config.graphic._getPopupPosition(); // 不是常量时，动态变化的坐标
        }
      }

      // 样式
      const style = {
        ...options,
        depthTest: this.depthTest,
        heightReference: heightReference,
        html: config.content
      };

      const popup = this._createDivGraphic({
        ...options,
        position: position,
        style: style,
        attr: config.graphic?.attr,
        target: target,
        event: config
      });
      this._layer.addGraphic(popup);
    }

    _createDivGraphic(options) {
      return new Popup(options)
    }

    getHeightReference(entity, defVal) {
      if (!entity) {
        return defVal
      }
      if (Cesium__namespace.defined(entity._heightReference)) {
        return entity._heightReference
      }

      const graphic = entity.billboard || entity.point || entity.model || entity.label;
      if (Cesium__namespace.defined(graphic?.heightReference)) {
        return graphic.heightReference._value
      }
      return defVal
    }
  }

  // 注册下
  register$1("popup", PopupMgr);

  class TooltipMgr extends PopupMgr {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);
      this.options.cacheTime = this.options.cacheTime ?? 20;
    }

    //= ========= 方法 ==========
    _enabledHook(show) {
      super._enabledHook(show);

      if (this.moveTimer && !show) {
        clearTimeout(this.moveTimer);
        delete this.moveTimer;
      }
    }

    _bindEvent() {
      this._map.on(EventType.mouseMoveTarget, this._mouseMoveHandler, this);
      this._map.on(EventType.mouseDown, this._mouseDownHandler, this);
      this._map.on(EventType.mouseUp, this._mouseUpHandler, this);
    }

    _unbindEvent() {
      this._map.off(EventType.mouseMoveTarget, this._mouseMoveHandler, this);
      this._map.off(EventType.mouseDown, this._mouseDownHandler, this);
      this._map.off(EventType.mouseUp, this._mouseUpHandler, this);
    }

    _mouseDownHandler(event) {
      if (!this.enabled) {
        return
      }
      this._isMouseUpdownPressed = true;
      this.close();
    }

    _mouseUpHandler(event) {
      if (!this.enabled) {
        return
      }
      this._isMouseUpdownPressed = false;
    }

    // 鼠标移动事件，setTimeout是为了优化效率
    _mouseMoveHandler(event) {
      if (!this.enabled) {
        return
      }

      if (this.moveTimer) {
        clearTimeout(this.moveTimer);
        delete this.moveTimer;
      }

      if (this._isMouseUpdownPressed || !this._enabled) {
        this.close();
        return
      }

      this.moveTimer = setTimeout(() => {
        delete this.moveTimer;
        this._mouseClickHandler(event);
      }, this.options.cacheTime);
    }

    _getConfig(target) {
      return target._tooltipConfig || (target.getTooltipConfig && target.getTooltipConfig())
    }

    _createDivGraphic(options) {
      return new Tooltip(options)
    }
  }

  // 注册下
  register$1("tooltip", TooltipMgr);

  // 小tooltip，一般用于鼠标操作的提示
  // 比如标绘中使用
  class SmallTooltip extends BaseControl {
    // 方向，默认false右侧，true为左侧
    get direction() {
      return this.options.direction
    }

    set direction(value) {
      this.options.direction = value;

      if (value) {
        // left css时
        addClass(this._containerArrow, "mars3d-smallTooltip-leftArrow");
        removeClass(this._containerArrow, "mars3d-smallTooltip-rightArrow");
      } else {
        // right css时
        addClass(this._containerArrow, "mars3d-smallTooltip-rightArrow");
        removeClass(this._containerArrow, "mars3d-smallTooltip-leftArrow");
      }
    }

    _enabledHook(show) {
      this.show = show;
    }

    /**
     * 创建_container控件容器对象的方法，
     * 对象添加到地图前创建一些对象的钩子方法，只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._container = create$3("div", "mars3d-smallTooltip");
      this._container.style.display = "none";
      this._containerArrow = create$3("div", "mars3d-smallTooltip-arrow mars3d-smallTooltip-rightArrow", this._container);
      this._containerContent = create$3("div", "mars3d-smallTooltip-inner", this._container);

      // 鼠标的移入
      this._container.addEventListener("click", (e) => {
        this.close();
      });
    }

    close() {
      this._container.style.display = "none";
    }

    open(position, message) {
      if (!this.enabled) {
        return
      }

      if (message) {
        this._containerContent.innerHTML = message;
      }

      if (position) {
        if (position instanceof Cesium__namespace.Cartesian3) {
          position = Cesium__namespace.SceneTransforms.wgs84ToWindowCoordinates(this._map.scene, position);
        }

        this._container.style.display = "block";

        this._container.style.top = position.y - this._container.clientHeight / 2 + "px";

        if (this.options.direction) {
          // left css时
          this._container.style.left = position.x - this._container.clientWidth - 25 + "px";
        } else {
          // right css时
          this._container.style.left = position.x + 25 + "px";
        }
      } else {
        this._container.style.display = "none";
      }
    }
  }

  // 注册下
  register$1("smallTooltip", SmallTooltip);

  /**
   * 右键菜单 控件
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Boolean} [options.preventDefault=true] 是否取消右键菜单
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class ContextMenu
   * @extends {BaseControl}
   */
  class ContextMenu extends BaseControl {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      this._menuIndex = 0;
      this._menuObj = {};

      if (Cesium__namespace.defaultValue(this.options.preventDefault, true)) {
        document.oncontextmenu = function (e) {
          e.preventDefault();
        };
      }
    }

    //= ========= 对外属性 ==========

    get target() {
      return this._target
    }

    //= ========= 方法 ==========
    _enabledHook() {
      this._target = null;
    }

    /**
     * 创建_container控件容器对象的方法，
     * 对象添加到地图前创建一些对象的钩子方法，只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._container = create$3("div", "mars3d-contextmenu");
      this._container.style.display = "none";
      this._containerUl = create$3("ul", "mars3d-contextmenu-ul", this._container);
      this._containerUl.id = this.parentContainerId + "-mars3d-contextmenu-ul";
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.on(EventType.leftDown, this._downHandler, this);
      this._map.on(EventType.middleDown, this._downHandler, this);
      this._map.on(EventType.wheel, this._downHandler, this);
      this._map.on(EventType.rightClick, this._rightClickHandler, this);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.off(EventType.leftDown, this._downHandler, this);
      this._map.off(EventType.middleDown, this._downHandler, this);
      this._map.off(EventType.wheel, this._downHandler, this);
      this._map.off(EventType.rightClick, this._rightClickHandler, this);

      this._target = null;
      this._eventResult = null;
    }

    //= ========= 内部方法 ==========
    _downHandler(event) {
      this.close();
    }

    _rightClickHandler(event) {
      this.close();
      if (!this.enabled) {
        return
      }

      // cesium 本身的 entity、primitive对象
      if (this._openByClick(event.czmObject, event)) {
        return
      }

      // mars3d 的 BaseGraphic 继承对象
      if (this._openByClick(event.graphic, event)) {
        return
      }
      // mars3d 的  primitive 编辑时
      if (this._openByClick(event.graphic?.parent, event)) {
        return
      }

      // mars3d 的 BaseGraphicLayer 继承对象
      if (this._openByClick(event.layer, event)) {
        return
      }

      // mars3d 的 GroupLayer
      if (this._openByClick(event.layer?.parent, event)) {
        return
      }

      this._openByClick(this._map, event);
    }

    _openByClick(target, event) {
      if (!target) {
        return false
      }
      let cfg = target._contextmenuConfig || (target.getContextMenu && target.getContextMenu());

      if (cfg === false) {
        // false时关闭右键，不再往上冒泡
        return true
      }

      if (!cfg) {
        return false
      }

      cfg = {
        ...cfg,
        ...event
      };

      this.open(event.cartesian, cfg);

      return true
    }

    close(graphic, layer) {
      if (this._show === false) {
        return
      }
      if (graphic && graphic !== this._eventResult?.graphic) {
        return
      }
      if (layer && layer !== this._eventResult?.layer) {
        return
      }
      this.show = false;

      if (this.target?.fire) {
        this.target.fire(EventType.contextMenuClose, {}, true);
      } else {
        this._map.fire(EventType.contextMenuClose);
      }
    }

    open(position, config = {}) {
      const options = config.options || {};
      let target = config.target;
      if (config.layer && config.layer.fire) {
        target = config.layer;
      }
      if (config.graphic && config.graphic.fire) {
        target = config.graphic;
      }

      const contextmenu = config.content;
      if (!contextmenu || contextmenu.length === 0) {
        this.close();
        return
      }

      // 计算显示位置
      const windowPosition = config.windowPosition || Cesium__namespace.SceneTransforms.wgs84ToWindowCoordinates(this._map.scene, position);

      const eventResult = {
        ...config,
        windowPosition: windowPosition,
        position: position,
        target: target
      };
      this._eventResult = eventResult;

      let inhtml = "";
      for (let i = 0, len = contextmenu.length; i < len; i++) {
        const item = contextmenu[i];
        const result = this._getItemHtml(item, eventResult);
        if (result) {
          inhtml += result;
        }
      }

      if (inhtml === "") {
        this.close();
        return
      }

      this._containerUl.innerHTML = inhtml;

      const contextmenuItemList = this._containerUl.querySelectorAll(".contextmenu-item");
      const that = this;
      for (let i = 0; i < contextmenuItemList.length; i++) {
        const contextmenuItem = contextmenuItemList[i];

        contextmenuItem.addEventListener("click", function (e) {
          if (e.stopPropagation) {
            e.stopPropagation();
          }

          const index = Number(this.getAttribute("data-index"));
          const item = that._menuObj[index];
          const callback = item.callback;
          const result = { ...eventResult, data: item };
          if (callback) {
            callback(result);
          }
          if (that.target?.fire) {
            that.target.fire(EventType.contextMenuClick, result, true);
          } else {
            that._map.fire(EventType.contextMenuClick, result);
          }

          const childrenCount = Number(this.getAttribute("data-count") || 0);
          if (childrenCount === 0) {
            that.close();
          }
        });

        // 鼠标滑过弹出二级菜单
        contextmenuItem.addEventListener("mouseover", function (e) {
          // 所有的二级菜单隐藏
          const oldsub = that._container.querySelectorAll(".mars3d-sub-menu");
          for (let j = 0; j < oldsub.length; j++) {
            oldsub[j].style.display = "none";
          }

          const sub_menu = this.querySelector(".mars3d-sub-menu");
          if (sub_menu) {
            sub_menu.style.display = "block";
          }

          removeClass(that._containerUl.querySelector(".active"), "active");
          addClass(this, "active");
        });
      }

      // 不显示前，无法计算width和width
      this.show = true;
      this._target = target;

      // 计算位置
      let top = windowPosition.y;
      let left = windowPosition.x;
      if (options.anchor) {
        left += options.anchor[0];
        top += options.anchor[1];
      } else {
        if (options.offsetX) {
          left += options.offsetX;
        }
        if (options.offsetY) {
          top += options.offsetY;
        }
      }

      const menuHeight = this._container.offsetHeight;
      const menuWidth = this._container.offsetWidth;

      // 判断垂直方向 是否超过了 屏幕高度
      if (top + menuHeight > this._map.scene.canvas.clientHeight) {
        top -= menuHeight - 10;
        if (top <= 0) {
          top = 0;
        }
      } else {
        top += 10;
      }

      // 判断水平方向 是否超过了屏幕宽度
      let hasLeft = true;
      if (left + menuWidth > this._map.scene.canvas.clientWidth) {
        left -= menuWidth - 10;
        hasLeft = false;
        if (left <= 0) {
          left = 0;
        }
      } else {
        left += 10;
      }

      this._container.style.left = left + "px";
      this._container.style.top = top + "px";

      // 二级菜单
      const subItemList = this._containerUl.querySelectorAll(".mars3d-sub-menu");

      for (let j = 0; j < subItemList.length; j++) {
        const subItem = subItemList[j];

        const subHeight = Number(subItem.getAttribute("data-count") || 1) * 34;
        let subTop = top + subItem.parentElement.offsetTop;

        // 判断垂直方向 是否超过了 屏幕高度
        subItem.style.top = "0";
        subItem.style.bottom = "auto";
        if (subTop + subHeight > this._map.scene.canvas.clientHeight) {
          subTop -= subHeight;
          if (subTop > 0) {
            subItem.style.top = "auto";
            subItem.style.bottom = "0";
          }
        }

        if (hasLeft) {
          subItem.style.left = menuWidth + 10 + "px";
        } else {
          subItem.style.right = menuWidth + 10 + "px";
        }
      }

      if (target.fire) {
        target.fire(EventType.contextMenuOpen, {}, true);
      } else {
        this._map.fire(EventType.contextMenuOpen);
      }
    }

    _getItemHtml(item, eventresult) {
      if (item.hasOwnProperty("show")) {
        let show = item.show;
        try {
          if (typeof show === "function") {
            // 回调方法
            eventresult.data = item;
            show = item.show(eventresult);
          }
        } catch (e) {
          logError("右键菜单操作出错", e);
        }

        if (!show) {
          return
        }
      }

      let inhtml;
      if (item.text) {
        let childrenHtml = "";
        let childTip = "";
        let childrenCount = 0;
        if (item.children) {
          for (let j = 0, len2 = item.children.length; j < len2; j++) {
            const childitem = item.children[j];
            eventresult.data = childitem;
            const result = this._getItemHtml(childitem, eventresult);
            if (result) {
              childrenHtml += result;
              childrenCount++;
            }
          }

          if (childrenCount === 0) {
            return
          }

          childrenHtml = `<ul class="mars3d-contextmenu-ul mars3d-sub-menu" data-count="${childrenCount}">${childrenHtml}</ul>`;
          childTip = `
            <span  class="contextmenu-arrow" >
              <svg width="20" height="20" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="48" height="48" fill="white" fill-opacity="0.01"/><path d="M20 12L32 24L20 36V12Z" fill="#ffffff" stroke="#ffffff" stroke-width="4" stroke-linejoin="round"/></svg>
            </span>  `;
        }

        this._menuIndex++;
        this._menuObj[this._menuIndex] = item;

        const iconHtml = this._createIcon(item.icon || item.iconCls, null, "contextmenu-icon");

        inhtml = `<li class="contextmenu-item" data-index="${this._menuIndex}" data-count="${childrenCount}">
                    <a href="javascript:void(0)">${iconHtml}${item.text}${childTip}</a>
                    ${childrenHtml}
                </li>`;
      } else {
        inhtml = '<li class="line"></li>';
      }
      return inhtml
    }
  }

  // 注册下
  register$1("contextMenu", ContextMenu);

  /**
   * 键盘漫游控制类
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Number} [options.moveStep=10] 平移步长 (米)
   * @param {Number} [options.dirStep=25] 相机原地旋转步长，值越大步长越小。
   * @param {Number} [options.rotateStep=1.0] 相机围绕目标点旋转速率，0.3 - 2.0
   * @param {Number} [options.minPitch=0.1] 最小仰角  0 - 1
   * @param {Number} [options.maxPitch=0.95] 最大仰角  0 - 1
   * @param {Number} [options.minHeight=0] 最低高度（单位：米）
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @param {BaseClass|Boolean} [options.eventParent]  指定的事件冒泡对象，默认为所加入的map对象，false时不冒泡事件
   * @export
   * @class KeyboardRoam
   * @extends {BaseControl}
   */
  class KeyboardRoam extends BaseControl {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      // 赋值参数
      this.setOptions(options);

      this.flags = {
        moveForward: false,
        moveBackward: false,
        moveUp: false,
        moveDown: false,
        moveLeft: false,
        moveRight: false
      };
    }

    //= ========= 对外属性 ==========

    /**
     *  平移步长 (米)
     * @type {Number}
     */
    get moveStep() {
      return this._moveStep
    }

    set moveStep(value) {
      this._moveStep = value;
    }

    /**
     * 相机原地旋转步长，值越大步长越小。
     * @type {Number}
     */
    get dirStep() {
      return this._dirStep
    }

    set dirStep(value) {
      this._dirStep = value;
    }

    /**
     * 相机围绕目标点旋转速率，0.3 - 2.0
     * @type {Number}
     */
    get rotateStep() {
      return this._rotateStep
    }

    set rotateStep(value) {
      this._rotateStep = value;
    }

    /**
     * 最小仰角  0 - 1
     * @type {Number}
     */
    get minPitch() {
      return this._minPitch
    }

    set minPitch(value) {
      this._minPitch = value;
    }

    /**
     * 最大仰角  0 - 1
     * @type {Number}
     */
    get maxPitch() {
      return this._maxPitch
    }

    set maxPitch(value) {
      this._maxPitch = value;
    }

    /**
     * 最低高度（单位：米）
     * @type {Number}
     */
    get minHeight() {
      return this._minHeight
    }

    set minHeight(value) {
      this._minHeight = value;
    }

    //= ========= 方法 ==========
    /**
     * 重新赋值参数，同构造方法参数一致。
     * @param {Object} options 参数,与类的构造方法参数相同
     * @return {KeyboardRoam} 当前对象本身，可以链式调用
     */
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options
      };

      this._moveStep = this.options.moveStep ?? 10; // 平移步长 (米)
      this._dirStep = this.options.dirStep ?? 25; // 相机原地旋转步长，值越大步长越小。
      this._rotateStep = this.options.rotateStep ?? 1.0; // 相机围绕目标点旋转速率，0.3 - 2.0
      this._minPitch = this.options.minPitch ?? 0.1; // 最小仰角  0 - 1
      this._maxPitch = this.options.maxPitch ?? 0.95; // 最大仰角  0 - 1
      this._minHeight = this.options.minHeight ?? 0;

      return this
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      this._map.on(EventType.keydown, this._onKeyDown, this);
      this._map.on(EventType.keyup, this._onKeyUp, this);
      this._map.on(EventType.clockTick, this._onClockTick, this);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      this._map.off(EventType.keydown, this._onKeyDown, this);
      this._map.off(EventType.keyup, this._onKeyUp, this);
      this._map.off(EventType.clockTick, this._onClockTick, this);
    }

    //= ================相关事件回调方法======================
    _onKeyDown(event) {
      if (!this.enabled) {
        return
      }

      const flagName = this._getFlagForKeyCode(event.keyCode);
      if (typeof flagName !== "undefined") {
        this.flags[flagName] = true;
      }
    }

    _onKeyUp(event) {
      if (!this.enabled) {
        return
      }

      const flagName = this._getFlagForKeyCode(event.keyCode);
      if (typeof flagName !== "undefined") {
        this.flags[flagName] = false;
      }
    }

    _getFlagForKeyCode(keyCode) {
      switch (keyCode) {
        // 平移
        case "W".charCodeAt(0): // 向前平移镜头，不改变相机朝向
          return "moveForward"
        case "S".charCodeAt(0): // 向后平移镜头，不改变相机朝向
          return "moveBackward"
        case "D".charCodeAt(0): // 向右平移镜头，不改变相机朝向
          return "moveRight"
        case "A".charCodeAt(0): // 向左平移镜头，不改变相机朝向
          return "moveLeft"
        case "Q".charCodeAt(0): // 向上平移镜头，不改变相机朝向
          return "moveUp"
        case "E".charCodeAt(0): // 向下平移镜头，不改变相机朝向
          return "moveDown"

        // 相对于相机本身
        case 38: // 方向键上键
          this.rotateCamera(MoveType.TOP_ROTATE); // 相机原地上旋转
          break
        case 37: // 方向键左键
          this.rotateCamera(MoveType.LEFT_ROTATE); // 相机原地左旋转
          break
        case 39: // 方向键右键
          this.rotateCamera(MoveType.RIGHT_ROTATE); // 相机原地右旋转
          break
        case 40: // 方向键下键
          this.rotateCamera(MoveType.BOTTOM_ROTATE); // 相机原地下旋转
          break

        // 相对于屏幕中心点
        case "I".charCodeAt(0):
        case 104: // 数字键盘8
          this.moveCamera(MoveType.ENLARGE); // 向屏幕中心靠近
          break
        case "K".charCodeAt(0):
        case 101: // 数字键盘5
          this.moveCamera(MoveType.NARROW); // 向屏幕中心远离
          break
        case "J".charCodeAt(0):
        case 100: // 数字键盘4
          this.moveCamera(MoveType.LEFT_ROTATE); // 围绕屏幕中心左旋转
          break
        case "L".charCodeAt(0):
        case 102: // 数字键盘6
          this.moveCamera(MoveType.RIGHT_ROTATE); // 围绕屏幕中心右旋转
          break
        case "U".charCodeAt(0):
        case 103: // 数字键盘7
          this.moveCamera(MoveType.TOP_ROTATE); // 围绕屏幕中心上旋转
          break
        case "O".charCodeAt(0):
        case 105: // 数字键盘9
          this.moveCamera(MoveType.BOTTOM_ROTATE); // 围绕屏幕中心下旋转
          break
      }
      return undefined
    }

    //= ================平移======================
    /**
     * 开始自动向前平移镜头，不改变相机朝向
     * @return {void}  无
     */
    startMoveForward() {
      this.flags.moveForward = true;
    }

    /**
     * 停止自动向前平移镜头，不改变相机朝向
     * @return {void}  无
     */
    stopMoveForward() {
      this.flags.moveForward = false;
    }

    /**
     * 开始自动向后平移镜头，不改变相机朝向
     * @return {void}  无
     */
    startMoveBackward() {
      this.flags.moveBackward = true;
    }

    /**
     * 停止自动向后平移镜头，不改变相机朝向
     * @return {void}  无
     */
    stopMoveBackward() {
      this.flags.moveBackward = false;
    }

    /**
     *开始自动向右平移镜头，不改变相机朝向
     * @return {void}  无
     */
    startMoveRight() {
      this.flags.moveRight = true;
    }

    /**
     * 停止自动向右平移镜头，不改变相机朝向
     * @return {void}  无
     */
    stopMoveRight() {
      this.flags.moveRight = false;
    }

    /**
     *开始自动向左平移镜头，不改变相机朝向
     * @return {void}  无
     */
    startMoveLeft() {
      this.flags.moveLeft = true;
    }

    /**
     * 停止自动向左平移镜头，不改变相机朝向
     * @return {void}  无
     */
    stopMoveLeft() {
      this.flags.moveLeft = false;
    }

    moveForward(distance) {
      // 和模型的相机移动不太一样  不是沿着相机目标方向，而是默认向上方向 和 向右 方向的插值方向
      const camera = this._map.camera;
      let direction = camera.direction;
      // 获得此位置默认的向上方向
      const up = Cesium__namespace.Cartesian3.normalize(camera.position, new Cesium__namespace.Cartesian3());

      // right = direction * up
      const right = Cesium__namespace.Cartesian3.cross(direction, up, new Cesium__namespace.Cartesian3());

      direction = Cesium__namespace.Cartesian3.cross(up, right, new Cesium__namespace.Cartesian3());

      direction = Cesium__namespace.Cartesian3.normalize(direction, direction);
      direction = Cesium__namespace.Cartesian3.multiplyByScalar(direction, distance, direction);

      camera.position = Cesium__namespace.Cartesian3.add(camera.position, direction, camera.position);
    }

    _onClockTick(clock) {
      if (!this.enabled) {
        return
      }

      const camera = this._map.camera;

      // Change movement speed based on the distance of the camera to the surface of the ellipsoid.
      // var cameraHeight = this._map.scene.globe.ellipsoid.cartesianToCartographic(camera.position).height;
      // var moveRate = cameraHeight / this.moveStep;
      const moveRate = this.moveStep;

      if (this.flags.moveForward) {
        this.moveForward(moveRate);
      }
      if (this.flags.moveBackward) {
        this.moveForward(-moveRate);
      }
      if (this.flags.moveUp) {
        camera.moveUp(moveRate);
      }
      if (this.flags.moveDown) {
        if (camera.positionCartographic.height - moveRate >= this.minHeight) {
          camera.moveDown(moveRate);
        }
      }
      if (this.flags.moveLeft) {
        camera.moveLeft(moveRate);
      }
      if (this.flags.moveRight) {
        camera.moveRight(moveRate);
      }
    }

    //= ================相对于屏幕或相机======================
    _resetCamera(newCamera) {
      if (!newCamera) {
        return
      }
      this._map.scene.camera.position = newCamera.position;
      this._map.scene.camera.direction = newCamera.direction;
      this._map.scene.camera.right = newCamera.right;
      this._map.scene.camera.up = newCamera.up;
    }

    _limitAngle(up, position, type) {
      const dotNum = Cesium__namespace.Cartesian3.dot(up, Cesium__namespace.Cartesian3.normalize(position, new Cesium__namespace.Cartesian3()));
      if (type === "up" && dotNum < this.minPitch) {
        return false
      }
      if (type === "down" && dotNum > this.maxPitch) {
        return false
      }
      return true
    }

    _computedNewPos(camera, dir, rotate) {
      // var step = this.rotateStep;
      const oldpos = camera.position;
      const winCenter = this._map.getCenter();
      if (!winCenter) {
        return
      }
      const center = winCenter.toCartesian();
      if (!center) {
        return
      }
      const oldDis = Cesium__namespace.Cartesian3.distance(center, oldpos);
      let step = oldDis / 100;
      step = rotate ? step * this.rotateStep : step;
      const newCamera = {};
      let ray = new Cesium__namespace.Ray(oldpos, dir);
      newCamera.position = Cesium__namespace.Ray.getPoint(ray, step);

      // var cheight = Cesium.Cartographic.fromCartesian(newCamera.position).height;
      // if (cheight < 500)   return;

      newCamera.direction = camera.direction;
      newCamera.right = camera.right;
      newCamera.up = camera.up;
      if (rotate) {
        const newDir = Cesium__namespace.Cartesian3.normalize(
          Cesium__namespace.Cartesian3.subtract(newCamera.position, center, new Cesium__namespace.Cartesian3()),
          new Cesium__namespace.Cartesian3()
        );
        ray = new Cesium__namespace.Ray(center, newDir);
        newCamera.position = Cesium__namespace.Ray.getPoint(ray, oldDis);
        newCamera.direction = Cesium__namespace.Cartesian3.negate(newDir, new Cesium__namespace.Cartesian3());
        // newCamera.up = camera.up;
        newCamera.up = Cesium__namespace.Cartesian3.normalize(newCamera.position, new Cesium__namespace.Cartesian3());
        newCamera.right = Cesium__namespace.Cartesian3.cross(newCamera.direction, newCamera.up, new Cesium__namespace.Cartesian3());
      }
      return newCamera
    }

    /**
     * 相对于屏幕中心点 转动
     *
     * @param {MoveType} type 旋转的方向
     * @return {void}  无
     */
    moveCamera(type) {
      const camera = this._map.scene.camera;
      let newCamera;
      switch (type) {
        case MoveType.NARROW:
          newCamera = this._computedNewPos(camera, Cesium__namespace.Cartesian3.negate(camera.direction, new Cesium__namespace.Cartesian3()));
          break
        case MoveType.LEFT_ROTATE:
          newCamera = this._computedNewPos(camera, Cesium__namespace.Cartesian3.negate(camera.right, new Cesium__namespace.Cartesian3()), true);
          break
        case MoveType.RIGHT_ROTATE:
          newCamera = this._computedNewPos(camera, camera.right, true);
          break
        case MoveType.TOP_ROTATE:
          if (!this._limitAngle(Cesium__namespace.clone(camera.up), Cesium__namespace.clone(camera.position), "up")) {
            return
          }
          newCamera = this._computedNewPos(camera, Cesium__namespace.clone(camera.up), true);
          break
        case MoveType.BOTTOM_ROTATE:
          if (!this._limitAngle(Cesium__namespace.clone(camera.up), Cesium__namespace.clone(camera.position), "down")) {
            return
          }
          newCamera = this._computedNewPos(camera, Cesium__namespace.Cartesian3.negate(camera.up, new Cesium__namespace.Cartesian3()), true);
          break
        case MoveType.ENLARGE:
        default:
          newCamera = this._computedNewPos(camera, camera.direction);
          break
      }
      if (!newCamera) {
        return
      }
      this._resetCamera(newCamera);
    }

    /**
     * 相对于相机本身 转动
     *
     * @param {MoveType} type 旋转的方向
     * @return {void}  无
     */
    rotateCamera(type) {
      let winPos = [0, 0];
      const width = this._map.scene.canvas.clientWidth;
      const height = this._map.scene.canvas.clientHeight;
      const step = (width + height) / this.dirStep;
      switch (type) {
        case MoveType.LEFT_ROTATE:
          winPos = [(-step * width) / height, 0];
          break
        case MoveType.RIGHT_ROTATE:
          winPos = [(step * width) / height, 0];
          break
        case MoveType.TOP_ROTATE:
          winPos = [0, step];
          break
        case MoveType.BOTTOM_ROTATE:
          winPos = [0, -step];
          break
        default:
          return
      }
      const x = winPos[0] / width;
      const y = winPos[1] / height;
      // 这计算了，分别向右 和 向上移动的
      const lookFactor = 0.05;
      const camera = this._map.camera;
      camera.lookRight(x * lookFactor);
      camera.lookUp(y * lookFactor);

      // 获得direction 方向
      const direction = camera.direction;
      // 获得此位置默认的向上方向
      let up = Cesium__namespace.Cartesian3.normalize(camera.position, new Cesium__namespace.Cartesian3());

      // right = direction * up
      const right = Cesium__namespace.Cartesian3.cross(direction, up, new Cesium__namespace.Cartesian3());
      // up = right * direction
      up = Cesium__namespace.Cartesian3.cross(right, direction, new Cesium__namespace.Cartesian3());

      camera.up = up;
      camera.right = right;
    }
  }
  // 注册下
  register$1("keyboardRoam", KeyboardRoam);

  /**
   * 相机旋转的类型
   * @type {MoveType}
   */
  KeyboardRoam.MoveType = MoveType;

  // 高德POI查询 类
  class GaodePOIGeocoder {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      this.options = options;
      this.gaodekey = options.key || gaodeArr;
    }

    getArrayRandomOne() {
      const arr = this.gaodekey;
      const n = Math.floor(Math.random() * arr.length + 1) - 1;
      return arr[n]
    }

    geocode(query) {
      const key = this.getArrayRandomOne();

      const resource = new Cesium__namespace.Resource({
        url: "https://restapi.amap.com/v3/place/text",
        queryParameters: {
          count: 20,
          key: key,
          keywords: query,
          types: "110000|120000|130000|140000|180000|190000|",
          ...(this.options.parameters || {})
        }
      });

      const that = this;
      return resource.fetchJson().then(function (results) {
        if (results.infocode !== "10000") {
          logError("请求失败(" + results.infocode + ")：" + results.info);
          return {}
        }
        if (results.pois.length === 0) {
          logInfo("未查询到“" + query + "”相关数据！");
          return {}
        }

        let height = 3000;
        if (that.map.camera.positionCartographic.height < height) {
          height = that.map.camera.positionCartographic.height;
        }

        return results.pois.map(function (resultObject) {
          let arrjwd = resultObject.location.split(",");
          arrjwd = gcj2wgs(arrjwd); // 纠偏

          return {
            displayName: resultObject.name,
            destination: Cesium__namespace.Cartesian3.fromDegrees(arrjwd[0], arrjwd[1], height)
          }
        })
      })
    }
  }

  // 获取平台内置的右键菜单
  function getDefaultContextMenu(map) {
    const that = map.contextmenu;

    return [
      {
        text: map.getLangText("_查看此处坐标"),
        icon: Icon.Coordinates,
        show: function (e) {
          return Cesium__namespace.defined(e.cartesian)
        },
        callback: function (e) {
          // 经纬度
          const mpt = LngLatPoint.fromCartesian(e.cartesian);

          const ptNew = proj4Trans([mpt.lng, mpt.lat], "EPSG:4326", CRS.CGCS2000_GK_Zone_3);

          const inhtml = `
         ${map.getLangText("_经度")}:${mpt.lng}, ${map.getLangText("_纬度")}:${mpt.lat}, ${map.getLangText("_海拔")}:${mpt.alt},
         ${map.getLangText("_横坐标")}:${ptNew[0].toFixed(1)}, ${map.getLangText("_纵坐标")}:${ptNew[1].toFixed(1)} (CGCS2000)
        `;
          alert(inhtml, map.getLangText("_位置信息"));

          // 打印方便测试
          const ptX = formatNum$1(e.cartesian.x, 1); // 笛卡尔
          const ptY = formatNum$1(e.cartesian.y, 1);
          const ptZ = formatNum$1(e.cartesian.z, 1);
          logInfo(`经纬度：${mpt.toString()} , 笛卡尔：${ptX},${ptY},${ptZ}`);
        }
      },

      {
        text: map.getLangText("_查看当前视角"),
        icon: Icon.CameraInfo,
        callback: function (e) {
          const mpt = JSON.stringify(map.getCameraView());
          logInfo(mpt);
          alert(mpt, map.getLangText("_当前视角信息"));
        }
      },
      {
        text: map.getLangText("_视角切换"),
        icon: Icon.Camera,
        children: [
          {
            text: map.getLangText("_允许进入地下"),
            icon: Icon.UndergroundYes,
            show: function (e) {
              return map.scene.screenSpaceCameraController.enableCollisionDetection
            },
            callback: function (e) {
              map.scene.screenSpaceCameraController.enableCollisionDetection = false;
            }
          },
          {
            text: map.getLangText("_禁止进入地下"),
            icon: Icon.UndergroundNo,
            show: function (e) {
              return !map.scene.screenSpaceCameraController.enableCollisionDetection
            },
            callback: function (e) {
              map.scene.screenSpaceCameraController.enableCollisionDetection = true;
            }
          },
          {
            text: map.getLangText("_绕此处环绕飞行"),
            icon: Icon.RotatePointStart,
            show: function (e) {
              return e.cartesian && (!that.rotatePoint || !that.rotatePoint?.isStart)
            },
            callback: function (e) {
              if (!that.rotatePoint) {
                that.rotatePoint = new RotatePoint();
                map.addThing(that.rotatePoint);
              }
              that.rotatePoint.start(e.cartesian);
            }
          },
          {
            text: map.getLangText("_关闭环绕飞行"),
            icon: Icon.RotatePointStop,
            show: function (e) {
              return that.rotatePoint?.isStart
            },
            callback: function (e) {
              if (that.rotatePoint) {
                that.rotatePoint.stop();
              }
            }
          },

          {
            text: map.getLangText("_移动到此处"),
            icon: Icon.FlyToPoint,
            show: function (e) {
              return Cesium__namespace.defined(e.cartesian)
            },
            callback: function (e) {
              const cameraDistance = Cesium__namespace.Cartesian3.distance(e.cartesian, map.camera.positionWC) * 0.1;

              map.flyToPoint(e.cartesian, {
                radius: cameraDistance, // 距离目标点的距离
                maximumHeight: map.camera.positionCartographic.height
              });
            }
          },
          {
            text: map.getLangText("_第一视角站到此处"),
            icon: Icon.FirstPerspective,
            show: function (e) {
              return Cesium__namespace.defined(e.cartesian)
            },
            callback: function (e) {
              map.camera.flyTo({
                destination: addPositionsHeight(e.cartesian, 10), // 升高10米
                orientation: {
                  heading: map.camera.heading,
                  pitch: 0.0,
                  roll: 0.0
                },
                maximumHeight: map.camera.positionCartographic.height
              });
            }
          },
          {
            text: map.getLangText("_开启键盘漫游"),
            icon: Icon.KeyboardRoamYes,
            show: function (e) {
              return !map.keyboardRoam.enabled
            },
            callback: function (e) {
              map.keyboardRoam.enabled = true;
            }
          },
          {
            text: map.getLangText("_关闭键盘漫游"),
            icon: Icon.KeyboardRoamNo,
            show: function (e) {
              return map.keyboardRoam.enabled
            },
            callback: function (e) {
              map.keyboardRoam.enabled = false;
            }
          },
          {
            text: map.getLangText("_跟踪锁定"),
            icon: Icon.TrackedEntityYes,
            show: function (e) {
              const graphic = e.graphic;
              if (!graphic) {
                return false
              }

              if (graphic.entity instanceof Cesium__namespace.Entity) {
                return true
              } else if (graphic.trackedEntity instanceof Cesium__namespace.Entity) {
                return true
              }

              return false
            },
            callback: function (e) {
              map.trackedEntity = e.graphic;
            }
          },
          {
            text: map.getLangText("_取消锁定"),
            icon: Icon.TrackedEntityNo,
            show: function (e) {
              return map.trackedEntity !== undefined
            },
            callback: function (e) {
              map.trackedEntity = undefined;
            }
          }
        ]
      },
      {
        text: map.getLangText("_三维模型"),
        icon: Icon.Tileset,
        show: function (e) {
          const model = map.pick3DTileset(e.cartesian); // 拾取绘制返回的模型
          return Cesium__namespace.defined(model)
        },
        children: [
          {
            text: map.getLangText("_显示三角网"),
            icon: Icon.TilesetWireframeYes,
            show: function (e) {
              const model = map.pick3DTileset(e.cartesian); // 拾取绘制返回的模型
              return !model.debugWireframe
            },
            callback: function (e) {
              const model = map.pick3DTileset(e.cartesian); // 拾取绘制返回的模型
              model.debugWireframe = true;
            }
          },
          {
            text: map.getLangText("_关闭三角网"),
            icon: Icon.TilesetWireframeNo,
            show: function (e) {
              const model = map.pick3DTileset(e.cartesian); // 拾取绘制返回的模型
              return model.debugWireframe
            },
            callback: function (e) {
              const model = map.pick3DTileset(e.cartesian); // 拾取绘制返回的模型
              model.debugWireframe = false;
            }
          },
          {
            text: map.getLangText("_显示包围盒"),
            icon: Icon.TilesetBoundingVolumeYes,
            show: function (e) {
              const model = map.pick3DTileset(e.cartesian); // 拾取绘制返回的模型
              return !model.debugShowBoundingVolume
            },
            callback: function (e) {
              const model = map.pick3DTileset(e.cartesian); // 拾取绘制返回的模型
              model.debugShowBoundingVolume = true;
            }
          },
          {
            text: map.getLangText("_关闭包围盒"),
            icon: Icon.TilesetBoundingVolumeNo,
            show: function (e) {
              const model = map.pick3DTileset(e.cartesian); // 拾取绘制返回的模型
              return model.debugShowBoundingVolume
            },
            callback: function (e) {
              const model = map.pick3DTileset(e.cartesian); // 拾取绘制返回的模型
              model.debugShowBoundingVolume = false;
            }
          }
        ]
      },

      {
        text: map.getLangText("_地形服务"),
        icon: Icon.Terrain,
        show: function (e) {
          return Cesium__namespace.defined(e.cartesian)
        },
        children: [
          {
            text: map.getLangText("_开启地形"),
            icon: Icon.TerrainYes,
            show: function (e) {
              return !map.hasTerrain
            },
            callback: function (e) {
              map.hasTerrain = true;
            }
          },
          {
            text: map.getLangText("_关闭地形"),
            icon: Icon.TerrainNo,
            show: function (e) {
              return map.hasTerrain
            },
            callback: function (e) {
              map.hasTerrain = false;
            }
          },
          {
            text: map.getLangText("_显示三角网"),
            icon: Icon.TerrainWireframeYes,
            show: function (e) {
              return !map.scene.globe._surface.tileProvider._debug.wireframe
            },
            callback: function (e) {
              map.scene.globe._surface.tileProvider._debug.wireframe = true;
            }
          },
          {
            text: map.getLangText("_关闭三角网"),
            icon: Icon.TerrainWireframeNo,
            show: function (e) {
              return map.scene.globe._surface.tileProvider._debug.wireframe
            },
            callback: function (e) {
              map.scene.globe._surface.tileProvider._debug.wireframe = false;
            }
          }
        ]
      },
      {
        text: map.getLangText("_图上量算"),
        icon: Icon.Measure,
        children: [
          {
            text: map.getLangText("_距离"),
            icon: Icon.MeasureDistance,
            callback: function (e) {
              if (!that.measure) {
                that.measure = new Measure();
                map.addThing(that.measure);
              }
              that.measure.distance();
            }
          },
          {
            text: map.getLangText("_面积"),
            icon: Icon.MeasureArea,
            callback: function (e) {
              if (!that.measure) {
                that.measure = new Measure();
                map.addThing(that.measure);
              }
              that.measure.area();
            }
          },
          {
            text: map.getLangText("_高度差"),
            icon: Icon.MeasureHeight,
            callback: function (e) {
              if (!that.measure) {
                that.measure = new Measure();
                map.addThing(that.measure);
              }
              that.measure.heightTriangle();
            }
          },
          {
            text: map.getLangText("_角度"),
            icon: Icon.MeasureAngle,
            callback: function (e) {
              if (!that.measure) {
                that.measure = new Measure();
                map.addThing(that.measure);
              }
              that.measure.angle();
            }
          },
          {
            text: map.getLangText("_删除测量"),
            icon: Icon.Delete,
            show: function (e) {
              return that.measure && that.measure.hasMeasure
            },
            callback: function (e) {
              if (that.measure) {
                that.measure.clear();
              }
            }
          }
        ]
      },

      {
        text: map.getLangText("_图上标记"),
        icon: Icon.Draw,
        children: [
          {
            text: map.getLangText("_标记点"),
            icon: Icon.DrawPoint,
            callback: function (e) {
              map.graphicLayer.startDraw({
                type: "point",
                style: {
                  pixelSize: 12,
                  color: "#3388ff"
                },
                success: function (graphic) {
                  // eslint-disable-next-line no-console
                  console.log(JSON.stringify(graphic.coordinates));
                }
              });
            }
          },
          {
            text: map.getLangText("_标记线"),
            icon: Icon.DrawPolyline,
            callback: function (e) {
              map.graphicLayer.startDraw({
                type: "polyline",
                style: {
                  color: "#55ff33",
                  width: 3
                },
                success: function (graphic) {
                  // eslint-disable-next-line no-console
                  console.log(JSON.stringify(graphic.coordinates));
                }
              });
            }
          },
          {
            text: map.getLangText("_标记面"),
            icon: Icon.DrawPolygon,
            callback: function (e) {
              map.graphicLayer.startDraw({
                type: "polygon",
                style: {
                  color: "#29cf34",
                  opacity: 0.5,
                  outline: true,
                  outlineWidth: 2.0
                },
                success: function (graphic) {
                  // eslint-disable-next-line no-console
                  console.log(JSON.stringify(graphic.coordinates));
                }
              });
            }
          },
          {
            text: map.getLangText("_标记圆"),
            icon: Icon.DrawCircle,
            callback: function (e) {
              map.graphicLayer.startDraw({
                type: "circle",
                style: {
                  color: "#ffff00",
                  opacity: 0.6
                },
                success: function (graphic) {
                  // eslint-disable-next-line no-console
                  console.log(JSON.stringify(graphic.coordinates));
                }
              });
            }
          },
          {
            text: map.getLangText("_标记矩形"),
            icon: Icon.DrawRectangle,
            callback: function (e) {
              map.graphicLayer.startDraw({
                type: "rectangle",
                style: {
                  color: "#ffff00",
                  opacity: 0.6
                },
                success: function (graphic) {
                  // eslint-disable-next-line no-console
                  console.log(JSON.stringify(graphic.coordinates));
                }
              });
            }
          },
          {
            text: map.getLangText("_允许编辑"),
            icon: Icon.DrawEditYes,
            show: function (e) {
              return !map.graphicLayer.hasEdit
            },
            callback: function (e) {
              map.graphicLayer.hasEdit = true;
            }
          },
          {
            text: map.getLangText("_禁止编辑"),
            icon: Icon.DrawEditNo,
            show: function (e) {
              return map.graphicLayer.hasEdit
            },
            callback: function (e) {
              map.graphicLayer.hasEdit = false;
            }
          },
          {
            text: map.getLangText("_导出GeoJSON"),
            icon: Icon.DrawDownJson,
            show: function (e) {
              return map.graphicLayer.length > 0
            },
            callback: function (e) {
              downloadFile("图上标记.json", JSON.stringify(map.graphicLayer.toGeoJSON()));
            }
          },
          {
            text: map.getLangText("_清除所有标记"),
            icon: Icon.Delete,
            show: function (e) {
              return map.graphicLayer.length > 0
            },
            callback: function (e) {
              map.graphicLayer.clear();
            }
          }
        ]
      },
      {
        text: map.getLangText("_特效效果"),
        icon: Icon.Effect,
        children: [
          {
            text: map.getLangText("_开启下雨"),
            icon: Icon.RainEffectYes,
            show: function (e) {
              return !that.rainEffect
            },
            callback: function (e) {
              if (!that.rainEffect) {
                that.rainEffect = new RainEffect();
                map.addEffect(that.rainEffect);
              }
            }
          },
          {
            text: map.getLangText("_关闭下雨"),
            icon: Icon.RainEffectNo,
            show: function (e) {
              return that.rainEffect
            },
            callback: function (e) {
              if (that.rainEffect) {
                map.removeEffect(that.rainEffect, true);
                delete that.rainEffect;
              }
            }
          },
          {
            text: map.getLangText("_开启下雪"),
            icon: Icon.SnowEffectYes,
            show: function (e) {
              return !that.snowEffect
            },
            callback: function (e) {
              if (!that.snowEffect) {
                that.snowEffect = new SnowEffect();
                map.addEffect(that.snowEffect);
              }
            }
          },
          {
            text: map.getLangText("_关闭下雪"),
            icon: Icon.SnowEffectNo,
            show: function (e) {
              return that.snowEffect
            },
            callback: function (e) {
              if (that.snowEffect) {
                map.removeEffect(that.snowEffect, true);
                delete that.snowEffect;
              }
            }
          },

          {
            text: map.getLangText("_开启雾天气"),
            icon: Icon.FogEffectYes,
            show: function (e) {
              return !that.fogEffect
            },
            callback: function (e) {
              if (!that.fogEffect) {
                const height = map.camera.positionCartographic.height * 2;
                that.fogEffect = new FogEffect({
                  fogByDistance: new Cesium__namespace.Cartesian4(0.1 * height, 0.1, height, 0.8)
                });
                map.addEffect(that.fogEffect);
              }
            }
          },
          {
            text: map.getLangText("_关闭雾天气"),
            icon: Icon.FogEffectNo,
            show: function (e) {
              return that.fogEffect
            },
            callback: function (e) {
              if (that.fogEffect) {
                map.removeEffect(that.fogEffect, true);
                delete that.fogEffect;
              }
            }
          },

          {
            text: map.getLangText("_开启泛光"),
            icon: Icon.BloomEffectYes,
            show: function (e) {
              return !that.bloomEffect
            },
            callback: function (e) {
              if (!that.bloomEffect) {
                that.bloomEffect = new BloomEffect();
                map.addEffect(that.bloomEffect);
              }
            }
          },
          {
            text: map.getLangText("_关闭泛光"),
            icon: Icon.BloomEffectNo,
            show: function (e) {
              return that.bloomEffect
            },
            callback: function (e) {
              if (that.bloomEffect) {
                map.removeEffect(that.bloomEffect, true);
                delete that.bloomEffect;
              }
            }
          },

          {
            text: map.getLangText("_开启亮度"),
            icon: Icon.BrightnessEffectYes,
            show: function (e) {
              return !that.brightnessEffect
            },
            callback: function (e) {
              if (!that.brightnessEffect) {
                that.brightnessEffect = new BrightnessEffect();
                map.addEffect(that.brightnessEffect);
              }
            }
          },
          {
            text: map.getLangText("_关闭亮度"),
            icon: Icon.BrightnessEffectNo,
            show: function (e) {
              return that.brightnessEffect
            },
            callback: function (e) {
              if (that.brightnessEffect) {
                map.removeEffect(that.brightnessEffect, true);
                delete that.brightnessEffect;
              }
            }
          },

          {
            text: map.getLangText("_开启夜视"),
            icon: Icon.NightVisionEffectYes,
            show: function (e) {
              return !that.nightVisionEffect
            },
            callback: function (e) {
              if (!that.nightVisionEffect) {
                that.nightVisionEffect = new NightVisionEffect();
                map.addEffect(that.nightVisionEffect);
              }
            }
          },
          {
            text: map.getLangText("_关闭夜视"),
            icon: Icon.NightVisionEffectNo,
            show: function (e) {
              return that.nightVisionEffect
            },
            callback: function (e) {
              if (that.nightVisionEffect) {
                map.removeEffect(that.nightVisionEffect, true);
                delete that.nightVisionEffect;
              }
            }
          },

          {
            text: map.getLangText("_开启黑白"),
            icon: Icon.BlackAndWhiteEffectYes,
            show: function (e) {
              return !that.blackAndWhiteEffect
            },
            callback: function (e) {
              if (!that.blackAndWhiteEffect) {
                that.blackAndWhiteEffect = new BlackAndWhiteEffect();
                map.addEffect(that.blackAndWhiteEffect);
              }
            }
          },
          {
            text: map.getLangText("_关闭黑白"),
            icon: Icon.BlackAndWhiteEffectNo,
            show: function (e) {
              return that.blackAndWhiteEffect
            },
            callback: function (e) {
              if (that.blackAndWhiteEffect) {
                map.removeEffect(that.blackAndWhiteEffect, true);
                delete that.blackAndWhiteEffect;
              }
            }
          },

          {
            text: map.getLangText("_开启拾取高亮"),
            icon: Icon.OutlineEffectYes,
            show: function (e) {
              return !that.outlineEffect
            },
            callback: function (e) {
              if (!that.outlineEffect) {
                that.outlineEffect = new OutlineEffect();
                map.addEffect(that.outlineEffect);
              }
            }
          },
          {
            text: map.getLangText("_关闭拾取高亮"),
            icon: Icon.OutlineEffectNo,
            show: function (e) {
              return that.outlineEffect
            },
            callback: function (e) {
              if (that.outlineEffect) {
                map.removeEffect(that.outlineEffect, true);
                delete that.outlineEffect;
              }
            }
          }
        ]
      },
      {
        text: map.getLangText("_场景设置"),
        icon: Icon.Scene,
        children: [
          {
            text: map.getLangText("_开启深度监测"),
            icon: Icon.DepthTestYes,
            show: function (e) {
              return !map.scene.globe.depthTestAgainstTerrain
            },
            callback: function (e) {
              map.scene.globe.depthTestAgainstTerrain = true;
            }
          },
          {
            text: map.getLangText("_关闭深度监测"),
            icon: Icon.DepthTestNo,
            show: function (e) {
              return map.scene.globe.depthTestAgainstTerrain
            },
            callback: function (e) {
              map.scene.globe.depthTestAgainstTerrain = false;
            }
          },

          {
            text: map.getLangText("_显示星空背景"),
            icon: Icon.SkyBoxYes,
            show: function (e) {
              return !map.scene.skyBox.show
            },
            callback: function (e) {
              map.scene.skyBox.show = true; // 天空盒
              map.scene.moon.show = true; // 太阳
              map.scene.sun.show = true; // 月亮
            }
          },
          {
            text: map.getLangText("_关闭星空背景"),
            icon: Icon.SkyBoxNo,
            show: function (e) {
              return map.scene.skyBox.show
            },
            callback: function (e) {
              map.scene.skyBox.show = false; // 天空盒
              map.scene.moon.show = false; // 太阳
              map.scene.sun.show = false; // 月亮
            }
          },
          {
            text: map.getLangText("_开启日照阴影"),
            icon: Icon.ShadowYes,
            show: function (e) {
              return !map.viewer.shadows
            },
            callback: function (e) {
              map.viewer.shadows = true;
              map.viewer.terrainShadows = Cesium__namespace.ShadowMode.ENABLED;
              map.scene.globe.enableLighting = true;
            }
          },
          {
            text: map.getLangText("_关闭日照阴影"),
            icon: Icon.ShadowNo,
            show: function (e) {
              return map.viewer.shadows
            },
            callback: function (e) {
              map.viewer.shadows = false;
              map.viewer.terrainShadows = Cesium__namespace.ShadowMode.RECEIVE_ONLY;
              map.scene.globe.enableLighting = false;
            }
          },
          {
            text: map.getLangText("_开启大气渲染"),
            icon: Icon.SkyAtmosphereYes,
            show: function (e) {
              return !map.scene.skyAtmosphere.show
            },
            callback: function (e) {
              map.scene.skyAtmosphere.show = true;
              map.scene.globe.showGroundAtmosphere = true;
            }
          },
          {
            text: map.getLangText("_关闭大气渲染"),
            icon: Icon.SkyAtmosphereNo,
            show: function (e) {
              return map.scene.skyAtmosphere.show
            },
            callback: function (e) {
              map.scene.skyAtmosphere.show = false;
              map.scene.globe.showGroundAtmosphere = false;
            }
          },

          {
            text: map.getLangText("_场景出图"),
            icon: Icon.ExpImage,
            callback: function (e) {
              map.expImage();
            }
          }
        ]
      }
    ]
  }

  // 创建地球之前的汉化处理。
  function toChineseBeforeCreate(options) {
    // 时钟动画面板
    Cesium__namespace.AnimationViewModel.defaultDateFormatter = function (date, viewModel) {
      const jsdate = Cesium__namespace.JulianDate.toDate(date);
      return formatDate(jsdate, "yyyy-MM-dd")
    };
    Cesium__namespace.AnimationViewModel.defaultTimeFormatter = function (date, viewModel) {
      const jsdate = Cesium__namespace.JulianDate.toDate(date);
      return formatDate(jsdate, "HH:mm:ss")
    };

    // 时间线
    Cesium__namespace.Timeline.prototype.makeLabel = function (time) {
      const jsdate = Cesium__namespace.JulianDate.toDate(time);
      return formatDate(jsdate, "yyyy-MM-dd HH:mm:ss")
    };
  }

  // 创建地球之后的汉化处理。
  function toChineseCreateEnd(options, viewer) {
    const mapContainer = viewer.container;

    // 初始视图
    updateAttribute(mapContainer, { "View Home": "初始视图" }, "cesium-home-button", "title");

    // 搜索按钮
    const geocoderTxt = {
      "Enter an address or landmark...": "请输入地址...",
      "Searching...": "查询中..."
    };
    updateAttribute(mapContainer, geocoderTxt, "cesium-geocoder-input", "placeholder");

    // 全屏按钮
    const fullscreenButtonTxt = {
      "Full screen": "全屏",
      "Exit full screen": "退出全屏",
      "Full screen unavailable": "全屏不可用"
    };
    updateAttributeByEvent(mapContainer, fullscreenButtonTxt, "cesium-fullscreenButton", "title", "onmouseover");

    // VR
    const vrButtonTxt = {
      "Enter VR mode": "进入VR模式",
      "Exit VR mode": "退出VR模式",
      "VR mode is unavailable": "VR模式不可用"
    };
    updateAttributeByEvent(mapContainer, vrButtonTxt, "cesium-vrButton", "title", "onmouseover");

    // 视图切换按钮
    const sceneModePickerTxt = {
      "2D": "二维视图",
      "3D": "三维视图",
      "Columbus View": "哥伦布2.5D视图"
    };
    updateAttributeByEvent(mapContainer, sceneModePickerTxt, "cesium-sceneModePicker-button3D", "title", "onmouseover");
    updateAttribute(mapContainer, sceneModePickerTxt, "cesium-sceneModePicker-dropDown-icon", "title");

    // 帮助按钮和面板
    updateAttribute(mapContainer, { "Navigation Instructions": "帮助" }, "cesium-navigation-help-button", "title");
    const helpTxt = {
      Mouse: "鼠标操作",
      Touch: "触摸手势",
      "Pan view": "平移视图",
      "Left click + drag": "鼠标左键+拖拽",
      "Zoom view": "缩放视图",
      "Right click + drag, or": "右键+拖拽，或者",
      "Mouse wheel scroll": "中键滚动",
      "Rotate view": "旋转视图",
      "Middle click + drag, or": "中键按下拖拽，或者",
      "CTRL + Left/Right click + drag": "按Ctrl键 同时 左/右键拖拽",
      "One finger drag": "单指拖动",
      "Two finger pinch": "双指向内或向外滑动",
      "Tilt view": "倾斜视图",
      "Two finger drag, same direction": "双指按相同方向拖动",
      "Two finger drag, opposite direction": "双指按相反方向拖动"
    };
    let mouseButton = mapContainer.getElementsByClassName("cesium-navigation-button-left");
    if (mouseButton.length > 0) {
      mouseButton = mouseButton[0];
      if (helpTxt[mouseButton.textContent]) {
        mouseButton.innerHTML = mouseButton.children[0].outerHTML + helpTxt[mouseButton.textContent];
      }
    }

    let touchButton = mapContainer.getElementsByClassName("cesium-navigation-button-right");
    if (touchButton.length > 0) {
      touchButton = touchButton[0];
      if (helpTxt[touchButton.textContent]) {
        touchButton.innerHTML = touchButton.children[0].outerHTML + helpTxt[touchButton.textContent];
      }
    }

    updateHtml(mapContainer, helpTxt, "cesium-navigation-help-pan");
    updateHtml(mapContainer, helpTxt, "cesium-navigation-help-details");
    updateHtml(mapContainer, helpTxt, "cesium-navigation-help-zoom");
    updateHtml(mapContainer, helpTxt, "cesium-navigation-help-rotate");
    updateHtml(mapContainer, helpTxt, "cesium-navigation-help-tilt");

    // 图层选择
    let dropDownContainer = mapContainer.getElementsByClassName("cesium-baseLayerPicker-dropDown");
    if (dropDownContainer.length > 0) {
      dropDownContainer = dropDownContainer[0];
      const baseLayerPickerTxt = {
        // 图层
        Imagery: "影像",
        "Cesium ion": "官方ION",
        Other: "其他",
        Terrain: "地形服务",
        "WGS84 Ellipsoid": "WGS84 椭球",
        "Cesium World Terrain": "Cesium 世界地形图",
        "WGS84 standard ellipsoid, also known as EPSG:4326": "WGS84标准椭球，又称EPSG：4326",
        "High-resolution global terrain tileset curated from several datasources and hosted by Cesium ion":
          "高分辨率全球地形图块集由几个数据源组成，由Cesium ion托管"
      };
      // 修改标题
      updateHtml(dropDownContainer, baseLayerPickerTxt, "cesium-baseLayerPicker-sectionTitle");
      // 副标题
      updateHtml(dropDownContainer, baseLayerPickerTxt, "cesium-baseLayerPicker-categoryTitle");
      // 具体标签
      updateHtml(dropDownContainer, baseLayerPickerTxt, "cesium-baseLayerPicker-itemLabel");
      // 具体地图描述
      updateAttribute(dropDownContainer, baseLayerPickerTxt, "cesium-baseLayerPicker-item", "title");

      // 鼠标悬浮事件监听，解决选择不同影像title 动态修改无法固定汉化问题
      const selectLayerToolbar = mapContainer.getElementsByClassName("cesium-baseLayerPicker-selected");
      if (selectLayerToolbar.length > 0) {
        selectLayerToolbar[0].parentElement.onmouseover = function (event) {
          const currentTitle = event.currentTarget.getAttribute("title");
          const currentTargets = currentTitle.split("\n");
          let tempTitle1 = "";
          let tempTitle2 = "";
          if (baseLayerPickerTxt[currentTargets[0]]) {
            tempTitle1 += baseLayerPickerTxt[currentTargets[0]];
          } else {
            tempTitle1 += currentTargets[0];
          }

          if (baseLayerPickerTxt[currentTargets[0]]) {
            tempTitle2 += baseLayerPickerTxt[currentTargets[1]];
          } else {
            tempTitle2 += currentTargets[1];
          }
          event.currentTarget.setAttribute("title", tempTitle1 + "\n" + tempTitle2);
        };
      }
    }

    // 时钟动画面板
    let parentContainer = mapContainer.getElementsByClassName("cesium-viewer-animationContainer");
    if (parentContainer.length > 0) {
      parentContainer = parentContainer[0];
      const animatioxtnTxt = {
        Today: "今天",
        "Today (real-time)": "今天（实际时间）",
        Pause: "暂停",
        "Play Reverse": "后退播放",
        "Play Forward": "前进播放",
        "Current time not in range": "当前时间不在范围内"
      };
      updateHtmlByTagName(parentContainer, animatioxtnTxt, "title");
    }

    // webgl渲染失败后，刷新页面
    viewer.scene.renderError.addEventListener(function (scene, error) {
      const errorPanelTxt = {
        "An error occurred while rendering.  Rendering has stopped.": "WebGL发生渲染错误,渲染已经停止,请刷新页面。",
        "Error constructing CesiumWidget.": "构造CesiumWidget时出错"
      };
      updateHtml(mapContainer, errorPanelTxt, "cesium-widget-errorPanel-header");
    });
  }

  // /**
  //  * 更新dom innerHtml
  //  * @param {*} parent 父容器对象
  //  * @param {*} objHH 汉化对象
  //  * @param {*} className class名称
  //  */
  function updateHtml(parent, objHH, className) {
    const doms = parent.getElementsByClassName(className);
    for (let i = 0; i < doms.length; i++) {
      if (objHH[doms[i].innerHTML]) {
        doms[i].innerHTML = objHH[doms[i].innerHTML];
      }
    }
  }

  // /**
  //  * 更新dom innerHtml
  //  * @param {*} parent 父容器对象
  //  * @param {*} objHH 汉化对象
  //  * @param {*} tagName 标签名称
  //  */
  function updateHtmlByTagName(parent, objHH, tagName) {
    const doms = parent.getElementsByTagName(tagName);
    for (let i = 0; i < doms.length; i++) {
      if (objHH[doms[i].innerHTML]) {
        doms[i].innerHTML = objHH[doms[i].innerHTML];
      }
    }
  }

  // /**
  //  * 更新dom innerHtml
  //  * @param {*} parent 父容器对象
  //  * @param {*} objHH 汉化对象
  //  * @param {*} className class名称
  //  * @param {*} attributeName 属性名称
  //  */
  function updateAttribute(parent, objHH, className, attributeName) {
    if (!parent) {
      parent = document;
    }

    const doms = parent.getElementsByClassName(className);
    for (let i = 0; i < doms.length; i++) {
      if (objHH[doms[i].getAttribute(attributeName)]) {
        doms[i].setAttribute(attributeName, objHH[doms[i].getAttribute(attributeName)]);
      }
    }
  }

  // /**
  //  * 通过事件更新属性
  //  * @param {*} parent 父容器
  //  * @param {*} map 汉化对象
  //  * @param {*} className 样式名称
  //  * @param {*} attributeName 属性名称
  //  * @param {*} eventName 事件名称
  //  */
  function updateAttributeByEvent(parent, map, className, attributeName, eventName) {
    const doms = parent.getElementsByClassName(className);
    if (doms.length > 0) {
      for (let i = 0; i < doms.length; i++) {
        doms[i][eventName] = function (event) {
          const attr = event.currentTarget.getAttribute(attributeName);
          if (map[attr]) {
            event.currentTarget.setAttribute(attributeName, map[attr]);
          }
        };
      }
    }
  }

  // 如果options未设置时的默认参数[基本上默认都关闭]
  const DefaultOptions = {
    animation: false, // 是否创建动画小器件，左下角仪表
    timeline: false, // 是否显示时间线控件
    fullscreenButton: false, // 右下角全屏按钮
    vrButton: false, // 右下角vr虚拟现实按钮

    geocoder: false, // 是否显示地名查找控件
    sceneModePicker: false, // 是否显示投影方式控件
    homeButton: false, // 回到默认视域按钮
    navigationHelpButton: false, // 是否显示帮助信息控件
    navigationInstructionsInitiallyVisible: false, // 在用户明确单击按钮之前是否自动显示

    infoBox: false, // 是否显示点击要素之后显示的信息
    selectionIndicator: false, // 选择模型是是否显示绿色框,
    shouldAnimate: true,
    showRenderLoopErrors: true, // 是否显示错误弹窗信息

    baseLayerPicker: false, // 地图底图
    requestRenderMode: false // 显式渲染, 以减少Cesium渲染一个新帧总的时间，并且降低应用中Cesium的CPU使用率。
  };

  /**
   * 地图类 ，这是构造三维地球的一切的开始起点。
   *
   * @param {String|Cesium.Viewer} id 地图div容器的id 或 已构造好的Viewer对象
   * @param {Object} [options={}] 参数对象:
   * @param {Map.sceneOptions} [options.scene] 场景参数
   * @param {Map.controlOptions} [options.control] 添加的控件
   * @param {Map.effectOptions} [options.effect] 添加的特效
   * @param {Map.mouseOptions} [options.mouse] 鼠标操作相关配置参数
   * @param {Map.terrainOptions} [options.terrain] 地形服务配置
   * @param {Map.basemapOptions[]} [options.basemaps] 底图图层配置
   * @param {Map.layerOptions[]} [options.layers] 可以叠加显示的图层配置
   *
   * @param {ChinaCRS} [options.chinaCRS=ChinaCRS.WGS84] 标识当前三维场景的国内坐标系（用于部分图层内对比判断来自动纠偏或加偏）
   * @param {LangType} [options.lang] 使用的语言（如中文、英文等）。
   * @param {Object} [options.templateValues] 图层中统一的url模版，比如可以将服务url前缀统一使用模板，方便修改或动态配置。
   * @param {Map.tokenOptions} [options.token] 覆盖SDK内的{@link Token}所有第3方Token默认值
   *
   * @export
   * @class Map
   * @extends {BaseClass} 基础类
   *
   * @see [支持的事件类型]{@link Map.EventType}
   */
  class Map extends BaseClass {
    constructor(id, options = {}) {
      super(options);

      /**
       * 当前类的构造参数
       * @type {Object}
       * @readonly
       */
      this.options = options;

      // token默认值更新
      if (options.token) {
        updateAll(options.token);
      }

      // 汉化
      options.lang = options.lang ?? LangType.ZH;
      if (options.lang === LangType.ZH || options.lang === LangType.ZHHK) {
        toChineseBeforeCreate();
      }
      initBeforeCreateDefaultValue(options);

      if (id instanceof Cesium__namespace.Viewer) {
        this._viewer = id;
      } else {
        this._viewer = this._createViewer(id, options);
      }

      this._isFlyAnimation = false;
      this._highlightEnabled = true;

      this._controlList = new MarsArray();
      this._thingList = new MarsArray();
      this._layerList = new MarsArray();
      this._optionsBasemapsList = new MarsArray();
      this._optionsLayersList = new MarsArray();

      this._controlsByType = {};
      this._effects = {};

      this._sceneEvent = new SceneEvent(this); // Register scene events
      this._mouseEvent = new MouseEvent(this, options.mouse); // Register scene events

      this._sceneOption = new SceneOption(this); // Initialize the viewer option
      this._sceneOption.setOptions(this.options.scene, this.options.scene);

      this._zoomNavigation = new ZoomNavigation(this._viewer);

      // 当前三维场景的国内坐标系（用于部分图层内对比判断来自动纠偏或加偏）
      this.chinaCRS = this.options.chinaCRS || ChinaCRS.WGS84;

      // 汉化
      if (options.lang === LangType.ZH || options.lang === LangType.ZHHK) {
        toChineseCreateEnd(options, this._viewer);
      }

      this._initLayers(); // 处理图层
      this._initControls(); // 绑定添加相关控件
      this._initEffect();
    }

    //= ========= 对外属性 ==========

    /**
     * 地图对应的Cesium原生的  [Cesium.Viewer对象]{@link http://mars3d.cn/api/cesium/Viewer.html}
     * @type {Cesium.Viewer}
     * @readonly
     */
    get viewer() {
      return this._viewer
    }

    /**
     * 获取地图DOM容器。
     *
     * @type {HTMLDivElement}
     * @readonly
     */
    get container() {
      return this._viewer.container
    }

    /**
     * 获取ToolBar控件DOM容器，
     * 其样式为cesium-viewer-toolbar
     *
     * @type {HTMLDivElement}
     * @readonly
     */
    get toolbar() {
      return this._viewer._toolbar
    }

    /**
     * 获取Canvas画布
     *
     * @type {HTMLCanvasElement}
     * @readonly
     */
    get canvas() {
      return this._viewer.scene.canvas
    }

    /**
     * 获取场景。 [Cesium.Scene]{@link http://mars3d.cn/api/cesium/Scene.html}
     *
     * @type {Cesium.Scene}
     * @readonly
     */
    get scene() {
      return this._viewer.scene
    }

    /**
     * 获取相机 [Cesium.Camera]{@link http://mars3d.cn/api/cesium/Camera.html}
     *
     * @type {Cesium.Camera}
     * @readonly
     */
    get camera() {
      return this._viewer.camera
    }

    /**
     * 获取将在地球上渲染的ImageryLayer图像图层的集合
     *
     * @type {Cesium.ImageryLayerCollection}
     * @readonly
     */
    get imageryLayers() {
      return this._viewer.imageryLayers
    }

    /**
     * 获取要可视化的 DataSource 实例集。
     *
     * @type {Cesium.DataSourceCollection}
     * @readonly
     */
    get dataSources() {
      return this._viewer.dataSources
    }

    /**
     * 获取未绑定到特定数据源的实体的集合。这是 dataSourceDisplay.defaultDataSource.entities 的快捷方式。
     *
     * @type {Cesium.EntityCollection}
     * @readonly
     */
    get entities() {
      return this._viewer.entities
    }

    /**
     * 获取时钟 [Cesium.Clock]{@link http://mars3d.cn/api/cesium/Clock.html}
     *
     * @type {Cesium.Clock}
     * @readonly
     */
    get clock() {
      return this._viewer.clock
    }

    /**
     * 当前时间
     * @type {Cesium.JulianDate}
     */
    get currentTime() {
      return this._viewer.clock.currentTime
    }

    set currentTime(value) {
      this._viewer.clock.currentTime = value;
    }

    /**
     * 获取 CesiumWidget
     *
     * @type {Cesium.CesiumWidget}
     * @readonly
     */
    get cesiumWidget() {
      return this._viewer.cesiumWidget
    }

    /**
     * 获取或设置相机当前正在跟踪的Entity实例。
     *
     * @type {Cesium.Entity|BaseEntity|undefined|*}
     */
    get trackedEntity() {
      return this._viewer.trackedEntity
    }

    set trackedEntity(value) {
      if (value && value.entity instanceof Cesium__namespace.Entity) {
        this._viewer.trackedEntity = value.entity; // 是BaseEntity
      } else if (value && value.trackedEntity instanceof Cesium__namespace.Entity) {
        this._viewer.trackedEntity = value.trackedEntity; // 是BasePointPrimitive
      } else {
        this._viewer.trackedEntity = value;
      }
    }

    /**
     * 获取或设置当前的地形服务
     *
     * @type {Cesium.TerrainProvider}
     */
    get terrainProvider() {
      return this._viewer.terrainProvider
    }

    set terrainProvider(value) {
      if (value) {
        value._marsOptions = value._marsOptions || {};
        value._marsOptions.onLoadSuccess = (data) => {
          this._terrain_onLoadSuccess(data);
        };
        value._marsOptions.onLoadError = (error) => {
          this._terrain_onLoadError(error);
        };
      }
      this._viewer.terrainProvider = value;
      this._defaultTerrainProvider = value;
    }

    /**
     *  是否开启地形
     * @type {Boolean}
     */
    get hasTerrain() {
      return Boolean(this._viewer.terrainProvider._layers)
    }

    set hasTerrain(value) {
      if (value) {
        if (this._defaultTerrainProvider == null) {
          this._defaultTerrainProvider = createTerrainProvider(this._getTerrainOptions());
        }
        this._viewer.terrainProvider = this._defaultTerrainProvider;
      } else {
        this._viewer.terrainProvider = getNoTerrainProvider();
      }
    }

    /**
     *  获取或设置当前显示的底图，设置时可以传入图层id或name
     * @type {String|Number|BaseTileLayer}
     */
    get basemap() {
      const allLayers = this._optionsBasemapsList.values;
      if (allLayers.length === 0) {
        if (this._viewer.baseLayerPicker) {
          return this._viewer.baseLayerPicker.viewModel.selectedImagery
        }
        return undefined
      }

      for (let i = 0; i < allLayers.length; i++) {
        const layer = allLayers[i];
        if (layer.hasEmptyGroup) {
          continue
        }
        if (layer.isAdded) {
          return layer
        }
      }
      return undefined
    }

    // 设置当前显示的底图
    // 根据config配置的id或name属性，更新显示指定的地图底图
    set basemap(idorname) {
      let curr_id;
      let curr_name;

      if (idorname && isObject(idorname)) {
        curr_id = idorname.id;
        curr_name = idorname.name;
      } else {
        curr_id = idorname;
        curr_name = idorname;
      }

      const allLayers = this._optionsBasemapsList.values;
      if (allLayers.length === 0) {
        if (this._viewer.baseLayerPicker) {
          const baseLayer = this._viewer.baseLayerPicker.viewModel;

          let sel;
          if (idorname) {
            let selectIndex;
            let index = -1;
            for (let i = 0; i < this.options.basemaps.length; i++) {
              const item = this.options.basemaps[i];
              if (item.type === "group" && item.layers == null) {
                continue
              }

              index++;
              // eslint-disable-next-line eqeqeq
              if (curr_name == item.name || curr_id == item.id) {
                selectIndex = index;
                break
              }
            }
            if (Cesium__namespace.defined(selectIndex)) {
              sel = baseLayer.imageryProviderViewModels[selectIndex];
            }
          }
          baseLayer.selectedImagery = sel;
        }
        return
      }

      for (let i = 0; i < allLayers.length; i++) {
        const layer = allLayers[i];
        if (layer.hasEmptyGroup) {
          continue
        }

        // eslint-disable-next-line eqeqeq
        if (curr_name == layer.name || curr_id == layer.id) {
          if (!layer.isAdded) {
            this.addLayer(layer);
          }
        } else {
          if (layer.isAdded) {
            this.removeLayer(layer);
          }
        }
      }
    }

    /**
     * 是否只拾取模型上的点
     * @type {Boolean}
     *
     */
    get onlyPickModelPosition() {
      return this._viewer.scene.onlyPickModelPosition
    }

    set onlyPickModelPosition(value) {
      this._viewer.scene.onlyPickModelPosition = value;
    }

    /**
     * 获取鼠标事件控制器
     *
     * @type {MouseEvent}
     * @readonly
     */
    get mouseEvent() {
      return this._mouseEvent
    }

    // 不公开
    get popup() {
      return this._popupMgr
    }

    get tooltip() {
      return this._tooltipMgr
    }

    get smallTooltip() {
      return this._smallTooltip
    }

    /**
     * 右键菜单控件对象
     * @type {ContextMenu}
     * @readonly
     */
    get contextmenu() {
      return this._contextmenuMgr
    }

    /**
     *  获取键盘漫游控制器
     *
     * @type {KeyboardRoam}
     * @readonly
     */
    get keyboardRoam() {
      return this._keyboardRoam
    }

    /**
     *  获取地图上已构造的控件对象
     *
     * @type {Object}
     * @readonly
     */
    get controls() {
      return this._controlsByType
    }

    /**
     *  获取地图上已构造的effect特效对象
     *
     * @type {Object}
     * @readonly
     */
    get effects() {
      return this._effects
    }

    /**
     * 默认绑定的图层，简单场景时快捷方便使用
     *
     * @type {GraphicLayer}
     * @readonly
     */
    get graphicLayer() {
      if (this._graphicLayer == null) {
        this._graphicLayer = new GraphicLayer({
          name: "默认数据图层",
          private: true
        });
        this.addLayer(this._graphicLayer);
      }
      return this._graphicLayer
    }

    /**
     *  获取当前地图层级（概略），一般为0-21层
     *
     * @type {Number}
     * @readonly
     */
    get level() {
      // return this._viewer.scene.globe._surface._tilesToRender[0].level;

      const height = Math.abs(this._viewer.camera.positionCartographic.height);
      if (height === this._prevCameraHeight) {
        return this._level
      }
      this._level = heightToZoom(height);
      this._prevCameraHeight = height;
      return this._level
    }

    /**
     *  是否固定光照，
     *  true：可避免gltf、3dtiles模型随时间存在亮度不一致。
     *
     * @type {Boolean}
     */
    get fixedLight() {
      return this._fixedLight
    }

    set fixedLight(val) {
      this._fixedLight = val;
      if (!this._sunlight) {
        this._sunlight = this.scene.light;
      }

      if (val) {
        const directionalLight = new Cesium__namespace.DirectionalLight({
          direction: new Cesium__namespace.Cartesian3(0.35492591601301104, -0.8909182691839401, -0.2833588392420772)
        });
        this.scene.light = directionalLight; // 固定光照
      } else {
        this.scene.light = this._sunlight;
      }
    }

    /**
     * 使用的语言（如中文、英文等）。
     * @type {LangType}
     */
    get lang() {
      return this.options.lang || LangType.ZH
    }

    set lang(val) {
      this.options.lang = val;
    }

    /**
     * 鼠标滚轮放大的步长比例
     * @default 3.0
     * @type {Number}
     */
    get zoomFactor() {
      return this.scene.screenSpaceCameraController._zoomFactor
    }

    set zoomFactor(val) {
      this.scene.screenSpaceCameraController._zoomFactor = val;
    }

    /**
     * 是否全局启用highlight ，如果在某些场景，如标绘时，可以手动关闭下
     * @default true
     * @type {Boolean}
     */
    get highlightEnabled() {
      return this._highlightEnabled
    }

    set highlightEnabled(val) {
      this._highlightEnabled = val;
      if (!val) {
        this.closeHighlight();
      }
    }

    //= ========= 方法 ==========
    _createViewer(id, options) {
      if (!id) {
        throw new Error("Map：id 不能为空")
      }

      const viewerOption = {
        ...DefaultOptions,
        ...(options.control || {}),
        ...(options.scene || {}),
        timeline: false
      };

      if (viewerOption.globe && !(viewerOption.globe instanceof Cesium__namespace.Globe)) {
        delete viewerOption.globe;
      }
      if (viewerOption.cameraController) {
        delete viewerOption.cameraController;
      }
      if (viewerOption.contextmenu) {
        delete viewerOption.contextmenu;
      }
      if (viewerOption.location) {
        delete viewerOption.location;
      }
      if (viewerOption.mouseDownView) {
        delete viewerOption.mouseDownView;
      }
      if (viewerOption.navigation) {
        delete viewerOption.navigation;
      }

      // 自定义搜索栏Geocoder
      if (viewerOption.geocoder === true && options.lang === LangType.ZH) {
        viewerOption.geocoder = new GaodePOIGeocoder(viewerOption.geocoderConfig);
        viewerOption.geocoder.map = this;
      }

      // 地图底图图层预处理
      let hasremoveimagery = false;
      if (viewerOption.baseLayerPicker) {
        // 有baseLayerPicker插件时
        if (!viewerOption.imageryProviderViewModels && options.basemaps?.length > 0) {
          const imgOBJ = getImageryProviderViewModels(options.basemaps, this.options.templateValues);
          viewerOption.imageryProviderViewModels = imgOBJ.imageryProviderViewModels;

          if (imgOBJ.selectedIndex === -1) {
            hasremoveimagery = true;
          } else {
            viewerOption.selectedImageryProviderViewModel = imgOBJ.imageryProviderViewModels[imgOBJ.selectedIndex];
          }
        }

        if (!viewerOption.terrainProviderViewModels) {
          viewerOption.terrainProviderViewModels = getTerrainProviderViewModels(this._getTerrainOptions());
          viewerOption.selectedTerrainProviderViewModel = viewerOption.terrainProviderViewModels[options.terrain?.show ? 1 : 0];
        }
      } else {
        // 无baseLayerPicker插件时
        if (viewerOption.imageryProvider == null) {
          // 未配底图时
          hasremoveimagery = true;
          viewerOption.imageryProvider = new Cesium__namespace.TileMapServiceImageryProvider({
            url: Cesium__namespace.buildModuleUrl("Assets/Textures/NaturalEarthII")
          });
        }

        // 地形
        let terrainProvider;
        if (options.terrain && options.terrain.show) {
          terrainProvider = createTerrainProvider(this._getTerrainOptions());
          viewerOption.terrainProvider = terrainProvider;
          this._defaultTerrainProvider = terrainProvider;
        } else {
          viewerOption.terrainProvider = getNoTerrainProvider();
        }
      }

      // 地球初始化
      const viewer = new Cesium__namespace.Viewer(id, viewerOption);

      // 地图底图图层
      if (hasremoveimagery) {
        const imageryLayerCollection = viewer.imageryLayers;
        const length = imageryLayerCollection.length;
        for (let i = 0; i < length; i++) {
          const layer = imageryLayerCollection.get(0);
          imageryLayerCollection.remove(layer, true);
        }
      }
      return viewer
    }

    // 地形事件处理
    _terrain_onLoadSuccess(data) {
      this.fire(EventType.terrainLoadSuccess, { data });
    }

    _terrain_onLoadError(error) {
      this.hasTerrain = false; // 自动切换到无地形
      this.fire(EventType.terrainLoadError, { error });
    }

    _getTerrainOptions() {
      if (!this.options.terrain) {
        return this.options.terrain
      }
      const terrainOptions = {
        templateValues: this.options.templateValues,
        marsOptions: {
          onLoadSuccess: (data) => {
            this._terrain_onLoadSuccess(data);
          },
          onLoadError: (error) => {
            this._terrain_onLoadError(error);
          }
        },
        ...this.options.terrain
      };
      return terrainOptions
    }

    /// /////////////////一些常用方法//////////////////////
    /**
     * 设置Scene场景参数
     * @param {Map.sceneOptions} options 参数
     * @return {Map} 当前对象本身，可以链式调用
     *
     */
    setSceneOptions(options) {
      if (!options || Object.keys(options).length === 0) {
        return this
      }

      this.options.scene = merge(this.options.scene, options);
      this._sceneOption.setOptions(this.options.scene, options);
      return this
    }

    /**
     * 获取地图的配置参数，即new Map传入的参数。
     * @return {Object} 地图的配置参数
     */
    getOptions() {
      return clone(this.options, ["parent", "eventParent"])
    }

    /**
     * 获取地图的当前实时状态对应的配置参数。
     * @return {Object} 地图的配置参数
     */
    getCurrentOptions() {
      const mapOptions = this.getOptions();
      mapOptions.scene.center = this.getCameraView();
      mapOptions.layers = [];
      // 后置加的图层的处理
      const mapLayers = this.getLayers({ basemaps: false });
      for (let i = mapLayers.length - 1; i >= 0; i--) {
        const layer = mapLayers[i];
        if (layer.isPrivate || layer.parent) {
          continue
        }
        mapOptions.layers.push(layer.toJSON());
      }

      return mapOptions
    }

    /**
     * 获取平台内置的右键菜单，图标可以覆盖 mars3d.Icon.* 值
     * @return {Object[]} 右键菜单
     */
    getDefaultContextMenu() {
      return getDefaultContextMenu(this)
    }

    /**
     * 取地图屏幕中心点坐标
     * @return {LngLatPoint} 屏幕中心点坐标
     */
    getCenter() {
      return getCenter(this.scene)
    }

    /**
     * 取相机到屏幕中心点的距离
     * @return {Number} 相机到屏幕中心点的距离，单位：米
     */
    getCameraDistance() {
      const center = this.getCenter();
      if (center) {
        const distance = Cesium__namespace.Cartesian3.distance(center.toCartesian(), this._viewer.camera.positionWC);
        return distance
      } else {
        return 0
      }
    }

    /**
     * 提取地球当前视域边界,示例：{ xmin: 70,  xmax: 140,  ymin: 0,  ymax: 55, height: 0, }
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.formatNum=false] 是否格式化小数位，只保留6位小数
     * @param {Number} [options.scale=1] 通过在每个方向上按给定比例扩展当前边界，0.x时返回缩小的比例边界，大于1时返回放大的边界
     * @return {Object} 当前视域边界
     */
    getExtent(options) {
      return getExtent(this, options)
    }

    /**
     * 当存在地形夸张时，获取其实际的高度值
     * @param {Number} alt 鼠标拾取的高度值
     * @return {Number} 其实际的高度值
     */
    getRealAlt(alt) {
      if (!this.options.scene?.globe?.realAlt) {
        return alt
      }

      const terrainExaggeration = this._viewer.scene.globe.terrainExaggeration || this._viewer.scene.terrainExaggeration;
      if (terrainExaggeration) {
        return alt / terrainExaggeration
      }
      return alt
    }

    /**
     * 截图，导出地图场景图片
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.download=true] 是否自动下载图片
     * @param {String} [options.filename='场景出图_' + width + 'x' + height] 图片名称
     * @param {Number} [options.width=canvas.width] 图片的高度像素值
     * @param {Number} [options.height=canvas.height] 图片的高度像素值
     * @param {String} [options.type='image/jpeg'] 图片格式
     * @param {Number} [options.encoderOptions=0.92] 在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。
     * @return {Promise<Object>} 截图完成后的回调方法的Promise
     */
    expImage(options) {
      return expImage(this._viewer, options)
    }

    /**
     * 设置鼠标的默认状态样式
     * @param {String} [val] cursor样式
     * @return {void}  无
     */
    setCursor(val = "") {
      this._default_cursor = val;
      this.container.style.cursor = val;
    }

    // 编辑状态时，切换 “+”号/默认样式
    _setEditCursor(val) {
      if (!this.container) {
        return
      }

      if (val) {
        this.container.style.cursor = "crosshair";
      } else {
        this.container.style.cursor = this._default_cursor || "";
      }
    }

    /**
     * 获取坐标位置的3dtiles模型对象
     *
     * @param {Cesium.Cartesian3|Cesium.Cartesian3[]} positions 坐标  或 坐标数组
     * @return {Cesium.Cesium3DTileset|undefined} 3dtiles模型对象
     */
    pick3DTileset(positions) {
      return pick3DTileset(this.scene, positions)
    }

    /**
     * 获取坐标位置的3dtiles模型图层
     *
     * @param {Cesium.Cartesian3|Cesium.Cartesian3[]} positions 坐标  或 坐标数组
     * @return {TilesetLayer|undefined} 3dtiles模型图层
     */
    pickTilesetLayer(positions) {
      const tileset = pick3DTileset(this.scene, positions);
      if (tileset) {
        return this.getLayerById(tileset._mars3d_layerId)
      } else {
        return null
      }
    }

    /// /////////////////事件相关//////////////////////
    on(type, callback, context) {
      const result = this._sceneEvent.on(type, callback, context || this);
      if (!result) {
        super.on(type, callback, context);
      }
      return this
    }

    off(type, callback, context) {
      const result = this._sceneEvent.off(type, callback, context || this);
      if (!result) {
        super.off(type, callback, context);
      }
      return this
    }

    /// //////////////layer 图层相关///////////////////////////
    // 处理图层
    _initLayers() {
      // 赋值默认值
      this.options.basemaps = this.options.basemaps || [];
      this.options.layers = this.options.layers || [];

      this._layerIdx = 1;
      this._arrLayerIdx = [];

      const basemapsCfg = this.options.basemaps;
      const layersCfg = this.options.layers;

      // 记录所有id，方便计算 nextid
      for (let i = 0; i < basemapsCfg.length; i++) {
        const item = basemapsCfg[i];
        if (item.id) {
          this._arrLayerIdx.push(item.id);
        }
      }
      for (let i = 0; i < layersCfg.length; i++) {
        const item = layersCfg[i];
        if (item.id) {
          this._arrLayerIdx.push(item.id);
        }
      }

      const allLayers = []; // 计算order
      const layersPromse = [];

      // 底图处理
      if (!this._viewer.baseLayerPicker) {
        // 使用baseLayerPicker时无法切换了
        for (let i = 0; i < basemapsCfg.length; i++) {
          const item = basemapsCfg[i];
          if (!item.name) {
            item.name = "";
          }
          if (!item.id) {
            item.id = this.getNextLayerId();
          }

          const layer = create$2(item, this.options.templateValues);
          if (!layer) {
            continue
          }
          layer._hasMapInit = true; // 标识图层属于Map初始化时构造的

          if (item.show) {
            const layerPromse = this.addLayer(layer);
            layersPromse.push(layerPromse);
          }
          this._optionsBasemapsList.set(item.id, layer);

          allLayers.push(item);

          if (layer.hasChildLayer && item.layers) {
            for (let idx = 0; idx < item.layers.length; idx++) {
              const childitem = item.layers[idx];
              childitem.pid = item.id;
              childitem.parent = layer;

              if (!childitem.id) {
                childitem.id = this.getNextLayerId();
              }
              allLayers.push(childitem);
            }
          }
        }
      }

      // 可叠加图层
      for (let i = 0; i < layersCfg.length; i++) {
        const item = layersCfg[i];
        if (!item.id) {
          item.id = this.getNextLayerId();
        }

        const layer = create$2(item, this.options.templateValues);
        if (!layer) {
          continue
        }
        layer._hasMapInit = true; // 标识图层属于Map初始化时构造的

        if (item.show) {
          const layerPromse = this.addLayer(layer);
          layersPromse.push(layerPromse);
        }
        this._optionsLayersList.set(item.id, layer);

        allLayers.push(item);

        if (layer.hasChildLayer && item.layers) {
          for (let idx = 0; idx < item.layers.length; idx++) {
            const childitem = item.layers[idx];
            childitem.pid = item.id;
            childitem.parent = layer;

            if (!childitem.id) {
              childitem.id = this.getNextLayerId();
            }
            allLayers.push(childitem);
          }
        }
      }

      // 计算 顺序字段,
      for (let i = 0; i < allLayers.length; i++) {
        const item = allLayers[i];

        // 计算层次顺序
        let zIndex = Number(item.zIndex);
        if (isNaN(zIndex)) {
          zIndex = i;
        }
        item.zIndex = zIndex;

        // 图层的处理
        const layer = this._layerList.get(item.id);
        if (layer) {
          layer.zIndex = zIndex;
        }
      }

      // load事件处理
      layersPromse.push(
        new Promise((resolve, reject) => {
          function onMap_tileLoadProgress(count) {
            if (count === 0) {
              this.off(EventType.tileLoadProgress, onMap_tileLoadProgress);
              resolve(true); // 所有瓦片初始化加载完成
            }
          }
          this.on(EventType.tileLoadProgress, onMap_tileLoadProgress);
        })
      );
      layersPromse.push(this.terrainProvider.readyPromise); // 地形服务完成加载

      Promise.all(layersPromse).then((result) => {
        this.fire(EventType.load, { list: result });
      });
    }

    /**
     * 重新设置basemps底图图层，对options.basemaps重新赋值
     *
     * @param {Map.basemapOptions[]} arr 底图图层配置
     * @return {BaseLayer[]} 图层数组
     */
    setBasemapsOptions(arr) {
      if (!arr || arr.length === 0) {
        return
      }

      this._optionsBasemapsList.removeAll();
      this.options.basemaps = arr;

      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        if (!item.name) {
          item.name = "";
        }
        if (!item.id) {
          item.id = this.getNextLayerId();
        }

        const layer = create$2(item, this.options.templateValues);
        if (!layer) {
          continue
        }

        if (item.show) {
          this.addLayer(layer);
        }
        this._optionsBasemapsList.set(item.id, layer);

        if (layer.hasChildLayer && item.layers) {
          for (let idx = 0; idx < item.layers.length; idx++) {
            const childitem = item.layers[idx];
            childitem.pid = item.id;
            childitem.parent = layer;

            if (!childitem.id) {
              childitem.id = this.getNextLayerId();
            }
          }
        }
      }

      return this._optionsBasemapsList.values
    }

    /**
     * 重新设置layers图层，对options.layers重新赋值
     *
     * @param {Map.layerOptions[]} arr 可以叠加显示的图层配置
     * @return {BaseLayer[]} 图层数组
     */
    setLayersOptions(arr) {
      if (!arr || arr.length === 0) {
        return
      }

      this._optionsLayersList.removeAll();
      this.options.layers = arr;

      // 可叠加图层
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        if (!item.id) {
          item.id = this.getNextLayerId();
        }

        const layer = create$2(item, this.options.templateValues);
        if (!layer) {
          continue
        }

        if (item.show) {
          this.addLayer(layer);
        }
        this._optionsLayersList.set(item.id, layer);

        if (layer.hasChildLayer && item.layers) {
          for (let idx = 0; idx < item.layers.length; idx++) {
            const childitem = item.layers[idx];
            childitem.pid = item.id;
            childitem.parent = layer;
            if (!childitem.id) {
              childitem.id = this.getNextLayerId();
            }
          }
        }
      }
      return this._optionsLayersList.values
    }

    /**
     * 获取图层ID值，按顺序取值。
     * 没有id的图层，会自动使用本方法进行id赋值处理
     * @return {Number} 图层ID
     */
    getNextLayerId() {
      while (this._arrLayerIdx.indexOf(this._layerIdx) !== -1) {
        this._layerIdx++;
      }
      this._arrLayerIdx.push(this._layerIdx);
      return this._layerIdx
    }

    /**
     * 添加图层到地图上
     *
     * @param {BaseLayer} layer 图层对象
     * @param {Boolean} [showVal] 如果传值，覆盖图层的show属性
     * @return {Promise<Boolean|Object>} 图层加载完成承诺
     */
    addLayer(layer, showVal) {
      return new Promise((resolve, reject) => {
        if (!layer || !layer._onAdd) {
          resolve(false);
          return
        }

        if (Cesium__namespace.defined(showVal)) {
          layer.show = showVal;
        }

        if (layer._state === State.ADDED) {
          resolve(false);
          return
        }

        layer._onAdd(this);

        const oldLayer = this._layerList.get(layer.id);
        if (oldLayer && oldLayer !== layer) {
          layer.id = this.getNextLayerId();
          logWarn("addLayer:图层id存在冲突，已重新赋值id", layer);
        }

        this._layerList.set(layer.id, layer);

        // 处理加载状态
        layer.readyPromise.then(function (layer) {
          resolve(true); // 异步图层加载完成
        });
      })
    }

    /**
     * 移除图层
     *
     * @param {BaseLayer} layer 需要移除的图层
     * @param {boolean} [hasDestroy] 是否释放 destroy
     * @return {Map} 当前对象本身，可以链式调用
     */
    removeLayer(layer, hasDestroy) {
      if (!layer) {
        return this
      }

      if (isString(layer) || isNumber(layer)) {
        layer = this._layerList.get(layer); // 直接传入id时
        if (!layer) {
          return this
        }
      }

      if (layer._state !== State.ADDED) {
        return
      }

      this._layerList.remove(layer.id);

      if (hasDestroy && layer.clear) {
        layer.clear();
      }
      layer._onRemove();

      if (hasDestroy) {
        this._optionsBasemapsList.remove(layer.id);
        this._optionsLayersList.remove(layer.id);

        layer.destroy();
      }
      return this
    }

    /**
     * 是否有指定的图层存在（就是已经addLayer的图层）
     *
     * @param {String|Number|BaseLayer} layer 指定的图层或图层ID
     * @return {Boolean} 是否存在
     */
    hasLayer(layer) {
      if (!layer) {
        return false
      }
      if (isObject(layer)) {
        layer = layer.id;
      }

      return this._layerList.contains(layer)
    }

    /**
     * 遍历每一个图层并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} [context]  侦听器的上下文(this关键字将指向的对象)。
     * @return {Map} 当前对象本身,可以链式调用
     */
    eachLayer(method, context) {
      this._layerList.forEach(method, context || this);
      return this
    }

    /**
     * 根据指定属性获取图层，包括config.json配置的图层
     * @param {String|Number} attrValue 属性值
     * @param {String} [attrName='id'] 属性键
     * @return {BaseLayer|*} 图层对象
     */
    getLayer(attrValue, attrName) {
      if (isObject(attrValue)) {
        attrValue = attrValue.id;
      }
      return this.getLayerByAttr(attrValue, attrName)
    }

    /**
     * 根据ID或取图层 ，包括config.json配置的图层
     * @param {String|Number} id 图层id或uuid
     * @return {BaseLayer|*} 图层对象
     */
    getLayerById(id) {
      let layer = this._layerList.get(id);
      if (layer) {
        return layer
      }

      layer = this._optionsLayersList.get(id); // config.json已有的配置layers图层
      if (layer) {
        return layer
      }

      layer = this._optionsBasemapsList.get(id); // config.json已有的配置basemaps图层
      if (layer) {
        return layer
      }

      // 查找子图层等
      const layers = this.getLayers({
        basemaps: true, // 是否取config.json中的basempas
        layers: true // 是否取config.json中的layers
      });
      for (let i = 0, len = layers.length; i < len; i++) {
        const layer = layers[i];
        if (layer.id === id) {
          return layer
        }

        if (layer.hasChildLayer && layer.arrLayer) {
          for (let idx = 0; idx < layer.arrLayer.length; idx++) {
            const childLayer = layer.arrLayer[idx];
            if (childLayer.id === id) {
              return childLayer
            }
          }
        }
      }
      return undefined
    }

    /**
     * 根据指定属性获取图层
     * @param {String|Number} attrValue 属性值
     * @param {String} [attrName='id'] 属性键
     * @return {BaseLayer|*} 图层对象
     */
    getLayerByAttr(attrValue, attrName) {
      let layer = this._layerList.getByAttr(attrValue, attrName);
      if (layer) {
        return layer
      }
      layer = this._optionsLayersList.getByAttr(attrValue, attrName); // config.json已有的配置layers图层
      if (layer) {
        return layer
      }

      layer = this._optionsBasemapsList.getByAttr(attrValue, attrName); // config.json已有的配置basemaps图层
      if (layer) {
        return layer
      }

      return undefined
    }

    /**
     * 根据指定属性获取图层列表
     * @param {String|Number} attrValue 属性值
     * @param {String} [attrName='id'] 属性键
     * @return {BaseLayer[]|*} 图层对象列表
     */
    getLayersByAttr(attrValue, attrName) {
      let layers = this._layerList.getListByAttr(attrValue, attrName);
      layers = layers.concat(this._optionsLayersList.getByAttr(attrValue, attrName)); // config.json已有的配置layers图层
      layers = layers.concat(this._optionsBasemapsList.getByAttr(attrValue, attrName)); // config.json已有的配置basemaps图层
      return layers
    }

    /**
     * 获取所有图层
     *
     * @param {Object} [options] 参数对象，包括以下：
     * @param {Boolean} [options.basemaps] 默认不比较及处理，true:返回所有basemps中配置图层，false：排除所有所有basemps中配置图层
     * @param {Boolean} [options.layers] 默认不比较及处理，true:返回所有operationallayers中配置图层，false：排除所有operationallayers中配置图层
     * @param {Boolean} [options.childs=true] 是否获取GroupLayer内的子图层
     * @return {BaseLayer[]|Array} 图层数组
     */
    getLayers(options = {}) {
      let result = [];

      if (options.basemaps) {
        result = result.concat(this._optionsBasemapsList.values);
      }
      if (options.layers) {
        result = result.concat(this._optionsLayersList.values);
      }

      // 兼容旧版参数
      if (options.filter) {
        options.basemaps = false;
        options.layers = false;
      }

      this._layerList.forEach((layer) => {
        if (layer.isPrivate) {
          return
        }

        if (options.childs === false && layer.parent) {
          return // 子图层
        }

        if (Cesium__namespace.defined(options.basemaps) && this._optionsBasemapsList.contains(layer.id)) {
          return // config.json已有的配置basemaps图层
        }
        if (Cesium__namespace.defined(options.layers) && this._optionsLayersList.contains(layer.id)) {
          return // config.json已有的配置layers图层
        }

        result.push(layer);
      });

      return result
    }

    /**
     * 获取所有basemps底图图层
     *
     * @param {Boolean} [removeEmptyGroup=false] 是否移除 空图层组
     * @return {BaseLayer[]|Array} 图层数组
     */
    getBasemaps(removeEmptyGroup) {
      if (removeEmptyGroup) {
        const arrNew = [];
        this._optionsBasemapsList.forEach((layer) => {
          if (layer.hasEmptyGroup) {
            return
          }
          arrNew.push(layer);
        });
        return arrNew
      } else {
        return this._optionsBasemapsList.values
      }
    }

    /**
     * 获取所有瓦片图层，可以用于卷帘对比
     *
     * @return {BaseTileLayer[]|Array} 图层数组
     */
    getTileLayers() {
      let result = [];

      result = result.concat(this.getBasemaps(true));

      this._optionsLayersList.forEach((layer) => {
        if (layer.isTile && !layer.isPrivate) {
          result.push(layer);
        }
      });

      this._layerList.forEach((layer) => {
        if (!layer.isTile || layer.isPrivate) {
          return
        }
        if (this._optionsBasemapsList.contains(layer.id)) {
          return // config.json已有的配置basemaps图层
        }
        if (this._optionsLayersList.contains(layer.id)) {
          return // config.json已有的配置layers图层
        }

        result.push(layer);
      });
      return result
    }

    /// //////////////control 控件相关///////////////////////////
    // 按配置进行初始化相关控件
    _initControls() {
      const control = this.options?.control || {};

      // 添加火星图片标识
      addImage(this._viewer.scene);

      const navigationHelpButton = this._viewer.navigationHelpButton?._wrapper;

      // 调整原生的几个按钮位置
      const vrButton = this._viewer.vrButton?._container;
      if (vrButton) {
        removeClass(vrButton, "cesium-viewer-vrContainer"); // 修改样式
        addClass(vrButton, "cesium-button cesium-toolbar-button mars3d-vrButton");
        vrButton.parentNode.removeChild(vrButton);
        if (navigationHelpButton) {
          this.toolbar.insertBefore(vrButton, navigationHelpButton);
        } else {
          this.toolbar.appendChild(vrButton);
        }
      }
      const fullscreenButton = this._viewer.fullscreenButton?._container;
      if (fullscreenButton) {
        removeClass(fullscreenButton, "cesium-viewer-fullscreenContainer"); // 修改样式
        addClass(fullscreenButton, "cesium-button cesium-toolbar-button");
        fullscreenButton.style.display = "inline-block";

        fullscreenButton.parentNode.removeChild(fullscreenButton);
        if (navigationHelpButton) {
          this.toolbar.insertBefore(fullscreenButton, navigationHelpButton);
        } else {
          this.toolbar.appendChild(fullscreenButton);
        }
      }

      // 挂载cesium内置控件到controls
      const arr = [
        "animation",
        "timeline",
        "baseLayerPicker",
        "fullscreenButton",
        "vrButton",
        "geocoder",
        "homeButton",
        "sceneModePicker",
        "projectionPicker",
        "navigationHelpButton"
      ];
      arr.forEach((element) => {
        const czmContrl = this._viewer[element];
        if (czmContrl) {
          czmContrl.type = element;
          czmContrl._show = true;
          if (element === "fullscreenButton" || element === "vrButton") {
            czmContrl._mainContainer = czmContrl._container;
          } else {
            czmContrl._mainContainer = czmContrl._wrapper || czmContrl._element || czmContrl._container;
          }

          Object.defineProperty(czmContrl, "show", {
            get() {
              return this._show
            },
            set(value) {
              this._show = value;
              this._mainContainer.style.display = value ? "inline-block" : "none";
            }
          });
          this._controlsByType[element] = czmContrl;
        }
      });

      // 绑定popup
      this._popupMgr = new PopupMgr(control.popup);
      this.addControl(this._popupMgr);

      // 绑定tooltip
      this._tooltipMgr = new TooltipMgr(control.tooltip);
      this.addControl(this._tooltipMgr);

      // 绑定右键菜单
      this._contextmenuMgr = new ContextMenu(control.contextmenu);
      this.addControl(this._contextmenuMgr);
      if (control.contextmenu?.hasDefault ?? true) {
        this.bindContextMenu(this.getDefaultContextMenu()); // 显示默认菜单
      }

      // 绑定小tooltip
      this._smallTooltip = new SmallTooltip(control.smallTooltip);
      this.addControl(this._smallTooltip);

      // 绑定键盘漫游
      this._keyboardRoam = new KeyboardRoam({ enabled: false, ...(control.keyboardRoam || {}) });
      this.addControl(this._keyboardRoam);

      //= ==================其他普通control==================================
      for (const key in control) {
        const val = control[key];
        if (!val || val.enabled === false) {
          continue
        }

        const item = create$1(key, val);
        if (item) {
          this.addControl(item);
        }
      }
    }

    /**
     * 添加控件到地图上
     *
     * @param {BaseControl} control 控件对象
     * @param {Boolean} [enabledVal] 如果传值，覆盖控件的enabled属性
     * @return {Map} 当前对象本身，可以链式调用
     */
    addControl(control, enabledVal) {
      if (!control || !control._onAdd) {
        return this // 不是控件
      }

      if (this._controlsByType[control.type]) {
        logWarn(`地图上已有${control.type}控件,请直接使用 map.controls.${control.type} 对象 `, this);
        return
      }

      if (Cesium__namespace.defined(enabledVal)) {
        control.enabled = enabledVal;
      }
      control._onAdd(this);

      this._controlList.set(control.id, control);
      this._controlsByType[control.type] = control; // 挂载到对象中，方便外部使用

      if (this.controls.compass) {
        this.controls.compass.updateSize();
      }

      this.fire(EventType.addControl, { control: control });

      return this
    }

    /**
     * 移除控件
     *
     * @param {BaseControl} control 需要移除的控件
     * @param {boolean} [hasDestroy] 是否释放
     * @return {Map} 当前对象本身，可以链式调用
     */
    removeControl(control, hasDestroy) {
      if (!control) {
        return this
      }

      this._controlList.remove(control.id);
      delete this._controlsByType[control.type];

      control._onRemove();

      this.fire(EventType.removeControl, { control: control });

      if (hasDestroy) {
        control.destroy();
      }
      return this
    }

    /**
     * 是否有指定的控件存在（就是已经addControl的控件）
     *
     * @param {BaseControl|String} control 指定的控件或控件ID
     * @return {Boolean} 是否存在
     */
    hasControl(control) {
      return this._controlList.contains(control?.id || control)
    }

    /**
     * 遍历每一个控件并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} [context] 侦听器的上下文(this关键字将指向的对象)。
     * @return {Map} 当前对象本身,可以链式调用
     */
    eachControl(method, context) {
      this._controlList.forEach(method, context || this);
      return this
    }

    /**
     * 根据指定属性获取控件
     * @param {String|Number|Boolean} attrValue 属性值
     * @param {String} [attrName='id'] 属性键
     * @return {BaseControl} 控件对象
     */
    getControl(attrValue, attrName) {
      return this._controlList.getByAttr(attrValue, attrName)
    }

    /// //////////////其他的添加移除钩子方法///////////////////////////
    // 按配置进行初始化相关控件
    _initEffect() {
      const effect = this.options?.effect;
      if (effect) {
        for (const key in effect) {
          const val = effect[key];
          if (!val || val.enabled === false) {
            continue
          }
          const item = create(key, val);
          if (item) {
            this.addEffect(item);
          }
        }
      }
    }

    /**
     * 添加特效对象到地图上
     *
     * @param {BaseEffect} effect 特效对象
     * @return {Map} 当前对象本身，可以链式调用
     */
    addEffect(effect) {
      if (!effect || !effect._onAdd) {
        return this // 不是有效对象
      }
      if (this._effects[effect.type]) {
        logError(`地图上已有${effect.type}特效,请直接使用 map.effects.${effect.type} 对象 `, this);
        return
      }

      this.addThing(effect);

      this._effects[effect.type] = effect; // 挂载到对象中，方便外部使用

      this.fire(EventType.addEffect, { effect: effect });
    }

    /**
     * 移除特效对象
     *
     * @param {BaseEffect} effect 需要移除的特效对象
     * @param {boolean} [hasDestroy] 是否释放
     * @return {Map} 当前对象本身，可以链式调用
     */
    removeEffect(effect, hasDestroy) {
      delete this._effects[effect.type];
      this.fire(EventType.removeEffect, { effect: effect });

      this.removeThing(effect, hasDestroy);
    }

    /**
     * 根据指定属性获取Thing对象
     *
     * @param {String|*} key 属性值（如id、name值）
     * @param {String} [attrName='id'] 属性名称
     * @return {BaseEffect} Thing对象
     */
    getEffect(key, attrName = "id") {
      return this.getThing(key, attrName)
    }

    /**
     * 添加Thing对象到地图上
     *
     * @param {BaseThing} item Thing对象
     * @return {Map} 当前对象本身，可以链式调用
     */
    addThing(item) {
      if (!item || !item._onAdd) {
        return this // 不是有效对象
      }

      item._onAdd(this);
      this._thingList.set(item.id, item);

      return this
    }

    /**
     * 移除Thing对象
     *
     * @param {BaseThing} item 需要移除的Thing对象
     * @param {boolean} [hasDestroy] 是否释放
     * @return {Map} 当前对象本身，可以链式调用
     */
    removeThing(item, hasDestroy) {
      if (!item) {
        return this
      }

      this._thingList.remove(item.id);

      if (hasDestroy && item.clear) {
        item.clear();
      }
      item._onRemove();
      if (hasDestroy) {
        item.destroy();
      }
      return this
    }

    /**
     * 是否有指定的Thing对象存在（就是已经addThing的图层）
     *
     * @param {BaseThing|String} thing 指定的Thing对象或Thing对象ID
     * @return {Boolean} 是否存在
     */
    hasThing(thing) {
      return this._thingList.contains(thing?.id || thing)
    }

    /**
     * 遍历每一个Thing对象并将其作为参数传递给回调函数
     *
     * @param {Function} method 回调方法
     * @param {Object} [context]  侦听器的上下文(this关键字将指向的对象)。
     * @return {Map} 当前对象本身,可以链式调用
     */
    eachThing(method, context) {
      this._thingList.forEach(method, context || this);
      return this
    }

    /**
     * 根据指定属性获取Thing对象
     *
     * @param {String|Number|Boolean} attrValue 属性值
     * @param {String} [attrName='id'] 属性名称
     * @return {BaseThing} Thing对象
     */
    getThing(attrValue, attrName) {
      this._thingList.getByAttr(attrValue, attrName);
      return undefined
    }

    /**
     * 根据设置的lang参数，获取当前key对应语言的文本内容。
     * @param {String} key  文本key
     * @return {void}  lang参数指定的对应文本内容
     */
    getLangText(key) {
      return getLangText(key, this.lang)
    }

    /// //////////////相机及视角 相关///////////////////////////

    /**
     * 放大地图
     * @param {Number} [relativeAmount=2]  相对量
     * @return {Boolean} 是否有移动位置
     */
    zoomIn(relativeAmount) {
      return this._zoomNavigation.zoomIn(relativeAmount)
    }

    /**
     * 缩小地图
     * @param {Number} [relativeAmount=2]  相对量
     * @return {Boolean} 是否有移动位置
     */
    zoomOut(relativeAmount) {
      return this._zoomNavigation.zoomOut(relativeAmount)
    }

    /**
     * 设置鼠标操作习惯方式。
     * 默认为中键旋转，右键拉伸远近。传`rightTilt:true`可以设置为右键旋转，中键拉伸远近。
     * @param {Boolean} [rightTilt=false]  是否右键旋转
     * @return {void}  无
     */
    changeMouseModel(rightTilt) {
      this._hasRightTilt = rightTilt;
      if (rightTilt) {
        // 旋转【右键】
        this._viewer.scene.screenSpaceCameraController.tiltEventTypes = [
          Cesium__namespace.CameraEventType.RIGHT_DRAG,
          Cesium__namespace.CameraEventType.PINCH,
          {
            eventType: Cesium__namespace.CameraEventType.LEFT_DRAG,
            modifier: Cesium__namespace.KeyboardEventModifier.CTRL
          },
          {
            eventType: Cesium__namespace.CameraEventType.RIGHT_DRAG,
            modifier: Cesium__namespace.KeyboardEventModifier.CTRL
          }
        ];
        // 放大缩小【中键】
        this._viewer.scene.screenSpaceCameraController.zoomEventTypes = [
          Cesium__namespace.CameraEventType.MIDDLE_DRAG,
          Cesium__namespace.CameraEventType.WHEEL,
          Cesium__namespace.CameraEventType.PINCH
        ];
      } else {
        // 旋转【中键】
        this._viewer.scene.screenSpaceCameraController.tiltEventTypes = [
          Cesium__namespace.CameraEventType.MIDDLE_DRAG,
          Cesium__namespace.CameraEventType.PINCH,
          {
            eventType: Cesium__namespace.CameraEventType.LEFT_DRAG,
            modifier: Cesium__namespace.KeyboardEventModifier.CTRL
          },
          {
            eventType: Cesium__namespace.CameraEventType.RIGHT_DRAG,
            modifier: Cesium__namespace.KeyboardEventModifier.CTRL
          }
        ];
        // 放大缩小【右键】
        this._viewer.scene.screenSpaceCameraController.zoomEventTypes = [
          Cesium__namespace.CameraEventType.RIGHT_DRAG,
          Cesium__namespace.CameraEventType.WHEEL,
          Cesium__namespace.CameraEventType.PINCH
        ];
      }

      if (this.controls.mouseDownView) {
        this.controls.mouseDownView.changeMouseModel();
      }
    }

    /**
     * 清除鼠标操作限定的Pitch范围
     * @return {void}  无
     */
    clearPitchRange() {
      delete this._pitch_max;
      delete this._pitch_min;
      delete this._pitch_minHeight;

      this._viewer.scene.screenSpaceCameraController.inertiaSpin = 0.9;
      this._viewer.scene.screenSpaceCameraController.inertiaTranslate = 0.9;

      this.off(EventType.mouseDown, this._setPitchRange_rightDownHandler, this);
      this.off(EventType.mouseUp, this._setPitchRange_rightUpHandler, this);
      this.off(EventType.mouseMove, this._setPitchRange_mouseMoveHandler, this);
      this.off(EventType.cameraMoveStart, this._setPitchRange_cameraChangedHandler, this);
    }

    /**
     * 设置鼠标操作限定的Pitch范围
     * @param {Number} max  最大值（角度值）
     * @param {Number} [min=-90]  最小值（角度值）
     * @return {void}  无
     */
    setPitchRange(max, min = -90) {
      this.clearPitchRange();

      this._viewer.scene.screenSpaceCameraController.inertiaSpin = 0;
      this._viewer.scene.screenSpaceCameraController.inertiaTranslate = 0;

      this._pitch_max = Cesium__namespace.Math.toRadians(max);
      this._pitch_min = Cesium__namespace.Math.toRadians(min);
      this._pitch_minHeight = this._viewer.camera.positionCartographic.height;

      this.on(EventType.mouseDown, this._setPitchRange_rightDownHandler, this);
      this.on(EventType.mouseUp, this._setPitchRange_rightUpHandler, this);
      this.on(EventType.cameraChanged, this._setPitchRange_cameraChangedHandler, this);
    }

    _setPitchRange_rightDownHandler(evnet) {
      if (this._viewer.scene.mode !== Cesium__namespace.SceneMode.SCENE3D) {
        return
      }
      this.on(EventType.mouseMove, this._setPitchRange_mouseMoveHandler, this);
    }

    _setPitchRange_rightUpHandler(evnet) {
      this._viewer.scene.screenSpaceCameraController.enableTilt = true;
      this.off(EventType.mouseMove, this._setPitchRange_mouseMoveHandler, this);
    }

    _setPitchRange_mouseMoveHandler(evnet) {
      let enableTilt = true;
      const isUp = evnet.endPosition.y < evnet.startPosition.y;
      if (isUp && this._viewer.camera.pitch > this._pitch_max) {
        enableTilt = false;
      } else if (!isUp && this._viewer.camera.pitch < this._pitch_min) {
        enableTilt = false;
      } else {
        enableTilt = true;
      }
      this._viewer.scene.screenSpaceCameraController.enableTilt = enableTilt;
    }

    _setPitchRange_cameraChangedHandler(evnet) {
      let pitch = this._viewer.camera.pitch;
      if (pitch > this._pitch_max || pitch < this._pitch_min) {
        this._viewer.scene.screenSpaceCameraController.enableTilt = false;

        // clamp the pitch
        if (pitch > this._pitch_max) {
          pitch = this._pitch_max;
        } else if (pitch < this._pitch_min) {
          pitch = this._pitch_min;
        }

        const destination = Cesium__namespace.Cartesian3.fromRadians(
          this._viewer.camera.positionCartographic.longitude,
          this._viewer.camera.positionCartographic.latitude,
          Math.max(this._viewer.camera.positionCartographic.height, this._pitch_minHeight)
        );

        this._viewer.camera.cancelFlight();
        this._viewer.camera.setView({
          destination: destination,
          orientation: {
            pitch: pitch
          }
        });
        this._viewer.scene.screenSpaceCameraController.enableTilt = true;
      }
    }

    /**
     * 设置相机pitch值，保持地图中心位置不变。
     * @param {Number} pitch 俯仰角度值， 0至360
     * @param {Object} [options] 具有以下属性的对象:
     * @param {Number} [options.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} [options.duration] 飞行持续时间（秒）。如果省略，内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     *
     */
    setPitch(pitch, options = {}) {
      const center = this.getCenter();
      if (!center) {
        return Promise.resolve(false)
      }
      const distance = Cesium__namespace.Cartesian3.distance(center.toCartesian(), this._viewer.camera.positionWC);
      return this.flyToPoint(center, { ...options, radius: distance, pitch: pitch })
    }

    /**
     * 停止视角定位等操作
     * @return {Map} 当前对象本身，可以链式调用
     */
    cancelFlyTo() {
      Route.clearLastCamera();
      this._isCenterAtArr = false;
      this._viewer.camera.cancelFlight(); // 取消飞行
      return this
    }

    cancelFlight() {
      return this.cancelFlyTo()
    }

    /**
     * 获取当前相机视角参数，
     * 示例：{"lat":30.526361,"lng":116.335987,"alt":45187,"heading":0,"pitch":-45}
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Boolean} [options.simplify=true] 是否简化，false时保留角度1位小数位
     * @return {Object} 当前相机视角参数
     */
    getCameraView(options) {
      return getCameraView(this.camera, options)
    }

    /**
     * 将相机本身定位至指定位置
     *
     * @param {Object} cameraView 飞行参数
     * @param {Number} cameraView.lng 经度值, 180 - 180
     * @param {Number} cameraView.lat 纬度值, -90 - 90
     * @param {Number} [cameraView.alt] 高度值
     * @param {Number} [cameraView.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
     * @param {Number} [cameraView.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
     * @param {Number} [cameraView.roll] 翻滚角度值，绕经度线旋转角度, 0-360
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Cesium.Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     */
    setCameraView(cameraView, options = {}) {
      return new Promise((resolve, reject) => {
        if (!cameraView) {
          resolve(false);
          return
        }

        if (isNumber(options)) {
          // 可以只传一个数字，代表duration时间
          options = { duration: options };
        }

        let height = options.minHeight ?? 2500;
        if (this._viewer.camera.positionCartographic.height < height) {
          height = this._viewer.camera.positionCartographic.height;
        }
        if (Cesium__namespace.defined(cameraView.z)) {
          height = cameraView.z; // 兼容旧z命名
        }
        if (Cesium__namespace.defined(cameraView.alt)) {
          height = cameraView.alt;
        }

        const flyToOptions = {
          ...options,
          destination: Cesium__namespace.Cartesian3.fromDegrees(cameraView.x || cameraView.lng, cameraView.y || cameraView.lat, height), // 经度、纬度、高度
          orientation: {
            heading: Cesium__namespace.Math.toRadians(cameraView.heading ?? 0), // 绕垂直于地心的轴旋转
            pitch: Cesium__namespace.Math.toRadians(cameraView.pitch ?? -90), // 绕纬度线旋转
            roll: Cesium__namespace.Math.toRadians(cameraView.roll ?? 0) // 绕经度线旋转
          },
          complete: () => {
            if (options.complete) {
              options.complete();
            }
            resolve(true);
          },
          cancel: () => {
            if (options.cancel) {
              options.cancel();
            }
            resolve(false);
          }
        };
        if (options.duration === 0) {
          this._viewer.camera.setView(flyToOptions);
        } else {
          this._viewer.camera.flyTo(flyToOptions);
        }
      })
    }

    /**
     * 将相机本身定位至指定位置，同 setCameraView 方法
     * 为了兼容老版本用户习惯和center参数名称一致而用的别名方法。
     * @param {Object} cameraView 飞行参数，同 setCameraView 方法
     * @param {Object} [options={}] 参数对象，同 setCameraView 方法
     * @return {void}  无
     */
    centerAt(cameraView, options) {
      this.setCameraView(cameraView, options);
    }

    /**
     * 飞行到默认视角，
     * 一般为config.json中的center参数配置的视角。
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @return {void}  无
     *
     */
    flyHome(options) {
      if (this.options?.scene?.center) {
        this.setCameraView(this.options.scene.center, options);
      } else if (this.options?.scene?.extent) {
        this.flyToExtent(this.options.scene.extent, options);
      }
    }

    /**
     *  定位到多个相机视角位置，按数组顺序播放
     *
     * @param {Object[]} arr 视角参数数组，每个对象包含：
     * @param {Number} arr.lng 经度值, -180 至 180
     * @param {Number} arr.lat 纬度值, -90 至 90
     * @param {Number} arr.alt 高度值
     * @param {Number} arr.heading 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} arr.pitch 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} arr.roll 翻滚角度值，绕经度线旋转角度, 0至360
     * @param {Number} [arr.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Number} [arr.stop=1] 该步骤飞行结束的停留时间（单位：秒）。
     * @param {Function} [arr.onStart] 该步骤飞行开始前的回调方法
     * @param {Function} [arr.onEnd] 该步骤飞行开始结束后的回调方法
     *
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 全部飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Cesium.Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction=Cesium.EasingFunction.LINEAR_NONE] 控制在飞行过程中如何插值时间。
     * @return {void}  无
     *
     */
    setCameraViewList(arr, options = {}) {
      this.cancelFlyTo();

      this.arrCenterTemp = arr;
      this._isCenterAtArr = true;
      this._setCameraViewListItem(0, options);
    }

    _setCameraViewListItem(i, options) {
      const that = this;
      if (!this._isCenterAtArr || i < 0 || i >= this.arrCenterTemp.length) {
        this._isCenterAtArr = false;
        if (options?.complete) {
          options.complete();
        }
        return
      }
      const cameraView = this.arrCenterTemp[i];

      if (cameraView.onStart) {
        cameraView.onStart();
      }

      let lastTimer;
      this.setCameraView(cameraView, {
        easingFunction: Cesium__namespace.EasingFunction.LINEAR_NONE,
        ...options,
        duration: cameraView.duration,
        complete: function () {
          if (cameraView.onEnd) {
            cameraView.onEnd();
          }

          const stopTime = cameraView.stop ?? 1;
          lastTimer = setTimeout(() => {
            that._setCameraViewListItem(++i, options);
          }, stopTime * 1000);
        },
        cancle: function () {
          this._isCenterAtArr = false;
          clearTimeout(lastTimer);

          if (options?.cancel) {
            options.cancel();
          }
        }
      });
    }

    /**
     * 飞行至Cesium相关矢量对象处，是Cesium本身的flyTo方法。
     *
     * 将相机移至提供的一个或多个实体或数据源。如果数据源仍在加载过程中，或者可视化仍在加载中，此方法在执行飞行之前等待数据准备就绪。
     * 偏移量是在以边界球中心为中心的局部东北向上参考框中的航向/俯仰/范围。航向角和俯仰角是在局部的东西向北参考系中定义的。航向是从y轴到x轴的角度。间距是从xy平面开始的旋转。正螺距角度在平面上方。负俯仰角在平面下方。范围是到中心的距离。如果范围是零，则将计算范围以使整个边界球都可见。
     *
     * 在2D模式下，必须有一个俯视图。摄像机将被放置在目标上方并向下看。上方的高度目标将是范围。航向将根据偏移量确定。如果标题不能根据偏移量确定，航向将为北。
     *
     * @param {*} target 需要定位的Cesium内部对象。您还可以传递一个： Cesium.Entity|Cesium.Entity[]|Cesium.EntityCollection|Cesium.DataSource|Cesium.ImageryLayer|Cesium.Cesium3DTileset|Cesium.TimeDynamicPointCloud|Promise.<Entity|Entity[]|Cesium.EntityCollection|Cesium.DataSource|Cesium.ImageryLayer|Cesium.Cesium3DTileset|Cesium.TimeDynamicPointCloud>
     * @param {Object} [options] 具有以下属性的对象:
     * @param {Number} [options.duration=3.0] 飞行持续时间（秒）。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Cesium.HeadingPitchRange} [options.offset] 在局部东北朝上的参考框中，距目标的偏移量为中心。
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     */
    flyTo(target, options) {
      if (!target) {
        return
      }
      return this._viewer.flyTo(target, options)
    }

    /**
     * 飞行定位到 Graphic矢量对象 处
     *
     * @param {BaseGraphic|BaseGraphic[]} graphic 矢量对象
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.radius] 点状数据时，相机距离目标点的距离（单位：米）
     * @param {Number} [options.scale=1.2] 线面数据时，缩放比例，可以控制视角比矩形略大一些，这样效果更友好。
     *
     * @param {Number} [options.minHeight] 定位时相机的最小高度值，用于控制避免异常数据
     * @param {Number} [options.maxHeight] 定位时相机的最大高度值，用于控制避免异常数据
     * @param {Number} [options.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} [options.pitch] 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} [options.roll] 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Cesium.Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     */
    flyToGraphic(graphic, options = {}) {
      if (!graphic || graphic.length === 0) {
        return Promise.resolve(false)
      }

      // 单个对象时
      if (graphic.flyTo) {
        options.clampToGround = graphic.style?.clampToGround;
        return graphic.flyTo(options)
      }

      if (!Array.isArray(graphic)) {
        return Promise.resolve(false)
      }

      if (graphic.length === 1) {
        return graphic[0].flyTo(options)
      }

      let rectangleAll;
      for (let i = 0, len = graphic.length; i < len; i++) {
        const item = graphic[i];
        if (!item.getRectangle) {
          continue
        }

        const rectangle = item.getRectangle();
        if (!Cesium__namespace.defined(rectangle)) {
          continue
        }

        if (rectangleAll) {
          rectangleAll = Cesium__namespace.Rectangle.union(rectangle, rectangleAll);
        } else {
          rectangleAll = rectangle;
        }
      }
      return this.flyToExtent(rectangleAll, options)
    }

    /**
     * 定位至坐标数组
     *
     * @param {Cesium.Cartesian3[]} positions 坐标数组
     * @param {Object} [options={}] 参数对象:
     *
     * @param {Number} [options.radius] 点状数据时，相机距离目标点的距离（单位：米）
     * @param {Number} [options.scale=1.2] 线面数据时，缩放比例，可以控制视角比矩形略大一些，这样效果更友好。
     *
     * @param {Number} [options.minHeight] 定位时相机的最小高度值，用于控制避免异常数据
     * @param {Number} [options.maxHeight] 定位时相机的最大高度值，用于控制避免异常数据
     * @param {Number} [options.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} [options.pitch] 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} [options.roll] 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Cesium.Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     */
    flyToPositions(positions, options = {}) {
      if (!positions || positions.length === 0) {
        return Promise.resolve(false)
      }
      if (positions.length === 1) {
        return this.flyToPoint(positions[0], options)
      }
      const extent = getRectangle(positions, true);
      if (!extent) {
        return Promise.resolve(false)
      }

      if (extent.xmin === extent.xmax || extent.ymin === extent.ymax || extent.xmax - extent.xmin > 200) {
        // 是重合的多个点 或跨越了180度线时
        return this.flyToPoint([extent.xmin, extent.ymin, extent.height], options)
      } else {
        // 是矩形区域时
        extent.height = getMaxHeight(positions);
        options.scale = options.scale || 1.2;
        return this.flyToExtent(extent, options)
      }
    }

    /**
     * 相机飞行定位至矩形区域
     *
     * @param {Object|Cesium.Rectangle} extent 飞行参数, Object时可以传入：
     * @param {Number} extent.xmin 最小经度值, -180 至 180
     * @param {Number} extent.xmax 最大经度值, -180 至 180
     * @param {Number} extent.ymin 最小纬度值, -90 至 90
     * @param {Number} extent.ymax 最大纬度值, -90 至 90
     * @param {Number} [extent.height=0] 矩形高度值
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.scale] 缩放比例，可以控制视角比矩形略大一些，这样效果更友好。
     * @param {Number} [options.minHeight] 定位时相机的最小高度值，用于控制避免异常数据
     * @param {Number} [options.maxHeight] 定位时相机的最大高度值，用于控制避免异常数据
     * @param {Number} [options.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} [options.pitch] 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} [options.roll] 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Cesium.Matrix4} [options.endTransform] 变换矩阵表示飞行结束时相机所处的参照系。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机飞得比这个值高，在飞行过程中调整俯仰以向下看，并保持地球在视口。
     * @param {Number} [options.flyOverLongitude] 地球上的两点之间总有两条路。这个选项迫使相机选择战斗方向飞过那个经度。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Boolean} [options.convert=true] 是否将目的地从世界坐标转换为场景坐标（仅在不使用3D时相关）。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction] 控制在飞行过程中如何插值时间。
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     */
    flyToExtent(extent, options = {}) {
      if (extent instanceof Cesium__namespace.Rectangle) {
        extent = formatRectangle(extent);
      }

      const xmin = extent.xmin;
      const xmax = extent.xmax;
      const ymin = extent.ymin;
      const ymax = extent.ymax;

      const centerx = (xmin + xmax) / 2;
      const centery = (ymin + ymax) / 2;
      let height = extent.height ?? options.height ?? 0;
      if (height === 0) {
        height = getHeight(this._viewer.scene, Cesium__namespace.Cartesian3.fromDegrees(centerx, centery));
      }

      // 求矩形最大边的边长
      const recta = Cesium__namespace.Rectangle.fromDegrees(xmin, ymin, xmax, ymax);
      const granularity = Math.max(recta.height, recta.width);
      if (granularity > 0) {
        options.radius = (options.radius ?? 0) + Cesium__namespace.Math.chordLength(granularity, this._viewer.scene.globe.ellipsoid.maximumRadius);
      }

      return this.flyToPoint(new LngLatPoint(centerx, centery, height), options)
    }

    /**
     * 定位至目标点(非相机位置)
     *
     * @param {LngLatPoint|Cesium.Cartesian3|Number[]} point 目标点位置（视角中心点）
     * @param {Object} [options={}] 具有以下属性的对象:
     * @param {Number} [options.radius] 相机距离目标点的距离（单位：米）
     * @param {Number} [options.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0至360
     * @param {Number} [options.pitch] 俯仰角度值，绕纬度线旋转角度, 0至360
     * @param {Number} [options.roll] 翻滚角度值，绕经度线旋转角度, 0至360
     *
     * @param {Number} [options.duration] 飞行持续时间（秒）。如果省略，内部会根据飞行距离计算出理想的飞行时间。
     * @param {Boolean} [options.clampToGround] 是否贴地对象,true时异步计算实际高度值后进行定位。
     * @param {Cesium.Camera.FlightCompleteCallback} [options.complete] 飞行完成后要执行的函数。
     * @param {Cesium.Camera.FlightCancelledCallback} [options.cancel] 飞行取消时要执行的函数。
     * @param {Cesium.Matrix4} [options.endTransform] 表示飞行完成后摄像机将位于的参考帧的变换矩阵。
     * @param {Number} [options.maximumHeight] 飞行高峰时的最大高度。
     * @param {Number} [options.pitchAdjustHeight] 如果相机的飞行角度高于该值，请在飞行过程中调整俯仰角度以向下看，并将地球保持在视口中。
     * @param {Number} [options.flyOverLongitude] 地球上2点之间总是有两种方式。此选项会迫使相机选择战斗方向以在该经度上飞行。
     * @param {Number} [options.flyOverLongitudeWeight] 仅在通过flyOverLongitude指定的lon上空飞行，只要该方式的时间不超过flyOverLongitudeWeight的短途时间。
     * @param {Cesium.EasingFunction.Callback} [options.easingFunction]  控制在飞行过程中如何插值时间。
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     */
    flyToPoint(point, options = {}) {
      return new Promise((resolve, reject) => {
        if (!point) {
          resolve(false);
          return
        }
        point = LngLatPoint.parse(point);
        const position = point.toCartesian();
        if (options.clampToGround) {
          // 求贴地高度
          getSurfaceHeight(this._viewer.scene, position, { has3dtiles: true }).then((result) => {
            point.alt = result.height;

            delete options.clampToGround;
            this.flyToPoint(point, options).then((result) => {
              resolve(result);
            });
          });
          return
        }

        let radius = options.radius || this.getCameraDistance() || 100;

        if (Cesium__namespace.defined(options.scale) && options.scale > 0) {
          radius *= options.scale;
        }
        if (Cesium__namespace.defined(options.minHeight) && radius < options.minHeight) {
          radius = options.minHeight;
        }
        if (Cesium__namespace.defined(options.maxHeight) && radius > options.maxHeight) {
          radius = options.maxHeight;
        }

        let pitch;
        if (Cesium__namespace.defined(options.pitch)) {
          pitch = Cesium__namespace.Math.toRadians(options.pitch);
        } else {
          pitch = this._viewer.camera.pitch;
          const pitchoDegrees = Cesium__namespace.Math.toDegrees(pitch);
          if (Cesium__namespace.defined(options.minPitch) && pitchoDegrees < options.minPitch) {
            pitch = Cesium__namespace.Math.toRadians(options.minPitch);
          }
          if (Cesium__namespace.defined(options.maxPitch) && pitchoDegrees > options.maxPitch) {
            pitch = Cesium__namespace.Math.toRadians(options.maxPitch);
          }
        }

        const heading = Cesium__namespace.defined(options.heading) ? Cesium__namespace.Math.toRadians(options.heading) : this._viewer.camera.heading;
        const offset = new Cesium__namespace.HeadingPitchRange(heading, pitch, radius);
        const boundingSphere = new Cesium__namespace.BoundingSphere(position, 0);

        if (options.duration === 0) {
          this._viewer.camera.lookAt(position, offset);
          if (!options.lock && !this._viewer.trackedEntity) {
            this._viewer.camera.lookAtTransform(Cesium__namespace.Matrix4.IDENTITY);
          }

          if (options.complete) {
            options.complete();
          }
          resolve(true);
        } else {
          this._viewer.camera.flyToBoundingSphere(boundingSphere, {
            ...options,
            offset: offset,
            complete: () => {
              if (options.complete) {
                options.complete();
              }
              resolve(true);
            },
            cancel: () => {
              if (options.cancel) {
                options.cancel();
              }
              resolve(false);
            }
          });
        }
      })
    }

    /**
     *是否在调用了openFlyAnimation正在进行开场动画
     * @return {Boolean} 是否在开场动画
     */
    isFlyAnimation() {
      return this._isFlyAnimation
    }

    /**
     * 执行开场动画，动画播放地球飞行定位到指定区域
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Object} [options.center=getCameraView()] 飞行到的指定区域视角参数
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     */
    openFlyAnimation(options = {}) {
      const viewer = this._viewer;
      const view = options.center || this.getCameraView(); // 默认为原始视角

      return new Promise((resolve, reject) => {
        this._isFlyAnimation = true;

        const that = this;
        function onFlyEnd(isOK) {
          resolve(isOK);
          if (options.callback) {
            options.callback(isOK); // 兼容v3.4之前版本callback
          }
          that._isFlyAnimation = false;

          if (that.openFlyAnimationEndFun) {
            that.openFlyAnimationEndFun();
            delete that.openFlyAnimationEndFun;
          }
        }

        viewer.camera.setView({
          destination: Cesium__namespace.Cartesian3.fromDegrees(-85.16, 13.71, 23000000.0)
        });
        viewer.camera.flyTo({
          destination: Cesium__namespace.Cartesian3.fromDegrees(view.lng, view.lat, 23000000.0),
          duration: options.duration1 || 2,
          easingFunction: options.easingFunction1 || Cesium__namespace.EasingFunction.LINEAR_NONE,
          complete: () => {
            let z = view.alt ?? 90000;
            if (z < 200000 && view.pitch !== -90) {
              z = z * 1.2 + 8000;
              viewer.camera.flyTo({
                destination: Cesium__namespace.Cartesian3.fromDegrees(view.lng, view.lat, z),
                duration: options.duration2,
                easingFunction: options.easingFunction2,
                complete: () => {
                  this.setCameraView(view, {
                    duration: options.duration3 || 2,
                    easingFunction: options.easingFunction3,
                    complete: () => {
                      onFlyEnd(true);
                    },
                    cancel: () => {
                      onFlyEnd(false);
                    }
                  });
                },
                cancel: () => {
                  onFlyEnd(false);
                }
              });
            } else {
              this.setCameraView(view, {
                duration: options.duration3 || 2,
                easingFunction: options.easingFunction3,
                complete: () => {
                  onFlyEnd(true);
                },
                cancel: () => {
                  onFlyEnd(false);
                }
              });
            }
          },
          cancel: () => {
            onFlyEnd(false);
          }
        });
      })
    }

    /**
     * 执行旋转地球动画
     *
     * @param {Object} [options={}] 参数对象:
     * @param {Number} [options.duration=10] 动画时长（单位：秒）
     * @param {Object} [options.center=getCameraView()] 飞行到的指定区域视角参数
     * @returns {Promise<Boolean>} 如果飞行成功则解析为true的承诺，如果当前未在场景中可视化目标或取消飞行，则为false的Promise
     */
    rotateAnimation(options = {}) {
      const viewer = this._viewer;

      const first = options.center || this.getCameraView(); // 默认为原始视角
      const duration3 = (options.duration ?? 10) / 3;

      return new Promise((resolve, reject) => {
        // 动画 1/3
        viewer.camera.flyTo({
          destination: Cesium__namespace.Cartesian3.fromDegrees(first.lng + 120, first.lat, first.alt),
          orientation: {
            heading: Cesium__namespace.Math.toRadians(first.heading),
            pitch: Cesium__namespace.Math.toRadians(first.pitch),
            roll: Cesium__namespace.Math.toRadians(first.roll)
          },
          duration: duration3,
          easingFunction: Cesium__namespace.EasingFunction.LINEAR_NONE,
          complete: function () {
            // 动画 2/3
            viewer.camera.flyTo({
              destination: Cesium__namespace.Cartesian3.fromDegrees(first.lng + 240, first.lat, first.alt),
              orientation: {
                heading: Cesium__namespace.Math.toRadians(first.heading),
                pitch: Cesium__namespace.Math.toRadians(first.pitch),
                roll: Cesium__namespace.Math.toRadians(first.roll)
              },
              duration: duration3,
              easingFunction: Cesium__namespace.EasingFunction.LINEAR_NONE,
              complete: function () {
                // 动画 3/3
                viewer.camera.flyTo({
                  destination: Cesium__namespace.Cartesian3.fromDegrees(first.lng, first.lat, first.alt),
                  orientation: {
                    heading: Cesium__namespace.Math.toRadians(first.heading),
                    pitch: Cesium__namespace.Math.toRadians(first.pitch),
                    roll: Cesium__namespace.Math.toRadians(first.roll)
                  },
                  duration: duration3,
                  easingFunction: Cesium__namespace.EasingFunction.LINEAR_NONE,
                  complete: function () {
                    resolve(true);
                  },
                  cancel: () => {
                    resolve(false);
                  }
                });
                // 动画3/3 end
              },
              cancel: () => {
                resolve(false);
              }
            });
            // 动画2/3 end
          },
          cancel: () => {
            resolve(false);
          }
        });
        // 动画1/3 end
      })
    }

    /**
     * 清除已高亮的矢量对象
     * @param {Object} [result] 事件对象
     * @return {void}  无
     */
    closeHighlight(result) {
      if (result?.graphic === this.last_highlighGraphic) {
        return
      }

      if (this.last_highlighGraphic && this.last_highlighGraphic.closeHighlight) {
        this.last_highlighGraphic.closeHighlight();
      }
      this._clearLastHighlight();
    }

    _clearLastHighlight() {
      if (this.last_highlighGraphic) {
        this.last_highlighGraphic = null;
      }
      if (this.outlineEffect) {
        this.outlineEffect.selected = [];
      }
      // this._viewer.scene.requestRender(); //显式渲染一个帧
    }

    /**
     * 高亮矢量对象
     * @param {BaseGraphic|*} graphic 矢量对象
     * @param {Object} highlightStyle 高亮的样式，具体见各{@link GraphicType}矢量数据的style参数。
     * @param {Object} [event] 鼠标事件对象
     * @return {void}  无
     */
    openHighlight(graphic, highlightStyle, event) {
      if (!this._highlightEnabled) {
        return
      }

      if (!graphic.openHighlight) {
        logInfo("该对象暂不支持highlight高亮", graphic);
        return
      }
      this.closeHighlight();

      if (highlightStyle.outlineEffect) {
        // 采用OutlineEffect
        if (!this.outlineEffect) {
          this.outlineEffect = new OutlineEffect({ eventType: false });
          this.addEffect(this.outlineEffect);
        }
        this.outlineEffect.setOptions(highlightStyle);

        this.outlineEffect.selected = this.mouseEvent.getPicked(event);
      } else {
        // 普通style
        graphic.openHighlight(highlightStyle, false, event?.pickedObject);
      }
      this.last_highlighGraphic = graphic;

      this._viewer.scene.requestRender(); // 显式渲染一个帧
    }

    //= ============= popup/tooltip/contextMenu ======================

    /**
     * 打开Popup弹窗
     *
     * @param {LngLatPoint|Cesium.Cartesian3|Number[]} position 矢量对象 或 显示的位置
     * @param {String|Function|BaseGraphic|BaseGraphicLayer} content 弹窗内容html字符串，或者 回调方法 或者矢量对象/图层。
     * @param {Popup.StyleOptions} [options] 配置参数
     * @return {Map} 当前对象本身，可以链式调用
     */
    openPopup(position, content, options) {
      this._popupMgr.open(position, {
        content: content,
        options: options
      });
      return this
    }

    /**
     * 关闭Popup弹窗
     * @return {Map} 当前对象本身，可以链式调用
     */
    closePopup() {
      if (this._popupMgr) {
        this._popupMgr.close();
      }
      return this
    }

    /**
     * 打开Tooltip弹窗
     *
     * @param {LngLatPoint|Cesium.Cartesian3|Number[]} position 矢量对象 或 显示的位置
     * @param {String|Function} content 弹窗内容html字符串，或者 回调方法
     * @param {Tooltip.StyleOptions} [options] 配置参数
     * @return {Map} 当前对象本身，可以链式调用
     */
    openTooltip(position, content, options = {}) {
      this._tooltipMgr.open(position, {
        content: content,
        options: options,
        target: this
      });
      return this
    }

    /**
     * 关闭Tooltip弹窗
     * @return {Map} 当前对象本身，可以链式调用
     */
    closeTooltip() {
      if (this._tooltipMgr) {
        this._tooltipMgr.close();
      }
      return this
    }

    /**
     * 获取绑定的右键菜单数组
     *
     * @return {Object[]} 右键菜单数组
     */
    getContextMenu() {
      return this._contextmenuConfig?.content
    }

    /**
     * 绑定地图的默认右键菜单
     *
     * @param {Object[]} content 右键菜单配置数组，数组中每一项包括：
     * @param {String} [content.text] 菜单文字
     * @param {String} [content.icon] 图标,可以是：图片url路径、base64字符串、svg字符串、字体图标class名
     * @param {Function|Boolean} [content.show] 菜单项是否显示的回调方法
     * @param {Function} [content.callback] 菜单项单击后的回调方法
     * @param {Object[]} [content.children] 当有二级子菜单时，配置数组。
     *
     * @param {Object} [options={}] 控制参数
     * @param {Number} [options.offsetX] 用于非规则对象时，横向偏移的px像素值
     * @param {Number} [options.offsetY] 用于非规则对象时，垂直方向偏移的px像素值
     * @return {Map} 当前对象本身，可以链式调用
     *
     * @example
     *
      //内置的默认右键菜单获取方法
      var defaultContextmenuItems =map.getDefaultContextMenu()
      map.bindContextMenu(defaultContextmenuItems)
     */
    bindContextMenu(content, options) {
      this._contextmenuConfig = {
        content: content,
        options: options
      };
      return this
    }

    /**
     * 解除绑定的右键菜单
     * @return {Map} 当前对象本身，可以链式调用
     */
    unbindContextMenu() {
      this._contextmenuConfig = null;
      return this
    }

    /**
     * 打开右键菜单
     *
     * @param {Cesium.Cartesian3} [position]  显示的位置
     * @return {Map} 当前对象本身，可以链式调用
     *
     */
    openContextMenu(position) {
      this._contextmenuMgr.open(position, this._contextmenuConfig);
      return this
    }

    /**
     *  关闭右键菜单
     *
     * @return {Map} 当前对象本身，可以链式调用
     */
    closeContextMenu() {
      if (this._contextmenuMgr) {
        this._contextmenuMgr.close();
      }
      return this
    }

    /**
     * 显示小提示窗，一般用于鼠标操作的提示。
     *
     * @param {Cesium.Cartesian2|Cesium.Cartesian3} position 显示的屏幕坐标位置 或 笛卡尔坐标位置
     * @param {*} message 显示的内容
     * @return {Map} 当前对象本身，可以链式调用
     *
     */
    openSmallTooltip(position, message) {
      this._smallTooltip.open(position, message);
      return this
    }

    /**
     * 关闭小提示窗
     *
     * @return {Map} 当前对象本身，可以链式调用
     */
    closeSmallTooltip() {
      if (!this._smallTooltip) {
        return
      }
      this._smallTooltip.close();
      return this
    }

    //= ============= destroy ======================
    /**
     * 销毁地图
     * @return {void}  无
     */
    destroy() {
      if (!this._viewer) {
        return
      }

      const fullscreenButton = this._viewer.fullscreenButton?._container;
      if (Cesium__namespace.defined(fullscreenButton)) {
        fullscreenButton.parentNode.removeChild(fullscreenButton);
        this._viewer._fullscreenButton.destroy();
        delete this._viewer._fullscreenButton;
      }

      this._controlList.destroy();
      this._thingList.destroy();
      this._layerList.destroy();
      this._mouseEvent.destroy();
      this._viewer.destroy();

      // 删除所有绑定的数据
      for (const i in this) {
        delete this[i];
      }
    }
  }

  /**
   * @typedef {Object} Map.sceneOptions
   * 场景参数
   *
   * @property {Object} [center] 默认相机视角
   * @property {Number} center.lng 经度值, 180 - 180
   * @property {Number} center.lat 纬度值, -90 - 90
   * @property {Number} center.alt 高度值
   * @property {Number} [center.heading] 方向角度值，绕垂直于地心的轴旋转角度, 0-360
   * @property {Number} [center.pitch] 俯仰角度值，绕纬度线旋转角度, 0-360
   * @property {Number} [center.roll] 翻滚角度值，绕经度线旋转角度, 0-360
   *
   * @property {Object} [extent] 矩形范围 相机视角,与center二选一
   * @property {Number} extent.xmin 最小经度值, -180 至 180
   * @property {Number} extent.xmax 最大经度值, -180 至 180
   * @property {Number} extent.ymin 最小纬度值, -90 至 90
   * @property {Number} extent.ymax 最大纬度值, -90 至 90
   *
   * @property { Boolean} [removeDblClick=false] 是否移除Cesium默认的双击事件
   * @property {String} [ionToken] Cesium Ion服务的 Token令牌
   * @property {Number} [resolutionScale=1.0] 获取或设置渲染分辨率的缩放比例。小于1.0的值可以改善性能不佳的设备上的性能，而值大于1.0则将以更高的速度呈现分辨率，然后缩小比例，从而提高视觉保真度。例如，如果窗口小部件的尺寸为640x480，则将此值设置为0.5将导致场景以320x240渲染，然后在设置时按比例放大设置为2.0将导致场景以1280x960渲染，然后按比例缩小。
   *
   * 以下是Cesium.Scene对象相关参数
   * @property {Boolean} [showSun] 是否显示太阳，如修改对象可以用 [map.scene.sun]{@link http://mars3d.cn/api/cesium/Sun.html}
   * @property {Boolean} [showMoon] 是否显示月亮，如修改对象可以用 [map.scene.moon]{@link http://mars3d.cn/api/cesium/Moon.html}
   * @property {Boolean} [showSkyBox] 是否显示天空盒，如修改对象可以用 [map.scene.skyBox]{@link http://mars3d.cn/api/cesium/SkyBox.html}
   * @property {Boolean} [showSkyAtmosphere] 是否显示地球大气层外光圈，如修改对象可以用 [map.scene.skyAtmosphere]{@link http://mars3d.cn/api/cesium/SkyAtmosphere.html}
   * @property {Boolean} [fog] 是否启用雾化效果，如修改对象可以用 [map.scene.fog]{@link http://mars3d.cn/api/cesium/fog.html}
   * @property {Boolean} [fxaa]  是否开启快速抗锯齿
   * @property {Boolean} [highDynamicRange] 是否关闭高动态范围渲染(不关闭时地图会变暗)
   * @property {String} [backgroundColor] 空间背景色 ，css颜色值
   *
   * 以下是Cesium.Viewer所支持的options【控件相关的写在另外的control属性中】
   * @property {Cesium.SceneMode} [sceneMode=Cesium.SceneMode.SCENE3D] 初始场景模式。可以设置进入场景后初始是2D、2.5D、3D 模式。
   * @property {Boolean} [scene3DOnly=false] 为 true 时，每个几何实例将仅以3D渲染以节省GPU内存。
   * @property {Cesium.MapProjection} [mapProjection=new Cesium.GeographicProjection()] 在二维模式下时，地图的呈现坐标系，默认为EPSG4326坐标系，如果需要EPSG3857墨卡托坐标系展示，传 new Cesium.WebMercatorProjection() 即可
   * @property {Cesium.MapMode2D} [mapMode2D=Cesium.MapMode2D.INFINITE_SCROLL] 在二维模式下时，地图是可旋转的还是可以在水平方向无限滚动。
   * @property {Boolean} [shouldAnimate=true] 是否开启时钟动画
   * @property {Boolean} [shadows=false] 是否启用日照阴影
   * @property {Boolean} [useDefaultRenderLoop=true] 如果此小部件应控制渲染循环，则为true，否则为false。
   * @property {Number} [targetFrameRate]  使用默认渲染循环时的目标帧速率。
   * @property {Boolean} [useBrowserRecommendedResolution=true] 如果为true，则以浏览器建议的分辨率渲染，并忽略 window.devicePixelRatio 。
   * @property {Boolean} [automaticallyTrackDataSourceClocks=true] 如果为true，则此小部件将自动跟踪新添加的数据源的时钟设置，并在数据源的时钟发生更改时进行更新。如果要独立配置时钟，请将其设置为false。
   * @property {Object} [contextOptions={}] WebGL创建属性 传递给 Cesium.Scene 的 options 。{@link Cesium.Scene}
   * @property {Boolean} [contextOptions.allowTextureFilterAnisotropic =true] 允许纹理过滤各向异性
   * @property {Boolean} [contextOptions.requestWebgl2 =false] 是否启用webgl2
   * @property {Object} [contextOptions.webgl] WebGL画布,用于 canvas.getContext("webgl", webglOptions)
   * @property {Boolean} [contextOptions.webgl.alpha=false] 是否包含alpha缓冲区，如果需要DIV透明时，需要改为true
   * @property {Boolean} [contextOptions.webgl.antialias] 是否执行抗锯齿
   * @property {Boolean} [contextOptions.webgl.failIfMajorPerformanceCaveat] 如果系统性能较低，是否创建上下文
   * @property {Boolean} [contextOptions.webgl.depth] 绘图缓冲区的深度缓冲区至少为16位
   * @property {Boolean} [contextOptions.webgl.stencil=true] 绘图缓冲区具有至少8位的模板缓冲区
   * @property {String} [contextOptions.webgl.powerPreference="high-performance"] 对用户代理的提示，指示GPU的哪种配置适合WebGL上下文
   * @property {Boolean} [orderIndependentTranslucency=true] 如果为true，并且配置支持它，则使用顺序无关的半透明性。
   * @property {Cesium.ShadowMode} [terrainShadows=Cesium.ShadowMode.RECEIVE_ONLY] 确定地形是否投射或接收来自光源的阴影。
   * @property {Boolean} [requestRenderMode=false] 是否显式渲染，如果为真，渲染帧只会在需要时发生，这是由场景中的变化决定的。启用可以减少你的应用程序的CPU/GPU使用量，并且在移动设备上使用更少的电池，但是需要使用 {@link Scene#requestRender} 在这种模式下显式地渲染一个新帧。在许多情况下，在API的其他部分更改场景后，这是必要的。参见 {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.
   * @property {Number} [maximumRenderTimeChange=0.0] 如果requestRenderMode为true，这个值定义了在请求渲染之前允许的模拟时间的最大变化。参见 {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.
   *
   * 以下是Cesium.Globe对象相关参数
   * @property {Object} [globe] globe地球相关参数
   * @property {Boolean} [globe.show=true] 是否显示地球
   * @property {String} [globe.baseColor='#546a53'] 地球背景色 ，css颜色值
   * @property {Boolean} [globe.depthTestAgainstTerrain=false] 是否启用深度监测,可以开启来测试矢量对象是否在地形下面或被遮挡。
   * @property {Boolean} [globe.showGroundAtmosphere=true] 是否在地球上绘制的地面大气
   * @property {Boolean} [globe.enableLighting=false] 是否显示晨昏线，可以看到地球的昼夜区域
   * @property {Number} [globe.tileCacheSize=100] 地形图块缓存的大小，表示为图块数。任何其他只要不需要渲染，就会释放超出此数目的图块这个框架。较大的数字将消耗更多的内存，但显示细节更快例如，当缩小然后再放大时。
   * @property {Number} [globe.terrainExaggeration=1.0]  地形夸张倍率，用于放大地形的标量。请注意，地形夸张不会修改其他相对于椭球的图元。
   * @property {Number} [globe.realAlt=false]  地形夸张倍率，在测量高度和下侧提示的高度信息中是否转换为实际真实高度值。
   * @property {Number} [globe.terrainExaggerationRelativeHeight = 0.0]  地形被夸大的高度。默认为0.0（相对于椭球表面缩放）。高于此高度的地形将向上缩放，低于此高度的地形将向下缩放。请注意，地形夸大不会修改任何其他图元，因为它们是相对于椭球体定位的。
   *
   * 以下是Cesium.ScreenSpaceCameraController对象相关参数
   * @property {Object} [cameraController] 相机操作相关参数
   * @property {Number} [cameraController.minimumZoomDistance=1.0] 相机最近视距，变焦时相机位置的最小量级（以米为单位），默认为1。该值是相机与地表(含地形)的相对距离。
   * @property {Number} [cameraController.maximumZoomDistance=50000000.0] 相机最远视距，变焦时相机位置的最大值（以米为单位）。该值是相机与地表(含地形)的相对距离。
   * @property {Number} [cameraController.zoomFactor=3.0] 滚轮放大倍数，控制鼠标滚轮操作的步长
   * @property {Number} [cameraController.minimumCollisionTerrainHeight=80000] 最小碰撞高度，低于此高度时绕鼠标键绕圈，大于时绕视图中心点绕圈。
   * @property {Boolean} [cameraController.constrainedAxis=true] 南北极绕轴心旋转，为false时 解除在南北极区域鼠标操作限制
   * @property {Boolean} [cameraController.enableRotate=true] 2D和3D视图下，是否允许用户旋转相机
   * @property {Boolean} [cameraController.enableTranslate=true] 2D和哥伦布视图下，是否允许用户平移地图
   * @property {Boolean} [cameraController.enableTilt=true] 3D和哥伦布视图下，是否允许用户倾斜相机
   * @property {Boolean} [cameraController.enableZoom=true] 是否允许 用户放大和缩小视图
   * @property {Boolean} [cameraController.enableCollisionDetection=true] 是否允许 地形相机的碰撞检测
   *
   * 以下是Cesium.Clock时钟相关参数
   * @property {Object} [clock] 时钟相关参数
   * @property {String|Cesium.JulianDate} [clock.currentTime] 当前的时间
   * @property {Number} [clock.multiplier=1.0] 当前的速度
   *
   * @see [Cesium.Scene]{@link http://mars3d.cn/api/cesium/Scene.html}
   */

  /**
   * @typedef {Object} Map.controlOptions
   * 添加到地图的控件 参数
   *
   * @property {Boolean} [homeButton=false] 视角复位按钮，是否显示
   * @property {Object} [zoom] 放大缩小按钮 , 对应 {@link Zoom}构造参数
   * @property {Boolean} [sceneModePicker=false] 二三维切换按钮，是否显示二维、三维、2.5D视图切换按钮
   * @property {Boolean} [projectionPicker=false] 投影切换按钮, 是否显示用于在透视和正投影之间进行切换按钮
   * @property {Boolean} [fullscreenButton=false] 全屏按钮，是否显示
   * @property {Element | String} [fullscreenElement=document.body] 当按下全屏按钮时，要置于全屏模式的元素或id
   * @property {Boolean} [vrButton=false] VR效果按钮，是否显示
   * @property {Boolean|Cesium.GeocoderService[]} [geocoder=false] 是否显示 地名查找控件按钮，是Cesium原生控件
   * @property {Boolean} [navigationHelpButton=false] 帮助按钮，是否显示
   * @property {Boolean} [navigationInstructionsInitiallyVisible=true] 帮助按钮 在用户明确单击按钮之前是否自动显示
   * @property {Boolean} [baseLayerPicker=false] 是否显示 底图切换 按钮，是Cesium原生控件
   * @property {Cesium.ProviderViewModel[]} [imageryProviderViewModels=[]] baseLayerPicker底图切换面板中，用于图像的ProviderViewModel实例数组，默认自动根据basemaps数组生成。
   * @property {Cesium.ProviderViewModel} [selectedImageryProviderViewModel] baseLayerPicker底图切换面板中，如果没有提供当前基本图像层的视图模型，则使用第一个可用的图像层。默认为show:true的basemaps图层
   * @property {Cesium.ProviderViewModel[]} [terrainProviderViewModels=[]] baseLayerPicker底图切换面板中，用于地形的ProviderViewModel实例数组。默认自动使用terrain配置+无地形。
   * @property {Cesium.ProviderViewModel} [selectedTerrainProviderViewModel] baseLayerPicker底图切换面板中，如果没有提供当前基础地形层的视图模型，则使用第一个可用的地形层。
   *
   * @property {Object} [compass] 导航球, 对应 {@link Compass}构造参数
   * @property {Object} [locationBar] 状态栏, 对应 {@link LocationBar}构造参数
   * @property {Boolean} [locationBar.fps] 是否显示实时FPS帧率
   * @property {String|Function} [locationBar.format] 显示内容的格式化html展示的内容格式化字符串。  支持以下模版配置：【鼠标所在位置】 经度:{lng}， 纬度:{lat}， 海拔：{alt}米， 【相机的】 方向角度：{heading}， 俯仰角度：{pitch}， 视高：{cameraHeight}米， 【地图的】 层级：{level}，
   * @property {Object} [distanceLegend] 比例尺, 对应 {@link DistanceLegend}构造参数
   * @property {Object} [clockAnimate] 时钟控制, 对应{@link ClockAnimate}构造参数
   * @property {Boolean} [animation=true] 时钟仪表控制(Cesium原生)
   * @property {Number[]} [animationTicks]  时钟仪表控制(Cesium原生)的可选步长
   * @property {Boolean} [timeline=true] 时间线, 是否创建下侧时间线控件面板
   * @property {Object} [overviewMap] 鹰眼地图, 对应{@link OverviewMap }构造参数
   * @property {Object} [mapSplit] 卷帘对比, 对应{@link MapSplit }构造参数
   * @property {Object} [keyboardRoam] 键盘漫游, 对应{@link KeyboardRoam }构造参数
   *
   * @property {Boolean} [mouseDownView] 鼠标滚轮缩放美化样式(指示图标), 对应 {@link MouseDownView}构造参数
   * @property {Boolean} [infoBox=true]  信息面板，是否显示点击要素之后显示的信息，是Cesium原生控件
   * @property {Boolean} [selectionIndicator=true] 选中框，是否显示选择模型时的绿色框，是Cesium原生控件
   * @property {Boolean} [showRenderLoopErrors=true] 如果为true，则在发生渲染循环错误时，此小部件将自动向包含错误的用户显示HTML面板，是Cesium原生控件
   *
   * @property {Object} [contextmenu] 内置 右键菜单 控制参数, 对应{@link ContextMenu }构造参数
   * @property {Boolean} [contextmenu.preventDefault=true] 是否取消右键菜单
   * @property {Boolean} [contextmenu.hasDefault=true] 是否绑定默认的地图右键菜单
   * @property {Object} [popup] 内置 Popup 控制参数
   * @property {Boolean} [popup.depthTest=true] 是否打开深度判断（true时判断是否在球背面）
   * @property {Object} [tooltip] 内置 Tooltip 控制参数
   * @property {Number} [tooltip.cacheTime=20] 延迟缓存的时间，单位：毫秒
   *
   * @see ControlType
   */

  /**
   * @typedef {Object} Map.mouseOptions
   * 鼠标操作相关配置 参数
   *
   * @property {Boolean} [enabledMoveTarget=true]  是否开启鼠标移动事件的拾取矢量数据
   * @property {Number} [moveDelay=30] 鼠标移动事件的延迟毫秒数
   * @property {Number} [pickWidth=4] 拾取时所选矩形的宽度，单位：像素
   * @property {Number} [pickHeight=4] 拾取时所选矩形的高度，单位：像素
   * @property {Number} [pickLimit=9] 在允许allowDrillPick穿透拾取时，限制拾取的对象个数。
   *
   * @see MouseEvent
   */

  /**
   * @typedef {Object} Map.effectOptions
   * 添加到地图的特效 参数
   *
   * @property {Object} [bloom] 泛光,对应{@link BloomEffect }构造参数
   * @property {Object} [brightness]  亮度,对应{@link BrightnessEffect }构造参数
   * @property {Object} [rain] 雨天气,对应{@link RainEffect }构造参数
   * @property {Object} [snow] 雪天气 ,对应{@link SnowEffect }构造参数
   * @property {Object} [snowCover] 地面积雪,对应{@link SnowCoverEffect }构造参数
   * @property {Object} [fog] 雾天气,对应{@link FogEffect }构造参数
   * @property {Object} [depthOfField] 景深,对应{@link DepthOfFieldEffect }构造参数
   * @property {Object} [mosaic] 马赛克,对应{@link MosaicEffect }构造参数
   * @property {Object} [nightVision] 夜视,对应{@link NightVisionEffect }构造参数
   * @property {Object} [blackAndWhite] 黑白,对应{@link BlackAndWhiteEffect }构造参数
   * @property {Object} [outline] 对象轮廓描边,对应{@link OutlineEffect }构造参数
   * @property {Object} [bloomTarget] 对象泛光,对应{@link BloomTargetEffect }构造参数
   *
   * @see EffectType
   */

  /**
   * @typedef {Object} Map.terrainOptions
   *
   * 地形服务配置
   *
   * @property {TerrainType} [type="xyz"] 地形类型
   * @property {String|Cesium.Resource} url 地形服务地址
   * @property {Boolean} [show=false] 是否启用显示地形
   * @property {Boolean} [requestVertexNormals=false] 是否应该从服务器请求额外的光照信息，如果可用，以每个顶点法线的形式。
   * @property {Boolean} [requestWaterMask=false] 是否应该向服务器请求每个瓦的水掩膜(如果有的话)。
   * @property {Boolean} [requestMetadata=true] 是否应该从服务器请求每个块元数据(如果可用)。
   *
   * @see TerrainType
   */

  /**
   * @typedef {Object} Map.basemapOptions
   * 底图图层配置
   *
   * @property {String} type 图层类型
   * @property {*} [多个参数]  每种不同type都有自己的不同属性，具体参考{@link LayerType}找到type对应的BaseTileLayer子类图层类,查看其构造参数
   *
   * @see LayerType
   */

  /**
   * @typedef {Object} Map.layerOptions
   * 可以叠加显示的图层配置，
   *
   * @property {String} type 图层类型
   * @property {String|Number} [id ] 图层id标识
   * @property {String|Number} [pid = -1] 图层父级的id，一般图层管理中使用
   * @property {String} [name = ''] 图层名称
   * @property {Boolean} [show = true] 图层是否显示
   * @property {Object} [center] 图层自定义定位视角，默认根据数据情况自动定位。
   * @property {Object} [popup] 当图层支持popup弹窗时，绑定的值
   * @property {Popup.StyleOptions} [popupOptions] popup弹窗时的配置参数
   * @property {Object} [tooltip]  当图层支持tooltip弹窗时，绑定的值
   * @property {Tooltip.StyleOptions} [tooltipOptions] tooltip弹窗时的配置参数
   *
   * @property {*} [多个参数]  每种type都有自己的不同属性，具体参考{@link LayerType}找到type对应的图层类,查看其构造参数
   *
   * @see LayerType
   */

  /**
   * @typedef {Object} Map.tokenOptions 覆盖SDK内的{@link Token}所有第3方Token默认值
   *
   * @property {String|String[]} [tianditu] 天地图
   * @property {String|String[]} [gaode] 高德
   * @property {String|String[]} [baidu] 百度
   * @property {String} [ion] Ion服务
   * @property {String} [mapbox] mapbox地图
   * @property {String} [bing] 微软Bing地图
   */

  /**
   * @typedef {Object} Map.EventType
   * Map支持的{@link EventType}事件类型
   *
   * @property {String} addLayer 添加图层
   * @property {String} removeLayer 移除图层
   * @property {String} terrainChange 地形变化
   * @property {String} tileLoadProgress 地图中瓦片加载进度变化
   *
   * @property {String} cameraMoveStart 相机开启移动前 场景事件
   * @property {String} cameraMoveEnd 相机移动完成后 场景事件
   * @property {String} cameraChanged 相机位置完成 场景事件
   * @property {String} preUpdate 场景更新前 场景事件
   * @property {String} postUpdate 场景更新后 场景事件
   * @property {String} preRender 场景渲染前 场景事件
   * @property {String} postRender 场景渲染后 场景事件
   * @property {String} morphStart 场景模式(2D/3D/哥伦布)变换前 场景事件
   * @property {String} morphComplete 完成场景模式(2D/3D/哥伦布)变换 场景事件
   * @property {String} clockTick 时钟跳动 场景事件
   * @property {String} renderError 场景渲染失败（需要刷新页面）
   *
   * @property {String} click 左键单击 鼠标事件
   * @property {String} clickGraphic 左键单击到矢量或模型数据时 鼠标事件
   * @property {String} clickTileGraphic 左键单击到wms或arcgis瓦片服务的对应矢量数据时
   * @property {String} clickMap 左键单击地图空白（未单击到矢量或模型数据）时 鼠标事件
   * @property {String} dblClick 左键双击 鼠标事件
   * @property {String} leftDown 左键鼠标按下 鼠标事件
   * @property {String} leftUp 左键鼠标按下后释放 鼠标事件
   * @property {String} mouseMove 鼠标移动 鼠标事件
   * @property {String} mouseMoveTarget 鼠标移动（拾取目标，并延迟处理） 鼠标事件
   * @property {String} wheel 鼠标滚轮滚动 鼠标事件
   * @property {String} rightClick 右键单击 鼠标事件
   * @property {String} rightDown 右键鼠标按下 鼠标事件
   * @property {String} rightUp 右键鼠标按下后释放 鼠标事件
   * @property {String} middleClick 中键单击 鼠标事件
   * @property {String} middleDown 中键鼠标按下 鼠标事件
   * @property {String} middleUp 中键鼠标按下后释放 鼠标事件
   * @property {String} pinchStart 在触摸屏上两指缩放开始 鼠标事件
   * @property {String} pinchEnd 在触摸屏上两指缩放结束 鼠标事件
   * @property {String} pinchMove 在触摸屏上两指移动 鼠标事件
   * @property {String} mouseDown 鼠标按下 [左中右3键都触发] 鼠标事件
   * @property {String} mouseUp 鼠标按下后释放 [左中右3键都触发] 鼠标事件
   * @property {String} mouseOver 鼠标移入 鼠标事件
   * @property {String} mouseOut 鼠标移出 鼠标事件
   * @property {String} keydown 按键按下 键盘事件
   * @property {String} keyup 按键按下后释放 键盘事件
   *
   * @property {String} popupOpen popup弹窗打开后
   * @property {String} popupClose popup弹窗关闭
   * @property {String} tooltipOpen tooltip弹窗打开后
   * @property {String} tooltipClose tooltip弹窗关闭
   * @property {String} contextMenuOpen 右键菜单 打开后
   * @property {String} contextMenuClose 右键菜单 关闭
   * @property {String} contextMenuClick 右键菜单 单击某一项后
   *
   * @example
   * //绑定监听事件
   * map.on(mars3d.EventType.click, function (event) {
   *   console.log('单击了地图对象', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * 地图分屏对比 控件，
   * 默认自动读取当前Map配置，也会合并传入的scene、control等参数值
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Map.basemapOptions[]} [options.basemaps] 底图图层配置
   * @param {Map.layerOptions[]} [options.layers] 可以叠加显示的图层配置
   * @param {Map.sceneOptions} [options.scene] 场景参数
   * @param {Map.controlOptions} [options.control] 添加的控件
   * @param {Map.effectOptions} [options.effect] 添加的特效
   * @param {Map.mouseOptions} [options.mouse] 鼠标操作相关配置参数
   * @param {Map.terrainOptions} [options.terrain] 地形服务配置
   * @param {String} [options.className="mars3d-container  mars3d-mapCompare"]  对比地图DIV的样式名称
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @export
   * @class MapCompare
   * @extends {BaseControl}
   */
  class MapCompare extends BaseControl {
    /**
     * 对比的地图对象
     * @type {Map}
     */
    get mapEx() {
      return this._mapEx
    }

    _mountedHook() {
      this._container = create$3("div", this.options.className || "mars3d-container  mars3d-mapCompare");
    }

    _addedHook() {
      if (!this.options.parentContainer) {
        this._map.container.firstChild.style.width = "50%";
      }

      let mapOptions = { ...this.options };
      if (!mapOptions.basemaps && !mapOptions.layers) {
        mapOptions = merge(mapOptions, this._map.getCurrentOptions());
        mapOptions.control = mapOptions.control || {};
        mapOptions.control.baseLayerPicker = true; // basemaps底图切换按钮
        mapOptions.control.sceneModePicker = false;
      }

      // 创建对比的三维地球场景
      this._mapEx = new Map(this._container, mapOptions);

      // 场景模式(2D/3D/哥伦布)变换完成
      this._map.on(EventType.morphComplete, this._morphCompleteHandler, this);

      this._map.on(EventType.cameraChanged, this._map_extentChangeHandler, this);
      this._map.camera.percentageChanged = 0.01;

      this._mapEx.on(EventType.cameraChanged, this._mapEx_extentChangeHandler, this);
      this._mapEx.camera.percentageChanged = 0.01;

      this._map_extentChangeHandler();
    }

    _removedHook() {
      this._map.off(EventType.morphComplete, this._morphCompleteHandler, this);
      this._map.off(EventType.cameraChanged, this._map_extentChangeHandler, this);
      this._mapEx.off(EventType.cameraChanged, this._mapEx_extentChangeHandler, this);

      this._mapEx.destroy();
      delete this._mapEx;
    }

    _morphCompleteHandler(event) {
      if (this._map.scene.mode === Cesium__namespace.SceneMode.SCENE2D) {
        this._mapEx.scene.screenSpaceCameraController.enableTilt = false;
      } else {
        this._mapEx.scene.screenSpaceCameraController.enableTilt = true;
      }
    }

    _map_extentChangeHandler(e) {
      this._mapEx.off(EventType.cameraChanged, this._mapEx_extentChangeHandler, this);

      this._updateView(this._map, this._mapEx);
      this._mapEx.on(EventType.cameraChanged, this._mapEx_extentChangeHandler, this);
    }

    _mapEx_extentChangeHandler(e) {
      this._map.off(EventType.cameraChanged, this._map_extentChangeHandler, this);

      this._updateView(this._mapEx, this._map);
      this._map.on(EventType.cameraChanged, this._map_extentChangeHandler, this);
    }

    // “变化屏”mapChange变化，将“被更新屏”mapUpdate同步更新
    _updateView(mapChange, mapUpdate) {
      const view = mapChange.getCameraView();
      mapUpdate.setCameraView(view, { duration: 0 });
    }
  }

  // 注册下
  register$1("mapCompare", MapCompare);

  /**
   * 鹰眼地图 控件
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Map.basemapOptions} options.basemap 瓦片底图图层配置
   * @param {Map.layerOptions[]} [options.layers] 可以叠加显示的图层配置
   * @param {Map.sceneOptions} [options.scene] 鹰眼地图场景参数
   * @param {RectangleEntity.StyleOptions} [options.rectangle] 矩形区域样式信息，不配置时不显示矩形。
   * @param {Object} [options.style] 可以CSS样式，如:
   * @param {String} [options.style.top]   css定位top位置, 如 top: '10px'
   * @param {String} [options.style.bottom]   css定位bottom位置
   * @param {String} [options.style.left]   css定位left位置
   * @param {String} [options.style.right]   css定位right位置
   * @param {Object} [options.flyToOptions]   小地图的定位参数
   * @param {Number} [options.flyToOptions.scale=2] 缩放比例，可以控制视角比矩形略大一些，这样效果更友好。
   * @param {Number} [options.flyToOptions.duration=0] 飞行时间（单位：秒）。如果省略，SDK内部会根据飞行距离计算出理想的飞行时间。
   * @param {Cesium.Camera.FlightCompleteCallback} [options.flyToOptions.complete] 飞行完成后要执行的函数。
   * @param {Cesium.Camera.FlightCancelledCallback} [options.flyToOptions.cancel] 飞行取消时要执行的函数。
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @export
   * @class OverviewMap
   * @extends {BaseControl}
   */
  class OverviewMap extends BaseControl {
    /**
     * 鹰眼小地图对象
     * @type {Map}
     */
    get smallMap() {
      return this._smallMap
    }

    _mountedHook() {
      this.options.flyToOptions = this.options.flyToOptions || {};
      this._container = create$3("div", "mars3d-overviewMap");

      this.setStyle(this.options.style || { right: "10px", top: "10px" });
    }

    _addedHook() {
      // 构造鹰眼地图
      this.initMinMap();

      // 监听视角变化
      this._map.camera.percentageChanged = 0.01;
      this._map.on(EventType.cameraChanged, this._map_cameraChanged, this);

      this._map_cameraChanged();
    }

    _removedHook() {
      this._map.off(EventType.cameraChanged, this._map_cameraChanged, this);

      this._smallMap.destroy();
      delete this._smallMap;
    }

    _map_cameraChanged() {
      const extent = this._map.getExtent();
      this._rectangle = Cesium__namespace.Rectangle.fromDegrees(extent.xmin, extent.ymin, extent.xmax, extent.ymax);

      // let center = this._map.getCenter();
      // if (!center) {
      //   let worldPosition = center.toCartesian();
      //   let distance = Cesium.Cartesian3.distance(worldPosition, this._map.camera.positionWC);
      //   this._smallMap.camera.lookAt(worldPosition, new Cesium.Cartesian3(0.0, 0.0, distance * 1.5));
      // }

      this._smallMap.flyToExtent(extent, { duration: 0, scale: 2, ...this.options.flyToOptions });
    }

    initMinMap() {
      const extent = this._map.getExtent();

      // 创建三维地球场景
      this._smallMap = new Map(this._container, {
        scene: {
          ...this.options.scene,
          extent: extent,
          sceneMode: Cesium__namespace.SceneMode.SCENE2D,
          cameraController: {
            enableRotate: false,
            enableTranslate: false,
            enableTilt: false,
            enableZoom: false
          }
        },
        basemaps: [
          {
            ...this.options.basemap,
            show: true
          }
        ],
        layers: this.options.layers
      });

      if (this.options.rectangle) {
        this._rectangle = Cesium__namespace.Rectangle.fromDegrees(extent.xmin, extent.ymin, extent.xmax, extent.ymax);

        this._extentGraphic = new RectangleEntity({
          rectangle: new Cesium__namespace.CallbackProperty((time) => {
            return this._rectangle
          }, false),
          style: {
            color: "rgba(0,0,255,0.2)",
            outline: true,
            outlineWidth: 1,
            outlineColor: "#ff7800",
            ...this.options.rectangle
          }
        });
        this._smallMap.graphicLayer.addGraphic(this._extentGraphic);
      }
    }
  }

  // 注册下
  register$1("overviewMap", OverviewMap);

  const icon$1 = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="20" height="20" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="48" height="48" fill="white" fill-opacity="0.01"/>
  <path d="M16 12V36" stroke="#ffffff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M32 12V36" stroke="#ffffff" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;

  const icon = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="20" height="20" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="48" height="48" fill="white" fill-opacity="0.01"/>
  <path d="M15 24V11.8756L25.5 17.9378L36 24L25.5 30.0622L15 36.1244V24Z" fill="none" stroke="#ffffff" stroke-width="5" stroke-linejoin="round"/>
</svg>`;

  /**
   * 时钟及其动画的管理控制
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {string} [options.format = "yyyy-MM-dd HH:mm:ss"] 当前时间格式化字符串
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @export
   * @class ClockAnimate
   * @extends {BaseControl}
   *
   * @see [支持的事件类型]{@link ClockAnimate.EventType}
   */
  class ClockAnimate extends BaseControl {
    //= ========= 构造方法 ==========
    constructor(options = {}) {
      super(options);

      this.options.format = this.options.format || "yyyy-MM-dd HH:mm:ss";
    }

    //= ========= 方法 ==========

    /**
     * 创建_container控件容器对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._container = create$3("div", "mars3d-clockAnimate");
      this._container.innerHTML = `
      <button id="btn-clockAnimate-start" class="mars3d-clockAnimate-btn" title="暂停">
        ${icon$1}
      </button>
      <button id="btn-clockAnimate-now" class="mars3d-clockAnimate-btn" title="返回到当前时间" >
        <svg width="20" height="20" style="margin-top: 5px;" viewBox="0 0 48 58" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect width="48" height="48" fill="white" fill-opacity="0.01"/><rect width="48" height="58" fill="white" fill-opacity="0.01"/>
          <path d="M34.0234 6.68921C31.0764 4.97912 27.6525 4 24 4C12.9543 4 4 12.9543 4 24C4 35.0457 12.9543 44 24 44C35.0457 44 44 35.0457 44 24C44 20.3727 43.0344 16.9709 41.3461 14.0377" stroke="#ffffff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M31.9498 16.0502C31.9498 16.0502 28.5621 25.0947 27.0001 26.6568C25.438 28.2189 22.9053 28.2189 21.3432 26.6568C19.7811 25.0947 19.7811 22.562 21.3432 20.9999C22.9053 19.4378 31.9498 16.0502 31.9498 16.0502Z" fill="none" stroke="#ffffff" stroke-width="4" stroke-linejoin="round"/>
        </svg>
      </button>
      <span id="txt-clockAnimate-time" class="time" title="当前时间"> 2017-08-25 00:00:00 </span>
      <input id="txt-clockAnimate-speed" type="number" class="mars3d-clockAnimate-speed" value="1" title="速度（倍率）" />
    `;
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      // 回到当前时间
      const btnNow = this._container.querySelector("#btn-clockAnimate-now");
      btnNow.addEventListener("click", (e) => {
        this._map.clock.currentTime = Cesium__namespace.JulianDate.now();
        this.updateStatus();
        this.fire(EventType.click, { mouseEvent: e, targetType: "now", time: this._map.clock.currentTime });
      });

      // 暂停及继续
      const btnStart = this._container.querySelector("#btn-clockAnimate-start");
      btnStart.addEventListener("click", (e) => {
        this._map.clock.shouldAnimate = !this._map.clock.shouldAnimate;
        this.updateStatus();
        this.fire(EventType.click, { mouseEvent: e, targetType: "state", state: this._map.clock.shouldAnimate });
      });
      this._containerBtnStart = btnStart;

      // 当前时间文本
      this._containerTime = this._container.querySelector("#txt-clockAnimate-time");
      this._containerTime.addEventListener("click", (e) => {
        this.fire(EventType.click, { mouseEvent: e, targetType: "label" });
      });

      // 速度
      this._containerSpeed = this._container.querySelector("#txt-clockAnimate-speed");
      this._containerSpeed.setAttribute("value", this._map.clock.multiplier);
      this._containerSpeed.addEventListener("change", (e) => {
        const val = Number(this._containerSpeed.value || 1);
        if (!isNaN(val)) {
          this._map.clock.multiplier = val;
          this.fire(EventType.change, { mouseEvent: e, speed: val });
        }
      });

      // 修改其他控件样式
      setTimeout(() => {
        this._showHook(true);
      }, 1000);

      // 绑定监听事件
      // this._map.clock.onTick.addEventListener(this.clock_onTickHandler, this);
      this.timeTik = setInterval(() => {
        this.clock_onTickHandler();
      }, 500);

      this.clock_onTickHandler();
    }

    _showHook(show) {
      // 修改其他控件样式
      const timeline = this._getTimeline();
      const timelineContainer = timeline?.container;
      if (timelineContainer) {
        timelineContainer.style.left = show ? `${this._container.offsetWidth + 1}px` : "0";
      }

      if (this._map.controls?.distanceLegend) {
        const hasEx = show || (timelineContainer && timelineContainer.style.display !== "none");
        this._map.controls.distanceLegend.setStyle({
          bottom: hasEx ? "27px" : "2px"
        });
      }
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this.timeTik) {
        clearInterval(this.timeTik);
        this.timeTik = null;
      }
    }

    //= ========= 内部方法 ==========
    clock_onTickHandler() {
      this.updateStatus();

      const val = Number(this._containerSpeed.value);
      if (this._map.clock.multiplier !== val) {
        this._containerSpeed.setAttribute("value", this._map.clock.multiplier);
      }

      const date = Cesium__namespace.JulianDate.toDate(this._map.clock.currentTime);
      this._containerTime.innerHTML = formatDate(date, this.options.format);
    }

    updateStatus() {
      if (this.isAnimate === this._map.clock.shouldAnimate) {
        return
      }
      this.isAnimate = this._map.clock.shouldAnimate;

      if (this.isAnimate) {
        this._containerBtnStart.setAttribute("title", "暂停");
        this._containerBtnStart.innerHTML = icon$1;

        this._containerSpeed.style.display = "inline";
      } else {
        this._containerBtnStart.setAttribute("title", "继续");
        this._containerBtnStart.innerHTML = icon;

        this._containerSpeed.style.display = "none";
      }

      const timeline = this._getTimeline();
      const timelineContainer = timeline?.container;
      if (timelineContainer) {
        timelineContainer.style.left = `${this._container.offsetWidth + 1}px`;
      }
    }
  }

  // 注册下
  register$1("clockAnimate", ClockAnimate);

  /**
   * 时间线 控件
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {Object} [options.style] 可以CSS样式，如:
   * @param {String} [options.style.top]   css定位top位置, 如 top: '10px'
   * @param {String} [options.style.bottom=0]   css定位bottom位置
   * @param {String} [options.style.left=0]   css定位left位置
   * @param {String} [options.style.right=0]   css定位right位置
   *
   * @param {String|Number} [options.id = createGuid()] 对象的id标识
   * @param {Boolean} [options.enabled = true] 对象的启用状态
   * @param {HTMLElement} [options.parentContainer] 控件加入的父容器，默认为map所在的DOM map.container
   * @param {Number} [options.insertIndex] 可以自定义插入到父容器中的index顺序，默认是插入到最后面。
   * @param {HTMLElement} [options.insertBefore] 可以自定义插入到指定兄弟容器的前面，与insertIndex二选一。
   * @export
   * @class Timeline
   * @extends {BaseControl}
   */
  class Timeline extends BaseControl {
    get parentContainer() {
      return this._map?.container
    }

    //= ========= 方法 ==========

    /**
     * 创建_container控件容器对象的方法
     * 只会调用一次
     * @return {void}  无
     * @private
     */
    _mountedHook() {
      this._container = create$3("div", "cesium-viewer-timelineContainer");
      this._container.style.right = "0px";

      if (this.options.style) {
        this.setStyle(this.options.style);
      }
    }

    /**
     * 对象添加到地图上的创建钩子方法，
     * 每次add时都会调用
     * @return {void}  无
     * @private
     */
    _addedHook() {
      if (this._map.viewer?.timeline) {
        return
      }

      this._timeline = new Cesium__namespace.Timeline(this._container, this._map.clock);
      this._timeline.addEventListener("settime", this.onTimelineScrubfunction, false);
      this._timeline.zoomTo(this._map.clock.startTime, this._map.clock.stopTime);
    }

    /**
     * 对象从地图上移除的创建钩子方法，
     * 每次remove时都会调用
     * @return {void}  无
     * @private
     */
    _removedHook() {
      if (this._timeline) {
        this._timeline.removeEventListener("settime", this.onTimelineScrubfunction, false);
        this._timeline.destroy();
        delete this._timeline;
      }
    }

    onTimelineScrubfunction(e) {
      const clock = e.clock;
      clock.currentTime = e.timeJulian;
      clock.shouldAnimate = false;
    }

    /**
     * @param {Cesium.JulianDate} startTime 开始时间
     * @param {Cesium.JulianDate} stopTime 结束时间
     * @returns {void}
     */
    zoomTo(startTime, stopTime) {
      return this._timeline.zoomTo(startTime, stopTime)
    }
  }

  // 注册下
  register$1("timeline", Timeline);

  var index$1 = {
    __proto__: null,
    BaseControl: BaseControl,
    LocationBar: LocationBar,
    MouseDownView: MouseDownView,
    Zoom: Zoom,
    ToolButton: ToolButton,
    Compass: Compass,
    DistanceLegend: DistanceLegend,
    MapSplit: MapSplit,
    MapCompare: MapCompare,
    OverviewMap: OverviewMap,
    ClockAnimate: ClockAnimate,
    Timeline: Timeline
  };

  /**
   * 百度 POI查询 工具类 ，
   * 参考文档： {@link https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-placeapi}
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String[]} [options.key = mars3d.Token.baiduArr] 百度KEY,实际项目中请使用自己申请的百度KEY，因为我们的key不保证长期有效。
   * @param {String} [options.city = '全国' ] 限定查询的区域，支持城市及对应百度编码（Citycode）（指定的区域的返回结果加权，可能返回其他城市高权重结果。若要对返回结果区域严格限制，请使用city_limit参数）
   * @param {Object} [options.headers={}] 将被添加到HTTP请求头。
   * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
   * @export
   * @class BaiduPOI
   */
  class BaiduPOI {
    // 构造方法
    constructor(options = {}) {
      this._key_index = 0;
      this._keys = options.key || baiduArr;
      this._city = options.city || "全国"; // 默认全国,可改为具体城市
    }

    /**
     * 百度key数组，内部轮询使用
     * @type {String[]}
     */
    get keys() {
      return this._keys
    }

    set keys(val) {
      this._keys = val;
    }

    /**
     * 轮询取单个key进行使用
     * @type {String}
     * @readonly
     */
    get key() {
      const thisidx = this._key_index++ % this._keys.length;
      return this._keys[thisidx]
    }

    // 【内部】格式化返回的数据
    _formatPOIData(arr) {
      const arrNew = [];
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        let coor = [];
        if (item.location) {
          coor = gcj2wgs([item.location.lng, item.location.lat]);
        } // 坐标
        arrNew.push({
          id: item.uid,
          name: item.name, // 名称
          lng: coor[0],
          lat: coor[1],

          type: item.detail_info?.tag ?? item.tag, // 类别
          xzqh: item.province + item.city + item.district, // 行政区域
          address: item.address, // 地址
          tel: item.telephone || "",
          detailUrl: item.detail_info?.detail_url, // 详情url
          info: item,

          // 兼容老版本
          x: coor[0],
          y: coor[1],
          detail_info: item.detail_info
        });
      }
      return arrNew
    }

    _getKeywords(text) {
      if (isString(text)) {
        return text.replace(/ /gm, "$").replace(/,/gm, "$")
      } else if (Array.isArray(text)) {
        return text.join("$")
      }
      return text
    }

    /**
     * 根据经纬度坐标获取地址，逆地理编码
     *
     * @param {Object} queryOptions 查询参数
     * @param {LngLatPoint|Cesium.Cartesian3|String|Array|Object} [queryOptions.location = null] 经纬度坐标
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    getAddress(queryOptions) {
      if (this._getAddress_ing) {
        // 正在查询中，屏蔽下
        return Promise.resolve()
      }
      const filter = {
        ak: this.key, // 请求服务权限标识
        output: "json",
        language: "zh-CN",
        coordtype: "wgs84ll",
        ret_coordtype: "gcj02ll"
      };

      const point = LngLatPoint.parse(queryOptions.location);
      filter.location = point.lat + "," + point.lng; // 40.04785,116.3135

      // console.log(filter)
      this._getAddress_ing = true;
      return Cesium__namespace.Resource.fetchJsonp({
        url: "https://api.map.baidu.com/reverse_geocoding/v3/",
        ...this.options,
        queryParameters: filter
      })
        .then((data) => {
          this._getAddress_ing = false;
          if (data.status !== 0) {
            console.log("未查询到相关结果！");
            return
          }

          const info = data.result;
          const result = {
            address: info.formatted_address,
            city: info.cityCode, // info.addressComponent?.adcode,
            component: info.addressComponent
          };

          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          this._getAddress_ing = false;
          logError("BaiduPOI 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }

    /**
     * 搜索提示查询
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 输入建议关键字（支持拼音）
     * @param {LngLatPoint|Cesium.Cartesian3|String|Array|Object} [queryOptions.location] 传入location参数后，返回结果将以距离进行排序
     * @param {String} [queryOptions.city] 可以重新限定查询的区域，默认为类构造时传入的city
     * @param {Boolean} [queryOptions.citylimit = false] 取值为"true"，仅返回city中指定城市检索结果
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    autoTip(queryOptions) {
      const filter = {
        ak: this.key, // 请求服务权限标识
        output: "json",
        ret_coordtype: "gcj02ll"
      };

      if (Cesium__namespace.defined(this._city)) {
        filter.region = this._city;
        filter.city_limit = true;
      }
      if (Cesium__namespace.defined(queryOptions.city)) {
        filter.region = queryOptions.city;
        filter.city_limit = true;
      }
      if (Cesium__namespace.defined(queryOptions.citylimit)) {
        filter.city_limit = queryOptions.citylimit;
      }
      if (queryOptions.text) {
        filter.query = this._getKeywords(queryOptions.text);
      }
      if (queryOptions.location) {
        filter.coord_type = 1; // 标识是WGS84ll即GPS经纬度

        const point = LngLatPoint.parse(queryOptions.location);
        filter.location = point.lat + "," + point.lng; // 40.04785,116.3135
      }

      return Cesium__namespace.Resource.fetchJsonp({
        url: "https://api.map.baidu.com/place/v2/suggestion",
        ...this.options,
        queryParameters: filter
      })
        .then((data) => {
          if (data.status !== 0) {
            console.log("未查询到相关结果！");
            return
          }

          const arr = this._formatPOIData(data.result);
          const result = {
            allcount: data.total,
            count: arr.length,
            list: arr
          };
          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          logError("BaiduPOI 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }

    /**
     * 关键字搜索
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 检索关键字。支持多个关键字并集检索，不同关键字间以空格符号分隔，最多支持10个关键字检索。
     * @param {String} [queryOptions.types=''] 检索分类偏好，与text组合进行检索，多个分类以","分隔（POI分类），如果需要严格按分类检索，请通过text参数设置
     * @param {Object} [queryOptions.location = null] 圆形区域检索中心点，不支持多个点
     * @param {Number} queryOptions.location.lat 纬度
     * @param {Number} queryOptions.location.lng 经度
     * @param {Number} [queryOptions.radius] 圆形区域检索半径，单位为米。（增加区域内数据召回权重，如需严格限制召回数据在区域内，请搭配使用radiuslimit参数），当半径过大，超过中心点所在城市边界时，会变为城市范围检索，检索范围为中心点所在城市
     * @param {Boolean} [queryOptions.radiuslimit = false] 是否严格限定召回结果在设置检索半径范围内。true（是），false（否）。设置为true时会影响返回结果中total准确性及每页召回poi数量， 设置为false时可能会召回检索半径外的poi。
     * @param {String} [queryOptions.city = null] 可以重新限定查询的区域，默认为类构造时传入的city
     * @param {Boolean} [queryOptions.citylimit = false] 取值为"true"，仅返回city中指定城市检索结果
     *
     * @param {Number} [queryOptions.page=0] 分页页码，默认为0, 0代表第一页，1代表第二页，以此类推。常与 count 搭配使用，仅当返回结果为poi时可以翻页。
     * @param {Number} [queryOptions.count=20] 单次召回POI数量，最大返回20条。多关键字检索时，返回的记录数为关键字个数*count。多关键词检索时，单页返回总数=关键词数量*count
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    queryText(queryOptions) {
      const filter = {
        ak: this.key, // 请求服务权限标识
        output: "json",
        ret_coordtype: "gcj02ll",
        scope: 2, // 检索结果详细程度。取值为1 或空，则返回基本信息；取值为2，返回检索POI详细信息
        page_num: queryOptions.page || 0,
        page_size: queryOptions.count || 20,
        tag: queryOptions.types || ""
      };

      if (Cesium__namespace.defined(this._city)) {
        filter.region = this._city;
        filter.city_limit = true;
      }
      if (Cesium__namespace.defined(queryOptions.city)) {
        filter.region = queryOptions.city;
        filter.city_limit = true;
      }

      if (Cesium__namespace.defined(queryOptions.citylimit)) {
        filter.city_limit = queryOptions.citylimit;
      }
      if (queryOptions.text) {
        filter.query = this._getKeywords(queryOptions.text);
      }
      if (queryOptions.location) {
        filter.coord_type = 1; // 标识是WGS84ll即GPS经纬度
        const point = LngLatPoint.parse(queryOptions.location);
        filter.location = point.lat + "," + point.lng; // 40.04785,116.3135
      }
      if (Cesium__namespace.defined(queryOptions.radius)) {
        if (queryOptions.radius > 5000000) {
          delete filter.location;
        } else {
          filter.radius = queryOptions.radius;
        }
        if (Cesium__namespace.defined(queryOptions.radiuslimit)) {
          filter.radius_limit = queryOptions.radiuslimit;
        }
      }

      return Cesium__namespace.Resource.fetchJsonp({
        url: "https://api.map.baidu.com/place/v2/search",
        ...this.options,
        queryParameters: filter
      })
        .then((data) => {
          if (data.status !== 0) {
            const meg = "POI 请求失败(" + data.status + ")：" + data.message;
            if (queryOptions.error) {
              queryOptions.error(meg);
            }
            return
          }

          if (!data.results || data.result_type === "city_type" || data.results.length === 0) {
            if (queryOptions._sendCount) {
              const result = {
                allcount: 0,
                count: 0,
                list: []
              };
              if (queryOptions.success) {
                queryOptions.success(result);
              }
              return result
            } else {
              delete queryOptions.radius;
              delete queryOptions.location;

              queryOptions._sendCount = 1;
              return this.queryText(queryOptions)
            }
          }

          const arr = this._formatPOIData(data.results);
          const result = {
            allcount: data.total,
            count: arr.length,
            list: arr
          };
          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          logError("BaiduPOI 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }

    /**
     * 周边搜索(圆形搜索)
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 检索关键字。支持多个关键字并集检索，不同关键字间以空格符号分隔，最多支持10个关键字检索。
     * @param {String} [queryOptions.types=''] 检索分类偏好，与text组合进行检索，多个分类以","分隔（POI分类），如果需要严格按分类检索，请通过text参数设置
     * @param {LngLatPoint|Cesium.Cartesian3|String|Array|Object} [queryOptions.location] 圆形区域检索中心点，取值范围:0-50000。规则：大于50000按默认值，单位：米
     * @param {Number} [queryOptions.radius=3000] 圆形区域检索半径，单位为米。（增加区域内数据召回权重，如需严格限制召回数据在区域内，请搭配使用radiuslimit参数），当半径过大，超过中心点所在城市边界时，会变为城市范围检索，检索范围为中心点所在城市
     * @param {Boolean} [queryOptions.limit = false] 是否严格限定召回结果在设置检索半径范围内。true（是），false（否）。设置为true时会影响返回结果中total准确性及每页召回poi数量， 设置为false时可能会召回检索半径外的poi。
     *
     * @param {Number} [queryOptions.count=20] 单次召回POI数量，最大返回25条。多关键字检索时，返回的记录数为关键字个数*count。多关键词检索时，单页返回总数=关键词数量*count
     * @param {Number} [queryOptions.page=0] 分页页码，默认为0, 0代表第一页，1代表第二页，以此类推。常与 count 搭配使用，仅当返回结果为poi时可以翻页。
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    queryCircle(queryOptions) {
      const filter = {
        ak: this.key, // 请求服务权限标识
        output: "json",
        ret_coordtype: "gcj02ll",
        scope: 2, // 检索结果详细程度。取值为1 或空，则返回基本信息；取值为2，返回检索POI详细信息
        radius: queryOptions.radius || 3000,
        radius_limit: queryOptions.limit,
        page_num: queryOptions.page || 0,
        page_size: queryOptions.count || 20,
        tag: queryOptions.types || ""
      };

      // 坐标构造 location
      if (queryOptions.location) {
        filter.coord_type = 1; // 标识是WGS84ll即GPS经纬度
        const point = LngLatPoint.parse(queryOptions.location);
        filter.location = point.lat + "," + point.lng; // 40.04785,116.3135
      } else {
        logError("BaiduPOI: 请传入参location数");
      }

      // 关键字构造
      if (queryOptions.text) {
        filter.query = this._getKeywords(queryOptions.text);
      } else {
        // 无关键字时，指定类别
        filter.query = "行政地标";
      }

     return Cesium__namespace.Resource.fetchJsonp({
        url: "https://api.map.baidu.com/place/v2/search",
        ...this.options,
        queryParameters: filter
      })
        .then((data) => {
          if (data.status !== 0) {
            const meg = "POI 请求失败(" + data.status + ")：" + data.message;
            if (queryOptions.error) {
              queryOptions.error(meg);
            }
            return
          }

          if (!data.results || data.result_type === "city_type" || data.results.length === 0) {
            if (queryOptions.error) {
              queryOptions.error("未查询到相关结果！");
            }
            return
          }

          const arr = this._formatPOIData(data.results);
          let resArr;
          if (queryOptions.limit) {
            resArr = this._filterPOIData_circle(arr, queryOptions.location, filter.radius);
          } else {
            resArr = arr;
          }
          const result = {
            allcount: data.total,
            count: resArr.length,
            list: resArr
          };
          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          logError("BaiduPOI 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }

    // 圆形搜索筛选
    _filterPOIData_circle(arr, point, radius) {
      if (!arr || !point || !radius) {
        return arr
      }
      const center = point.toCartesian();

      const arrNew = [];
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const c3 = Cesium__namespace.Cartesian3.fromDegrees(item.x, item.y, point.alt);
        const distance = Cesium__namespace.Cartesian3.distance(c3, center);
        if (distance < radius) {
          // 表示在圆内
          arrNew.push(item);
        }
      }
      return arrNew
    }
  }

  /**
   * 高德 POI查询 工具类，
   * 参考文档：{@link https://lbs.amap.com/api/webservice/guide/api/search}
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String[]} [options.key = mars3d.Token.gaodeArr] 百度KEY,在实际项目中请使用自己申请的高德KEY，因为我们的key不保证长期有效。
   * @param {Object} [options.headers={}] 将被添加到HTTP请求头。
   * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
   * @export
   * @class GaodePOI
   */
  class GaodePOI {
    constructor(options = {}) {
      this._key_index = 0;
      this._keys = options.key || gaodeArr;
    }

    /**
     * 高德key数组，内部轮询使用
     * @type {String[]}
     */
    get keys() {
      return this._keys
    }

    set keys(val) {
      this._keys = val;
    }

    /**
     * 轮询取单个key进行使用
     * @type {String}
     * @readonly
     */
    get key() {
      const thisidx = this._key_index++ % this._keys.length;
      return this._keys[thisidx]
    }

    // 【内部】格式化返回的数据
    _formatPOIData(arr) {
      const arrNew = [];
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        let coor = [];
        if (item.location && item.location.length > 0) {
          coor = gcj2wgs(item.location.split(","));
        } // 坐标
        arrNew.push({
          id: item.id,
          name: item.name, // 名称
          lng: Number(coor[0]),
          lat: Number(coor[1]),
          type: item.type, // 类别
          xzqh: item.pname + item.cityname + item.adname, // 行政区域
          address: item.address, // 地址
          tel: item.tel || "",
          info: item,
          // detailUrl: "https://www.amap.com/detail/" + item.id, //详情url

          // 兼容老版本
          x: Number(coor[0]),
          y: Number(coor[1])
        });
      }
      return arrNew
    }

    _getKeywords(text) {
      if (isString(text)) {
        return text.replace(/ /gm, "|").replace(/,/gm, "|")
      } else if (Array.isArray(text)) {
        return text.join("|")
      }
      return text
    }

    /**
     * 根据经纬度坐标获取地址，逆地理编码
     *
     * @param {Object} queryOptions 查询参数
     * @param {LngLatPoint|Cesium.Cartesian3|String|Array|Object} [queryOptions.location] 经纬度坐标
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    getAddress(queryOptions) {
      if (this._getAddress_ing) {
        // 正在查询中，屏蔽下
        return Promise.resolve()
      }
      const filter = {
        key: this.key, // 请求服务权限标识
        output: "json"
      };

      queryOptions.location = LngLatPoint.parse(queryOptions.location);
      const cartg = wgs2gcj([queryOptions.location.lng, queryOptions.location.lat]);
      filter.location = cartg[0] + "," + cartg[1];

      // console.log(filter)
      this._getAddress_ing = true;
      return Cesium__namespace.Resource.fetchJsonp({
        url: "https://restapi.amap.com/v3/geocode/regeo",
        ...this.options,
        queryParameters: filter
      })
        .then((data) => {
          this._getAddress_ing = false;
          if (data.infocode !== "10000") {
            console.log("未查询到相关结果！");
            return
          }
          const info = data.regeocode;
          const result = {
            address: info.formatted_address,
            city: info.addressComponent?.adcode,
            component: info.addressComponent
          };

          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          this._getAddress_ing = false;
          logError("BaiduPOI 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }

    /**
     * 高德搜索提示
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 输入建议关键字（支持拼音）
     * @param {LngLatPoint|Cesium.Cartesian3|String|Array|Object} [queryOptions.location] 建议使用location参数，可在此location附近优先返回搜索关键词信息,在请求参数city不为空时生效
     * @param {String} [queryOptions.city] 可以重新限定查询的区域，默认为类构造时传入的city
     * @param {Boolean} [queryOptions.citylimit = false] 取值为"true"，仅返回city中指定城市检索结果
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    autoTip(queryOptions) {
      const filter = {
        key: this.key, // 请求服务权限标识
        output: "json"
      };
      if (Cesium__namespace.defined(queryOptions.city)) {
        filter.city = queryOptions.city;
        filter.citylimit = true;
      }
      if (Cesium__namespace.defined(queryOptions.citylimit)) {
        filter.citylimit = queryOptions.citylimit;
      }
      if (queryOptions.text) {
        filter.keywords = this._getKeywords(queryOptions.text);
      } else {
        // 无关键字时，指定类别(keywords和types两者至少必选其一)
        if (!filter.types) {
          filter.types = "120000|130000|190000";
        }
      }
      if (queryOptions.location) {
        queryOptions.location = LngLatPoint.parse(queryOptions.location);
        const cartg = wgs2gcj([queryOptions.location.lng, queryOptions.location.lat]);
        filter.location = cartg[0] + "," + cartg[1];
      }
      // console.log(filter)

      return fetchJson({
        url: "https://restapi.amap.com/v3/assistant/inputtips",
        queryParameters: filter,
        ...this.options
      })
        .then((data) => {
          if (!data.tips) {
            console.log("未查询到相关结果！");
            return
          }

          const arr = this._formatPOIData(data.tips);
          const result = {
            allcount: data.count,
            count: arr.length,
            list: arr
          };
          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          logError("GaodePOI 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }

    /**
     * 按限定区域搜索
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 检索关键字。支持多个关键字并集检索，不同关键字间以空格符号分隔，最多支持10个关键字检索。
     * @param {String} [queryOptions.types=''] 检索分类偏好，与text组合进行检索，多个分类以","分隔（POI分类），如果需要严格按分类检索，请通过text参数设置
     *
     * @param {BaseGraphic|*} [queryOptions.graphic] 限定的搜索区域
     * @param {Boolean} [queryOptions.limit = false] 取值为"true"，严格返回限定区域内检索结果
     *
     * @param {Number} [queryOptions.page=0] 分页页码，默认为0, 0代表第一页，1代表第二页，以此类推。常与 count 搭配使用，仅当返回结果为poi时可以翻页。
     * @param {Number} [queryOptions.count=20] 单次召回POI数量，默认为10条记录，最大返回20条。多关键字检索时，返回的记录数为关键字个数*count。多关键词检索时，单页返回总数=关键词数量*count
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    query(queryOptions) {
      const graphic = queryOptions.graphic;
      if (graphic) {
        if (graphic.type === "rectangle") {
          queryOptions.polygon = graphic.outlineCoordinates;
          return this.queryPolygon(queryOptions)
        } else if (graphic.type === "polygon") {
          queryOptions.polygon = graphic.coordinates;
          return this.queryPolygon(queryOptions)
        } else if (graphic.type === "circle") {
          queryOptions.location = graphic.point;
          queryOptions.radius = graphic.radius;
          return this.queryCircle(queryOptions)
        } else {
          return Promise.resolve()
        }
      } else if (queryOptions.polygon) {
        return this.queryPolygon(queryOptions)
      } else {
        return this.queryText(queryOptions)
      }
    }

    /**
     * 根据ID获取POI点详情
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.id AOI唯一标识， 最多可以传入1个id，传入目标区域的poiid即可
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    detail(queryOptions) {
      const filter = {
        key: this.key, // 请求服务权限标识
        id: queryOptions.id,
        output: "json"
      };

      return fetchJson({
        url: "https://restapi.amap.com/v3/place/detail",
        queryParameters: filter,
        ...this.options
      })
        .then((data) => {
          if (data.infocode !== "10000") {
            const meg = "POI 请求失败(" + data.infocode + ")：" + data.info;
            if (queryOptions.error) {
              queryOptions.error(meg);
            }
            return
          }

          if (!data.pois || data.pois.length === 0) {
            if (queryOptions.error) {
              queryOptions.error("未查询到相关结果！");
            }
            return
          }

          const result = data.pois[0];
          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          logError("GaodePOI 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }

    /**
     * 关键字搜索
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 检索关键字。支持多个关键字并集检索，不同关键字间以空格符号分隔，最多支持10个关键字检索。
     * @param {String} [queryOptions.types=''] 检索分类偏好，与text组合进行检索，多个分类以","分隔（POI分类），如果需要严格按分类检索，请通过text参数设置
     * @param {String} [queryOptions.city] 可以重新限定查询的区域，默认为类构造时传入的city
     * @param {Boolean} [queryOptions.citylimit = false] 取值为"true"，仅返回city中指定城市检索结果
     *
     * @param {Number} [queryOptions.count=20] 单次召回POI数量，最大返回25条。多关键字检索时，返回的记录数为关键字个数*count。多关键词检索时，单页返回总数=关键词数量*count
     * @param {Number} [queryOptions.page=0] 分页页码，默认为0, 0代表第一页，1代表第二页，以此类推。常与 count 搭配使用，仅当返回结果为poi时可以翻页。
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    queryText(queryOptions) {
      const filter = {
        key: this.key, // 请求服务权限标识
        output: "json",
        page: (queryOptions.page || 0) + 1, // 高德从1开始
        offset: queryOptions.count || 20,
        types: queryOptions.types || ""
      };

      if (Cesium__namespace.defined(queryOptions.city)) {
        filter.city = queryOptions.city;
        filter.citylimit = true;
      }
      if (Cesium__namespace.defined(queryOptions.citylimit)) {
        filter.citylimit = queryOptions.citylimit;
      }

      // 关键字构造
      if (queryOptions.text) {
        filter.keywords = this._getKeywords(queryOptions.text);
      } else {
        // 无关键字时，指定类别(keywords和types两者至少必选其一)
        if (!filter.types) {
          filter.types = "120000|130000|190000";
        }
      }

      return fetchJson({
        url: "https://restapi.amap.com/v3/place/text",
        queryParameters: filter,
        ...this.options
      })
        .then((data) => {
          if (data.infocode !== "10000") {
            const meg = "POI 请求失败(" + data.infocode + ")：" + data.info;
            if (queryOptions.error) {
              queryOptions.error(meg);
            }
            return
          }

          if (!data.pois) {
            if (queryOptions.error) {
              queryOptions.error("未查询到相关结果！");
            }
            return
          }

          const arr = this._formatPOIData(data.pois);
          const result = {
            allcount: data.count,
            count: arr.length,
            list: arr
          };
          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          logError("GaodePOI 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }

    /**
     * 周边搜索(圆形搜索)
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 检索关键字。支持多个关键字并集检索，不同关键字间以空格符号分隔，最多支持10个关键字检索。
     * @param {String} [queryOptions.types=''] 检索分类偏好，与text组合进行检索，多个分类以","分隔（POI分类），如果需要严格按分类检索，请通过text参数设置
     * @param {LngLatPoint|Cesium.Cartesian3|String|Array|Object} [queryOptions.location] 圆形区域检索中心点，取值范围:0-50000。规则：大于50000按默认值，单位：米
     * @param {Number} [queryOptions.radius=3000] 圆形区域检索半径，单位为米。（增加区域内数据召回权重，如需严格限制召回数据在区域内，请搭配使用radiuslimit参数），当半径过大，超过中心点所在城市边界时，会变为城市范围检索，检索范围为中心点所在城市
     * @param {Boolean} [queryOptions.limit = false] 是否严格限定召回结果在设置检索半径范围内。true（是），false（否）。设置为true时会影响返回结果中total准确性及每页召回poi数量， 设置为false时可能会召回检索半径外的poi。
     *
     * @param {Number} [queryOptions.count=20] 单次召回POI数量，最大返回25条。多关键字检索时，返回的记录数为关键字个数*count。多关键词检索时，单页返回总数=关键词数量*count
     * @param {Number} [queryOptions.page=0] 分页页码，默认为0, 0代表第一页，1代表第二页，以此类推。常与 count 搭配使用，仅当返回结果为poi时可以翻页。
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    queryCircle(queryOptions) {
      const filter = {
        output: "json",
        key: this.key, // 请求服务权限标识
        radius: queryOptions.radius || 3000,
        page: (queryOptions.page || 0) + 1, // 高德从1开始
        offset: queryOptions.count || 20,
        types: queryOptions.types || ""
      };

      // 坐标构造 location
      if (queryOptions.location) {
        queryOptions.location = LngLatPoint.parse(queryOptions.location);
        const cartg = wgs2gcj([queryOptions.location.lng, queryOptions.location.lat]);
        filter.location = cartg[0] + "," + cartg[1];
      } else {
        logError("GaodePOI: 请传入参location数");
      }

      // 关键字构造
      if (queryOptions.text) {
        filter.keywords = this._getKeywords(queryOptions.text);
      } else {
        // 无关键字时，指定类别(keywords和types两者至少必选其一)
        if (!filter.types) {
          filter.types = "120000|130000|190000";
        }
      }

      return fetchJson({
        url: "https://restapi.amap.com/v3/place/around",
        queryParameters: filter,
        ...this.options
      })
        .then((data) => {
          if (data.infocode !== "10000") {
            if (queryOptions.error) {
              const msg = "POI 请求失败(" + data.infocode + ")：" + data.info;
              queryOptions.error(msg);
            }
            return
          }

          if (!data.pois) {
            if (queryOptions.error) {
              queryOptions.error("未查询到相关结果！");
            }
            return
          }

          const arr = this._formatPOIData(data.pois);
          let resArr;
          if (queryOptions.limit) {
            resArr = this._filterPOIData_circle(arr, queryOptions.location, filter.radius);
          } else {
            resArr = arr;
          }
          const result = {
            allcount: data.count,
            count: resArr.length,
            list: resArr
          };
          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          logError("GaodePOI 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }

    // 圆形搜索筛选
    _filterPOIData_circle(arr, point, radius) {
      if (!arr || !point || !radius) {
        return arr
      }
      const center = point.toCartesian();

      const arrNew = [];
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const c3 = Cesium__namespace.Cartesian3.fromDegrees(item.x, item.y, point.alt);
        const distance = Cesium__namespace.Cartesian3.distance(c3, center);
        if (distance < radius) {
          // 表示在圆内
          arrNew.push(item);
        }
      }
      return arrNew
    }

    /**
     * 多边形搜索
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.text 检索关键字。支持多个关键字并集检索，不同关键字间以空格符号分隔，最多支持10个关键字检索。
     * @param {String} [queryOptions.types=''] 检索分类偏好，与text组合进行检索，多个分类以","分隔（POI分类），如果需要严格按分类检索，请通过text参数设置
     * @param {Array[]} queryOptions.polygon  经纬度数组，经纬度小数点后不得超过6位。多边形为矩形时，可传入左上右下两顶点坐标对；其他情况下首尾坐标对需相同。
     * @param {Boolean} [queryOptions.limit = false] 是否严格限定召回结果在设置检索的多边形或矩形范围内。true（是），false（否）。设置为true时会影响返回结果中total准确性及每页召回poi数量， 设置为false时可能会召回检索半径外的poi。
     * @param {Number} [queryOptions.count=20] 单次召回POI数量，最大返回25条。多关键字检索时，返回的记录数为关键字个数*count。多关键词检索时，单页返回总数=关键词数量*count
     * @param {Number} [queryOptions.page=0] 分页页码，默认为0, 0代表第一页，1代表第二页，以此类推。常与 count 搭配使用，仅当返回结果为poi时可以翻页。
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    queryPolygon(queryOptions) {
      const filter = {
        key: this.key, // 请求服务权限标识
        output: "json",
        page: (queryOptions.page || 0) + 1, // 高德从1开始
        offset: queryOptions.count || 20,
        types: queryOptions.types || ""
      };

      // 坐标构造 polygon
      const coors = queryOptions.polygon;
      let coorArr = [];
      if (coors.length === 2) {
        // 矩形
        const cartg1 = wgs2gcj(coors[0]);
        const cartg2 = wgs2gcj(coors[1]);
        filter.polygon = cartg1[0] + "," + cartg1[1] + "|" + cartg2[0] + "," + cartg2[1];
        coorArr = [coors[0], [coors[0][0], coors[1][1]], coors[1], [coors[1][0], coors[0][1]]];
      } else {
        // 多边形
        coorArr = coors;
        let polygon = "";
        const newCoors = coors.concat([coors[coors.length - 1]]);
        for (let i = 0; i < newCoors.length; i++) {
          const cartg = wgs2gcj(newCoors[i]);
          if (i === newCoors.length - 1) {
            polygon += cartg[0] + "," + cartg[1];
          } else {
            polygon += cartg[0] + "," + cartg[1] + "|";
          }
        }
        filter.polygon = polygon;
      }

      // 关键字构造
      if (queryOptions.text) {
        filter.keywords = this._getKeywords(queryOptions.text);
      } else {
        // 无关键字时，指定类别(keywords和types两者至少必选其一)
        if (!filter.types) {
          filter.types = "120000|130000|190000";
        }
      }

      return fetchJson({
        url: "https://restapi.amap.com/v3/place/polygon",
        queryParameters: filter,
        ...this.options
      })
        .then((data) => {
          if (data.infocode !== "10000") {
            if (queryOptions.error) {
              const msg = "POI 请求失败(" + data.infocode + ")：" + data.info;
              queryOptions.error(msg);
            }
            return
          }

          if (!data.pois) {
            if (queryOptions.error) {
              queryOptions.error("未查询到相关结果！");
            }
            return
          }
          const arr = this._formatPOIData(data.pois);
          let resArr;
          if (queryOptions.limit) {
            resArr = this._filterPOIData_polygon(arr, coorArr);
          } else {
            resArr = arr;
          }
          const result = {
            allcount: data.count,
            count: resArr.length,
            list: resArr
          };
          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          logError("GaodePOI 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }

    // 多边形与矩形的二次筛选
    _filterPOIData_polygon(arr, coors) {
      if (!arr || !coors) {
        return
      }

      // 判断tur库是否存在 start
      try {
        if (!turf.booleanPointInPolygon) {
          throw new Error("turf不存在")
        }
      } catch (e) {
        logError("GaodePOI：该方法依赖turf库，请引入该库。", e);
        return arr
      }
      // 判断tur库是否存在 end

      coors = coors.concat([coors[0]]);

      const turfPolygon = { type: "Polygon", coordinates: [coors] };

      const arrNew = [];
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const turfPoint = {
          type: "Feature",
          geometry: { type: "Point", coordinates: [item.x, item.y] }
        };
        if (turf.booleanPointInPolygon(turfPoint, turfPolygon)) {
          arrNew.push(item);
        }
      }
      return arrNew
    }
  }

  const RouteType = {
    Walking: 1, // 步行
    Bicycling: 2, // 骑行
    Driving: 3 // 驾车
  };

  /**
   * 高德 路径规划  工具类，
   * 参考文档：{@link https://lbs.amap.com/api/webservice/guide/api/direction}
   *
   * @param {Object} [options] 参数对象，包括以下：
   * @param {String[]} [options.key = mars3d.Token.gaodeArr] 百度KEY,在实际项目中请使用自己申请的高德KEY，因为我们的key不保证长期有效。
   * @param {Object} [options.headers={}] 将被添加到HTTP请求头。
   * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
   *
   * @export
   * @class GaodeRoute
   */
  class GaodeRoute {
    constructor(opts = {}) {
      this._key_index = 0;
      this._keys = opts.key || gaodeArr;
    }

    /**
     * 高德key数组，内部轮询使用
     * @type {String[]}
     */
    get keys() {
      return this._keys
    }

    set keys(val) {
      this._keys = val;
    }

    /**
     * 轮询取单个key进行使用
     * @type {String}
     * @readonly
     */
    get key() {
      const thisidx = this._key_index++ % this._keys.length;
      return this._keys[thisidx]
    }

    // 【内部】格式化返回的数据
    _formatRouteData(start, end, resultPaths) {
      let wgs_origin, wgs_destination;
      const paths = [];
      if (start) {
        wgs_origin = gcj2wgs(start.split(","));
      }
      if (end) {
        wgs_destination = gcj2wgs(end.split(","));
      }
      if (resultPaths && resultPaths.length > 0) {
        for (let i = 0; i < resultPaths.length; i++) {
          const route = [];
          route.push(wgs_origin); // 连接起点
          const item = resultPaths[i];
          const steps = item.steps;
          const newSteps = [];
          const roadInfo = []; // 途径地方
          for (let index = 0; index < steps.length; index++) {
            const obj = {
              instruction: steps[index].instruction, // 路段步行指示
              distance: steps[index].distance, // 路段距离 米
              duration: steps[index].duration, // 路段预计时间 秒
              points: [],
              route: steps[index].road
            };
            const polyline = steps[index].polyline;
            const polylineArr = polyline.split(";");
            for (let ind = 0; ind < polylineArr.length; ind++) {
              const one = polylineArr[ind];
              const wgs = gcj2wgs(one.split(","));
              route.push(wgs);
              obj.points.push(wgs);
            }
            roadInfo.push(obj.route);
            newSteps.push(obj);
          }
          route.push(wgs_destination); // 连接终点
          paths.push({
            allDistance: item.distance, // 总距离
            allDuration: item.duration, // 全部所需时间
            steps: newSteps, // 每一段的数据
            points: route, // 包含起点和终点的 完整路径的wgs84坐标数组
            road: roadInfo
          });
        }
      }

      return {
        origin: wgs_origin, // 起点
        destination: wgs_destination, // 终点
        paths: paths // 所有方案
      }
    }

    /**
     * 按指定类别自动查询
     *
     * @param {Object} queryOptions 查询参数
     * @param {GaodeRoute.RouteType|Number} queryOptions.type 类型
     * @param {Array[]} queryOptions.points 按起点、终点 顺序的坐标数组,如[[117.500244, 40.417801],[117.500244, 40.417801]]
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    query(queryOptions) {
      switch (queryOptions.type) {
        case RouteType.Bicycling: // 骑行
          return this.queryBicycling(queryOptions)
        case RouteType.Driving: // 驾车
          return this.queryDriving(queryOptions)
        case RouteType.Walking: // 步行
        default:
          return this.queryWalking(queryOptions)
      }
    }

    /**
     * 按指定类别自动查询(多个路线数组，递归处理)
     *
     * @param {Object} queryOptions 查询参数
     * @param {GaodeRoute.RouteType} queryOptions.type 类型
     * @param {Array[]} queryOptions.points 多条，按起点终点 顺序的坐标数组,如[
     *  [ [117.500244, 40.417801],[117.500244, 40.417801] ],
     *  [ [117.500244, 40.417801],[117.500244, 40.417801] ]
     * ]
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    queryArr(queryOptions) {
      return new Promise((resolve, reject) => {
        const that = this;
        let index = -1;

        const newOpts = {};
        for (const key in queryOptions) {
          if (key === "points" || key === "success" || key === "error") {
            continue
          }
          newOpts[key] = queryOptions[key];
        }
        const arrPoints = queryOptions.points;
        const arrResult = [];

        function queryNextLine() {
          index++;
          newOpts.points = arrPoints[index];
          newOpts.success = function (data) {
            if (data && data.paths && data.paths.length > 0) {
              arrResult.push(data.paths[0]);
            } else {
              arrResult.push(null);
            }

            if (index >= arrPoints.length - 1) {
              if (queryOptions.success) {
                queryOptions.success(arrResult);
              }
              resolve(arrResult);
            } else {
              queryNextLine();
            }
          };
          newOpts.error = newOpts.success;

          that.query(newOpts);
        }
        queryNextLine();
      })
    }

    /**
     * 计算结果中的最短距离的导航路径
     *
     * @param {Object[]} data queryArr返回的结果数组
     * @return {Object} 返回路线数据和index顺序
     */
    getShortestPath(data) {
      let mindis = Number.MAX_VALUE;
      let lineData = null;
      let index = -1;
      for (let i = 0; i < data.length; i++) {
        const item = data[i];
        if (item) {
          if (item.allDistance <= mindis) {
            lineData = item;
            index = i;
            mindis = item.allDistance;
          }
        }
      }
      return {
        lineData: lineData,
        index: index
      }
    }

    /**
     * 步行路径规划 (单个查询)
     *
     * @param {Object} queryOptions 查询参数
     * @param {Array[]} queryOptions.points 按起点、终点 顺序的坐标数组,如[[117.500244, 40.417801],[117.500244, 40.417801]]
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    queryWalking(queryOptions) {
      const filter = {
        key: this.key, // 请求服务权限标识
        output: "json"
      };
      // 坐标构造
      const startP = wgs2gcj(queryOptions.points[0]);
      const endP = wgs2gcj(queryOptions.points[queryOptions.points.length - 1]);
      filter.origin = startP[0] + "," + startP[1];
      filter.destination = endP[0] + "," + endP[1];

      return fetchJson({
        url: "https://restapi.amap.com/v3/direction/walking",
        queryParameters: filter,
        ...this.options
      })
        .then((data) => {
          if (data.infocode !== "10000") {
            if (queryOptions.error) {
              const msg = "路径规划 请求失败(" + data.infocode + ")：" + data.info;
              queryOptions.error(msg);
            }
            return
          }

          if (!data.route || !data.route.paths) {
            if (queryOptions.error) {
              queryOptions.error("未查询到相关结果！");
            }
            return
          }

          const result = this._formatRouteData(filter.origin, filter.destination, data.route.paths);

          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          logError("GaodeRoute 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }

    /**
     * 骑行路径查询 (单个查询)
     *
     * @param {Object} queryOptions 查询参数
     * @param {Array[]} queryOptions.points 按起点、终点 顺序的坐标数组,如[[117.500244, 40.417801],[117.500244, 40.417801]]
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    queryBicycling(queryOptions) {
      const filter = {
        key: this.key, // 请求服务权限标识
        output: "json"
      };
      const startP = wgs2gcj(queryOptions.points[0]);
      const endP = wgs2gcj(queryOptions.points[queryOptions.points.length - 1]);
      filter.origin = startP[0] + "," + startP[1];
      filter.destination = endP[0] + "," + endP[1];

      return fetchJson({
        url: "https://restapi.amap.com/v4/direction/bicycling",
        queryParameters: filter,
        ...this.options
      })
        .then((data) => {
          if (data.infocode !== "10000") {
            const msg = "路径规划 请求失败(" + data.infocode + ")：" + data.info;
            if (queryOptions.error) {
              queryOptions.error(msg);
            }
            return
          }

          if (!data.route || !data.route.paths) {
            if (queryOptions.error) {
              queryOptions.error("未查询到相关结果！");
            }
            return
          }
          const result = this._formatRouteData(filter.origin, filter.destination, data.route.paths);
          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          logError("GaodeRoute 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }

    /**
     * 驾车路径规划查询
     *
     * @param {Object} queryOptions 查询参数
     * @param {Array[]} queryOptions.points 按起点、途经点、终点 顺序的坐标数组,如[[117.500244, 40.417801],[117.500244, 40.417801]]
     * @param {Array[]} queryOptions.avoidpolygons 区域避让数组(支持多个)，支持32个避让区域，每个区域最多可有16个顶点。避让区域不能超过81平方公里，否则避让区域会失效。
     *
     * @param {String} [queryOptions.extensions='base'] 返回结果控制,可选值：core/all  base:返回基本信息；all：返回全部信息
     * @param {String} [queryOptions.strategy=0] 驾车选择策略，参考高德官网说明，默认为0：速度优先，不考虑当时路况，此路线不一定距离最短
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    queryDriving(queryOptions) {
      const filter = {
        key: this.key, // 请求服务权限标识
        output: "json",
        extensions: queryOptions.extensions || "base",
        strategy: queryOptions.strategy || 0 // 0 返回一条速度优先的路径
      };

      const startP = wgs2gcj(queryOptions.points[0]);
      const endP = wgs2gcj(queryOptions.points[queryOptions.points.length - 1]);
      filter.origin = startP[0] + "," + startP[1]; // 出发点
      filter.destination = endP[0] + "," + endP[1]; // 目的地

      if (queryOptions.points.length > 2) {
        let waypoints = "";
        for (let i = 1, len = queryOptions.points.length - 1; i < len; i++) {
          const item = wgs2gcj(queryOptions.points[i]);
          waypoints += item[0] + "," + item[1] + ";";
        }
        filter.waypoints = waypoints; // 途经点
      }

      if (queryOptions.avoidpolygons?.length > 0) {
        let avoidpolygons = "";
        // 坐标点之间用";"分隔，区域之间用"|"分隔。
        for (let k = 0, len = queryOptions.avoidpolygons.length; k < len; k++) {
          if (k > 0) {
            avoidpolygons += "|"; // 区域之间用"|"分隔。
          }
          const item = queryOptions.avoidpolygons[k];
          for (let j = 0, len2 = item.length; j < len2; j++) {
            const item2 = wgs2gcj(item[j]);
            avoidpolygons += item2[0] + "," + item2[1] + ";"; // 坐标点之间用";"分隔
          }
        }
        filter.avoidpolygons = avoidpolygons; // 区域避让
      }

      return fetchJson({
        url: "https://restapi.amap.com/v3/direction/driving",
        queryParameters: filter,
        ...this.options
      })
        .then((data) => {
          if (data.infocode !== "10000") {
            if (queryOptions.error) {
              const msg = "路径规划 请求失败(" + data.infocode + ")：" + data.info;
              queryOptions.error(msg);
            }
            return
          }

          if (!data.route || !data.route.paths || data.route.paths.length === 0) {
            if (queryOptions.error) {
              queryOptions.error("未查询到相关结果！");
            }
            return
          }
          const result = this._formatRouteData(filter.origin, filter.destination, data.route.paths);
          if (queryOptions.success) {
            queryOptions.success(result);
          }
          return result
        })
        .catch((error) => {
          logError("GaodeRoute 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        })
    }
  }

  /**
   * 路径规划方式
   * @property {Number}  Walking 步行
   * @property {Number}  Bicycling 骑行
   * @property {Number}  Driving 驾车
   * @enum
   */
  GaodeRoute.RouteType = RouteType;

  const Def_Parameters = {
    service: "WFS",
    request: "GetFeature",
    version: "1.0.0",
    outputFormat: "application/json",
    maxFeatures: 1000
  };

  /**
   * GeoServer WFS服务查询类
   *
   * @param {Object|*} options 参数对象，包括以下：
   * @param {String} options.url GeoServer服务地址, 示例：'http://server.mars3d.cn/geoserver/mars/wfs'
   * @param {String} options.layer 图层名称（命名空间:图层名称），多个图层名称用逗号隔开
   * @param {String} [options.crs="EPSG:4326"]  服务数据的坐标系，如'EPSG:4326' （可以从 {@link http://epsg.io }查询）
   * @param {Object} [options.headers={}] 将被添加到HTTP请求头。
   * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
   *
   * //以下是GeoJsonLayer图层参数
   * @param {String|Number} [options.id = createGuid()] 赋予给layer图层，图层id标识
   * @param {String|Number} [options.pid = -1] 赋予给layer图层，图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 赋予给layer图层，图层名称
   * @param {Object|Function} [options.symbol] 赋予给layer图层，图层矢量数据的style样式，参考{@link GeoJsonLayer}
   * @param {Object} [options.graphicOptions] 赋予给layer图层，图层默认的graphic的构造参数，参考{@link GeoJsonLayer}
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  赋予给layer图层，图层绑定的popup弹窗值，参考{@link GeoJsonLayer}
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  赋予给layer图层，图层绑定的tooltip弹窗值，参考{@link GeoJsonLayer}
   *
   * @export
   * @class QueryGeoServer
   * @extends {BaseClass}
   */
  class QueryGeoServer extends BaseClass {
    /**
     * 用于显示查询结果的GeoJsonLayer图层，图层参数在当前类构造方法中传入
     * @type {GeoJsonLayer}
     * @readonly
     */
    get layer() {
      if (!this._geoJsonLayer) {
        const layerOptions = { popup: "all", ...this.options };
        delete layerOptions.url;
        delete layerOptions.data;

        this._geoJsonLayer = new GeoJsonLayer(layerOptions);
        this._geoJsonLayer.on(EventType.load, this.geoJsonLayer_onLoadHandler, this);
        this._geoJsonLayer.on(EventType.click, this.geoJsonLayer_onClickHandler, this);
      }
      return this._geoJsonLayer
    }

    /**
     * 查询服务，基于filter条件
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} [queryOptions.text] 检索关键字
     * @param {String} [queryOptions.column] 检索关键字时，对应的字段名称
     * @param {Boolean} [queryOptions.like=true] 检索关键字时，是否模糊匹配，false时精确查询
     * @param {BaseGraphic|*} [queryOptions.graphic] 限定的搜索区域
     * @param {String} [queryOptions.geometryName='the_geom'] 限定的搜索区域时，对应的geometry字段名称
     * @param {Number} [queryOptions.maxFeatures=1000] 返回结果最大数量
     * @param {String} [queryOptions.sortBy] 排序的属性名称，默认升序，降序时+D
     * @param {*} [queryOptions.更多参数] WFS服务支持的其他参数，均支持
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {QueryGeoServer} 当前对象本身，可以链式调用
     */
    query(queryOptions) {
      // 请求的wfs参数
      let filter = '<Filter xmlns="http://www.opengis.net/ogc" xmlns:gml="http://www.opengis.net/gml"><And>';

      // 关键字
      if (queryOptions.text) {
        if (Cesium__namespace.defaultValue(queryOptions.like, true)) {
          filter += ` <PropertyIsLike wildCard="*" singleChar="#" escapeChar="!">
            <PropertyName>${queryOptions.column}</PropertyName>
            <Literal>*${queryOptions.text}*</Literal>
        </PropertyIsLike>`;
        } else {
          filter += ` <PropertyIsLike wildCard="*" singleChar="#" escapeChar="!">
            <PropertyName>${queryOptions.column}</PropertyName>
            <Literal>${queryOptions.text}</Literal>
        </PropertyIsLike>`;
        }
      }

      // 限定区域范围
      if (queryOptions.graphic) {
        const graphic = queryOptions.graphic;
        let coordinates;
        if (graphic.type === "rectangle") {
          coordinates = graphic.outlineCoordinates;
        } else if (graphic.type === "polygon") {
          coordinates = graphic.coordinates;
        } else if (graphic.type === "circle") {
          coordinates = graphic.getOutlineCoordinates(true, 30);
        } else if (Cesium__namespace.defined(graphic.xmax) && Cesium__namespace.defined(graphic.xmin) && Cesium__namespace.defined(graphic.ymin) && Cesium__namespace.defined(graphic.ymax)) {
          coordinates = [
            [graphic.xmin, graphic.ymax],
            [graphic.xmin, graphic.ymin],
            [graphic.xmax, graphic.ymin],
            [graphic.xmax, graphic.ymax]
          ];
        }
        if (coordinates) {
          coordinates.push(coordinates[0]);

          let polygon = "";
          for (let i = 0; i < coordinates.length; i++) {
            let pt = coordinates[i];
            if (this.options.crs && this.options.crs !== CRS.EPSG4326 && this.options.crs !== CRS.EPSG4490) {
              pt = proj4Trans(pt, "EPSG:4326", this.options.crs);
            }
            polygon += pt[0] + "," + pt[1] + " ";
          }

          filter += `<Intersects>
                      <PropertyName>${queryOptions.geometryName || "the_geom"}</PropertyName>
                      <gml:Polygon>
                          <gml:outerBoundaryIs>
                              <gml:LinearRing>
                                  <gml:coordinates>${polygon}</gml:coordinates>
                              </gml:LinearRing>
                          </gml:outerBoundaryIs>
                      </gml:Polygon>
                  </Intersects>`;
        }
      }

      filter += "</And></Filter>";

      // 请求参数
      const parameters = {
        ...Def_Parameters,
        ...queryOptions,
        typeName: this.options.layer,
        filter: filter
      };
      delete parameters.success;
      delete parameters.error;
      delete parameters.graphic;
      delete parameters.text;
      delete parameters.column;

      return new Promise((resolve, reject) => {
        sendAjax({
          ...this.options,
          queryParameters: parameters
        })
          .then((featureCollection) => {
            queryOptions._promise = { resolve, reject };
            this.processFeatureCollection(featureCollection, queryOptions);
          })
          .catch((error) => {
            logError("QueryGeoServer 请求出错", error);
            if (queryOptions.error) {
              queryOptions.error("请求出错", error);
            }
          });
      })
    }

    /**
     * 查询服务，基于cql_filter条件
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} queryOptions.cql_filter 筛选服务数据的[SQL语句]{@link https://docs.geoserver.org/2.12.2/user/services/wfs/vendor.html#wfs-vendor-parameters}
     * @param {BaseGraphic|*} [queryOptions.graphic] 限定的搜索区域,自动转换后加入到cql_filter中，也可以外部自行处理
     * @param {String} [queryOptions.geometryName='the_geom'] 限定的搜索区域时，对应的geometry字段名称
     * @param {Number} [queryOptions.maxFeatures=1000] 返回结果最大数量
     * @param {String} [queryOptions.sortBy] 排序的属性名称，默认升序，降序时+D
     * @param {*} [queryOptions.更多参数] WFS服务支持的其他参数，均支持
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {QueryGeoServer} 当前对象本身，可以链式调用
     */
    queryBySql(queryOptions) {
      // 请求的wfs参数
      let cql_filter = queryOptions.cql_filter || "1=1";

      // 限定区域范围
      if (queryOptions.graphic) {
        let graphic = queryOptions.graphic;
        const geomName = queryOptions.geometryName || "the_geom";
        let coordinates;
        if (graphic.type === "rectangle") {
          graphic = graphic.getRectangle({ isFormat: true });
          const bbox = graphic.xmin + "," + graphic.ymin + "," + graphic.xmax + "," + graphic.ymax;
          cql_filter += ` and BBOX(${geomName}, ${bbox})`;
        } else if (graphic.type === "polygon") {
          coordinates = graphic.coordinates;
        } else if (graphic.type === "circle") {
          coordinates = graphic.getOutlineCoordinates(true, 30);
        } else if (Cesium__namespace.defined(graphic.xmax) && Cesium__namespace.defined(graphic.xmin) && Cesium__namespace.defined(graphic.ymin) && Cesium__namespace.defined(graphic.ymax)) {
          const bbox = graphic.xmin + "," + graphic.ymin + "," + graphic.xmax + "," + graphic.ymax;
          cql_filter += ` and BBOX(${geomName}, ${bbox})`;
        }
        if (coordinates) {
          coordinates.push(coordinates[0]);

          const coors = [];
          for (let i = 0; i < coordinates.length; i++) {
            coors.push(coordinates[i][0] + " " + coordinates[i][1]);
          }
          cql_filter += ` and INTERSECTS (${geomName},POLYGON((${coors.join(",")})))`;
        }
      }

      // 请求参数
      const parameters = {
        ...Def_Parameters,
        ...queryOptions,
        typeName: this.options.layer,
        cql_filter: cql_filter
      };
      delete parameters.success;
      delete parameters.error;
      delete parameters.graphic;

      sendAjax({
        ...this.options,
        queryParameters: parameters
      })
        .then((featureCollection) => {
          this.processFeatureCollection(featureCollection, queryOptions);
        })
        .catch((error) => {
          logError("QueryGeoServer 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error("请求出错", error);
          }
        });
    }

    processFeatureCollection(featureCollection, queryOptions) {
      if (featureCollection && featureCollection.type === "Feature") {
        featureCollection = { type: "FeatureCollection", features: [featureCollection] };
      }

      if (!featureCollection || !featureCollection.features || featureCollection.features.length === 0) {
        if (queryOptions.success) {
          queryOptions.success({ count: 0 });
        }
        if (queryOptions._promise?.resolve) {
          queryOptions._promise.resolve({ count: 0 });
        }
      } else {
        // 剔除有问题数据
        const featuresOK = [];
        for (let i = 0; i < featureCollection.features.length; i++) {
          const feature = featureCollection.features[i];
          if (feature?.geometry?.coordinates?.length > 0) {
            featuresOK.push(feature);
          }
        }
        featureCollection.features = featuresOK;

        if (this._geoJsonLayer) {
          this._last_success = (list) => {
            const result = {
              geojson: featureCollection,
              count: featureCollection.features.length,
              list: list
            };
            if (queryOptions.success) {
              queryOptions.success(result);
            }
            if (queryOptions._promise?.resolve) {
              queryOptions._promise.resolve(result);
            }
          };
          this._geoJsonLayer.load({ data: featureCollection });
        } else {
          const result = {
            geojson: featureCollection,
            count: featureCollection.features.length
          };
          if (queryOptions.success) {
            queryOptions.success(result);
          }
          if (queryOptions._promise?.resolve) {
            queryOptions._promise.resolve(result);
          }
        }
      }
    }

    geoJsonLayer_onLoadHandler(event) {
      if (this._last_success) {
        this._last_success(event.list);
        this._last_success = null;
      }
      this.fire(EventType.load, event);
    }

    geoJsonLayer_onClickHandler(event) {
      this.fire(EventType.click, {
        ...event,
        layer: this._geoJsonLayer
      });
    }

    /**
     * 清除
     * @return {void}  无
     */
    clear() {
      if (this._last_success) {
        this._last_success = null;
      }
      if (this._geoJsonLayer) {
        this._geoJsonLayer.clear();
      }
    }
  }

  /**
   * @typedef {Object} QueryArcServer.EventType
   * 当前类支持的{@link EventType}事件类型
   *
   * @property {String} click 左键单击 鼠标事件
   * @property {String} load 完成加载，执行所有内部处理后
   *
   * @example
   * //绑定监听事件
   * layer.on(mars3d.EventType.load, function (event) {
   *   console.log('矢量数据对象加载完成', event)
   * })
   * @see BaseClass#on
   * @see BaseClass#off
   */

  /**
   * ArcGIS WFS矢量服务查询类
   *
   * @param {Object|*} options 参数对象，包括以下：
   * @param {String} options.url ArcGIS服务地址, 示例：'http://server.mars3d.cn/arcgis/rest/services/mars/hefei/MapServer/37'
   * @param {Number} [options.pageSize=10] 每页条数 *
   * @param {Object} [options.headers={}] 将被添加到HTTP请求头。
   * @param {Cesium.Proxy} [options.proxy] 加载资源时使用的代理。
   *
   * //以下是GeoJsonLayer图层参数
   * @param {String|Number} [options.id = createGuid()] 赋予给layer图层，图层id标识
   * @param {String|Number} [options.pid = -1] 赋予给layer图层，图层父级的id，一般图层管理中使用
   * @param {String} [options.name = ''] 赋予给layer图层，图层名称
   * @param {Object|Function} [options.symbol] 赋予给layer图层，图层矢量数据的style样式，参考{@link GeoJsonLayer}
   * @param {Object} [options.graphicOptions] 赋予给layer图层，图层默认的graphic的构造参数，参考{@link GeoJsonLayer}
   * @param {String|Globe.getTemplateHtml_template[]|Function} [options.popup]  赋予给layer图层，图层绑定的popup弹窗值，参考{@link GeoJsonLayer}
   * @param {String|Globe.getTemplateHtml_template[]|Function|Object} [options.tooltip]  赋予给layer图层，图层绑定的tooltip弹窗值，参考{@link GeoJsonLayer}
   *
   * @export
   * @class QueryArcServer
   * @extends {BaseClass}
   * @see [支持的事件类型]{@link QueryArcServer.EventType}
   */
  class QueryArcServer extends BaseClass {
    constructor(options = {}) {
      super(options);

      this.options = options;

      this._pageSize = options.pageSize ?? 10; // 每页条数
      this._allCount = 0; // 总记录数
      this._allPage = 0; // 总页数
      this._pageIndex = 1; // 当前第几页
      this.arrIDS = [];
    }
    //= ========= 对外属性 =========

    /**
     * ArcGIS服务地址
     * @type {String}
     */
    get url() {
      return this.options.url
    }

    set url(val) {
      this.options.url = val;
    }

    /**
     * 分页的 每页条数
     * @type {Number}
     */
    get pageSize() {
      return this._pageSize
    }

    set pageSize(val) {
      this._pageSize = val;
    }

    /**
     * 总记录数
     * @type {Number}
     * @readonly
     */
    get allCount() {
      return this._allCount
    }

    /**
     * 总页数
     * @type {Number}
     * @readonly
     */
    get allPage() {
      return this._allPage
    }

    /**
     * 页码，当前第几页
     * @type {Number}
     * @readonly
     */
    get pageIndex() {
      return this._pageIndex
    }

    set pageIndex(val) {
      this._pageIndex = val;
      this.showPage(val);
    }

    /**
     * 用于显示查询结果的GeoJsonLayer图层，图层参数在当前类构造方法中传入
     * @type {GeoJsonLayer}
     * @readonly
     */
    get layer() {
      if (!this._geoJsonLayer) {
        const layerOptions = { popup: "all", ...this.options };
        delete layerOptions.url;
        delete layerOptions.data;

        this._geoJsonLayer = new GeoJsonLayer(layerOptions);
        this._geoJsonLayer.on(EventType.load, this.geoJsonLayer_onLoadHandler, this);
        this._geoJsonLayer.on(EventType.click, this.geoJsonLayer_onClickHandler, this);
      }
      return this._geoJsonLayer
    }

    //= ========= 方法 ==========
    /**
     * 首页，查看第1页数据
     * @return {void}  无
     */
    showFirstPage() {
      this.showPage(1);
    }

    /**
     * 上一页
     * @return {void}  无
     */
    showPretPage() {
      this._pageIndex = this._pageIndex - 1;
      if (this._pageIndex < 1) {
        this._pageIndex = 1;
      }

      this.showPage(this._pageIndex);
    }

    /**
     * 下一页
     * @return {void}  无
     */
    showNextPage() {
      this._pageIndex = this._pageIndex + 1;
      if (this._pageIndex > this.allPage) {
        this._pageIndex = this.allPage;
      }
      this.showPage(this._pageIndex);
    }

    /**
     * 跳转到指定页
     * @param {Number} pageIndex 指定页
     * @return {void}  无
     */
    showPage(pageIndex) {
      this._pageIndex = pageIndex;
      this._queryPageByIds();
    }

    /**
     * 按指定类别自动查询
     *
     * @param {Object} queryOptions 查询参数
     * @param {String} [queryOptions.text] 检索关键字。
     * @param {String} [queryOptions.column] 检索关键字的字段名称。
     * @param {Boolean} [queryOptions.like=true] 检索关键字时，是否模糊匹配，false时精确查询。
     * @param {String} [queryOptions.where] 自定义的检索条件，与text二选一
     * @param {BaseGraphic|*} [queryOptions.graphic] 限定的搜索区域
     * @param {Boolean} [queryOptions.page=true] 是否分页查询,false时不分页，一次性查询返回
     *
     * @param {Function} [queryOptions.success] 查询完成的回调方法
     * @param {Function} [queryOptions.error] 查询失败的回调方法
     * @return {Promise<Object>} 查询完成的Promise,等价于success参数
     */
    query(queryOptions) {
      this._pageIndex = 1;
      this.arrIDS = [];

      // 请求的wfs参数
      const parameters = {
        f: "json",
        inSr: 4326,
        outSR: 4326,
        outFields: "*",
        returnGeometry: true,
        where: queryOptions.where || "1=1"
      };

      if (this.options.token) {
        parameters.token = this.options.token;
      }

      // 查询关键字
      if (queryOptions.column) {
        let where = "";
        if (queryOptions.like ?? true) {
          // 根据关键字进行查询
          where = queryOptions.column + "  like '%" + queryOptions.text + "%' ";
        } else {
          // 根据某个属性类别进行查询
          where = queryOptions.column + "='" + queryOptions.text + "'";
        }
        parameters.where = where;
      }

      // 限定范围
      if (queryOptions.graphic) {
        const graphic = queryOptions.graphic;

        parameters.spatialRel = "esriSpatialRelIntersects"; // 包含或交叉关系

        if (graphic.type === "rectangle") {
          const coor = graphic.outlineCoordinates;
          parameters.geometryType = "esriGeometryEnvelope"; // 矩形边界
          parameters.geometry = JSON.stringify({
            xmin: coor[0][0],
            ymin: coor[0][1],
            xmax: coor[2][0],
            ymax: coor[2][1],
            spatialReference: {
              wkid: 4326
            }
          });
        } else if (Cesium__namespace.defined(graphic.xmax) && Cesium__namespace.defined(graphic.xmin) && Cesium__namespace.defined(graphic.ymin) && Cesium__namespace.defined(graphic.ymax)) {
          parameters.geometryType = "esriGeometryEnvelope"; // 矩形边界
          parameters.geometry = JSON.stringify({
            xmin: graphic.xmin,
            ymin: graphic.ymin,
            xmax: graphic.xmax,
            ymax: graphic.ymax,
            spatialReference: {
              wkid: 4326
            }
          });
        } else {
          let geojson;
          if (graphic.type === "polygon") {
            geojson = graphic.toGeoJSON();
          } else if (graphic.type === "circle") {
            geojson = {
              type: "Feature",
              geometry: { type: "Polygon", coordinates: [graphic.outlineCoordinates] }
            };
          } else {
            // geojson
            geojson = queryOptions.graphic;
          }
          parameters.geometry = JSON.stringify(geojsonToArcGIS$1(geojson.geometry));
          parameters.geometryType = geojsonTypeToArcGIS(geojson.geometry.type);
        }
      }

      return new Promise((resolve, reject) => {
        queryOptions._promise = { resolve, reject };

        if (queryOptions.page ?? true) {
          // 分页
          parameters.returnIdsOnly = true; // 只返回id

          sendAjax({
            ...this.options,
            url: this.url + "/query",
            queryParameters: parameters
          })
            .then((result) => {
              const arrIDS = result.objectIds;

              if (arrIDS) {
                this.arrIDS = arrIDS;

                this._allCount = arrIDS.length; // 总记录数
                this._allPage = Math.ceil(this._allCount / this._pageSize); // 总页数
              }

              delete parameters.returnIdsOnly;
              this._queryPageByIds(parameters, queryOptions);
            })
            .catch((error) => {
              logError("QueryArcServer 请求出错", error);
              if (queryOptions.error) {
                queryOptions.error(error, error.message);
              }
            });
        } else {
          // 不分页
          sendAjax({
            ...this.options,
            url: this.url + "/query",
            queryParameters: parameters
          })
            .then((result) => {
              const featureCollection = arcgisToGeoJSON$1(result);
              this.processFeatureCollection(featureCollection, queryOptions);
            })
            .catch((error) => {
              logError("QueryArcServer 请求出错", error);
              if (queryOptions.error) {
                queryOptions.error(error, error.message);
              }
            });
        }
      })
    }

    // 根据id数组，进行单页查询数据
    _queryPageByIds(parameters, queryOptions) {
      if (parameters) {
        this.lastParameters = parameters;
      } else if (this.lastParameters) {
        parameters = this.lastParameters;
      }
      if (queryOptions) {
        this.lastQueryOpts = queryOptions;
      } else if (this.lastParameters) {
        queryOptions = this.lastQueryOpts;
      }

      if (!this.arrIDS || this.arrIDS.length === 0 || this._pageIndex < 1 || this._pageIndex > this.allPage) {
        const result = {
          geojson: null,

          count: 0,
          allCount: this.allCount,

          pageSize: this.pageSize,
          allPage: this.allPage,
          pageIndex: this.pageIndex
        };
        if (queryOptions.success) {
          queryOptions.success(result);
        }
        if (queryOptions._promise?.resolve) {
          queryOptions._promise.resolve(result);
        }
        return
      }

      // 计算 id集合中 该页所在起止位置，找到需要获取的id数组
      const startNum = (this._pageIndex - 1) * this._pageSize;
      const endNum = this._pageIndex * this._pageSize;
      const ids = this.arrIDS.slice(startNum, endNum);

      // 查询该id集合内的数据
      parameters.objectIds = ids.join(",");

      sendAjax({
        ...this.options,
        url: this.url + "/query",
        queryParameters: parameters
      })
        .then((result) => {
          const featureCollection = arcgisToGeoJSON$1(result);
          this.processFeatureCollection(featureCollection, queryOptions);
        })
        .catch((error) => {
          logError("QueryArcServer 请求出错", error);
          if (queryOptions.error) {
            queryOptions.error(error, error.message);
          }
        });
    }

    processFeatureCollection(featureCollection, queryOptions) {
      if (!featureCollection || !featureCollection.features || featureCollection.features.length === 0) {
        const result = {
          geojson: null,

          count: 0,
          allCount: this.allCount,

          pageSize: this.pageSize,
          allPage: this.allPage,
          pageIndex: this.pageIndex
        };
        if (queryOptions.success) {
          queryOptions.success(result);
        }
        if (queryOptions._promise?.resolve) {
          queryOptions._promise.resolve(result);
        }
      } else {
        // 剔除有问题数据
        const featuresOK = [];
        for (let i = 0; i < featureCollection.features.length; i++) {
          const feature = featureCollection.features[i];
          if (feature?.geometry?.coordinates?.length > 0) {
            featuresOK.push(feature);
          }
        }
        featureCollection.features = featuresOK;

        const result = {
          geojson: featureCollection,

          count: featureCollection.features.length,
          allCount: this.allCount,

          pageSize: this.pageSize,
          allPage: this.allPage,
          pageIndex: this.pageIndex
        };

        if (this._geoJsonLayer) {
          this._last_success = (list) => {
            result.list = list;
            if (queryOptions.success) {
              queryOptions.success(result);
            }
            if (queryOptions._promise?.resolve) {
              queryOptions._promise.resolve(result);
            }
          };
          this._geoJsonLayer.load({ data: featureCollection });
        } else {
          if (queryOptions.success) {
            queryOptions.success(result);
          }
          if (queryOptions._promise?.resolve) {
            queryOptions._promise.resolve(result);
          }
        }
      }
    }

    geoJsonLayer_onLoadHandler(event) {
      if (this._last_success) {
        this._last_success(event.list);
        this._last_success = null;
      }
      this.fire(EventType.load, event);
    }

    geoJsonLayer_onClickHandler(event) {
      this.fire(EventType.click, {
        ...event,
        layer: this._geoJsonLayer
      });
    }

    /**
     * 清除
     * @return {void}  无
     */
    clear() {
      if (this._last_success) {
        this._last_success = null;
      }
      if (this._geoJsonLayer) {
        this._geoJsonLayer.clear();
      }
    }
  }

  function geojsonTypeToArcGIS(geoJsonType) {
    let arcgisGeometryType;
    switch (geoJsonType) {
      case "MultiPoint":
        arcgisGeometryType = "esriGeometryMultipoint";
        break
      case "LineString":
        arcgisGeometryType = "esriGeometryPolyline";
        break
      case "MultiLineString":
        arcgisGeometryType = "esriGeometryPolyline";
        break
      case "Polygon":
        arcgisGeometryType = "esriGeometryPolygon";
        break
      case "MultiPolygon":
        arcgisGeometryType = "esriGeometryPolygon";
        break
      case "Point":
      default:
        arcgisGeometryType = "esriGeometryPoint";
        break
    }

    return arcgisGeometryType
  }

  var index = {
    __proto__: null,
    BaiduPOI: BaiduPOI,
    GaodePOI: GaodePOI,
    GaodeRoute: GaodeRoute,
    QueryGeoServer: QueryGeoServer,
    QueryArcServer: QueryArcServer
  };

  //= ========== 框架基本信息 =========
  const name = "Mars3D三维可视化平台";
  const website = "http://mars3d.cn";
  const author = "合肥火星科技有限公司";

  // //= ============ 兼容老版本（非升级用户，可以删除下面代码） =============
  // export { LngLatPoint as LatLngPoint } from "./core/LngLatPoint" // v3.2更名
  // export { LngLatArray as LatLngArray } from "./core/LngLatArray" // v3.2更名

  exports.Cesium = Cesium__namespace;
  Object.defineProperty(exports, 'Resource', {
    enumerable: true,
    get: function () { return Cesium.Resource; }
  });
  exports.BaseClass = BaseClass;
  exports.BaseMaterialConver = BaseMaterialConver;
  exports.BaseStyleConver = BaseStyleConver;
  exports.BaseThing = BaseThing;
  exports.BillboardStyleConver = BillboardStyleConver;
  exports.BoxStyleConver = BoxStyleConver;
  exports.CRS = CRS;
  exports.ChinaCRS = ChinaCRS;
  exports.CircleStyleConver = CircleStyleConver;
  exports.ClipType = ClipType;
  exports.CloudStyleConver = CloudStyleConver;
  exports.ColorOptsConver = ColorOptsConver;
  exports.ControlType = ControlType;
  exports.ControlUtil = ControlUtil;
  exports.CorridorStyleConver = CorridorStyleConver;
  exports.CylinderStyleConver = CylinderStyleConver;
  exports.DivGraphicStyleConver = DivGraphicStyleConver;
  exports.DomUtil = DomUtil;
  exports.DrawUtil = DrawUtil;
  exports.EffectType = EffectType;
  exports.EffectUtil = EffectUtil;
  exports.EllipsoidStyleConver = EllipsoidStyleConver;
  exports.EventType = EventType;
  exports.GraphicType = GraphicType;
  exports.GraphicUtil = GraphicUtil;
  exports.GroundSkyBox = GroundSkyBox;
  exports.GroupThing = GroupThing;
  exports.Icon = Icon;
  exports.ImageOptsConver = ImageOptsConver;
  exports.LabelStyleConver = LabelStyleConver;
  exports.Lang = Lang;
  exports.LangType = LangType;
  exports.LayerType = LayerType;
  exports.LayerUtil = LayerUtil;
  exports.LngLatArray = LngLatArray;
  exports.LngLatPoint = LngLatPoint;
  exports.LocalWorldTransform = LocalWorldTransform;
  exports.Log = Log;
  exports.Map = Map;
  exports.MaterialType = MaterialType$1;
  exports.MaterialUtil = MaterialUtil;
  exports.MeasureUtil = MeasureUtil;
  exports.ModelStyleConver = ModelStyleConver;
  exports.MoveType = MoveType;
  exports.MultipleSkyBox = MultipleSkyBox;
  exports.PathStyleConver = PathStyleConver;
  exports.PlaneStyleConver = PlaneStyleConver;
  exports.PointStyleConver = PointStyleConver;
  exports.PointTrans = PointTrans;
  exports.PointUtil = PointUtil;
  exports.PolyUtil = PolyUtil;
  exports.PolygonStyleConver = PolygonStyleConver;
  exports.PolylineStyleConver = PolylineStyleConver;
  exports.PolylineVolumeStyleConver = PolylineVolumeStyleConver;
  exports.RectangleStyleConver = RectangleStyleConver;
  exports.RectangularSensorStyleConver = RectangularSensorStyleConver;
  exports.State = State;
  exports.Token = Token;
  exports.Util = Util;
  exports.WallStyleConver = WallStyleConver;
  exports.author = author;
  exports.control = index$1;
  exports.effect = index$2;
  exports.graphic = index$6;
  exports.layer = index$4;
  exports.material = index$7;
  exports.name = name;
  exports.proj4 = proj4;
  exports.provider = index$5;
  exports.query = index;
  exports.thing = index$3;
  exports.update = update;
  exports.version = version;
  exports.website = website;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
